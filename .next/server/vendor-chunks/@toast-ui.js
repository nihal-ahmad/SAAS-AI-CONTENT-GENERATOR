/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@toast-ui";
exports.ids = ["vendor-chunks/@toast-ui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@toast-ui/editor/dist/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@toast-ui/editor/dist/esm/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ ToastUIEditor),\n/* harmony export */   EditorCore: () => (/* binding */ ToastUIEditorCore),\n/* harmony export */   \"default\": () => (/* binding */ ToastUIEditor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.js\");\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-commands */ \"(ssr)/./node_modules/prosemirror-commands/dist/index.js\");\n/* harmony import */ var prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-inputrules */ \"(ssr)/./node_modules/prosemirror-inputrules/dist/index.js\");\n/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-history */ \"(ssr)/./node_modules/prosemirror-history/dist/index.js\");\n/**\n * @toast-ui/editor\n * @version 3.2.2 | Fri Feb 17 2023\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n * @license MIT\n */\n\n\n\n\n\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics$1 = function(d, b) {\r\n    extendStatics$1 = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics$1(d, b);\r\n};\r\n\r\nfunction __extends$1(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics$1(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign$1 = function() {\r\n    __assign$1 = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign$1.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray$1(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n}\n\n/**\n * @fileoverview Execute the provided callback once for each property of object which actually exist.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Execute the provided callback once for each property of object which actually exist.\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the property\n *  2) The name of the property\n *  3) The object being traversed\n * @param {Object} obj The object that will be traversed\n * @param {function} iteratee  Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEachOwnProperties from 'tui-code-snippet/collection/forEachOwnProperties';\n * \n * // CommonJS\n * const forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); \n *\n * let sum = 0;\n *\n * forEachOwnProperties({a:1,b:2,c:3}, function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n */\nfunction forEachOwnProperties$2(obj, iteratee, context) {\n  var key;\n\n  context = context || null;\n\n  for (key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (iteratee.call(context, obj[key], key, obj) === false) {\n        break;\n      }\n    }\n  }\n}\n\nvar forEachOwnProperties_1 = forEachOwnProperties$2;\n\n/**\n * @fileoverview Extend the target object from other objects.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * @module object\n */\n\n/**\n * Extend the target object from other objects.\n * @param {object} target - Object that will be extended\n * @param {...object} objects - Objects as sources\n * @returns {object} Extended object\n * @memberof module:object\n */\nfunction extend(target, objects) { // eslint-disable-line no-unused-vars\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n  var source, prop, i, len;\n\n  for (i = 1, len = arguments.length; i < len; i += 1) {\n    source = arguments[i];\n    for (prop in source) {\n      if (hasOwnProp.call(source, prop)) {\n        target[prop] = source[prop];\n      }\n    }\n  }\n\n  return target;\n}\n\nvar extend_1 = extend;\n\n/**\n * @fileoverview Check whether the given variable is a string or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a string or not.\n * If the given variable is a string, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is string?\n * @memberof module:type\n */\nfunction isString$3(obj) {\n  return typeof obj === 'string' || obj instanceof String;\n}\n\nvar isString_1 = isString$3;\n\n/**\n * @fileoverview Check whether the given variable is an instance of Array or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is an instance of Array or not.\n * If the given variable is an instance of Array, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is array instance?\n * @memberof module:type\n */\nfunction isArray$3(obj) {\n  return obj instanceof Array;\n}\n\nvar isArray_1 = isArray$3;\n\n/**\n * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Execute the provided callback once for each element present\n * in the array(or Array-like object) in ascending order.\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the element\n *  2) The index of the element\n *  3) The array(or Array-like object) being traversed\n * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed\n * @param {function} iteratee Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEachArray from 'tui-code-snippet/collection/forEachArray';\n * \n * // CommonJS\n * const forEachArray = require('tui-code-snippet/collection/forEachArray'); \n *\n * let sum = 0;\n *\n * forEachArray([1,2,3], function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n */\nfunction forEachArray$3(arr, iteratee, context) {\n  var index = 0;\n  var len = arr.length;\n\n  context = context || null;\n\n  for (; index < len; index += 1) {\n    if (iteratee.call(context, arr[index], index, arr) === false) {\n      break;\n    }\n  }\n}\n\nvar forEachArray_1 = forEachArray$3;\n\n/**\n * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isArray$2 = isArray_1;\nvar forEachArray$2 = forEachArray_1;\nvar forEachOwnProperties$1 = forEachOwnProperties_1;\n\n/**\n * @module collection\n */\n\n/**\n * Execute the provided callback once for each property of object(or element of array) which actually exist.\n * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the property(or The value of the element)\n *  2) The name of the property(or The index of the element)\n *  3) The object being traversed\n * @param {Object} obj The object that will be traversed\n * @param {function} iteratee Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEach from 'tui-code-snippet/collection/forEach'; \n * \n * // CommonJS\n * const forEach = require('tui-code-snippet/collection/forEach'); \n *\n * let sum = 0;\n *\n * forEach([1,2,3], function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n *\n * // In case of Array-like object\n * const array = Array.prototype.slice.call(arrayLike); // change to array\n * forEach(array, function(value){\n *   sum += value;\n * });\n */\nfunction forEach$4(obj, iteratee, context) {\n  if (isArray$2(obj)) {\n    forEachArray$2(obj, iteratee, context);\n  } else {\n    forEachOwnProperties$1(obj, iteratee, context);\n  }\n}\n\nvar forEach_1 = forEach$4;\n\n/**\n * @fileoverview Setting element style\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isString$2 = isString_1;\nvar forEach$3 = forEach_1;\n\n/**\n * Setting element style\n * @param {(HTMLElement|SVGElement)} element - element to setting style\n * @param {(string|object)} key - style prop name or {prop: value} pair object\n * @param {string} [value] - style value\n * @memberof module:domUtil\n */\nfunction css(element, key, value) {\n  var style = element.style;\n\n  if (isString$2(key)) {\n    style[key] = value;\n\n    return;\n  }\n\n  forEach$3(key, function(v, k) {\n    style[k] = v;\n  });\n}\n\nvar css_1 = css;\n\n/* eslint-disable complexity */\n\nvar isArray$1 = isArray_1;\n\n/**\n * @module array\n */\n\n/**\n * Returns the first index at which a given element can be found in the array\n * from start index(default 0), or -1 if it is not present.\n * It compares searchElement to elements of the Array using strict equality\n * (the same method used by the ===, or triple-equals, operator).\n * @param {*} searchElement Element to locate in the array\n * @param {Array} array Array that will be traversed.\n * @param {number} startIndex Start index in array for searching (default 0)\n * @returns {number} the First index at which a given element, or -1 if it is not present\n * @memberof module:array\n * @example\n * // ES6\n * import inArray from 'tui-code-snippet/array/inArray';\n * \n * // CommonJS\n * const inArray = require('tui-code-snippet/array/inArray');\n *\n * const arr = ['one', 'two', 'three', 'four'];\n * const idx1 = inArray('one', arr, 3); // -1\n * const idx2 = inArray('one', arr); // 0\n */\nfunction inArray$4(searchElement, array, startIndex) {\n  var i;\n  var length;\n  startIndex = startIndex || 0;\n\n  if (!isArray$1(array)) {\n    return -1;\n  }\n\n  if (Array.prototype.indexOf) {\n    return Array.prototype.indexOf.call(array, searchElement, startIndex);\n  }\n\n  length = array.length;\n  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {\n    if (array[i] === searchElement) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nvar inArray_1 = inArray$4;\n\n/**\n * @fileoverview Check whether the given variable is undefined or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is undefined or not.\n * If the given variable is undefined, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is undefined?\n * @memberof module:type\n */\nfunction isUndefined$4(obj) {\n  return obj === undefined; // eslint-disable-line no-undefined\n}\n\nvar isUndefined_1 = isUndefined$4;\n\n/**\n * @fileoverview Get HTML element's design classes.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isUndefined$3 = isUndefined_1;\n\n/**\n * Get HTML element's design classes.\n * @param {(HTMLElement|SVGElement)} element target element\n * @returns {string} element css class name\n * @memberof module:domUtil\n */\nfunction getClass$3(element) {\n  if (!element || !element.className) {\n    return '';\n  }\n\n  if (isUndefined$3(element.className.baseVal)) {\n    return element.className;\n  }\n\n  return element.className.baseVal;\n}\n\nvar getClass_1 = getClass$3;\n\n/**\n * @fileoverview Set className value\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isArray = isArray_1;\nvar isUndefined$2 = isUndefined_1;\n\n/**\n * Set className value\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {(string|string[])} cssClass - class names\n * @private\n */\nfunction setClassName$2(element, cssClass) {\n  cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;\n\n  cssClass = cssClass.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n  if (isUndefined$2(element.className.baseVal)) {\n    element.className = cssClass;\n\n    return;\n  }\n\n  element.className.baseVal = cssClass;\n}\n\nvar _setClassName = setClassName$2;\n\n/**\n * @fileoverview Add css class to element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEach$2 = forEach_1;\nvar inArray$3 = inArray_1;\nvar getClass$2 = getClass_1;\nvar setClassName$1 = _setClassName;\n\n/**\n * domUtil module\n * @module domUtil\n */\n\n/**\n * Add css class to element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to add\n * @memberof module:domUtil\n */\nfunction addClass(element) {\n  var cssClass = Array.prototype.slice.call(arguments, 1);\n  var classList = element.classList;\n  var newClass = [];\n  var origin;\n\n  if (classList) {\n    forEach$2(cssClass, function(name) {\n      element.classList.add(name);\n    });\n\n    return;\n  }\n\n  origin = getClass$2(element);\n\n  if (origin) {\n    cssClass = [].concat(origin.split(/\\s+/), cssClass);\n  }\n\n  forEach$2(cssClass, function(cls) {\n    if (inArray$3(cls, newClass) < 0) {\n      newClass.push(cls);\n    }\n  });\n\n  setClassName$1(element, newClass);\n}\n\nvar addClass_1 = addClass;\n\n/**\n * @fileoverview Remove css class from element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEachArray$1 = forEachArray_1;\nvar inArray$2 = inArray_1;\nvar getClass$1 = getClass_1;\nvar setClassName = _setClassName;\n\n/**\n * Remove css class from element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to remove\n * @memberof module:domUtil\n */\nfunction removeClass(element) {\n  var cssClass = Array.prototype.slice.call(arguments, 1);\n  var classList = element.classList;\n  var origin, newClass;\n\n  if (classList) {\n    forEachArray$1(cssClass, function(name) {\n      classList.remove(name);\n    });\n\n    return;\n  }\n\n  origin = getClass$1(element).split(/\\s+/);\n  newClass = [];\n  forEachArray$1(origin, function(name) {\n    if (inArray$2(name, cssClass) < 0) {\n      newClass.push(name);\n    }\n  });\n\n  setClassName(element, newClass);\n}\n\nvar removeClass_1 = removeClass;\n\n/**\n * @fileoverview Check whether the given variable is a number or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a number or not.\n * If the given variable is a number, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is number?\n * @memberof module:type\n */\nfunction isNumber(obj) {\n  return typeof obj === 'number' || obj instanceof Number;\n}\n\nvar isNumber_1 = isNumber;\n\n/**\n * @fileoverview Check whether the given variable is null or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is null or not.\n * If the given variable(arguments[0]) is null, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is null?\n * @memberof module:type\n */\nfunction isNull$1(obj) {\n  return obj === null;\n}\n\nvar isNull_1 = isNull$1;\n\n/**\n * @fileoverview Request image ping.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEachOwnProperties = forEachOwnProperties_1;\n\n/**\n * @module request\n */\n\n/**\n * Request image ping.\n * @param {String} url url for ping request\n * @param {Object} trackingInfo infos for make query string\n * @returns {HTMLElement}\n * @memberof module:request\n * @example\n * // ES6\n * import imagePing from 'tui-code-snippet/request/imagePing';\n * \n * // CommonJS\n * const imagePing = require('tui-code-snippet/request/imagePing');\n *\n * imagePing('https://www.google-analytics.com/collect', {\n *   v: 1,\n *   t: 'event',\n *   tid: 'trackingid',\n *   cid: 'cid',\n *   dp: 'dp',\n *   dh: 'dh'\n * });\n */\nfunction imagePing$1(url, trackingInfo) {\n  var trackingElement = document.createElement('img');\n  var queryString = '';\n  forEachOwnProperties(trackingInfo, function(value, key) {\n    queryString += '&' + key + '=' + value;\n  });\n  queryString = queryString.substring(1);\n\n  trackingElement.src = url + '?' + queryString;\n\n  trackingElement.style.display = 'none';\n  document.body.appendChild(trackingElement);\n  document.body.removeChild(trackingElement);\n\n  return trackingElement;\n}\n\nvar imagePing_1 = imagePing$1;\n\n/**\n * @fileoverview Send hostname on DOMContentLoaded.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isUndefined$1 = isUndefined_1;\nvar imagePing = imagePing_1;\n\nvar ms7days = 7 * 24 * 60 * 60 * 1000;\n\n/**\n * Check if the date has passed 7 days\n * @param {number} date - milliseconds\n * @returns {boolean}\n * @private\n */\nfunction isExpired(date) {\n  var now = new Date().getTime();\n\n  return now - date > ms7days;\n}\n\n/**\n * Send hostname on DOMContentLoaded.\n * To prevent hostname set tui.usageStatistics to false.\n * @param {string} appName - application name\n * @param {string} trackingId - GA tracking ID\n * @ignore\n */\nfunction sendHostname(appName, trackingId) {\n  var url = 'https://www.google-analytics.com/collect';\n  var hostname = location.hostname;\n  var hitType = 'event';\n  var eventCategory = 'use';\n  var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';\n  var date = window.localStorage.getItem(applicationKeyForStorage);\n\n  // skip if the flag is defined and is set to false explicitly\n  if (!isUndefined$1(window.tui) && window.tui.usageStatistics === false) {\n    return;\n  }\n\n  // skip if not pass seven days old\n  if (date && !isExpired(date)) {\n    return;\n  }\n\n  window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());\n\n  setTimeout(function() {\n    if (document.readyState === 'interactive' || document.readyState === 'complete') {\n      imagePing(url, {\n        v: 1,\n        t: hitType,\n        tid: trackingId,\n        cid: hostname,\n        dp: hostname,\n        dh: appName,\n        el: appName,\n        ec: eventCategory\n      });\n    }\n  }, 1000);\n}\n\nvar sendHostname_1 = sendHostname;\n\n/Mac/.test(navigator.platform);\nvar reSpaceMoreThanOne = /[\\u0020]+/g;\nvar reEscapeChars$1 = /[>(){}[\\]+-.!#|]/g;\nvar reEscapeHTML = /<([a-zA-Z_][a-zA-Z0-9\\-._]*)(\\s|[^\\\\>])*\\/?>|<(\\/)([a-zA-Z_][a-zA-Z0-9\\-._]*)\\s*\\/?>|<!--[^-]+-->|<([a-zA-Z_][a-zA-Z0-9\\-.:/]*)>/g;\nvar reEscapeBackSlash = /\\\\[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\\\\]/g;\nvar reEscapePairedChars = /[*_~`]/g;\nvar reMdImageSyntax = /!\\[.*\\]\\(.*\\)/g;\nvar reEscapedCharInLinkSyntax = /[[\\]]/g;\nvar reEscapeBackSlashInSentence = /(?:^|[^\\\\])\\\\(?!\\\\)/g;\nvar XMLSPECIAL$1 = '[&<>\"]';\nvar reXmlSpecial$1 = new RegExp(XMLSPECIAL$1, 'g');\nfunction replaceUnsafeChar$1(char) {\n    switch (char) {\n        case '&':\n            return '&amp;';\n        case '<':\n            return '&lt;';\n        case '>':\n            return '&gt;';\n        case '\"':\n            return '&quot;';\n        default:\n            return char;\n    }\n}\nfunction escapeXml$1(text) {\n    if (reXmlSpecial$1.test(text)) {\n        return text.replace(reXmlSpecial$1, replaceUnsafeChar$1);\n    }\n    return text;\n}\nfunction sendHostName() {\n    sendHostname_1('editor', 'UA-129966929-1');\n}\nfunction includes(arr, targetItem) {\n    return arr.indexOf(targetItem) !== -1;\n}\nvar availableLinkAttributes = ['rel', 'target', 'hreflang', 'type'];\nvar reMarkdownTextToEscapeMap = {\n    codeblock: /(^ {4}[^\\n]+\\n*)+/,\n    thematicBreak: /^ *((\\* *){3,}|(- *){3,} *|(_ *){3,}) */,\n    atxHeading: /^(#{1,6}) +[\\s\\S]+/,\n    seTextheading: /^([^\\n]+)\\n *(=|-){2,} */,\n    blockquote: /^( *>[^\\n]+.*)+/,\n    list: /^ *(\\*+|-+|\\d+\\.) [\\s\\S]+/,\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? */,\n    link: /!?\\[.*\\]\\(.*\\)/,\n    reflink: /!?\\[.*\\]\\s*\\[([^\\]]*)\\]/,\n    verticalBar: /\\u007C/,\n    fencedCodeblock: /^((`|~){3,})/,\n};\nfunction sanitizeLinkAttribute(attribute) {\n    if (!attribute) {\n        return null;\n    }\n    var linkAttributes = {};\n    availableLinkAttributes.forEach(function (key) {\n        if (!isUndefined_1(attribute[key])) {\n            linkAttributes[key] = attribute[key];\n        }\n    });\n    return linkAttributes;\n}\nfunction repeat$1(text, count) {\n    var result = '';\n    for (var i = 0; i < count; i += 1) {\n        result += text;\n    }\n    return result;\n}\nfunction isNeedEscapeText(text) {\n    var needEscape = false;\n    forEachOwnProperties_1(reMarkdownTextToEscapeMap, function (reMarkdownTextToEscape) {\n        if (reMarkdownTextToEscape.test(text)) {\n            needEscape = true;\n        }\n        return !needEscape;\n    });\n    return needEscape;\n}\nfunction escapeTextForLink(text) {\n    var imageSyntaxRanges = [];\n    var result = reMdImageSyntax.exec(text);\n    while (result) {\n        imageSyntaxRanges.push([result.index, result.index + result[0].length]);\n        result = reMdImageSyntax.exec(text);\n    }\n    return text.replace(reEscapedCharInLinkSyntax, function (matched, offset) {\n        var isDelimiter = imageSyntaxRanges.some(function (range) { return offset > range[0] && offset < range[1]; });\n        return isDelimiter ? matched : \"\\\\\" + matched;\n    });\n}\nfunction escape$1(text) {\n    var aheadReplacer = function (matched) { return \"\\\\\" + matched; };\n    var behindReplacer = function (matched) { return matched + \"\\\\\"; };\n    var escapedText = text.replace(reSpaceMoreThanOne, ' ');\n    if (reEscapeBackSlash.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeBackSlash, aheadReplacer);\n    }\n    if (reEscapeBackSlashInSentence.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeBackSlashInSentence, behindReplacer);\n    }\n    escapedText = escapedText.replace(reEscapePairedChars, aheadReplacer);\n    if (reEscapeHTML.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeHTML, aheadReplacer);\n    }\n    if (isNeedEscapeText(escapedText)) {\n        escapedText = escapedText.replace(reEscapeChars$1, aheadReplacer);\n    }\n    return escapedText;\n}\nfunction quote(text) {\n    var result;\n    if (text.indexOf('\"') === -1) {\n        result = '\"\"';\n    }\n    else {\n        result = text.indexOf(\"'\") === -1 ? \"''\" : '()';\n    }\n    return result[0] + text + result[1];\n}\nfunction isNil(value) {\n    return isNull_1(value) || isUndefined_1(value);\n}\nfunction shallowEqual(o1, o2) {\n    if (o1 === null && o1 === o2) {\n        return true;\n    }\n    if (typeof o1 !== 'object' || typeof o2 !== 'object' || isNil(o1) || isNil(o2)) {\n        return o1 === o2;\n    }\n    for (var key in o1) {\n        if (o1[key] !== o2[key]) {\n            return false;\n        }\n    }\n    for (var key in o2) {\n        if (!(key in o1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction last$1(arr) {\n    return arr[arr.length - 1];\n}\nfunction between$1(value, min, max) {\n    return value >= min && value <= max;\n}\nfunction isObject$1(obj) {\n    return typeof obj === 'object' && obj !== null;\n}\nfunction deepMergedCopy(targetObj, obj) {\n    var resultObj = __assign$1({}, targetObj);\n    if (targetObj && obj) {\n        Object.keys(obj).forEach(function (prop) {\n            if (isObject$1(resultObj[prop])) {\n                if (Array.isArray(obj[prop])) {\n                    resultObj[prop] = deepCopyArray(obj[prop]);\n                }\n                else if (resultObj.hasOwnProperty(prop)) {\n                    resultObj[prop] = deepMergedCopy(resultObj[prop], obj[prop]);\n                }\n                else {\n                    resultObj[prop] = deepCopy(obj[prop]);\n                }\n            }\n            else {\n                resultObj[prop] = obj[prop];\n            }\n        });\n    }\n    return resultObj;\n}\nfunction deepCopyArray(items) {\n    return items.map(function (item) {\n        if (isObject$1(item)) {\n            return Array.isArray(item) ? deepCopyArray(item) : deepCopy(item);\n        }\n        return item;\n    });\n}\nfunction deepCopy(obj) {\n    var keys = Object.keys(obj);\n    if (!keys.length) {\n        return obj;\n    }\n    return keys.reduce(function (acc, prop) {\n        if (isObject$1(obj[prop])) {\n            acc[prop] = Array.isArray(obj[prop]) ? deepCopyArray(obj[prop]) : deepCopy(obj[prop]);\n        }\n        else {\n            acc[prop] = obj[prop];\n        }\n        return acc;\n    }, {});\n}\nfunction assign(targetObj, obj) {\n    if (obj === void 0) { obj = {}; }\n    Object.keys(obj).forEach(function (prop) {\n        if (targetObj.hasOwnProperty(prop) && typeof targetObj[prop] === 'object') {\n            if (Array.isArray(obj[prop])) {\n                targetObj[prop] = obj[prop];\n            }\n            else {\n                assign(targetObj[prop], obj[prop]);\n            }\n        }\n        else {\n            targetObj[prop] = obj[prop];\n        }\n    });\n    return targetObj;\n}\nfunction getSortedNumPair(valueA, valueB) {\n    return valueA > valueB ? [valueB, valueA] : [valueA, valueB];\n}\n\n/**\n * @fileoverview Transform the Array-like object to Array.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEachArray = forEachArray_1;\n\n/**\n * Transform the Array-like object to Array.\n * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.\n * @param {*} arrayLike Array-like object\n * @returns {Array} Array\n * @memberof module:collection\n * @example\n * // ES6\n * import toArray from 'tui-code-snippet/collection/toArray'; \n * \n * // CommonJS\n * const toArray = require('tui-code-snippet/collection/toArray'); \n *\n * const arrayLike = {\n *   0: 'one',\n *   1: 'two',\n *   2: 'three',\n *   3: 'four',\n *   length: 4\n * };\n * const result = toArray(arrayLike);\n *\n * alert(result instanceof Array); // true\n * alert(result); // one,two,three,four\n */\nfunction toArray$1(arrayLike) {\n  var arr;\n  try {\n    arr = Array.prototype.slice.call(arrayLike);\n  } catch (e) {\n    arr = [];\n    forEachArray(arrayLike, function(value) {\n      arr.push(value);\n    });\n  }\n\n  return arr;\n}\n\nvar toArray_1 = toArray$1;\n\nfunction createParagraph(schema, content) {\n    var paragraph = schema.nodes.paragraph;\n    if (!content) {\n        return paragraph.createAndFill();\n    }\n    return paragraph.create(null, isString_1(content) ? schema.text(content) : content);\n}\nfunction createTextNode$1(schema, text, marks) {\n    return schema.text(text, marks);\n}\nfunction createTextSelection(tr, from, to) {\n    if (to === void 0) { to = from; }\n    var contentSize = tr.doc.content.size;\n    var size = contentSize > 0 ? contentSize - 1 : 1;\n    return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, Math.min(from, size), Math.min(to, size));\n}\nfunction addParagraph(tr, _a, schema) {\n    var pos = _a.pos;\n    tr.replaceWith(pos, pos, createParagraph(schema));\n    return tr.setSelection(createTextSelection(tr, pos + 1));\n}\nfunction replaceTextNode(_a) {\n    var state = _a.state, from = _a.from, startIndex = _a.startIndex, endIndex = _a.endIndex, createText = _a.createText;\n    var tr = state.tr, doc = state.doc, schema = state.schema;\n    for (var i = startIndex; i <= endIndex; i += 1) {\n        var _b = doc.child(i), nodeSize = _b.nodeSize, textContent = _b.textContent, content = _b.content;\n        var text = createText(textContent);\n        var node = text ? createTextNode$1(schema, text) : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n        var mappedFrom = tr.mapping.map(from);\n        var mappedTo = mappedFrom + content.size;\n        tr.replaceWith(mappedFrom, mappedTo, node);\n        from += nodeSize;\n    }\n    return tr;\n}\nfunction splitAndExtendBlock(tr, pos, text, node) {\n    var textLen = text.length;\n    tr.split(pos)\n        .delete(pos - textLen, pos)\n        .insert(tr.mapping.map(pos), node)\n        .setSelection(createTextSelection(tr, tr.mapping.map(pos) - textLen));\n}\n\nfunction getMdStartLine(mdNode) {\n    return mdNode.sourcepos[0][0];\n}\nfunction getMdEndLine(mdNode) {\n    return mdNode.sourcepos[1][0];\n}\nfunction getMdStartCh(mdNode) {\n    return mdNode.sourcepos[0][1];\n}\nfunction getMdEndCh(mdNode) {\n    return mdNode.sourcepos[1][1];\n}\nfunction isHTMLNode(mdNode) {\n    var type = mdNode.type;\n    return type === 'htmlBlock' || type === 'htmlInline';\n}\nfunction isStyledInlineNode(mdNode) {\n    var type = mdNode.type;\n    return (type === 'strike' ||\n        type === 'strong' ||\n        type === 'emph' ||\n        type === 'code' ||\n        type === 'link' ||\n        type === 'image');\n}\nfunction isCodeBlockNode(mdNode) {\n    return mdNode && mdNode.type === 'codeBlock';\n}\nfunction isListNode$1(mdNode) {\n    return mdNode && (mdNode.type === 'item' || mdNode.type === 'list');\n}\nfunction isOrderedListNode(mdNode) {\n    return isListNode$1(mdNode) && mdNode.listData.type === 'ordered';\n}\nfunction isBulletListNode(mdNode) {\n    return isListNode$1(mdNode) && mdNode.listData.type !== 'ordered';\n}\nfunction isTableCellNode(mdNode) {\n    return mdNode && (mdNode.type === 'tableCell' || mdNode.type === 'tableDelimCell');\n}\nfunction isInlineNode$1(mdNode) {\n    switch (mdNode.type) {\n        case 'code':\n        case 'text':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'htmlInline':\n        case 'linebreak':\n        case 'softbreak':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction findClosestNode(mdNode, condition, includeSelf) {\n    if (includeSelf === void 0) { includeSelf = true; }\n    mdNode = includeSelf ? mdNode : mdNode.parent;\n    while (mdNode && mdNode.type !== 'document') {\n        if (condition(mdNode)) {\n            return mdNode;\n        }\n        mdNode = mdNode.parent;\n    }\n    return null;\n}\nfunction traverseParentNodes(mdNode, iteratee, includeSelf) {\n    if (includeSelf === void 0) { includeSelf = true; }\n    mdNode = includeSelf ? mdNode : mdNode.parent;\n    while (mdNode && mdNode.type !== 'document') {\n        iteratee(mdNode);\n        mdNode = mdNode.parent;\n    }\n}\nfunction addOffsetPos(originPos, offset) {\n    return [originPos[0], originPos[1] + offset];\n}\nfunction setOffsetPos(originPos, newOffset) {\n    return [originPos[0], newOffset];\n}\nfunction getInlineMarkdownText(mdNode) {\n    var text = mdNode.firstChild.literal;\n    switch (mdNode.type) {\n        case 'emph':\n            return \"*\" + text + \"*\";\n        case 'strong':\n            return \"**\" + text + \"**\";\n        case 'strike':\n            return \"~~\" + text + \"~~\";\n        case 'code':\n            return \"`\" + text + \"`\";\n        case 'link':\n        case 'image':\n            /* eslint-disable no-case-declarations */\n            var _a = mdNode, destination = _a.destination, title = _a.title;\n            var delim = mdNode.type === 'link' ? '' : '!';\n            return delim + \"[\" + text + \"](\" + destination + (title ? \" \\\"\" + title + \"\\\"\" : '') + \")\";\n        default:\n            return null;\n    }\n}\nfunction isContainer$2(node) {\n    switch (node.type) {\n        case 'document':\n        case 'blockQuote':\n        case 'list':\n        case 'item':\n        case 'paragraph':\n        case 'heading':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'table':\n        case 'tableHead':\n        case 'tableBody':\n        case 'tableRow':\n        case 'tableCell':\n        case 'tableDelimRow':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getChildrenText$1(node) {\n    var buffer = [];\n    var walker = node.walker();\n    var event = null;\n    while ((event = walker.next())) {\n        var childNode = event.node;\n        if (childNode.type === 'text') {\n            buffer.push(childNode.literal);\n        }\n    }\n    return buffer.join('');\n}\n\nvar widgetRules = [];\nvar widgetRuleMap = {};\nvar reWidgetPrefix = /\\$\\$widget\\d+\\s/;\nfunction unwrapWidgetSyntax(text) {\n    var index = text.search(reWidgetPrefix);\n    if (index !== -1) {\n        var rest = text.substring(index);\n        var replaced = rest.replace(reWidgetPrefix, '').replace('$$', '');\n        text = text.substring(0, index);\n        text += unwrapWidgetSyntax(replaced);\n    }\n    return text;\n}\nfunction createWidgetContent(info, text) {\n    return \"$$\" + info + \" \" + text + \"$$\";\n}\nfunction widgetToDOM(info, text) {\n    var _a = widgetRuleMap[info], rule = _a.rule, toDOM = _a.toDOM;\n    var matches = unwrapWidgetSyntax(text).match(rule);\n    if (matches) {\n        text = matches[0];\n    }\n    return toDOM(text);\n}\nfunction getWidgetRules() {\n    return widgetRules;\n}\nfunction setWidgetRules(rules) {\n    widgetRules = rules;\n    widgetRules.forEach(function (rule, index) {\n        widgetRuleMap[\"widget\" + index] = rule;\n    });\n}\nfunction mergeNodes(nodes, text, schema, ruleIndex) {\n    return nodes.concat(createNodesWithWidget(text, schema, ruleIndex));\n}\n/**\n * create nodes with plain text and replace text matched to the widget rules with the widget node\n * For example, in case the text and widget rules as below\n *\n * text: $test plain text #test\n * widget rules: [{ rule: /$.+/ }, { rule: /#.+/ }]\n *\n * The creating node process is recursive and is as follows.\n *\n * in first widget rule(/$.+/)\n *  $test -> widget node\n *  plain text -> match with next widget rule\n *  #test -> match with next widget rule\n *\n * in second widget rule(/#.+/)\n *  plain text -> text node(no rule for matching)\n *  #test -> widget node\n */\nfunction createNodesWithWidget(text, schema, ruleIndex) {\n    if (ruleIndex === void 0) { ruleIndex = 0; }\n    var nodes = [];\n    var rule = (widgetRules[ruleIndex] || {}).rule;\n    var nextRuleIndex = ruleIndex + 1;\n    text = unwrapWidgetSyntax(text);\n    if (rule && rule.test(text)) {\n        var index = void 0;\n        while ((index = text.search(rule)) !== -1) {\n            var prev = text.substring(0, index);\n            // get widget node on first splitted text using next widget rule\n            if (prev) {\n                nodes = mergeNodes(nodes, prev, schema, nextRuleIndex);\n            }\n            // build widget node using current widget rule\n            text = text.substring(index);\n            var literal = text.match(rule)[0];\n            var info = \"widget\" + ruleIndex;\n            nodes.push(schema.nodes.widget.create({ info: info }, schema.text(createWidgetContent(info, literal))));\n            text = text.substring(literal.length);\n        }\n        // get widget node on last splitted text using next widget rule\n        if (text) {\n            nodes = mergeNodes(nodes, text, schema, nextRuleIndex);\n        }\n    }\n    else if (text) {\n        nodes =\n            ruleIndex < widgetRules.length - 1\n                ? mergeNodes(nodes, text, schema, nextRuleIndex)\n                : [schema.text(text)];\n    }\n    return nodes;\n}\nfunction getWidgetContent(widgetNode) {\n    var event;\n    var text = '';\n    var walker = widgetNode.walker();\n    while ((event = walker.next())) {\n        var node = event.node, entering = event.entering;\n        if (entering) {\n            if (node !== widgetNode && node.type !== 'text') {\n                text += getInlineMarkdownText(node);\n                // skip the children\n                walker.resumeAt(widgetNode, false);\n                walker.next();\n            }\n            else if (node.type === 'text') {\n                text += node.literal;\n            }\n        }\n    }\n    return text;\n}\n\nfunction getDefaultCommands() {\n    return {\n        deleteSelection: function () { return prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.deleteSelection; },\n        selectAll: function () { return prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.selectAll; },\n        undo: function () { return prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo; },\n        redo: function () { return prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.redo; },\n    };\n}\n\nfunction placeholder(options) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            decorations: function (state) {\n                var doc = state.doc;\n                if (options.text &&\n                    doc.childCount === 1 &&\n                    doc.firstChild.isTextblock &&\n                    doc.firstChild.content.size === 0) {\n                    var placeHolder = document.createElement('span');\n                    addClass_1(placeHolder, 'placeholder');\n                    if (options.className) {\n                        addClass_1(placeHolder, options.className);\n                    }\n                    placeHolder.textContent = options.text;\n                    return prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.DecorationSet.create(doc, [prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.widget(1, placeHolder)]);\n                }\n                return null;\n            },\n        },\n    });\n}\n\n/**\n * @fileoverview Check element has specific css class\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar inArray$1 = inArray_1;\nvar getClass = getClass_1;\n\n/**\n * Check element has specific css class\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {string} cssClass - css class\n * @returns {boolean}\n * @memberof module:domUtil\n */\nfunction hasClass(element, cssClass) {\n  var origin;\n\n  if (element.classList) {\n    return element.classList.contains(cssClass);\n  }\n\n  origin = getClass(element).split(/\\s+/);\n\n  return inArray$1(cssClass, origin) > -1;\n}\n\nvar hasClass_1 = hasClass;\n\n/**\n * @fileoverview Check element match selector\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar inArray = inArray_1;\nvar toArray = toArray_1;\n\nvar elProto = Element.prototype;\nvar matchSelector = elProto.matches ||\n    elProto.webkitMatchesSelector ||\n    elProto.mozMatchesSelector ||\n    elProto.msMatchesSelector ||\n    function(selector) {\n      var doc = this.document || this.ownerDocument;\n\n      return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;\n    };\n\n/**\n * Check element match selector\n * @param {HTMLElement} element - element to check\n * @param {string} selector - selector to check\n * @returns {boolean} is selector matched to element?\n * @memberof module:domUtil\n */\nfunction matches(element, selector) {\n  return matchSelector.call(element, selector);\n}\n\nvar matches_1 = matches;\n\nvar TAG_NAME = '[A-Za-z][A-Za-z0-9-]*';\nvar ATTRIBUTE_NAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\nvar UNQUOTED_VALUE = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar SINGLE_QUOTED_VALUE = \"'[^']*'\";\nvar DOUBLE_QUOTED_VALUE = '\"[^\"]*\"';\nvar ATTRIBUTE_VALUE = \"(?:\" + UNQUOTED_VALUE + \"|\" + SINGLE_QUOTED_VALUE + \"|\" + DOUBLE_QUOTED_VALUE + \")\";\nvar ATTRIBUTE_VALUE_SPEC = \"\" + '(?:\\\\s*=\\\\s*' + ATTRIBUTE_VALUE + \")\";\nvar ATTRIBUTE$1 = \"\" + '(?:\\\\s+' + ATTRIBUTE_NAME + ATTRIBUTE_VALUE_SPEC + \"?)\";\nvar OPEN_TAG = \"<(\" + TAG_NAME + \")(\" + ATTRIBUTE$1 + \")*\\\\s*/?>\";\nvar CLOSE_TAG = \"</(\" + TAG_NAME + \")\\\\s*[>]\";\nvar HTML_TAG = \"(?:\" + OPEN_TAG + \"|\" + CLOSE_TAG + \")\";\nvar reHTMLTag = new RegExp(\"^\" + HTML_TAG, 'i');\nvar reBR = /<br\\s*\\/*>/i;\nvar reHTMLComment = /<! ---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;\nvar ALTERNATIVE_TAG_FOR_BR = '</p><p>';\n\nfunction isPositionInBox(style, offsetX, offsetY) {\n    var left = parseInt(style.left, 10);\n    var top = parseInt(style.top, 10);\n    var width = parseInt(style.width, 10) + parseInt(style.paddingLeft, 10) + parseInt(style.paddingRight, 10);\n    var height = parseInt(style.height, 10) + parseInt(style.paddingTop, 10) + parseInt(style.paddingBottom, 10);\n    return offsetX >= left && offsetX <= left + width && offsetY >= top && offsetY <= top + height;\n}\nvar CLS_PREFIX = 'toastui-editor-';\nfunction cls() {\n    var names = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        names[_i] = arguments[_i];\n    }\n    var result = [];\n    for (var _a = 0, names_1 = names; _a < names_1.length; _a++) {\n        var name_1 = names_1[_a];\n        var className = void 0;\n        if (Array.isArray(name_1)) {\n            className = name_1[0] ? name_1[1] : null;\n        }\n        else {\n            className = name_1;\n        }\n        if (className) {\n            result.push(\"\" + CLS_PREFIX + className);\n        }\n    }\n    return result.join(' ');\n}\nfunction clsWithMdPrefix() {\n    var names = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        names[_i] = arguments[_i];\n    }\n    return names.map(function (className) { return CLS_PREFIX + \"md-\" + className; }).join(' ');\n}\nfunction isTextNode(node) {\n    return (node === null || node === void 0 ? void 0 : node.nodeType) === Node.TEXT_NODE;\n}\nfunction isElemNode(node) {\n    return node && node.nodeType === Node.ELEMENT_NODE;\n}\nfunction findNodes(element, selector) {\n    var nodeList = toArray_1(element.querySelectorAll(selector));\n    if (nodeList.length) {\n        return nodeList;\n    }\n    return [];\n}\nfunction appendNodes(node, nodesToAppend) {\n    nodesToAppend = isArray_1(nodesToAppend) ? toArray_1(nodesToAppend) : [nodesToAppend];\n    nodesToAppend.forEach(function (nodeToAppend) {\n        node.appendChild(nodeToAppend);\n    });\n}\nfunction insertBeforeNode(insertedNode, node) {\n    if (node.parentNode) {\n        node.parentNode.insertBefore(insertedNode, node);\n    }\n}\nfunction removeNode$1(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction unwrapNode(node) {\n    var result = [];\n    while (node.firstChild) {\n        result.push(node.firstChild);\n        if (node.parentNode) {\n            node.parentNode.insertBefore(node.firstChild, node);\n        }\n    }\n    removeNode$1(node);\n    return result;\n}\nfunction toggleClass(element, className, state) {\n    if (isUndefined_1(state)) {\n        state = !hasClass_1(element, className);\n    }\n    var toggleFn = state ? addClass_1 : removeClass_1;\n    toggleFn(element, className);\n}\nfunction createElementWith(contents, target) {\n    var container = document.createElement('div');\n    if (isString_1(contents)) {\n        container.innerHTML = contents;\n    }\n    else {\n        container.appendChild(contents);\n    }\n    var firstChild = container.firstChild;\n    if (target) {\n        target.appendChild(firstChild);\n    }\n    return firstChild;\n}\nfunction getOuterWidth(el) {\n    var computed = window.getComputedStyle(el);\n    return (['margin-left', 'margin-right'].reduce(function (acc, type) { return acc + parseInt(computed.getPropertyValue(type), 10); }, 0) + el.offsetWidth);\n}\nfunction closest(node, found) {\n    var condition;\n    if (isString_1(found)) {\n        condition = function (target) { return matches_1(target, found); };\n    }\n    else {\n        condition = function (target) { return target === found; };\n    }\n    while (node && node !== document) {\n        if (isElemNode(node) && condition(node)) {\n            return node;\n        }\n        node = node.parentNode;\n    }\n    return null;\n}\nfunction getTotalOffset(el, root) {\n    var offsetTop = 0;\n    var offsetLeft = 0;\n    while (el && el !== root) {\n        var top_1 = el.offsetTop, left = el.offsetLeft, offsetParent = el.offsetParent;\n        offsetTop += top_1;\n        offsetLeft += left;\n        if (offsetParent === root.offsetParent) {\n            break;\n        }\n        el = el.offsetParent;\n    }\n    return { offsetTop: offsetTop, offsetLeft: offsetLeft };\n}\nfunction setAttributes(attributes, element) {\n    Object.keys(attributes).forEach(function (attrName) {\n        if (isNil(attributes[attrName])) {\n            element.removeAttribute(attrName);\n        }\n        else {\n            element.setAttribute(attrName, attributes[attrName]);\n        }\n    });\n}\nfunction replaceBRWithEmptyBlock(html) {\n    // remove br in paragraph to compatible with markdown\n    var replacedHTML = html.replace(/<p><br\\s*\\/*><\\/p>/gi, '<p></p>');\n    var reHTMLTag = new RegExp(HTML_TAG, 'ig');\n    var htmlTagMatched = replacedHTML.match(reHTMLTag);\n    htmlTagMatched === null || htmlTagMatched === void 0 ? void 0 : htmlTagMatched.forEach(function (htmlTag, index) {\n        if (reBR.test(htmlTag)) {\n            var alternativeTag = ALTERNATIVE_TAG_FOR_BR;\n            if (index) {\n                var prevTag = htmlTagMatched[index - 1];\n                var openTagMatched = prevTag.match(OPEN_TAG);\n                if (openTagMatched && !/br/i.test(openTagMatched[1])) {\n                    var tagName = openTagMatched[1];\n                    alternativeTag = \"</\" + tagName + \"><\" + tagName + \">\";\n                }\n            }\n            replacedHTML = replacedHTML.replace(reBR, alternativeTag);\n        }\n    });\n    return replacedHTML;\n}\nfunction removeProseMirrorHackNodes(html) {\n    var reProseMirrorImage = /<img class=\"ProseMirror-separator\" alt=\"\">/g;\n    var reProseMirrorTrailingBreak = / class=\"ProseMirror-trailingBreak\"/g;\n    var resultHTML = html;\n    resultHTML = resultHTML.replace(reProseMirrorImage, '');\n    resultHTML = resultHTML.replace(reProseMirrorTrailingBreak, '');\n    return resultHTML;\n}\n\nvar pluginKey$1 = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('widget');\nvar MARGIN = 5;\nvar PopupWidget = /** @class */ (function () {\n    function PopupWidget(view, eventEmitter) {\n        var _this = this;\n        this.popup = null;\n        this.removeWidget = function () {\n            if (_this.popup) {\n                _this.rootEl.removeChild(_this.popup);\n                _this.popup = null;\n            }\n        };\n        this.rootEl = view.dom.parentElement;\n        this.eventEmitter = eventEmitter;\n        this.eventEmitter.listen('blur', this.removeWidget);\n        this.eventEmitter.listen('loadUI', function () {\n            _this.rootEl = closest(view.dom.parentElement, \".\" + cls('defaultUI'));\n        });\n        this.eventEmitter.listen('removePopupWidget', this.removeWidget);\n    }\n    PopupWidget.prototype.update = function (view) {\n        var widget = pluginKey$1.getState(view.state);\n        this.removeWidget();\n        if (widget) {\n            var node = widget.node, style = widget.style;\n            var _a = view.coordsAtPos(widget.pos), top_1 = _a.top, left = _a.left, bottom = _a.bottom;\n            var height = bottom - top_1;\n            var rect = this.rootEl.getBoundingClientRect();\n            var relTopPos = top_1 - rect.top;\n            css_1(node, { opacity: '0' });\n            this.rootEl.appendChild(node);\n            css_1(node, {\n                position: 'absolute',\n                left: left - rect.left + MARGIN + \"px\",\n                top: (style === 'bottom' ? relTopPos + height - MARGIN : relTopPos - height) + \"px\",\n                opacity: '1',\n            });\n            this.popup = node;\n            view.focus();\n        }\n    };\n    PopupWidget.prototype.destroy = function () {\n        this.eventEmitter.removeEventHandler('blur', this.removeWidget);\n    };\n    return PopupWidget;\n}());\nfunction addWidget(eventEmitter) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: pluginKey$1,\n        state: {\n            init: function () {\n                return null;\n            },\n            apply: function (tr) {\n                return tr.getMeta('widget');\n            },\n        },\n        view: function (editorView) {\n            return new PopupWidget(editorView, eventEmitter);\n        },\n    });\n}\n\nfunction addDefaultImageBlobHook(eventEmitter) {\n    eventEmitter.listen('addImageBlobHook', function (blob, callback) {\n        var reader = new FileReader();\n        reader.onload = function (_a) {\n            var target = _a.target;\n            return callback(target.result);\n        };\n        reader.readAsDataURL(blob);\n    });\n}\nfunction emitImageBlobHook(eventEmitter, blob, type) {\n    var hook = function (imageUrl, altText) {\n        eventEmitter.emit('command', 'addImage', {\n            imageUrl: imageUrl,\n            altText: altText || blob.name || 'image',\n        });\n    };\n    eventEmitter.emit('addImageBlobHook', blob, hook, type);\n}\nfunction pasteImageOnly(items) {\n    var images = toArray_1(items).filter(function (_a) {\n        var type = _a.type;\n        return type.indexOf('image') !== -1;\n    });\n    if (images.length === 1) {\n        var item = images[0];\n        if (item) {\n            return item.getAsFile();\n        }\n    }\n    return null;\n}\n\nfunction dropImage(_a) {\n    var eventEmitter = _a.eventEmitter;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                drop: function (_, ev) {\n                    var _a;\n                    var items = (_a = ev.dataTransfer) === null || _a === void 0 ? void 0 : _a.files;\n                    if (items) {\n                        forEachArray_1(items, function (item) {\n                            if (item.type.indexOf('image') !== -1) {\n                                ev.preventDefault();\n                                ev.stopPropagation();\n                                emitImageBlobHook(eventEmitter, item, ev.type);\n                                return false;\n                            }\n                            return true;\n                        });\n                    }\n                    return true;\n                },\n            },\n        },\n    });\n}\n\nvar Node$2 = /** @class */ (function () {\n    function Node() {\n    }\n    Object.defineProperty(Node.prototype, \"type\", {\n        get: function () {\n            return 'node';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Node.prototype.setContext = function (context) {\n        this.context = context;\n    };\n    return Node;\n}());\n\nfunction widgetNodeView(pmNode) {\n    var dom = document.createElement('span');\n    var node = widgetToDOM(pmNode.attrs.info, pmNode.textContent);\n    dom.className = 'tui-widget';\n    dom.appendChild(node);\n    return { dom: dom };\n}\nfunction isWidgetNode(pmNode) {\n    return pmNode.type.name === 'widget';\n}\nvar Widget = /** @class */ (function (_super) {\n    __extends$1(Widget, _super);\n    function Widget() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Widget.prototype, \"name\", {\n        get: function () {\n            return 'widget';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Widget.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: {\n                    info: { default: null },\n                },\n                group: 'inline',\n                inline: true,\n                content: 'text*',\n                selectable: false,\n                atom: true,\n                toDOM: function () {\n                    return ['span', { class: 'tui-widget' }, 0];\n                },\n                parseDOM: [\n                    {\n                        tag: 'span.tui-widget',\n                        getAttrs: function (dom) {\n                            var text = dom.textContent;\n                            var _a = text.match(/\\$\\$(widget\\d+)/), info = _a[1];\n                            return { info: info };\n                        },\n                    },\n                ],\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Widget;\n}(Node$2));\n\nvar EditorBase = /** @class */ (function () {\n    function EditorBase(eventEmitter) {\n        this.timer = null;\n        this.el = document.createElement('div');\n        this.el.className = 'toastui-editor';\n        this.eventEmitter = eventEmitter;\n        this.placeholder = { text: '' };\n    }\n    EditorBase.prototype.createState = function () {\n        return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({\n            schema: this.schema,\n            plugins: this.createPlugins(),\n        });\n    };\n    EditorBase.prototype.initEvent = function () {\n        var _a = this, eventEmitter = _a.eventEmitter, view = _a.view, editorType = _a.editorType;\n        view.dom.addEventListener('focus', function () { return eventEmitter.emit('focus', editorType); });\n        view.dom.addEventListener('blur', function () { return eventEmitter.emit('blur', editorType); });\n    };\n    EditorBase.prototype.emitChangeEvent = function (tr) {\n        this.eventEmitter.emit('caretChange', this.editorType);\n        if (tr.docChanged) {\n            this.eventEmitter.emit('change', this.editorType);\n        }\n    };\n    Object.defineProperty(EditorBase.prototype, \"defaultPlugins\", {\n        get: function () {\n            var rules = this.createInputRules();\n            var plugins = __spreadArray$1(__spreadArray$1([], this.keymaps), [\n                (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)(__assign$1({ 'Shift-Enter': prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.baseKeymap.Enter }, prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.baseKeymap)),\n                (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.history)(),\n                placeholder(this.placeholder),\n                addWidget(this.eventEmitter),\n                dropImage(this.context),\n            ]);\n            return rules ? plugins.concat(rules) : plugins;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    EditorBase.prototype.createInputRules = function () {\n        var widgetRules = getWidgetRules();\n        var rules = widgetRules.map(function (_a) {\n            var rule = _a.rule;\n            return new prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.InputRule(rule, function (state, match, start, end) {\n                var schema = state.schema, tr = state.tr, doc = state.doc;\n                var allMatched = match.input.match(new RegExp(rule, 'g'));\n                var pos = doc.resolve(start);\n                var parent = pos.parent;\n                var count = 0;\n                if (isWidgetNode(parent)) {\n                    parent = pos.node(pos.depth - 1);\n                }\n                parent.forEach(function (child) { return isWidgetNode(child) && (count += 1); });\n                // replace the content only if the count of matched rules in whole text is greater than current widget node count\n                if (allMatched.length > count) {\n                    var content = last$1(allMatched);\n                    var nodes = createNodesWithWidget(content, schema);\n                    // adjust start position based on widget content\n                    return tr.replaceWith(end - content.length + 1, end, nodes);\n                }\n                return null;\n            });\n        });\n        return rules.length ? (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.inputRules)({ rules: rules }) : null;\n    };\n    EditorBase.prototype.clearTimer = function () {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n    EditorBase.prototype.createSchema = function () {\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Schema({\n            nodes: this.specs.nodes,\n            marks: this.specs.marks,\n        });\n    };\n    EditorBase.prototype.createKeymaps = function (useCommandShortcut) {\n        var _a = getDefaultCommands(), undo = _a.undo, redo = _a.redo;\n        var allKeymaps = this.specs.keymaps(useCommandShortcut);\n        var historyKeymap = {\n            'Mod-z': undo(),\n            'Shift-Mod-z': redo(),\n        };\n        return useCommandShortcut ? allKeymaps.concat((0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)(historyKeymap)) : allKeymaps;\n    };\n    EditorBase.prototype.createCommands = function () {\n        return this.specs.commands(this.view);\n    };\n    EditorBase.prototype.createPluginProps = function () {\n        var _this = this;\n        return this.extraPlugins.map(function (plugin) { return plugin(_this.eventEmitter); });\n    };\n    EditorBase.prototype.focus = function () {\n        var _this = this;\n        this.clearTimer();\n        // prevent the error for IE11\n        this.timer = setTimeout(function () {\n            _this.view.focus();\n            _this.view.dispatch(_this.view.state.tr.scrollIntoView());\n        });\n    };\n    EditorBase.prototype.blur = function () {\n        this.view.dom.blur();\n    };\n    EditorBase.prototype.destroy = function () {\n        var _this = this;\n        this.clearTimer();\n        this.view.destroy();\n        Object.keys(this).forEach(function (prop) {\n            delete _this[prop];\n        });\n    };\n    EditorBase.prototype.moveCursorToStart = function (focus) {\n        var tr = this.view.state.tr;\n        this.view.dispatch(tr.setSelection(createTextSelection(tr, 1)).scrollIntoView());\n        if (focus) {\n            this.focus();\n        }\n    };\n    EditorBase.prototype.moveCursorToEnd = function (focus) {\n        var tr = this.view.state.tr;\n        this.view.dispatch(tr.setSelection(createTextSelection(tr, tr.doc.content.size - 1)).scrollIntoView());\n        if (focus) {\n            this.focus();\n        }\n    };\n    EditorBase.prototype.setScrollTop = function (top) {\n        this.view.dom.scrollTop = top;\n    };\n    EditorBase.prototype.getScrollTop = function () {\n        return this.view.dom.scrollTop;\n    };\n    EditorBase.prototype.setPlaceholder = function (text) {\n        this.placeholder.text = text;\n        this.view.dispatch(this.view.state.tr.scrollIntoView());\n    };\n    EditorBase.prototype.setHeight = function (height) {\n        css_1(this.el, { height: height + \"px\" });\n    };\n    EditorBase.prototype.setMinHeight = function (minHeight) {\n        css_1(this.el, { minHeight: minHeight + \"px\" });\n    };\n    EditorBase.prototype.getElement = function () {\n        return this.el;\n    };\n    return EditorBase;\n}());\n\n/**\n * @fileoverview Check whether the given variable is a function or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a function or not.\n * If the given variable is a function, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is function?\n * @memberof module:type\n */\nfunction isFunction(obj) {\n  return obj instanceof Function;\n}\n\nvar isFunction_1 = isFunction;\n\nvar defaultCommandShortcuts = [\n    'Enter',\n    'Shift-Enter',\n    'Mod-Enter',\n    'Tab',\n    'Shift-Tab',\n    'Delete',\n    'Backspace',\n    'Mod-Delete',\n    'Mod-Backspace',\n    'ArrowUp',\n    'ArrowDown',\n    'ArrowLeft',\n    'ArrowRight',\n    'Mod-d',\n    'Mod-D',\n    'Alt-ArrowUp',\n    'Alt-ArrowDown',\n];\nfunction execCommand(view, command, payload) {\n    view.focus();\n    return command(payload)(view.state, view.dispatch, view);\n}\nvar SpecManager = /** @class */ (function () {\n    function SpecManager(specs) {\n        this.specs = specs;\n    }\n    Object.defineProperty(SpecManager.prototype, \"nodes\", {\n        get: function () {\n            return this.specs\n                .filter(function (spec) { return spec.type === 'node'; })\n                .reduce(function (nodes, _a) {\n                var _b;\n                var name = _a.name, schema = _a.schema;\n                return __assign$1(__assign$1({}, nodes), (_b = {}, _b[name] = schema, _b));\n            }, {});\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpecManager.prototype, \"marks\", {\n        get: function () {\n            return this.specs\n                .filter(function (spec) { return spec.type === 'mark'; })\n                .reduce(function (marks, _a) {\n                var _b;\n                var name = _a.name, schema = _a.schema;\n                return __assign$1(__assign$1({}, marks), (_b = {}, _b[name] = schema, _b));\n            }, {});\n        },\n        enumerable: false,\n        configurable: true\n    });\n    SpecManager.prototype.commands = function (view, addedCommands) {\n        var specCommands = this.specs\n            .filter(function (_a) {\n            var commands = _a.commands;\n            return commands;\n        })\n            .reduce(function (allCommands, spec) {\n            var commands = {};\n            var specCommand = spec.commands();\n            if (isFunction_1(specCommand)) {\n                commands[spec.name] = function (payload) { return execCommand(view, specCommand, payload); };\n            }\n            else {\n                Object.keys(specCommand).forEach(function (name) {\n                    commands[name] = function (payload) { return execCommand(view, specCommand[name], payload); };\n                });\n            }\n            return __assign$1(__assign$1({}, allCommands), commands);\n        }, {});\n        var defaultCommands = getDefaultCommands();\n        Object.keys(defaultCommands).forEach(function (name) {\n            specCommands[name] = function (payload) { return execCommand(view, defaultCommands[name], payload); };\n        });\n        if (addedCommands) {\n            Object.keys(addedCommands).forEach(function (name) {\n                specCommands[name] = function (payload) { return execCommand(view, addedCommands[name], payload); };\n            });\n        }\n        return specCommands;\n    };\n    SpecManager.prototype.keymaps = function (useCommandShortcut) {\n        var specKeymaps = this.specs.filter(function (spec) { return spec.keymaps; }).map(function (spec) { return spec.keymaps(); });\n        return specKeymaps.map(function (keys) {\n            if (!useCommandShortcut) {\n                Object.keys(keys).forEach(function (key) {\n                    if (!includes(defaultCommandShortcuts, key)) {\n                        delete keys[key];\n                    }\n                });\n            }\n            return (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)(keys);\n        });\n    };\n    SpecManager.prototype.setContext = function (context) {\n        this.specs.forEach(function (spec) {\n            spec.setContext(context);\n        });\n    };\n    return SpecManager;\n}());\n\nfunction resolveSelectionPos(selection) {\n    var from = selection.from, to = selection.to;\n    if (selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection) {\n        return [from + 1, to - 1];\n    }\n    return [from, to];\n}\nfunction getMdLine(resolvedPos) {\n    return resolvedPos.index(0) + 1;\n}\nfunction getWidgetNodePos(node, chPos, direction) {\n    if (direction === void 0) { direction = 1; }\n    var additionalPos = 0;\n    node.forEach(function (child, pos) {\n        // add or subtract widget node tag\n        if (isWidgetNode(child) && pos + 2 < chPos) {\n            additionalPos += 2 * direction;\n        }\n    });\n    return additionalPos;\n}\nfunction getEditorToMdPos(doc, from, to) {\n    if (to === void 0) { to = from; }\n    var collapsed = from === to;\n    var startResolvedPos = doc.resolve(from);\n    var startLine = getMdLine(startResolvedPos);\n    var endLine = startLine;\n    var startOffset = startResolvedPos.start(1);\n    var endOffset = startOffset;\n    if (!collapsed) {\n        // prevent the end offset from pointing to the root document position\n        var endResolvedPos = doc.resolve(to === doc.content.size ? to - 1 : to);\n        endOffset = endResolvedPos.start(1);\n        endLine = getMdLine(endResolvedPos);\n        // To resolve the end offset excluding document tag size\n        if (endResolvedPos.pos === doc.content.size) {\n            to = doc.content.size - 2;\n        }\n    }\n    var startCh = Math.max(from - startOffset + 1, 1);\n    var endCh = Math.max(to - endOffset + 1, 1);\n    return [\n        [startLine, startCh + getWidgetNodePos(doc.child(startLine - 1), startCh, -1)],\n        [endLine, endCh + getWidgetNodePos(doc.child(endLine - 1), endCh, -1)],\n    ];\n}\nfunction getStartPosListPerLine(doc, endIndex) {\n    var startPosListPerLine = [];\n    for (var i = 0, pos = 0; i < endIndex; i += 1) {\n        var child = doc.child(i);\n        startPosListPerLine[i] = pos;\n        pos += child.nodeSize;\n    }\n    return startPosListPerLine;\n}\nfunction getMdToEditorPos(doc, startPos, endPos) {\n    var startPosListPerLine = getStartPosListPerLine(doc, endPos[0]);\n    var startIndex = startPos[0] - 1;\n    var endIndex = endPos[0] - 1;\n    var startNode = doc.child(startIndex);\n    var endNode = doc.child(endIndex);\n    // calculate the position corresponding to the line\n    var from = startPosListPerLine[startIndex];\n    var to = startPosListPerLine[endIndex];\n    // calculate the position corresponding to the character offset of the line\n    from += startPos[1] + getWidgetNodePos(startNode, startPos[1] - 1);\n    to += endPos[1] + getWidgetNodePos(endNode, endPos[1] - 1);\n    return [from, Math.min(to, doc.content.size)];\n}\nfunction getRangeInfo(selection) {\n    var $from = selection.$from, $to = selection.$to;\n    var from = selection.from, to = selection.to;\n    var doc = $from.doc;\n    if (selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection) {\n        $from = doc.resolve(from + 1);\n        $to = doc.resolve(to - 1);\n    }\n    if ($from.depth === 0) {\n        $from = doc.resolve(from - 1);\n        $to = $from;\n    }\n    return {\n        startFromOffset: $from.start(1),\n        endFromOffset: $to.start(1),\n        startToOffset: $from.end(1),\n        endToOffset: $to.end(1),\n        startIndex: $from.index(0),\n        endIndex: $to.index(0),\n        from: $from.pos,\n        to: $to.pos,\n    };\n}\nfunction getNodeContentOffsetRange(doc, targetIndex) {\n    var startOffset = 1;\n    var endOffset = 1;\n    for (var i = 0, offset = 0; i < doc.childCount; i += 1) {\n        var nodeSize = doc.child(i).nodeSize;\n        // calculate content start, end offset(not node offset)\n        startOffset = offset + 1;\n        endOffset = offset + nodeSize - 1;\n        if (i === targetIndex) {\n            break;\n        }\n        offset += nodeSize;\n    }\n    return { startOffset: startOffset, endOffset: endOffset };\n}\n\nvar HEADING = 'heading';\nvar BLOCK_QUOTE = 'blockQuote';\nvar LIST_ITEM = 'listItem';\nvar TABLE = 'table';\nvar TABLE_CELL = 'tableCell';\nvar CODE_BLOCK = 'codeBlock';\nvar THEMATIC_BREAK = 'thematicBreak';\nvar LINK = 'link';\nvar CODE = 'code';\nvar META = 'meta';\nvar DELIM = 'delimiter';\nvar TASK_DELIM = 'taskDelimiter';\nvar TEXT = 'markedText';\nvar HTML = 'html';\nvar CUSTOM_BLOCK = 'customBlock';\nvar delimSize = {\n    strong: 2,\n    emph: 1,\n    strike: 2,\n};\nfunction markInfo(start, end, type, attrs) {\n    return { start: start, end: end, spec: { type: type, attrs: attrs } };\n}\nfunction heading$1(_a, start, end) {\n    var level = _a.level, headingType = _a.headingType;\n    var marks = [markInfo(start, end, HEADING, { level: level })];\n    if (headingType === 'atx') {\n        marks.push(markInfo(start, addOffsetPos(start, level), DELIM));\n    }\n    else {\n        marks.push(markInfo(setOffsetPos(end, 0), end, HEADING, { seText: true }));\n    }\n    return marks;\n}\nfunction emphasisAndStrikethrough(_a, start, end) {\n    var type = _a.type;\n    var startDelimPos = addOffsetPos(start, delimSize[type]);\n    var endDelimPos = addOffsetPos(end, -delimSize[type]);\n    return [\n        markInfo(startDelimPos, endDelimPos, type),\n        markInfo(start, startDelimPos, DELIM),\n        markInfo(endDelimPos, end, DELIM),\n    ];\n}\nfunction markLink(start, end, linkTextStart, lastChildCh) {\n    return [\n        markInfo(start, end, LINK),\n        markInfo(setOffsetPos(start, linkTextStart[1] + 1), setOffsetPos(end, lastChildCh), LINK, {\n            desc: true,\n        }),\n        markInfo(setOffsetPos(end, lastChildCh + 2), addOffsetPos(end, -1), LINK, { url: true }),\n    ];\n}\nfunction image$1(_a, start, end) {\n    var lastChild = _a.lastChild;\n    var lastChildCh = lastChild ? getMdEndCh(lastChild) + 1 : 3; // 3: length of '![]'\n    var linkTextEnd = addOffsetPos(start, 1);\n    return __spreadArray$1([markInfo(start, linkTextEnd, META)], markLink(start, end, linkTextEnd, lastChildCh));\n}\nfunction link(_a, start, end) {\n    var lastChild = _a.lastChild, extendedAutolink = _a.extendedAutolink;\n    var lastChildCh = lastChild ? getMdEndCh(lastChild) + 1 : 2; // 2: length of '[]'\n    return extendedAutolink\n        ? [markInfo(start, end, LINK, { desc: true })]\n        : markLink(start, end, start, lastChildCh);\n}\nfunction code(_a, start, end) {\n    var tickCount = _a.tickCount;\n    var openDelimEnd = addOffsetPos(start, tickCount);\n    var closeDelimStart = addOffsetPos(end, -tickCount);\n    return [\n        markInfo(start, end, CODE),\n        markInfo(start, openDelimEnd, CODE, { start: true }),\n        markInfo(openDelimEnd, closeDelimStart, CODE, { marked: true }),\n        markInfo(closeDelimStart, end, CODE, { end: true }),\n    ];\n}\nfunction lineBackground(parent, start, end, prefix) {\n    var defaultBackground = {\n        start: start,\n        end: end,\n        spec: {\n            attrs: { className: prefix + \"-line-background\", codeStart: start[0], codeEnd: end[0] },\n        },\n        lineBackground: true,\n    };\n    return parent.type !== 'item' && parent.type !== 'blockQuote'\n        ? [\n            __assign$1(__assign$1({}, defaultBackground), { end: start, spec: { attrs: { className: prefix + \"-line-background start\" } } }),\n            __assign$1(__assign$1({}, defaultBackground), { start: [Math.min(start[0] + 1, end[0]), start[1]] }),\n        ]\n        : null;\n}\nfunction codeBlock$1(node, start, end, endLine) {\n    var fenceOffset = node.fenceOffset, fenceLength = node.fenceLength, fenceChar = node.fenceChar, info = node.info, infoPadding = node.infoPadding, parent = node.parent;\n    var fenceEnd = fenceOffset + fenceLength;\n    var marks = [markInfo(setOffsetPos(start, 1), end, CODE_BLOCK)];\n    if (fenceChar) {\n        marks.push(markInfo(start, addOffsetPos(start, fenceEnd), DELIM));\n    }\n    if (info) {\n        marks.push(markInfo(addOffsetPos(start, fenceLength), addOffsetPos(start, fenceLength + infoPadding + info.length), META));\n    }\n    var codeBlockEnd = \"^(\\\\s{0,4})(\" + fenceChar + \"{\" + fenceLength + \",})\";\n    var reCodeBlockEnd = new RegExp(codeBlockEnd);\n    if (reCodeBlockEnd.test(endLine)) {\n        marks.push(markInfo(setOffsetPos(end, 1), end, DELIM));\n    }\n    var lineBackgroundMarkInfo = lineBackground(parent, start, end, 'code-block');\n    return lineBackgroundMarkInfo ? marks.concat(lineBackgroundMarkInfo) : marks;\n}\nfunction customBlock$2(node, start, end) {\n    var _a = node, offset = _a.offset, syntaxLength = _a.syntaxLength, info = _a.info, parent = _a.parent;\n    var syntaxEnd = offset + syntaxLength;\n    var marks = [markInfo(setOffsetPos(start, 1), end, CUSTOM_BLOCK)];\n    marks.push(markInfo(start, addOffsetPos(start, syntaxEnd), DELIM));\n    if (info) {\n        marks.push(markInfo(addOffsetPos(start, syntaxEnd), addOffsetPos(start, syntaxLength + info.length), META));\n    }\n    marks.push(markInfo(setOffsetPos(end, 1), end, DELIM));\n    var lineBackgroundMarkInfo = lineBackground(parent, start, end, 'custom-block');\n    return lineBackgroundMarkInfo ? marks.concat(lineBackgroundMarkInfo) : marks;\n}\nfunction markListItemChildren(node, markType) {\n    var marks = [];\n    while (node) {\n        var type = node.type;\n        if (type === 'paragraph' || type === 'codeBlock') {\n            marks.push(markInfo([getMdStartLine(node), getMdStartCh(node) - 1], [getMdEndLine(node), getMdEndCh(node) + 1], markType));\n        }\n        node = node.next;\n    }\n    return marks;\n}\nfunction markParagraphInBlockQuote(node) {\n    var marks = [];\n    while (node) {\n        marks.push(markInfo([getMdStartLine(node), getMdStartCh(node)], [getMdEndLine(node), getMdEndCh(node) + 1], TEXT));\n        node = node.next;\n    }\n    return marks;\n}\nfunction blockQuote$2(node, start, end) {\n    var marks = node.parent && node.parent.type !== 'blockQuote' ? [markInfo(start, end, BLOCK_QUOTE)] : [];\n    if (node.firstChild) {\n        var childMarks = [];\n        if (node.firstChild.type === 'paragraph') {\n            childMarks = markParagraphInBlockQuote(node.firstChild.firstChild);\n        }\n        else if (node.firstChild.type === 'list') {\n            childMarks = markListItemChildren(node.firstChild, TEXT);\n        }\n        marks = __spreadArray$1(__spreadArray$1([], marks), childMarks);\n    }\n    return marks;\n}\nfunction getSpecOfListItemStyle(node) {\n    var depth = 0;\n    while (node.parent.parent && node.parent.parent.type === 'item') {\n        node = node.parent.parent;\n        depth += 1;\n    }\n    var attrs = [{ odd: true }, { even: true }][depth % 2];\n    return [LIST_ITEM, __assign$1(__assign$1({}, attrs), { listStyle: true })];\n}\nfunction item$1(node, start) {\n    var _a = node.listData, padding = _a.padding, task = _a.task;\n    var spec = getSpecOfListItemStyle(node);\n    var marks = [markInfo.apply(void 0, __spreadArray$1([start, addOffsetPos(start, padding)], spec))];\n    if (task) {\n        marks.push(markInfo(addOffsetPos(start, padding), addOffsetPos(start, padding + 3), TASK_DELIM));\n        marks.push(markInfo(addOffsetPos(start, padding + 1), addOffsetPos(start, padding + 2), META));\n    }\n    return marks.concat(markListItemChildren(node.firstChild, TEXT));\n}\nvar markNodeFuncMap = {\n    heading: heading$1,\n    strong: emphasisAndStrikethrough,\n    emph: emphasisAndStrikethrough,\n    strike: emphasisAndStrikethrough,\n    link: link,\n    image: image$1,\n    code: code,\n    codeBlock: codeBlock$1,\n    blockQuote: blockQuote$2,\n    item: item$1,\n    customBlock: customBlock$2,\n};\nvar simpleMarkClassNameMap = {\n    thematicBreak: THEMATIC_BREAK,\n    table: TABLE,\n    tableCell: TABLE_CELL,\n    htmlInline: HTML,\n};\nfunction getMarkInfo(node, start, end, endLine) {\n    var type = node.type;\n    if (isFunction_1(markNodeFuncMap[type])) {\n        // @ts-ignore\n        return markNodeFuncMap[type](node, start, end, endLine);\n    }\n    if (simpleMarkClassNameMap[type]) {\n        return [markInfo(start, end, simpleMarkClassNameMap[type])];\n    }\n    return null;\n}\n\nvar removingBackgroundIndexMap = {};\nfunction syntaxHighlight(_a) {\n    var schema = _a.schema, toastMark = _a.toastMark;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        appendTransaction: function (transactions, _, newState) {\n            var tr = transactions[0];\n            var newTr = newState.tr;\n            if (tr.docChanged) {\n                var markInfo_1 = [];\n                var editResult = tr.getMeta('editResult');\n                editResult.forEach(function (result) {\n                    var nodes = result.nodes, removedNodeRange = result.removedNodeRange;\n                    if (nodes.length) {\n                        markInfo_1 = markInfo_1.concat(getMarkForRemoving(newTr, nodes));\n                        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n                            var parent_1 = nodes_1[_i];\n                            var walker = parent_1.walker();\n                            var event_1 = walker.next();\n                            while (event_1) {\n                                var node = event_1.node, entering = event_1.entering;\n                                if (entering) {\n                                    markInfo_1 = markInfo_1.concat(getMarkForAdding(node, toastMark));\n                                }\n                                event_1 = walker.next();\n                            }\n                        }\n                    }\n                    else if (removedNodeRange) {\n                        var maxIndex = newTr.doc.childCount - 1;\n                        var _a = removedNodeRange.line, startLine = _a[0], endLine = _a[1];\n                        var startIndex = Math.min(startLine, maxIndex);\n                        var endIndex = Math.min(endLine, maxIndex);\n                        // cache the index to remove code block, custom block background when there are no adding nodes\n                        for (var i = startIndex; i <= endIndex; i += 1) {\n                            removingBackgroundIndexMap[i] = true;\n                        }\n                    }\n                });\n                appendMarkTr(newTr, schema, markInfo_1);\n            }\n            return newTr.setMeta('widget', tr.getMeta('widget'));\n        },\n    });\n}\nfunction isDifferentBlock(doc, index, attrs) {\n    return Object.keys(attrs).some(function (name) { return attrs[name] !== doc.child(index).attrs[name]; });\n}\nfunction addLineBackground(tr, doc, paragraph, blockPosInfo, attrs) {\n    if (attrs === void 0) { attrs = {}; }\n    var startIndex = blockPosInfo.startIndex, endIndex = blockPosInfo.endIndex, from = blockPosInfo.from, to = blockPosInfo.to;\n    var shouldChangeBlockType = false;\n    for (var i = startIndex; i <= endIndex; i += 1) {\n        // prevent to remove background of the node that need to have background\n        delete removingBackgroundIndexMap[i];\n        shouldChangeBlockType = isDifferentBlock(doc, i, attrs);\n    }\n    if (shouldChangeBlockType) {\n        tr.setBlockType(from, to, paragraph, attrs);\n    }\n}\nfunction appendMarkTr(tr, schema, marks) {\n    var doc = tr.doc;\n    var paragraph = schema.nodes.paragraph;\n    // get start position per line for lazy calculation\n    var startPosListPerLine = getStartPosListPerLine(doc, doc.childCount);\n    marks.forEach(function (_a) {\n        var start = _a.start, end = _a.end, spec = _a.spec, lineBackground = _a.lineBackground;\n        var startIndex = Math.min(start[0], doc.childCount) - 1;\n        var endIndex = Math.min(end[0], doc.childCount) - 1;\n        var startNode = doc.child(startIndex);\n        var endNode = doc.child(endIndex);\n        // calculate the position corresponding to the line\n        var from = startPosListPerLine[startIndex];\n        var to = startPosListPerLine[endIndex];\n        // calculate the position corresponding to the character offset of the line\n        from += start[1] + getWidgetNodePos(startNode, start[1] - 1);\n        to += end[1] + getWidgetNodePos(endNode, end[1] - 1);\n        if (spec) {\n            if (lineBackground) {\n                var posInfo = { from: from, to: to, startIndex: startIndex, endIndex: endIndex };\n                addLineBackground(tr, doc, paragraph, posInfo, spec.attrs);\n            }\n            else {\n                tr.addMark(from, to, schema.mark(spec.type, spec.attrs));\n            }\n        }\n        else {\n            tr.removeMark(from, to);\n        }\n    });\n    removeBlockBackground(tr, startPosListPerLine, paragraph);\n}\nfunction removeBlockBackground(tr, startPosListPerLine, paragraph) {\n    Object.keys(removingBackgroundIndexMap).forEach(function (index) {\n        var startIndex = Number(index);\n        // get the end position of the current line with the next node start position.\n        var endIndex = Math.min(Number(index) + 1, tr.doc.childCount - 1);\n        var from = startPosListPerLine[startIndex];\n        // subtract '1' for getting end position of the line\n        var to = startPosListPerLine[endIndex] - 1;\n        if (startIndex === endIndex) {\n            to += 2;\n        }\n        tr.setBlockType(from, to, paragraph);\n    });\n}\nfunction cacheIndexToRemoveBackground(doc, start, end) {\n    var skipLines = [];\n    removingBackgroundIndexMap = {};\n    for (var i = start[0] - 1; i < end[0]; i += 1) {\n        var node = doc.child(i);\n        var codeEnd = node.attrs.codeEnd;\n        var codeStart = node.attrs.codeStart;\n        if (codeStart && codeEnd && !includes(skipLines, codeStart)) {\n            skipLines.push(codeStart);\n            codeEnd = Math.min(codeEnd, doc.childCount);\n            // should subtract '1' to markdown line position\n            // because markdown parser has '1'(not zero) as the start number\n            var startIndex = codeStart - 1;\n            var endIndex = end[0];\n            for (var index = startIndex; index < endIndex; index += 1) {\n                removingBackgroundIndexMap[index] = true;\n            }\n        }\n    }\n}\nfunction getMarkForRemoving(_a, nodes) {\n    var doc = _a.doc;\n    var start = nodes[0].sourcepos[0];\n    var _b = last$1(nodes).sourcepos, end = _b[1];\n    var startPos = [start[0], start[1]];\n    var endPos = [end[0], end[1] + 1];\n    var marks = [];\n    cacheIndexToRemoveBackground(doc, start, end);\n    marks.push({ start: startPos, end: endPos });\n    return marks;\n}\nfunction getMarkForAdding(node, toastMark) {\n    var lineTexts = toastMark.getLineTexts();\n    var startPos = [getMdStartLine(node), getMdStartCh(node)];\n    var endPos = [getMdEndLine(node), getMdEndCh(node) + 1];\n    var markInfo = getMarkInfo(node, startPos, endPos, lineTexts[endPos[0] - 1]);\n    return markInfo !== null && markInfo !== void 0 ? markInfo : [];\n}\n\nvar defaultToolbarStateKeys = [\n    'taskList',\n    'orderedList',\n    'bulletList',\n    'table',\n    'strong',\n    'emph',\n    'strike',\n    'heading',\n    'thematicBreak',\n    'blockQuote',\n    'code',\n    'codeBlock',\n    'indent',\n    'outdent',\n];\nfunction getToolbarStateType$1(mdNode) {\n    var type = mdNode.type;\n    if (isListNode$1(mdNode)) {\n        if (mdNode.listData.task) {\n            return 'taskList';\n        }\n        return mdNode.listData.type === 'ordered' ? 'orderedList' : 'bulletList';\n    }\n    if (type.indexOf('table') !== -1) {\n        return 'table';\n    }\n    if (!includes(defaultToolbarStateKeys, type)) {\n        return null;\n    }\n    return type;\n}\nfunction getToolbarState$1(targetNode) {\n    var toolbarState = {\n        indent: { active: false, disabled: true },\n        outdent: { active: false, disabled: true },\n    };\n    var listEnabled = true;\n    traverseParentNodes(targetNode, function (mdNode) {\n        var type = getToolbarStateType$1(mdNode);\n        if (!type) {\n            return;\n        }\n        if (type === 'bulletList' || type === 'orderedList') {\n            // to apply the nearlist list state in the nested list\n            if (listEnabled) {\n                toolbarState[type] = { active: true };\n                toolbarState.indent.disabled = false;\n                toolbarState.outdent.disabled = false;\n                listEnabled = false;\n            }\n        }\n        else {\n            toolbarState[type] = { active: true };\n        }\n    });\n    return toolbarState;\n}\nfunction previewHighlight(_a) {\n    var toastMark = _a.toastMark, eventEmitter = _a.eventEmitter;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        view: function () {\n            return {\n                update: function (view, prevState) {\n                    var state = view.state;\n                    var doc = state.doc, selection = state.selection;\n                    if (prevState && prevState.doc.eq(doc) && prevState.selection.eq(selection)) {\n                        return;\n                    }\n                    var from = selection.from;\n                    var startChOffset = state.doc.resolve(from).start();\n                    var line = state.doc.content.findIndex(from).index + 1;\n                    var ch = from - startChOffset;\n                    if (from === startChOffset) {\n                        ch += 1;\n                    }\n                    var cursorPos = [line, ch];\n                    var mdNode = toastMark.findNodeAtPosition(cursorPos);\n                    var toolbarState = getToolbarState$1(mdNode);\n                    eventEmitter.emit('changeToolbarState', {\n                        cursorPos: cursorPos,\n                        mdNode: mdNode,\n                        toolbarState: toolbarState,\n                    });\n                    eventEmitter.emit('setFocusedNode', mdNode);\n                },\n            };\n        },\n    });\n}\n\nvar Doc$1 = /** @class */ (function (_super) {\n    __extends$1(Doc, _super);\n    function Doc() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Doc.prototype, \"name\", {\n        get: function () {\n            return 'doc';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Doc.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'block+',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Doc;\n}(Node$2));\n\nvar Mark = /** @class */ (function () {\n    function Mark() {\n    }\n    Object.defineProperty(Mark.prototype, \"type\", {\n        get: function () {\n            return 'mark';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Mark.prototype.setContext = function (context) {\n        this.context = context;\n    };\n    return Mark;\n}());\n\nfunction getTextByMdLine(doc, mdLine) {\n    return getTextContent(doc, mdLine - 1);\n}\nfunction getTextContent(doc, index) {\n    return doc.child(index).textContent;\n}\n\nvar reBlockQuote = /^\\s*> ?/;\nvar BlockQuote$1 = /** @class */ (function (_super) {\n    __extends$1(BlockQuote, _super);\n    function BlockQuote() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(BlockQuote.prototype, \"name\", {\n        get: function () {\n            return 'blockQuote';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BlockQuote.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('block-quote') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BlockQuote.prototype.createBlockQuoteText = function (text, isBlockQuote) {\n        return isBlockQuote ? text.replace(reBlockQuote, '').trim() : \"> \" + text.trim();\n    };\n    BlockQuote.prototype.extendBlockQuote = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, doc = _a.doc, tr = _a.tr, schema = _a.schema;\n            var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, to = _b.to;\n            var textContent = getTextContent(doc, endIndex);\n            var isBlockQuote = reBlockQuote.test(textContent);\n            if (isBlockQuote && to > endFromOffset && selection.empty) {\n                var isEmpty = !textContent.replace(reBlockQuote, '').trim();\n                if (isEmpty) {\n                    tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));\n                }\n                else {\n                    var slicedText = textContent.slice(to - endFromOffset).trim();\n                    var node = createTextNode$1(schema, _this.createBlockQuoteText(slicedText));\n                    splitAndExtendBlock(tr, endToOffset, slicedText, node);\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    BlockQuote.prototype.commands = function () {\n        var _this = this;\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, doc = state.doc;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            var isBlockQuote = reBlockQuote.test(getTextContent(doc, startIndex));\n            var tr = replaceTextNode({\n                state: state,\n                startIndex: startIndex,\n                endIndex: endIndex,\n                from: startFromOffset,\n                createText: function (textContent) { return _this.createBlockQuoteText(textContent, isBlockQuote); },\n            });\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));\n            return true;\n        }; };\n    };\n    BlockQuote.prototype.keymaps = function () {\n        var blockQuoteCommand = this.commands()();\n        return {\n            'alt-q': blockQuoteCommand,\n            'alt-Q': blockQuoteCommand,\n            Enter: this.extendBlockQuote(),\n        };\n    };\n    return BlockQuote;\n}(Mark));\n\nvar reList = /(^\\s*)([-*+] |[\\d]+\\. )/;\nvar reOrderedList = /(^\\s*)([\\d])+\\.( \\[[ xX]])? /;\nvar reOrderedListGroup = /^(\\s*)((\\d+)([.)]\\s(?:\\[(?:x|\\s)\\]\\s)?))(.*)/;\nvar reCanBeTaskList = /(^\\s*)([-*+]|[\\d]+\\.)( \\[[ xX]])? /;\nvar reBulletListGroup = /^(\\s*)([-*+]+(\\s(?:\\[(?:x|\\s)\\]\\s)?))(.*)/;\nvar reTaskList = /(^\\s*)([-*+] |[\\d]+\\. )(\\[[ xX]] )/;\nvar reBulletTaskList = /(^\\s*)([-*+])( \\[[ xX]]) /;\nfunction getListType(text) {\n    return reOrderedList.test(text) ? 'ordered' : 'bullet';\n}\nfunction getListDepth(mdNode) {\n    var depth = 0;\n    while (mdNode && mdNode.type !== 'document') {\n        if (mdNode.type === 'list') {\n            depth += 1;\n        }\n        mdNode = mdNode.parent;\n    }\n    return depth;\n}\nfunction findSameDepthList(toastMark, currentLine, depth, backward) {\n    var lineTexts = toastMark.getLineTexts();\n    var lineLen = lineTexts.length;\n    var result = [];\n    var line = currentLine;\n    while (backward ? line < lineLen : line > 1) {\n        line = backward ? line + 1 : line - 1;\n        var mdNode = toastMark.findFirstNodeAtLine(line);\n        var currentListDepth = getListDepth(mdNode);\n        if (currentListDepth === depth) {\n            result.push({ line: line, depth: depth, mdNode: mdNode });\n        }\n        else if (currentListDepth < depth) {\n            break;\n        }\n    }\n    return result;\n}\nfunction getSameDepthItems(_a) {\n    var toastMark = _a.toastMark, mdNode = _a.mdNode, line = _a.line;\n    var depth = getListDepth(mdNode);\n    var forwardList = findSameDepthList(toastMark, line, depth, false).reverse();\n    var backwardList = findSameDepthList(toastMark, line, depth, true);\n    return forwardList.concat([{ line: line, depth: depth, mdNode: mdNode }]).concat(backwardList);\n}\nfunction textToBullet(text) {\n    if (!reList.test(text)) {\n        return \"* \" + text;\n    }\n    var type = getListType(text);\n    if (type === 'bullet' && reCanBeTaskList.test(text)) {\n        text = text.replace(reBulletTaskList, '$1$2 ');\n    }\n    else if (type === 'ordered') {\n        text = text.replace(reOrderedList, '$1* ');\n    }\n    return text;\n}\nfunction textToOrdered(text, ordinalNum) {\n    if (!reList.test(text)) {\n        return ordinalNum + \". \" + text;\n    }\n    var type = getListType(text);\n    if (type === 'bullet' || (type === 'ordered' && reCanBeTaskList.test(text))) {\n        text = text.replace(reCanBeTaskList, \"$1\" + ordinalNum + \". \");\n    }\n    else if (type === 'ordered') {\n        // eslint-disable-next-line prefer-destructuring\n        var start = reOrderedListGroup.exec(text)[3];\n        if (Number(start) !== ordinalNum) {\n            text = text.replace(reOrderedList, \"$1\" + ordinalNum + \". \");\n        }\n    }\n    return text;\n}\nfunction getChangedInfo(doc, sameDepthItems, type, start) {\n    if (start === void 0) { start = 0; }\n    var firstIndex = Number.MAX_VALUE;\n    var lastIndex = 0;\n    var changedResults = sameDepthItems.map(function (_a, index) {\n        var line = _a.line;\n        firstIndex = Math.min(line - 1, firstIndex);\n        lastIndex = Math.max(line - 1, lastIndex);\n        var text = getTextByMdLine(doc, line);\n        text = type === 'bullet' ? textToBullet(text) : textToOrdered(text, index + 1 + start);\n        return { text: text, line: line };\n    });\n    return { changedResults: changedResults, firstIndex: firstIndex, lastIndex: lastIndex };\n}\nfunction getBulletOrOrdered(type, context) {\n    var sameDepthListInfo = getSameDepthItems(context);\n    return getChangedInfo(context.doc, sameDepthListInfo, type);\n}\nvar otherListToList = {\n    bullet: function (context) {\n        return getBulletOrOrdered('bullet', context);\n    },\n    ordered: function (context) {\n        return getBulletOrOrdered('ordered', context);\n    },\n    task: function (_a) {\n        var mdNode = _a.mdNode, doc = _a.doc, line = _a.line;\n        var text = getTextByMdLine(doc, line);\n        if (mdNode.listData.task) {\n            text = text.replace(reTaskList, '$1$2');\n        }\n        else if (isListNode$1(mdNode)) {\n            text = text.replace(reList, '$1$2[ ] ');\n        }\n        return { changedResults: [{ text: text, line: line }] };\n    },\n};\nvar otherNodeToList = {\n    bullet: function (_a) {\n        var doc = _a.doc, line = _a.line;\n        var lineText = getTextByMdLine(doc, line);\n        var changedResults = [{ text: \"* \" + lineText, line: line }];\n        return { changedResults: changedResults };\n    },\n    ordered: function (_a) {\n        var toastMark = _a.toastMark, doc = _a.doc, line = _a.line, startLine = _a.startLine;\n        var lineText = getTextByMdLine(doc, line);\n        var firstOrderedListNum = 1;\n        var firstOrderedListLine = startLine;\n        var skipped = 0;\n        for (var i = startLine - 1; i > 0; i -= 1) {\n            var mdNode = toastMark.findFirstNodeAtLine(i);\n            var text = getTextByMdLine(doc, i);\n            var canBeListNode = text && !!findClosestNode(mdNode, function (targetNode) { return isListNode$1(targetNode); });\n            var searchResult = reOrderedListGroup.exec(getTextByMdLine(doc, i));\n            if (!searchResult && !canBeListNode) {\n                break;\n            }\n            if (!searchResult && canBeListNode) {\n                skipped += 1;\n                continue;\n            }\n            var _b = searchResult, indent = _b[1], start = _b[3];\n            // basis on one depth list\n            if (!indent) {\n                firstOrderedListNum = Number(start);\n                firstOrderedListLine = i;\n                break;\n            }\n        }\n        var ordinalNum = firstOrderedListNum + line - firstOrderedListLine - skipped;\n        var changedResults = [{ text: ordinalNum + \". \" + lineText, line: line }];\n        return { changedResults: changedResults };\n    },\n    task: function (_a) {\n        var doc = _a.doc, line = _a.line;\n        var lineText = getTextByMdLine(doc, line);\n        var changedResults = [{ text: \"* [ ] \" + lineText, line: line }];\n        return { changedResults: changedResults };\n    },\n};\nvar extendList = {\n    bullet: function (_a) {\n        var line = _a.line, doc = _a.doc;\n        var lineText = getTextByMdLine(doc, line);\n        var _b = reBulletListGroup.exec(lineText), indent = _b[1], delimiter = _b[2];\n        return { listSyntax: \"\" + indent + delimiter };\n    },\n    ordered: function (_a) {\n        var toastMark = _a.toastMark, line = _a.line, mdNode = _a.mdNode, doc = _a.doc;\n        var depth = getListDepth(mdNode);\n        var lineText = getTextByMdLine(doc, line);\n        var _b = reOrderedListGroup.exec(lineText), indent = _b[1], start = _b[3], delimiter = _b[4];\n        var ordinalNum = Number(start) + 1;\n        var listSyntax = \"\" + indent + ordinalNum + delimiter;\n        var backwardList = findSameDepthList(toastMark, line, depth, true);\n        var filteredList = backwardList.filter(function (info) {\n            var searchResult = reOrderedListGroup.exec(getTextByMdLine(doc, info.line));\n            return (searchResult &&\n                searchResult[1].length === indent.length &&\n                !!findClosestNode(info.mdNode, function (targetNode) { return isOrderedListNode(targetNode); }));\n        });\n        return __assign$1({ listSyntax: listSyntax }, getChangedInfo(doc, filteredList, 'ordered', ordinalNum));\n    },\n};\nfunction getReorderedListInfo(doc, schema, line, ordinalNum, prevIndentLength) {\n    var nodes = [];\n    var lineText = getTextByMdLine(doc, line);\n    var searchResult = reOrderedListGroup.exec(lineText);\n    while (searchResult) {\n        var indent = searchResult[1], delimiter = searchResult[4], text = searchResult[5];\n        var indentLength = indent.length;\n        if (indentLength === prevIndentLength) {\n            nodes.push(createTextNode$1(schema, \"\" + indent + ordinalNum + delimiter + text));\n            ordinalNum += 1;\n            line += 1;\n        }\n        else if (indentLength > prevIndentLength) {\n            var nestedListInfo = getReorderedListInfo(doc, schema, line, 1, indentLength);\n            line = nestedListInfo.line;\n            nodes = nodes.concat(nestedListInfo.nodes);\n        }\n        if (indentLength < prevIndentLength || line > doc.childCount) {\n            break;\n        }\n        lineText = getTextByMdLine(doc, line);\n        searchResult = reOrderedListGroup.exec(lineText);\n    }\n    return { nodes: nodes, line: line };\n}\n\nvar reStartSpace = /(^\\s{1,4})(.*)/;\nfunction isBlockUnit(from, to, text) {\n    return from < to || reList.test(text) || reBlockQuote.test(text);\n}\nfunction isInTableCellNode(doc, schema, selection) {\n    var $pos = selection.$from;\n    if ($pos.depth === 0) {\n        $pos = doc.resolve($pos.pos - 1);\n    }\n    var node = $pos.node(1);\n    var startOffset = $pos.start(1);\n    var contentSize = node.content.size;\n    return (node.rangeHasMark(0, contentSize, schema.marks.table) &&\n        $pos.pos - startOffset !== contentSize &&\n        $pos.pos !== startOffset);\n}\nfunction createSelection(tr, posInfo) {\n    var from = posInfo.from, to = posInfo.to;\n    if (posInfo.type === 'indent') {\n        var softTabLen = 4;\n        from += softTabLen;\n        to += (posInfo.lineLen + 1) * softTabLen;\n    }\n    else {\n        var spaceLenList = posInfo.spaceLenList;\n        from -= spaceLenList[0];\n        for (var i = 0; i < spaceLenList.length; i += 1) {\n            to -= spaceLenList[i];\n        }\n    }\n    return createTextSelection(tr, from, to);\n}\nvar Paragraph$1 = /** @class */ (function (_super) {\n    __extends$1(Paragraph, _super);\n    function Paragraph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Paragraph.prototype, \"name\", {\n        get: function () {\n            return 'paragraph';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Paragraph.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'inline*',\n                attrs: {\n                    className: { default: null },\n                    codeStart: { default: null },\n                    codeEnd: { default: null },\n                },\n                selectable: false,\n                group: 'block',\n                parseDOM: [{ tag: 'div' }],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return attrs.className\n                        ? ['div', { class: clsWithMdPrefix(attrs.className) }, 0]\n                        : ['div', 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Paragraph.prototype.reorderList = function (startLine, endLine) {\n        var _a = this.context, view = _a.view, toastMark = _a.toastMark, schema = _a.schema;\n        var _b = view.state, tr = _b.tr, selection = _b.selection, doc = _b.doc;\n        var mdNode = toastMark.findFirstNodeAtLine(startLine);\n        var topListNode = mdNode;\n        while (mdNode && !isBulletListNode(mdNode) && mdNode.parent.type !== 'document') {\n            mdNode = mdNode.parent;\n            if (isOrderedListNode(mdNode)) {\n                topListNode = mdNode;\n                break;\n            }\n        }\n        if (topListNode) {\n            startLine = topListNode.sourcepos[0][0];\n        }\n        var _c = reOrderedListGroup.exec(getTextByMdLine(doc, startLine)), indent = _c[1], start = _c[3];\n        var indentLen = indent.length;\n        var _d = getReorderedListInfo(doc, schema, startLine, Number(start), indentLen), line = _d.line, nodes = _d.nodes;\n        endLine = Math.max(endLine, line - 1);\n        var startOffset = getNodeContentOffsetRange(doc, startLine - 1).startOffset;\n        for (var i = startLine - 1; i <= endLine - 1; i += 1) {\n            var _e = doc.child(i), nodeSize = _e.nodeSize, content = _e.content;\n            var mappedFrom = tr.mapping.map(startOffset);\n            var mappedTo = mappedFrom + content.size;\n            tr.replaceWith(mappedFrom, mappedTo, nodes[i - startLine + 1]);\n            startOffset += nodeSize;\n        }\n        var newSelection = createTextSelection(tr, selection.from, selection.to);\n        view.dispatch(tr.setSelection(newSelection));\n    };\n    Paragraph.prototype.indent = function (tabKey) {\n        var _this = this;\n        if (tabKey === void 0) { tabKey = false; }\n        return function () { return function (state, dispatch) {\n            var schema = state.schema, selection = state.selection, doc = state.doc;\n            var _a = getRangeInfo(selection), from = _a.from, to = _a.to, startFromOffset = _a.startFromOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            if (tabKey && isInTableCellNode(doc, schema, selection)) {\n                return false;\n            }\n            var startLineText = getTextContent(doc, startIndex);\n            if ((tabKey && isBlockUnit(from, to, startLineText)) ||\n                (!tabKey && reList.test(startLineText))) {\n                var tr = replaceTextNode({\n                    state: state,\n                    from: startFromOffset,\n                    startIndex: startIndex,\n                    endIndex: endIndex,\n                    createText: function (textContent) { return \"    \" + textContent; },\n                });\n                var posInfo = {\n                    type: 'indent',\n                    from: from,\n                    to: to,\n                    lineLen: endIndex - startIndex,\n                };\n                dispatch(tr.setSelection(createSelection(tr, posInfo)));\n                if (reOrderedListGroup.test(startLineText)) {\n                    _this.reorderList(startIndex + 1, endIndex + 1);\n                }\n            }\n            else if (tabKey) {\n                dispatch(state.tr.insert(to, createTextNode$1(schema, '    ')));\n            }\n            return true;\n        }; };\n    };\n    Paragraph.prototype.outdent = function (tabKey) {\n        var _this = this;\n        if (tabKey === void 0) { tabKey = false; }\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, doc = state.doc, schema = state.schema;\n            var _a = getRangeInfo(selection), from = _a.from, to = _a.to, startFromOffset = _a.startFromOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            if (tabKey && isInTableCellNode(doc, schema, selection)) {\n                return false;\n            }\n            var startLineText = getTextContent(doc, startIndex);\n            if ((tabKey && isBlockUnit(from, to, startLineText)) ||\n                (!tabKey && reList.test(startLineText))) {\n                var spaceLenList_1 = [];\n                var tr = replaceTextNode({\n                    state: state,\n                    from: startFromOffset,\n                    startIndex: startIndex,\n                    endIndex: endIndex,\n                    createText: function (textContent) {\n                        var searchResult = reStartSpace.exec(textContent);\n                        spaceLenList_1.push(searchResult ? searchResult[1].length : 0);\n                        return textContent.replace(reStartSpace, '$2');\n                    },\n                });\n                var posInfo = { type: 'outdent', from: from, to: to, spaceLenList: spaceLenList_1 };\n                dispatch(tr.setSelection(createSelection(tr, posInfo)));\n                if (reOrderedListGroup.test(startLineText)) {\n                    _this.reorderList(startIndex + 1, endIndex + 1);\n                }\n            }\n            else if (tabKey) {\n                var startText = startLineText.slice(0, to - startFromOffset);\n                var startTextWithoutSpace = startText.replace(/\\s{1,4}$/, '');\n                var deletStart = to - (startText.length - startTextWithoutSpace.length);\n                dispatch(state.tr.delete(deletStart, to));\n            }\n            return true;\n        }; };\n    };\n    Paragraph.prototype.deleteLines = function () {\n        var _this = this;\n        return function (state, dispatch) {\n            var view = _this.context.view;\n            var _a = getRangeInfo(state.selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;\n            var deleteRange = function () {\n                dispatch(state.tr.deleteRange(startFromOffset, endToOffset));\n                return true;\n            };\n            return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.chainCommands)(deleteRange, prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.joinForward)(state, dispatch, view);\n        };\n    };\n    Paragraph.prototype.moveDown = function () {\n        return function (state, dispatch) {\n            var doc = state.doc, tr = state.tr, selection = state.selection, schema = state.schema;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, endIndex = _a.endIndex;\n            if (endIndex < doc.content.childCount - 1) {\n                var _b = doc.child(endIndex + 1), nodeSize = _b.nodeSize, textContent = _b.textContent;\n                tr.delete(endToOffset, endToOffset + nodeSize)\n                    .split(startFromOffset)\n                    // subtract 2(start, end tag length) to insert prev line\n                    .insert(tr.mapping.map(startFromOffset) - 2, createTextNode$1(schema, textContent));\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Paragraph.prototype.moveUp = function () {\n        return function (state, dispatch) {\n            var tr = state.tr, doc = state.doc, selection = state.selection, schema = state.schema;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex;\n            if (startIndex > 0) {\n                var _b = doc.child(startIndex - 1), nodeSize = _b.nodeSize, textContent = _b.textContent;\n                tr.delete(startFromOffset - nodeSize, startFromOffset)\n                    .split(tr.mapping.map(endToOffset))\n                    .insert(tr.mapping.map(endToOffset), createTextNode$1(schema, textContent));\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Paragraph.prototype.commands = function () {\n        return {\n            indent: this.indent(),\n            outdent: this.outdent(),\n        };\n    };\n    Paragraph.prototype.keymaps = function () {\n        return {\n            Tab: this.indent(true)(),\n            'Shift-Tab': this.outdent(true)(),\n            'Mod-d': this.deleteLines(),\n            'Mod-D': this.deleteLines(),\n            'Alt-ArrowUp': this.moveUp(),\n            'Alt-ArrowDown': this.moveDown(),\n        };\n    };\n    return Paragraph;\n}(Node$2));\n\nvar Text$1 = /** @class */ (function (_super) {\n    __extends$1(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Text.prototype, \"name\", {\n        get: function () {\n            return 'text';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"schema\", {\n        get: function () {\n            return {\n                group: 'inline',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Text;\n}(Node$2));\n\nvar reHeading = /^#{1,6}\\s/;\nvar Heading$1 = /** @class */ (function (_super) {\n    __extends$1(Heading, _super);\n    function Heading() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Heading.prototype, \"name\", {\n        get: function () {\n            return 'heading';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heading.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: {\n                    level: { default: 1 },\n                    seText: { default: false },\n                },\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var level = attrs.level, seText = attrs.seText;\n                    var classNames = \"heading|heading\" + level;\n                    if (seText) {\n                        classNames += '|delimiter|setext';\n                    }\n                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Heading.prototype.createHeadingText = function (level, text, curHeadingSyntax) {\n        var textContent = text.replace(curHeadingSyntax, '').trim();\n        var headingText = '';\n        while (level > 0) {\n            headingText += '#';\n            level -= 1;\n        }\n        return headingText + \" \" + textContent;\n    };\n    Heading.prototype.commands = function () {\n        var _this = this;\n        return function (payload) { return function (state, dispatch) {\n            var level = payload.level;\n            var _a = getRangeInfo(state.selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            var tr = replaceTextNode({\n                state: state,\n                from: startFromOffset,\n                startIndex: startIndex,\n                endIndex: endIndex,\n                createText: function (textContent) {\n                    var matchedHeading = textContent.match(reHeading);\n                    var curHeadingSyntax = matchedHeading ? matchedHeading[0] : '';\n                    return _this.createHeadingText(level, textContent, curHeadingSyntax);\n                },\n            });\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));\n            return true;\n        }; };\n    };\n    return Heading;\n}(Mark));\n\nvar fencedCodeBlockSyntax = '```';\nvar CodeBlock$1 = /** @class */ (function (_super) {\n    __extends$1(CodeBlock, _super);\n    function CodeBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CodeBlock.prototype, \"name\", {\n        get: function () {\n            return 'codeBlock';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CodeBlock.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('code-block') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CodeBlock.prototype.commands = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;\n            var fencedNode = createTextNode$1(schema, fencedCodeBlockSyntax);\n            // add fenced start block\n            tr.insert(startFromOffset, fencedNode).split(startFromOffset + fencedCodeBlockSyntax.length);\n            // add fenced end block\n            tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), fencedNode);\n            dispatch(tr.setSelection(\n            // subtract fenced syntax length and open, close tag(2)\n            createTextSelection(tr, tr.mapping.map(endToOffset) - (fencedCodeBlockSyntax.length + 2))));\n            return true;\n        }; };\n    };\n    CodeBlock.prototype.keepIndentation = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, doc = _a.doc, schema = _a.schema;\n            var toastMark = _this.context.toastMark;\n            var _b = getRangeInfo(selection), startFromOffset = _b.startFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, from = _b.from, to = _b.to;\n            var textContent = getTextContent(doc, endIndex);\n            if (from === to && textContent.trim()) {\n                var matched = textContent.match(/^\\s+/);\n                var mdNode = toastMark.findFirstNodeAtLine(endIndex + 1);\n                if (isCodeBlockNode(mdNode) && matched) {\n                    var spaces = matched[0];\n                    var slicedText = textContent.slice(to - startFromOffset);\n                    var node = createTextNode$1(schema, spaces + slicedText);\n                    splitAndExtendBlock(tr, endToOffset, slicedText, node);\n                    dispatch(tr);\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    CodeBlock.prototype.keymaps = function () {\n        var codeBlockCommand = this.commands()();\n        return {\n            'Shift-Mod-p': codeBlockCommand,\n            'Shift-Mod-P': codeBlockCommand,\n            Enter: this.keepIndentation(),\n        };\n    };\n    return CodeBlock;\n}(Mark));\n\nvar reEmptyTable = /\\||\\s/g;\nfunction createTableHeader(columnCount) {\n    return [createTableRow(columnCount), createTableRow(columnCount, true)];\n}\nfunction createTableBody$1(columnCount, rowCount) {\n    var bodyRows = [];\n    for (var i = 0; i < rowCount; i += 1) {\n        bodyRows.push(createTableRow(columnCount));\n    }\n    return bodyRows;\n}\nfunction createTableRow(columnCount, delim) {\n    var row = '|';\n    for (var i = 0; i < columnCount; i += 1) {\n        row += delim ? ' --- |' : '  |';\n    }\n    return row;\n}\nfunction createTargetTypes(moveNext) {\n    return moveNext\n        ? { type: 'next', parentType: 'tableHead', childType: 'firstChild' }\n        : { type: 'prev', parentType: 'tableBody', childType: 'lastChild' };\n}\nvar Table$1 = /** @class */ (function (_super) {\n    __extends$1(Table, _super);\n    function Table() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Table.prototype, \"name\", {\n        get: function () {\n            return 'table';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Table.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('table') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Table.prototype.extendTable = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, doc = _a.doc, tr = _a.tr, schema = _a.schema;\n            if (!selection.empty) {\n                return false;\n            }\n            var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, to = _b.to;\n            var textContent = getTextContent(doc, endIndex);\n            // should add `1` to line for the markdown parser\n            // because markdown parser has `1`(not zero) as the start number\n            var mdPos = [endIndex + 1, to - endFromOffset + 1];\n            var mdNode = _this.context.toastMark.findNodeAtPosition(mdPos);\n            var cellNode = findClosestNode(mdNode, function (node) {\n                return isTableCellNode(node) &&\n                    (node.parent.type === 'tableDelimRow' || node.parent.parent.type === 'tableBody');\n            });\n            if (cellNode) {\n                var isEmpty = !textContent.replace(reEmptyTable, '').trim();\n                var parent_1 = cellNode.parent;\n                var columnCount = parent_1.parent.parent.columns.length;\n                var row = createTableRow(columnCount);\n                if (isEmpty) {\n                    tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));\n                }\n                else {\n                    tr\n                        .split(endToOffset)\n                        .insert(tr.mapping.map(endToOffset), createTextNode$1(schema, row))\n                        // should subtract `2` to selection end position considering ` |` text\n                        .setSelection(createTextSelection(tr, tr.mapping.map(endToOffset) - 2));\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Table.prototype.moveTableCell = function (moveNext) {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr;\n            var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endIndex = _b.endIndex, to = _b.to;\n            var mdPos = [endIndex + 1, to - endFromOffset];\n            var mdNode = _this.context.toastMark.findNodeAtPosition(mdPos);\n            var cellNode = findClosestNode(mdNode, function (node) { return isTableCellNode(node); });\n            if (cellNode) {\n                var parent_2 = cellNode.parent;\n                var _c = createTargetTypes(moveNext), type = _c.type, parentType = _c.parentType, childType = _c.childType;\n                var chOffset = getMdEndCh(cellNode);\n                if (cellNode[type]) {\n                    chOffset = getMdEndCh(cellNode[type]) - 1;\n                }\n                else {\n                    var row = !parent_2[type] && parent_2.parent.type === parentType\n                        ? parent_2.parent[type][childType]\n                        : parent_2[type];\n                    if (type === 'next') {\n                        // if there is next row, the base offset would be end position of the next row's first child.\n                        // Otherwise, the base offset is zero.\n                        var baseOffset = row ? getMdEndCh(row[childType]) : 0;\n                        // calculate tag(open, close) position('2') for selection\n                        chOffset += baseOffset + 2;\n                    }\n                    else if (type === 'prev') {\n                        // if there is prev row, the target position would be '-4' for calculating ' |' characters and tag(open, close)\n                        // Otherwise, the target position is zero.\n                        chOffset = row ? -4 : 0;\n                    }\n                }\n                dispatch(tr.setSelection(createTextSelection(tr, endFromOffset + chOffset)));\n                return true;\n            }\n            return false;\n        };\n    };\n    Table.prototype.addTable = function () {\n        return function (payload) { return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, schema = _a.schema;\n            var _b = payload, columnCount = _b.columnCount, rowCount = _b.rowCount;\n            var endToOffset = getRangeInfo(selection).endToOffset;\n            var headerRows = createTableHeader(columnCount);\n            var bodyRows = createTableBody$1(columnCount, rowCount - 1);\n            var rows = __spreadArray$1(__spreadArray$1([], headerRows), bodyRows);\n            rows.forEach(function (row) {\n                tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), createTextNode$1(schema, row));\n            });\n            // should add `4` to selection position considering `| ` text and start block tag length\n            dispatch(tr.setSelection(createTextSelection(tr, endToOffset + 4)));\n            return true;\n        }; };\n    };\n    Table.prototype.commands = function () {\n        return { addTable: this.addTable() };\n    };\n    Table.prototype.keymaps = function () {\n        return {\n            Enter: this.extendTable(),\n            Tab: this.moveTableCell(true),\n            'Shift-Tab': this.moveTableCell(false),\n        };\n    };\n    return Table;\n}(Mark));\n\nvar thematicBreakSyntax = '***';\nvar ThematicBreak$1 = /** @class */ (function (_super) {\n    __extends$1(ThematicBreak, _super);\n    function ThematicBreak() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ThematicBreak.prototype, \"name\", {\n        get: function () {\n            return 'thematicBreak';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ThematicBreak.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('thematic-break') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ThematicBreak.prototype.hr = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getRangeInfo(selection), from = _a.from, to = _a.to, endToOffset = _a.endToOffset;\n            var node = createTextNode$1(schema, thematicBreakSyntax);\n            tr\n                .split(from)\n                .replaceWith(tr.mapping.map(from), tr.mapping.map(to), node)\n                .split(tr.mapping.map(to)).setSelection(createTextSelection(tr, tr.mapping.map(endToOffset)));\n            dispatch(tr);\n            return true;\n        }; };\n    };\n    ThematicBreak.prototype.commands = function () {\n        return { hr: this.hr() };\n    };\n    ThematicBreak.prototype.keymaps = function () {\n        var lineCommand = this.hr()();\n        return { 'Mod-l': lineCommand, 'Mod-L': lineCommand };\n    };\n    return ThematicBreak;\n}(Mark));\n\nfunction cannotBeListNode(_a, line) {\n    var type = _a.type, sourcepos = _a.sourcepos;\n    // eslint-disable-next-line prefer-destructuring\n    var startLine = sourcepos[0][0];\n    return line <= startLine && (type === 'codeBlock' || type === 'heading' || type.match('table'));\n}\nvar ListItem$1 = /** @class */ (function (_super) {\n    __extends$1(ListItem, _super);\n    function ListItem() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ListItem.prototype, \"name\", {\n        get: function () {\n            return 'listItem';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ListItem.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: {\n                    odd: { default: false },\n                    even: { default: false },\n                    listStyle: { default: false },\n                },\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var odd = attrs.odd, even = attrs.even, listStyle = attrs.listStyle;\n                    var classNames = 'list-item';\n                    if (listStyle) {\n                        classNames += '|list-item-style';\n                    }\n                    if (odd) {\n                        classNames += '|list-item-odd';\n                    }\n                    if (even) {\n                        classNames += '|list-item-even';\n                    }\n                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ListItem.prototype.extendList = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, doc = _a.doc, schema = _a.schema, tr = _a.tr;\n            var toastMark = _this.context.toastMark;\n            var _b = getRangeInfo(selection), to = _b.to, startFromOffset = _b.startFromOffset, endFromOffset = _b.endFromOffset, endIndex = _b.endIndex, endToOffset = _b.endToOffset;\n            var textContent = getTextContent(doc, endIndex);\n            var isList = reList.test(textContent);\n            if (!isList || selection.from === startFromOffset || !selection.empty) {\n                return false;\n            }\n            var isEmpty = !textContent.replace(reCanBeTaskList, '').trim();\n            if (isEmpty) {\n                tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));\n            }\n            else {\n                var commandType = getListType(textContent);\n                // should add `1` to line for the markdown parser\n                // because markdown parser has `1`(not zero) as the start number\n                var mdNode = toastMark.findFirstNodeAtLine(endIndex + 1);\n                var slicedText = textContent.slice(to - endFromOffset);\n                var context = { toastMark: toastMark, mdNode: mdNode, doc: doc, line: endIndex + 1 };\n                var _c = extendList[commandType](context), listSyntax = _c.listSyntax, changedResults = _c.changedResults;\n                // change ordinal number of backward ordered list\n                if (changedResults === null || changedResults === void 0 ? void 0 : changedResults.length) {\n                    // split the block\n                    tr.split(to);\n                    // set first ordered list info\n                    changedResults.unshift({ text: listSyntax + slicedText, line: endIndex + 1 });\n                    _this.changeToListPerLine(tr, changedResults, {\n                        from: to,\n                        // don't subtract 1 because the line has increased through 'split' command.\n                        startLine: changedResults[0].line,\n                        endLine: last$1(changedResults).line,\n                    });\n                    var pos = tr.mapping.map(endToOffset) - slicedText.length;\n                    tr.setSelection(createTextSelection(tr, pos));\n                }\n                else {\n                    var node = createTextNode$1(schema, listSyntax + slicedText);\n                    splitAndExtendBlock(tr, endToOffset, slicedText, node);\n                }\n            }\n            dispatch(tr);\n            return true;\n        };\n    };\n    ListItem.prototype.toList = function (commandType) {\n        var _this = this;\n        return function () { return function (_a, dispatch) {\n            var doc = _a.doc, tr = _a.tr, selection = _a.selection;\n            var toastMark = _this.context.toastMark;\n            var rangeInfo = getRangeInfo(selection);\n            // should add `1` to line for the markdown parser\n            // because markdown parser has `1`(not zero) as the start number\n            var startLine = rangeInfo.startIndex + 1;\n            var endLine = rangeInfo.endIndex + 1;\n            var endToOffset = rangeInfo.endToOffset;\n            var skipLines = [];\n            for (var line = startLine; line <= endLine; line += 1) {\n                var mdNode = toastMark.findFirstNodeAtLine(line);\n                if (mdNode && cannotBeListNode(mdNode, line)) {\n                    break;\n                }\n                // to skip unnecessary processing\n                if (skipLines.indexOf(line) !== -1) {\n                    continue;\n                }\n                var context = { toastMark: toastMark, mdNode: mdNode, doc: doc, line: line, startLine: startLine };\n                var changedResults = (isListNode$1(mdNode)\n                    ? otherListToList[commandType](context)\n                    : otherNodeToList[commandType](context)).changedResults;\n                var endOffset = _this.changeToListPerLine(tr, changedResults, {\n                    from: getNodeContentOffsetRange(doc, changedResults[0].line - 1).startOffset,\n                    startLine: changedResults[0].line,\n                    endLine: last$1(changedResults).line,\n                    indexDiff: 1,\n                });\n                endToOffset = Math.max(endOffset, endToOffset);\n                if (changedResults) {\n                    skipLines = skipLines.concat(changedResults.map(function (info) { return info.line; }));\n                }\n            }\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));\n            return true;\n        }; };\n    };\n    ListItem.prototype.changeToListPerLine = function (tr, changedResults, _a) {\n        var from = _a.from, startLine = _a.startLine, endLine = _a.endLine, _b = _a.indexDiff, indexDiff = _b === void 0 ? 0 : _b;\n        var maxEndOffset = 0;\n        var _loop_1 = function (i) {\n            var _c = tr.doc.child(i), nodeSize = _c.nodeSize, content = _c.content;\n            var mappedFrom = tr.mapping.map(from);\n            var mappedTo = mappedFrom + content.size;\n            var changedResult = changedResults.filter(function (result) { return result.line - indexDiff === i; })[0];\n            if (changedResult) {\n                tr.replaceWith(mappedFrom, mappedTo, createTextNode$1(this_1.context.schema, changedResult.text));\n                maxEndOffset = Math.max(maxEndOffset, from + content.size);\n            }\n            from += nodeSize;\n        };\n        var this_1 = this;\n        for (var i = startLine - indexDiff; i <= endLine - indexDiff; i += 1) {\n            _loop_1(i);\n        }\n        return maxEndOffset;\n    };\n    ListItem.prototype.toggleTask = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, doc = _a.doc, schema = _a.schema;\n            var toastMark = _this.context.toastMark;\n            var _b = getRangeInfo(selection), startIndex = _b.startIndex, endIndex = _b.endIndex;\n            var newTr = null;\n            for (var i = startIndex; i <= endIndex; i += 1) {\n                var mdNode = toastMark.findFirstNodeAtLine(i + 1);\n                if (isListNode$1(mdNode) && mdNode.listData.task) {\n                    var _c = mdNode.listData, checked = _c.checked, padding = _c.padding;\n                    var stateChar = checked ? ' ' : 'x';\n                    var mdPos = mdNode.sourcepos[0];\n                    var startOffset = getNodeContentOffsetRange(doc, mdPos[0] - 1).startOffset;\n                    startOffset += mdPos[1] + padding;\n                    newTr = tr.replaceWith(startOffset, startOffset + 1, schema.text(stateChar));\n                }\n            }\n            if (newTr) {\n                dispatch(newTr);\n                return true;\n            }\n            return false;\n        };\n    };\n    ListItem.prototype.commands = function () {\n        return {\n            bulletList: this.toList('bullet'),\n            orderedList: this.toList('ordered'),\n            taskList: this.toList('task'),\n        };\n    };\n    ListItem.prototype.keymaps = function () {\n        var bulletCommand = this.toList('bullet')();\n        var orderedCommand = this.toList('ordered')();\n        var taskCommand = this.toList('task')();\n        var togleTaskCommand = this.toggleTask();\n        return {\n            'Mod-u': bulletCommand,\n            'Mod-U': bulletCommand,\n            'Mod-o': orderedCommand,\n            'Mod-O': orderedCommand,\n            'alt-t': taskCommand,\n            'alt-T': taskCommand,\n            'Shift-Ctrl-x': togleTaskCommand,\n            'Shift-Ctrl-X': togleTaskCommand,\n            Enter: this.extendList(),\n        };\n    };\n    return ListItem;\n}(Mark));\n\nfunction toggleMark(condition, syntax) {\n    return function () { return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var conditionFn = !isFunction_1(condition)\n            ? function (text) { return condition.test(text); }\n            : condition;\n        var syntaxLen = syntax.length;\n        var doc = tr.doc;\n        var _b = resolveSelectionPos(selection), from = _b[0], to = _b[1];\n        var prevPos = Math.max(from - syntaxLen, 1);\n        var nextPos = Math.min(to + syntaxLen, doc.content.size - 1);\n        var slice = selection.content();\n        var textContent = slice.content.textBetween(0, slice.content.size, '\\n');\n        var prevText = doc.textBetween(prevPos, from, '\\n');\n        var nextText = doc.textBetween(to, nextPos, '\\n');\n        textContent = \"\" + prevText + textContent + nextText;\n        if (prevText && nextText && conditionFn(textContent)) {\n            tr.delete(nextPos - syntaxLen, nextPos).delete(prevPos, prevPos + syntaxLen);\n        }\n        else {\n            tr.insertText(syntax, to).insertText(syntax, from);\n            var newSelection = selection.empty\n                ? createTextSelection(tr, from + syntaxLen)\n                : createTextSelection(tr, from + syntaxLen, to + syntaxLen);\n            tr.setSelection(newSelection);\n        }\n        dispatch(tr);\n        return true;\n    }; };\n}\n\nvar reStrong = /^(\\*{2}|_{2}).*([\\s\\S]*)\\1$/m;\nvar strongSyntax = '**';\nvar Strong$1 = /** @class */ (function (_super) {\n    __extends$1(Strong, _super);\n    function Strong() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strong.prototype, \"name\", {\n        get: function () {\n            return 'strong';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strong.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('strong') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strong.prototype.bold = function () {\n        return toggleMark(reStrong, strongSyntax);\n    };\n    Strong.prototype.commands = function () {\n        return { bold: this.bold() };\n    };\n    Strong.prototype.keymaps = function () {\n        var boldCommand = this.bold()();\n        return { 'Mod-b': boldCommand, 'Mod-B': boldCommand };\n    };\n    return Strong;\n}(Mark));\n\nvar reStrike = /^(~{2}).*([\\s\\S]*)\\1$/m;\nvar strikeSyntax = '~~';\nvar Strike$1 = /** @class */ (function (_super) {\n    __extends$1(Strike, _super);\n    function Strike() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strike.prototype, \"name\", {\n        get: function () {\n            return 'strike';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strike.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('strike') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strike.prototype.commands = function () {\n        return toggleMark(reStrike, strikeSyntax);\n    };\n    Strike.prototype.keymaps = function () {\n        var strikeCommand = this.commands()();\n        return { 'Mod-s': strikeCommand, 'Mod-S': strikeCommand };\n    };\n    return Strike;\n}(Mark));\n\nvar reEmph = /^(\\*|_).*([\\s\\S]*)\\1$/m;\nvar emphSyntax = '*';\nvar Emph$1 = /** @class */ (function (_super) {\n    __extends$1(Emph, _super);\n    function Emph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Emph.prototype, \"name\", {\n        get: function () {\n            return 'emph';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Emph.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('emph') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Emph.prototype.italic = function () {\n        return toggleMark(reEmph, emphSyntax);\n    };\n    Emph.prototype.commands = function () {\n        return { italic: this.italic() };\n    };\n    Emph.prototype.keymaps = function () {\n        var italicCommand = this.italic()();\n        return { 'Mod-i': italicCommand, 'Mod-I': italicCommand };\n    };\n    return Emph;\n}(Mark));\n\nvar reCode = /^(`).*([\\s\\S]*)\\1$/m;\nvar codeSyntax = '`';\nvar Code$1 = /** @class */ (function (_super) {\n    __extends$1(Code, _super);\n    function Code() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Code.prototype, \"name\", {\n        get: function () {\n            return 'code';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Code.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: {\n                    start: { default: false },\n                    end: { default: false },\n                    marked: { default: false },\n                },\n                toDOM: function (mark) {\n                    var _a = mark.attrs, start = _a.start, end = _a.end, marked = _a.marked;\n                    var classNames = 'code';\n                    if (start) {\n                        classNames += '|delimiter|start';\n                    }\n                    if (end) {\n                        classNames += '|delimiter|end';\n                    }\n                    if (marked) {\n                        classNames += '|marked-text';\n                    }\n                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Code.prototype.commands = function () {\n        return toggleMark(reCode, codeSyntax);\n    };\n    Code.prototype.keymaps = function () {\n        var codeCommand = this.commands()();\n        return { 'Shift-Mod-c': codeCommand, 'Shift-Mod-C': codeCommand };\n    };\n    return Code;\n}(Mark));\n\nvar Link$1 = /** @class */ (function (_super) {\n    __extends$1(Link, _super);\n    function Link() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Link.prototype, \"name\", {\n        get: function () {\n            return 'link';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Link.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: {\n                    url: { default: false },\n                    desc: { default: false },\n                },\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var url = attrs.url, desc = attrs.desc;\n                    var classNames = 'link';\n                    if (url) {\n                        classNames += '|link-url|marked-text';\n                    }\n                    if (desc) {\n                        classNames += '|link-desc|marked-text';\n                    }\n                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Link.prototype.addLinkOrImage = function (commandType) {\n        return function (payload) { return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, schema = _a.schema;\n            var _b = resolveSelectionPos(selection), from = _b[0], to = _b[1];\n            var _c = payload, linkText = _c.linkText, altText = _c.altText, linkUrl = _c.linkUrl, imageUrl = _c.imageUrl;\n            var text = linkText;\n            var url = linkUrl;\n            var syntax = '';\n            if (commandType === 'image') {\n                text = altText;\n                url = imageUrl;\n                syntax = '!';\n            }\n            text = escapeTextForLink(text);\n            syntax += \"[\" + text + \"](\" + url + \")\";\n            dispatch(tr.replaceWith(from, to, createTextNode$1(schema, syntax)));\n            return true;\n        }; };\n    };\n    Link.prototype.commands = function () {\n        return {\n            addImage: this.addLinkOrImage('image'),\n            addLink: this.addLinkOrImage('link'),\n        };\n    };\n    return Link;\n}(Mark));\n\nvar TaskDelimiter = /** @class */ (function (_super) {\n    __extends$1(TaskDelimiter, _super);\n    function TaskDelimiter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TaskDelimiter.prototype, \"name\", {\n        get: function () {\n            return 'taskDelimiter';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TaskDelimiter.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('delimiter', 'list-item') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TaskDelimiter;\n}(Mark));\nvar Delimiter = /** @class */ (function (_super) {\n    __extends$1(Delimiter, _super);\n    function Delimiter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Delimiter.prototype, \"name\", {\n        get: function () {\n            return 'delimiter';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Delimiter.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('delimiter') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Delimiter;\n}(Mark));\nvar Meta = /** @class */ (function (_super) {\n    __extends$1(Meta, _super);\n    function Meta() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Meta.prototype, \"name\", {\n        get: function () {\n            return 'meta';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Meta.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('meta') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Meta;\n}(Mark));\nvar MarkedText = /** @class */ (function (_super) {\n    __extends$1(MarkedText, _super);\n    function MarkedText() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(MarkedText.prototype, \"name\", {\n        get: function () {\n            return 'markedText';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MarkedText.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('marked-text') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return MarkedText;\n}(Mark));\nvar TableCell = /** @class */ (function (_super) {\n    __extends$1(TableCell, _super);\n    function TableCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableCell.prototype, \"name\", {\n        get: function () {\n            return 'tableCell';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableCell.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('table-cell') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableCell;\n}(Mark));\n\nvar Html = /** @class */ (function (_super) {\n    __extends$1(Html, _super);\n    function Html() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Html.prototype, \"name\", {\n        get: function () {\n            return 'html';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Html.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('html') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Html;\n}(Mark));\n\nvar customBlockSyntax = '$$';\nvar CustomBlock$1 = /** @class */ (function (_super) {\n    __extends$1(CustomBlock, _super);\n    function CustomBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CustomBlock.prototype, \"name\", {\n        get: function () {\n            return 'customBlock';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CustomBlock.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('custom-block') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CustomBlock.prototype.commands = function () {\n        return function (payload) { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;\n            if (!(payload === null || payload === void 0 ? void 0 : payload.info)) {\n                return false;\n            }\n            var customBlock = \"\" + customBlockSyntax + payload.info;\n            var startNode = createTextNode$1(schema, customBlock);\n            var endNode = createTextNode$1(schema, customBlockSyntax);\n            tr.insert(startFromOffset, startNode).split(startFromOffset + customBlock.length);\n            tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), endNode);\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset) - (customBlockSyntax.length + 2))));\n            return true;\n        }; };\n    };\n    return CustomBlock;\n}(Mark));\n\nvar reTaskMarkerKey = /x|backspace/i;\nvar reTaskMarker = /^\\[(\\s*)(x?)(\\s*)\\](?:\\s+)/i;\nfunction smartTask(_a) {\n    var schema = _a.schema, toastMark = _a.toastMark;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                keyup: function (view, ev) {\n                    var _a;\n                    var _b = view.state, doc = _b.doc, tr = _b.tr, selection = _b.selection;\n                    if (selection.empty && reTaskMarkerKey.test(ev.key)) {\n                        var _c = getRangeInfo(selection), startIndex = _c.startIndex, startFromOffset = _c.startFromOffset, from = _c.from;\n                        // should add `1` to line for the markdown parser\n                        // because markdown parser has `1`(not zero) as the start number\n                        var mdPos = [startIndex + 1, from - startFromOffset + 1];\n                        var mdNode = toastMark.findNodeAtPosition(mdPos);\n                        var paraNode = findClosestNode(mdNode, function (node) { var _a; return node.type === 'paragraph' && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'item'; });\n                        if ((_a = paraNode === null || paraNode === void 0 ? void 0 : paraNode.firstChild) === null || _a === void 0 ? void 0 : _a.literal) {\n                            var firstChild = paraNode.firstChild;\n                            var matched = firstChild.literal.match(reTaskMarker);\n                            if (matched) {\n                                var startMdPos = firstChild.sourcepos[0];\n                                var startSpaces = matched[1], stateChar = matched[2], lastSpaces = matched[3];\n                                var spaces = startSpaces.length + lastSpaces.length;\n                                var startOffset = getNodeContentOffsetRange(doc, startMdPos[0] - 1).startOffset;\n                                var startPos = startMdPos[1] + startOffset;\n                                if (stateChar) {\n                                    var addedPos = spaces ? spaces + 1 : 0;\n                                    tr.replaceWith(startPos, addedPos + startPos, schema.text(stateChar));\n                                    view.dispatch(tr);\n                                }\n                                else if (!spaces) {\n                                    tr.insertText(' ', startPos);\n                                    view.dispatch(tr);\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                },\n            },\n        },\n    });\n}\n\nvar EVENT_TYPE = 'cut';\nvar reLineEnding$2 = /\\r\\n|\\n|\\r/;\nvar MdEditor = /** @class */ (function (_super) {\n    __extends$1(MdEditor, _super);\n    function MdEditor(eventEmitter, options) {\n        var _this = _super.call(this, eventEmitter) || this;\n        var toastMark = options.toastMark, _a = options.useCommandShortcut, useCommandShortcut = _a === void 0 ? true : _a, _b = options.mdPlugins, mdPlugins = _b === void 0 ? [] : _b;\n        _this.editorType = 'markdown';\n        _this.el.classList.add('md-mode');\n        _this.toastMark = toastMark;\n        _this.extraPlugins = mdPlugins;\n        _this.specs = _this.createSpecs();\n        _this.schema = _this.createSchema();\n        _this.context = _this.createContext();\n        _this.keymaps = _this.createKeymaps(useCommandShortcut);\n        _this.view = _this.createView();\n        _this.commands = _this.createCommands();\n        _this.specs.setContext(__assign$1(__assign$1({}, _this.context), { view: _this.view }));\n        _this.createClipboard();\n        // To prevent unnecessary focus setting during initial rendering\n        _this.eventEmitter.listen('changePreviewTabWrite', function (isMarkdownTabMounted) {\n            return _this.toggleActive(true, isMarkdownTabMounted);\n        });\n        _this.eventEmitter.listen('changePreviewTabPreview', function () { return _this.toggleActive(false); });\n        _this.initEvent();\n        return _this;\n    }\n    MdEditor.prototype.toggleActive = function (active, isMarkdownTabMounted) {\n        toggleClass(this.el, 'active', active);\n        if (active) {\n            if (!isMarkdownTabMounted) {\n                this.focus();\n            }\n        }\n        else {\n            this.blur();\n        }\n    };\n    MdEditor.prototype.createClipboard = function () {\n        var _this = this;\n        this.clipboard = document.createElement('textarea');\n        this.clipboard.className = cls('pseudo-clipboard');\n        this.clipboard.addEventListener('paste', function (ev) {\n            var clipboardData = ev.clipboardData || window.clipboardData;\n            var items = clipboardData && clipboardData.items;\n            if (items) {\n                var containRtfItem = toArray_1(items).some(function (item) { return item.kind === 'string' && item.type === 'text/rtf'; });\n                // if it contains rtf, it's most likely copy paste from office -> no image\n                if (!containRtfItem) {\n                    var imageBlob = pasteImageOnly(items);\n                    if (imageBlob) {\n                        ev.preventDefault();\n                        emitImageBlobHook(_this.eventEmitter, imageBlob, ev.type);\n                    }\n                }\n            }\n        });\n        // process the pasted data in input event for IE11\n        this.clipboard.addEventListener('input', function (ev) {\n            var text = ev.target.value;\n            _this.replaceSelection(text);\n            ev.preventDefault();\n            ev.target.value = '';\n        });\n        this.el.insertBefore(this.clipboard, this.view.dom);\n    };\n    MdEditor.prototype.createContext = function () {\n        return {\n            toastMark: this.toastMark,\n            schema: this.schema,\n            eventEmitter: this.eventEmitter,\n        };\n    };\n    MdEditor.prototype.createSpecs = function () {\n        return new SpecManager([\n            new Doc$1(),\n            new Paragraph$1(),\n            new Widget(),\n            new Text$1(),\n            new Heading$1(),\n            new BlockQuote$1(),\n            new CodeBlock$1(),\n            new CustomBlock$1(),\n            new Table$1(),\n            new TableCell(),\n            new ThematicBreak$1(),\n            new ListItem$1(),\n            new Strong$1(),\n            new Strike$1(),\n            new Emph$1(),\n            new Code$1(),\n            new Link$1(),\n            new Delimiter(),\n            new TaskDelimiter(),\n            new MarkedText(),\n            new Meta(),\n            new Html(),\n        ]);\n    };\n    MdEditor.prototype.createPlugins = function () {\n        return __spreadArray$1([\n            syntaxHighlight(this.context),\n            previewHighlight(this.context),\n            smartTask(this.context)\n        ], this.createPluginProps()).concat(this.defaultPlugins);\n    };\n    MdEditor.prototype.createView = function () {\n        var _this = this;\n        return new prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView(this.el, {\n            state: this.createState(),\n            dispatchTransaction: function (tr) {\n                _this.updateMarkdown(tr);\n                var state = _this.view.state.applyTransaction(tr).state;\n                _this.view.updateState(state);\n                _this.emitChangeEvent(tr);\n            },\n            handleKeyDown: function (_, ev) {\n                if ((ev.metaKey || ev.ctrlKey) && ev.key.toUpperCase() === 'V') {\n                    _this.clipboard.focus();\n                }\n                _this.eventEmitter.emit('keydown', _this.editorType, ev);\n                return false;\n            },\n            handleDOMEvents: {\n                copy: function (_, ev) { return _this.captureCopy(ev); },\n                cut: function (_, ev) { return _this.captureCopy(ev, EVENT_TYPE); },\n                scroll: function () {\n                    _this.eventEmitter.emit('scroll', 'editor');\n                    return true;\n                },\n                keyup: function (_, ev) {\n                    _this.eventEmitter.emit('keyup', _this.editorType, ev);\n                    return false;\n                },\n            },\n            nodeViews: {\n                widget: widgetNodeView,\n            },\n        });\n    };\n    MdEditor.prototype.createCommands = function () {\n        return this.specs.commands(this.view);\n    };\n    MdEditor.prototype.captureCopy = function (ev, type) {\n        ev.preventDefault();\n        var _a = this.view.state, selection = _a.selection, tr = _a.tr;\n        if (selection.empty) {\n            return true;\n        }\n        var text = this.getChanged(selection.content());\n        if (ev.clipboardData) {\n            ev.clipboardData.setData('text/plain', text);\n        }\n        else {\n            window.clipboardData.setData('Text', text);\n        }\n        if (type === EVENT_TYPE) {\n            this.view.dispatch(tr.deleteSelection().scrollIntoView().setMeta('uiEvent', EVENT_TYPE));\n        }\n        return true;\n    };\n    MdEditor.prototype.updateMarkdown = function (tr) {\n        var _this = this;\n        if (tr.docChanged) {\n            tr.steps.forEach(function (step, index) {\n                if (step.slice && !(step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep)) {\n                    var doc = tr.docs[index];\n                    var _a = [step.from, step.to], from = _a[0], to = _a[1];\n                    var _b = getEditorToMdPos(doc, from, to), startPos = _b[0], endPos = _b[1];\n                    var changed = _this.getChanged(step.slice);\n                    if (startPos[0] === endPos[0] && startPos[1] === endPos[1] && changed === '') {\n                        changed = '\\n';\n                    }\n                    var editResult = _this.toastMark.editMarkdown(startPos, endPos, changed);\n                    _this.eventEmitter.emit('updatePreview', editResult);\n                    tr.setMeta('editResult', editResult).scrollIntoView();\n                }\n            });\n        }\n    };\n    MdEditor.prototype.getChanged = function (slice) {\n        var changed = '';\n        var from = 0;\n        var to = slice.content.size;\n        slice.content.nodesBetween(from, to, function (node, pos) {\n            if (node.isText) {\n                changed += node.text.slice(Math.max(from, pos) - pos, to - pos);\n            }\n            else if (node.isBlock && pos > 0) {\n                changed += '\\n';\n            }\n        });\n        return changed;\n    };\n    MdEditor.prototype.setSelection = function (start, end) {\n        if (end === void 0) { end = start; }\n        var tr = this.view.state.tr;\n        var _a = getMdToEditorPos(tr.doc, start, end), from = _a[0], to = _a[1];\n        this.view.dispatch(tr.setSelection(createTextSelection(tr, from, to)).scrollIntoView());\n    };\n    MdEditor.prototype.replaceSelection = function (text, start, end) {\n        var newTr;\n        var _a = this.view.state, tr = _a.tr, schema = _a.schema, doc = _a.doc;\n        var lineTexts = text.split(reLineEnding$2);\n        var nodes = lineTexts.map(function (lineText) {\n            return createParagraph(schema, createNodesWithWidget(lineText, schema));\n        });\n        var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(nodes), 1, 1);\n        this.focus();\n        if (start && end) {\n            var _b = getMdToEditorPos(doc, start, end), from = _b[0], to = _b[1];\n            newTr = tr.replaceRange(from, to, slice);\n        }\n        else {\n            newTr = tr.replaceSelection(slice);\n        }\n        this.view.dispatch(newTr.scrollIntoView());\n    };\n    MdEditor.prototype.deleteSelection = function (start, end) {\n        var newTr;\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc;\n        if (start && end) {\n            var _b = getMdToEditorPos(doc, start, end), from = _b[0], to = _b[1];\n            newTr = tr.deleteRange(from, to);\n        }\n        else {\n            newTr = tr.deleteSelection();\n        }\n        this.view.dispatch(newTr.scrollIntoView());\n    };\n    MdEditor.prototype.getSelectedText = function (start, end) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var from = selection.from, to = selection.to;\n        if (start && end) {\n            var pos = getMdToEditorPos(doc, start, end);\n            from = pos[0];\n            to = pos[1];\n        }\n        return doc.textBetween(from, to, '\\n');\n    };\n    MdEditor.prototype.getSelection = function () {\n        var _a = this.view.state.selection, from = _a.from, to = _a.to;\n        return getEditorToMdPos(this.view.state.tr.doc, from, to);\n    };\n    MdEditor.prototype.setMarkdown = function (markdown, cursorToEnd) {\n        if (cursorToEnd === void 0) { cursorToEnd = true; }\n        var lineTexts = markdown.split(reLineEnding$2);\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc, schema = _a.schema;\n        var nodes = lineTexts.map(function (lineText) {\n            return createParagraph(schema, createNodesWithWidget(lineText, schema));\n        });\n        this.view.dispatch(tr.replaceWith(0, doc.content.size, nodes));\n        if (cursorToEnd) {\n            this.moveCursorToEnd(true);\n        }\n    };\n    MdEditor.prototype.addWidget = function (node, style, mdPos) {\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc, selection = _a.selection;\n        var pos = mdPos ? getMdToEditorPos(doc, mdPos, mdPos)[0] : selection.to;\n        this.view.dispatch(tr.setMeta('widget', { pos: pos, node: node, style: style }));\n    };\n    MdEditor.prototype.replaceWithWidget = function (start, end, text) {\n        var _a = this.view.state, tr = _a.tr, schema = _a.schema, doc = _a.doc;\n        var pos = getMdToEditorPos(doc, start, end);\n        var nodes = createNodesWithWidget(text, schema);\n        this.view.dispatch(tr.replaceWith(pos[0], pos[1], nodes));\n    };\n    MdEditor.prototype.getRangeInfoOfNode = function (pos) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var mdPos = pos || getEditorToMdPos(doc, selection.from)[0];\n        var mdNode = this.toastMark.findNodeAtPosition(mdPos);\n        if (mdNode.type === 'text' && mdNode.parent.type !== 'paragraph') {\n            mdNode = mdNode.parent;\n        }\n        // add 1 sync for prosemirror position\n        mdNode.sourcepos[1][1] += 1;\n        return { range: mdNode.sourcepos, type: mdNode.type };\n    };\n    MdEditor.prototype.getMarkdown = function () {\n        return this.toastMark\n            .getLineTexts()\n            .map(function (lineText) { return unwrapWidgetSyntax(lineText); })\n            .join('\\n');\n    };\n    MdEditor.prototype.getToastMark = function () {\n        return this.toastMark;\n    };\n    return MdEditor;\n}(EditorBase));\n\n/**\n * @fileoverview Get event collection for specific HTML element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar EVENT_KEY = '_feEventKey';\n\n/**\n * Get event collection for specific HTML element\n * @param {HTMLElement} element - HTML element\n * @param {string} type - event type\n * @returns {array}\n * @private\n */\nfunction safeEvent$2(element, type) {\n  var events = element[EVENT_KEY];\n  var handlers;\n\n  if (!events) {\n    events = element[EVENT_KEY] = {};\n  }\n\n  handlers = events[type];\n  if (!handlers) {\n    handlers = events[type] = [];\n  }\n\n  return handlers;\n}\n\nvar _safeEvent = safeEvent$2;\n\n/**\n * @fileoverview Unbind DOM events\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isString$1 = isString_1;\nvar forEach$1 = forEach_1;\n\nvar safeEvent$1 = _safeEvent;\n\n/**\n * Unbind DOM events\n * If a handler function is not passed, remove all events of that type.\n * @param {HTMLElement} element - element to unbind events\n * @param {(string|object)} types - Space splitted events names or eventName:handler object\n * @param {function} [handler] - handler function\n * @memberof module:domEvent\n * @example\n * // Following the example of domEvent#on\n * \n * // Unbind one event from an element.\n * off(div, 'click', toggle);\n * \n * // Unbind multiple events with a same handler from multiple elements at once.\n * // Use event names splitted by a space.\n * off(element, 'mouseenter mouseleave', changeColor);\n * \n * // Unbind multiple events with different handlers from an element at once.\n * // Use an object which of key is an event name and value is a handler function.\n * off(div, {\n *   keydown: highlight,\n *   keyup: dehighlight\n * });\n * \n * // Unbind events without handlers.\n * off(div, 'drag');\n */\nfunction off(element, types, handler) {\n  if (isString$1(types)) {\n    forEach$1(types.split(/\\s+/g), function(type) {\n      unbindEvent(element, type, handler);\n    });\n\n    return;\n  }\n\n  forEach$1(types, function(func, type) {\n    unbindEvent(element, type, func);\n  });\n}\n\n/**\n * Unbind DOM events\n * If a handler function is not passed, remove all events of that type.\n * @param {HTMLElement} element - element to unbind events\n * @param {string} type - events name\n * @param {function} [handler] - handler function\n * @private\n */\nfunction unbindEvent(element, type, handler) {\n  var events = safeEvent$1(element, type);\n  var index;\n\n  if (!handler) {\n    forEach$1(events, function(item) {\n      removeHandler(element, type, item.wrappedHandler);\n    });\n    events.splice(0, events.length);\n  } else {\n    forEach$1(events, function(item, idx) {\n      if (handler === item.handler) {\n        removeHandler(element, type, item.wrappedHandler);\n        index = idx;\n\n        return false;\n      }\n\n      return true;\n    });\n    events.splice(index, 1);\n  }\n}\n\n/**\n * Remove an event handler\n * @param {HTMLElement} element - An element to remove an event\n * @param {string} type - event type\n * @param {function} handler - event handler\n * @private\n */\nfunction removeHandler(element, type, handler) {\n  if ('removeEventListener' in element) {\n    element.removeEventListener(type, handler);\n  } else if ('detachEvent' in element) {\n    element.detachEvent('on' + type, handler);\n  }\n}\n\nvar off_1 = off;\n\n/**\n * @fileoverview Bind DOM events\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isString = isString_1;\nvar forEach = forEach_1;\n\nvar safeEvent = _safeEvent;\n\n/**\n * Bind DOM events.\n * @param {HTMLElement} element - element to bind events\n * @param {(string|object)} types - Space splitted events names or eventName:handler object\n * @param {(function|object)} handler - handler function or context for handler method\n * @param {object} [context] context - context for handler method.\n * @memberof module:domEvent\n * @example\n * const div = document.querySelector('div');\n * \n * // Bind one event to an element.\n * on(div, 'click', toggle);\n * \n * // Bind multiple events with a same handler to multiple elements at once.\n * // Use event names splitted by a space.\n * on(div, 'mouseenter mouseleave', changeColor);\n * \n * // Bind multiple events with different handlers to an element at once.\n * // Use an object which of key is an event name and value is a handler function.\n * on(div, {\n *   keydown: highlight,\n *   keyup: dehighlight\n * });\n * \n * // Set a context for handler method.\n * const name = 'global';\n * const repository = {name: 'CodeSnippet'};\n * on(div, 'drag', function() {\n *   console.log(this.name);\n * }, repository);\n * // Result when you drag a div: \"CodeSnippet\"\n */\nfunction on(element, types, handler, context) {\n  if (isString(types)) {\n    forEach(types.split(/\\s+/g), function(type) {\n      bindEvent(element, type, handler, context);\n    });\n\n    return;\n  }\n\n  forEach(types, function(func, type) {\n    bindEvent(element, type, func, handler);\n  });\n}\n\n/**\n * Bind DOM events\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} handler - handler function or context for handler method\n * @param {object} [context] context - context for handler method.\n * @private\n */\nfunction bindEvent(element, type, handler, context) {\n  /**\n     * Event handler\n     * @param {Event} e - event object\n     */\n  function eventHandler(e) {\n    handler.call(context || element, e || window.event);\n  }\n\n  if ('addEventListener' in element) {\n    element.addEventListener(type, eventHandler);\n  } else if ('attachEvent' in element) {\n    element.attachEvent('on' + type, eventHandler);\n  }\n  memorizeHandler(element, type, handler, eventHandler);\n}\n\n/**\n * Memorize DOM event handler for unbinding.\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} handler - handler function that user passed at on() use\n * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features\n * @private\n */\nfunction memorizeHandler(element, type, handler, wrappedHandler) {\n  var events = safeEvent(element, type);\n  var existInEvents = false;\n\n  forEach(events, function(obj) {\n    if (obj.handler === handler) {\n      existInEvents = true;\n\n      return false;\n    }\n\n    return true;\n  });\n\n  if (!existInEvents) {\n    events.push({\n      handler: handler,\n      wrappedHandler: wrappedHandler\n    });\n  }\n}\n\nvar on_1 = on;\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar encodeCache = {};\n\n\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache(exclude) {\n  var i, ch, cache = encodeCache[exclude];\n  if (cache) { return cache; }\n\n  cache = encodeCache[exclude] = [];\n\n  for (i = 0; i < 128; i++) {\n    ch = String.fromCharCode(i);\n\n    if (/^[0-9a-z]$/i.test(ch)) {\n      // always allow unencoded alphanumeric characters\n      cache.push(ch);\n    } else {\n      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n    }\n  }\n\n  for (i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i];\n  }\n\n  return cache;\n}\n\n\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode$1(string, exclude, keepEscaped) {\n  var i, l, code, nextCode, cache,\n      result = '';\n\n  if (typeof exclude !== 'string') {\n    // encode(string, keepEscaped)\n    keepEscaped  = exclude;\n    exclude = encode$1.defaultChars;\n  }\n\n  if (typeof keepEscaped === 'undefined') {\n    keepEscaped = true;\n  }\n\n  cache = getEncodeCache(exclude);\n\n  for (i = 0, l = string.length; i < l; i++) {\n    code = string.charCodeAt(i);\n\n    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n        result += string.slice(i, i + 3);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (code < 128) {\n      result += cache[code];\n      continue;\n    }\n\n    if (code >= 0xD800 && code <= 0xDFFF) {\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n        nextCode = string.charCodeAt(i + 1);\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n          result += encodeURIComponent(string[i] + string[i + 1]);\n          i++;\n          continue;\n        }\n      }\n      result += '%EF%BF%BD';\n      continue;\n    }\n\n    result += encodeURIComponent(string[i]);\n  }\n\n  return result;\n}\n\nencode$1.defaultChars   = \";/?:@&=+$,-_.!~*'()#\";\nencode$1.componentChars = \"-_.!~*'()\";\n\n\nvar encode_1 = encode$1;\n\nvar lib = {};\n\nvar decode = {};\n\nvar Aacute$1 = \"Á\";\nvar aacute$1 = \"á\";\nvar Abreve = \"Ă\";\nvar abreve = \"ă\";\nvar ac = \"∾\";\nvar acd = \"∿\";\nvar acE = \"∾̳\";\nvar Acirc$1 = \"Â\";\nvar acirc$1 = \"â\";\nvar acute$1 = \"´\";\nvar Acy = \"А\";\nvar acy = \"а\";\nvar AElig$1 = \"Æ\";\nvar aelig$1 = \"æ\";\nvar af = \"⁡\";\nvar Afr = \"𝔄\";\nvar afr = \"𝔞\";\nvar Agrave$1 = \"À\";\nvar agrave$1 = \"à\";\nvar alefsym = \"ℵ\";\nvar aleph = \"ℵ\";\nvar Alpha = \"Α\";\nvar alpha = \"α\";\nvar Amacr = \"Ā\";\nvar amacr = \"ā\";\nvar amalg = \"⨿\";\nvar amp$2 = \"&\";\nvar AMP$1 = \"&\";\nvar andand = \"⩕\";\nvar And = \"⩓\";\nvar and = \"∧\";\nvar andd = \"⩜\";\nvar andslope = \"⩘\";\nvar andv = \"⩚\";\nvar ang = \"∠\";\nvar ange = \"⦤\";\nvar angle = \"∠\";\nvar angmsdaa = \"⦨\";\nvar angmsdab = \"⦩\";\nvar angmsdac = \"⦪\";\nvar angmsdad = \"⦫\";\nvar angmsdae = \"⦬\";\nvar angmsdaf = \"⦭\";\nvar angmsdag = \"⦮\";\nvar angmsdah = \"⦯\";\nvar angmsd = \"∡\";\nvar angrt = \"∟\";\nvar angrtvb = \"⊾\";\nvar angrtvbd = \"⦝\";\nvar angsph = \"∢\";\nvar angst = \"Å\";\nvar angzarr = \"⍼\";\nvar Aogon = \"Ą\";\nvar aogon = \"ą\";\nvar Aopf = \"𝔸\";\nvar aopf = \"𝕒\";\nvar apacir = \"⩯\";\nvar ap = \"≈\";\nvar apE = \"⩰\";\nvar ape = \"≊\";\nvar apid = \"≋\";\nvar apos$1 = \"'\";\nvar ApplyFunction = \"⁡\";\nvar approx = \"≈\";\nvar approxeq = \"≊\";\nvar Aring$1 = \"Å\";\nvar aring$1 = \"å\";\nvar Ascr = \"𝒜\";\nvar ascr = \"𝒶\";\nvar Assign = \"≔\";\nvar ast = \"*\";\nvar asymp = \"≈\";\nvar asympeq = \"≍\";\nvar Atilde$1 = \"Ã\";\nvar atilde$1 = \"ã\";\nvar Auml$1 = \"Ä\";\nvar auml$1 = \"ä\";\nvar awconint = \"∳\";\nvar awint = \"⨑\";\nvar backcong = \"≌\";\nvar backepsilon = \"϶\";\nvar backprime = \"‵\";\nvar backsim = \"∽\";\nvar backsimeq = \"⋍\";\nvar Backslash = \"∖\";\nvar Barv = \"⫧\";\nvar barvee = \"⊽\";\nvar barwed = \"⌅\";\nvar Barwed = \"⌆\";\nvar barwedge = \"⌅\";\nvar bbrk = \"⎵\";\nvar bbrktbrk = \"⎶\";\nvar bcong = \"≌\";\nvar Bcy = \"Б\";\nvar bcy = \"б\";\nvar bdquo = \"„\";\nvar becaus = \"∵\";\nvar because = \"∵\";\nvar Because = \"∵\";\nvar bemptyv = \"⦰\";\nvar bepsi = \"϶\";\nvar bernou = \"ℬ\";\nvar Bernoullis = \"ℬ\";\nvar Beta = \"Β\";\nvar beta = \"β\";\nvar beth = \"ℶ\";\nvar between = \"≬\";\nvar Bfr = \"𝔅\";\nvar bfr = \"𝔟\";\nvar bigcap = \"⋂\";\nvar bigcirc = \"◯\";\nvar bigcup = \"⋃\";\nvar bigodot = \"⨀\";\nvar bigoplus = \"⨁\";\nvar bigotimes = \"⨂\";\nvar bigsqcup = \"⨆\";\nvar bigstar = \"★\";\nvar bigtriangledown = \"▽\";\nvar bigtriangleup = \"△\";\nvar biguplus = \"⨄\";\nvar bigvee = \"⋁\";\nvar bigwedge = \"⋀\";\nvar bkarow = \"⤍\";\nvar blacklozenge = \"⧫\";\nvar blacksquare = \"▪\";\nvar blacktriangle = \"▴\";\nvar blacktriangledown = \"▾\";\nvar blacktriangleleft = \"◂\";\nvar blacktriangleright = \"▸\";\nvar blank = \"␣\";\nvar blk12 = \"▒\";\nvar blk14 = \"░\";\nvar blk34 = \"▓\";\nvar block = \"█\";\nvar bne = \"=⃥\";\nvar bnequiv = \"≡⃥\";\nvar bNot = \"⫭\";\nvar bnot = \"⌐\";\nvar Bopf = \"𝔹\";\nvar bopf = \"𝕓\";\nvar bot = \"⊥\";\nvar bottom = \"⊥\";\nvar bowtie = \"⋈\";\nvar boxbox = \"⧉\";\nvar boxdl = \"┐\";\nvar boxdL = \"╕\";\nvar boxDl = \"╖\";\nvar boxDL = \"╗\";\nvar boxdr = \"┌\";\nvar boxdR = \"╒\";\nvar boxDr = \"╓\";\nvar boxDR = \"╔\";\nvar boxh = \"─\";\nvar boxH = \"═\";\nvar boxhd = \"┬\";\nvar boxHd = \"╤\";\nvar boxhD = \"╥\";\nvar boxHD = \"╦\";\nvar boxhu = \"┴\";\nvar boxHu = \"╧\";\nvar boxhU = \"╨\";\nvar boxHU = \"╩\";\nvar boxminus = \"⊟\";\nvar boxplus = \"⊞\";\nvar boxtimes = \"⊠\";\nvar boxul = \"┘\";\nvar boxuL = \"╛\";\nvar boxUl = \"╜\";\nvar boxUL = \"╝\";\nvar boxur = \"└\";\nvar boxuR = \"╘\";\nvar boxUr = \"╙\";\nvar boxUR = \"╚\";\nvar boxv = \"│\";\nvar boxV = \"║\";\nvar boxvh = \"┼\";\nvar boxvH = \"╪\";\nvar boxVh = \"╫\";\nvar boxVH = \"╬\";\nvar boxvl = \"┤\";\nvar boxvL = \"╡\";\nvar boxVl = \"╢\";\nvar boxVL = \"╣\";\nvar boxvr = \"├\";\nvar boxvR = \"╞\";\nvar boxVr = \"╟\";\nvar boxVR = \"╠\";\nvar bprime = \"‵\";\nvar breve = \"˘\";\nvar Breve = \"˘\";\nvar brvbar$1 = \"¦\";\nvar bscr = \"𝒷\";\nvar Bscr = \"ℬ\";\nvar bsemi = \"⁏\";\nvar bsim = \"∽\";\nvar bsime = \"⋍\";\nvar bsolb = \"⧅\";\nvar bsol = \"\\\\\";\nvar bsolhsub = \"⟈\";\nvar bull = \"•\";\nvar bullet = \"•\";\nvar bump = \"≎\";\nvar bumpE = \"⪮\";\nvar bumpe = \"≏\";\nvar Bumpeq = \"≎\";\nvar bumpeq = \"≏\";\nvar Cacute = \"Ć\";\nvar cacute = \"ć\";\nvar capand = \"⩄\";\nvar capbrcup = \"⩉\";\nvar capcap = \"⩋\";\nvar cap = \"∩\";\nvar Cap = \"⋒\";\nvar capcup = \"⩇\";\nvar capdot = \"⩀\";\nvar CapitalDifferentialD = \"ⅅ\";\nvar caps = \"∩︀\";\nvar caret = \"⁁\";\nvar caron = \"ˇ\";\nvar Cayleys = \"ℭ\";\nvar ccaps = \"⩍\";\nvar Ccaron = \"Č\";\nvar ccaron = \"č\";\nvar Ccedil$1 = \"Ç\";\nvar ccedil$1 = \"ç\";\nvar Ccirc = \"Ĉ\";\nvar ccirc = \"ĉ\";\nvar Cconint = \"∰\";\nvar ccups = \"⩌\";\nvar ccupssm = \"⩐\";\nvar Cdot = \"Ċ\";\nvar cdot = \"ċ\";\nvar cedil$1 = \"¸\";\nvar Cedilla = \"¸\";\nvar cemptyv = \"⦲\";\nvar cent$1 = \"¢\";\nvar centerdot = \"·\";\nvar CenterDot = \"·\";\nvar cfr = \"𝔠\";\nvar Cfr = \"ℭ\";\nvar CHcy = \"Ч\";\nvar chcy = \"ч\";\nvar check = \"✓\";\nvar checkmark = \"✓\";\nvar Chi = \"Χ\";\nvar chi = \"χ\";\nvar circ = \"ˆ\";\nvar circeq = \"≗\";\nvar circlearrowleft = \"↺\";\nvar circlearrowright = \"↻\";\nvar circledast = \"⊛\";\nvar circledcirc = \"⊚\";\nvar circleddash = \"⊝\";\nvar CircleDot = \"⊙\";\nvar circledR = \"®\";\nvar circledS = \"Ⓢ\";\nvar CircleMinus = \"⊖\";\nvar CirclePlus = \"⊕\";\nvar CircleTimes = \"⊗\";\nvar cir = \"○\";\nvar cirE = \"⧃\";\nvar cire = \"≗\";\nvar cirfnint = \"⨐\";\nvar cirmid = \"⫯\";\nvar cirscir = \"⧂\";\nvar ClockwiseContourIntegral = \"∲\";\nvar CloseCurlyDoubleQuote = \"”\";\nvar CloseCurlyQuote = \"’\";\nvar clubs = \"♣\";\nvar clubsuit = \"♣\";\nvar colon = \":\";\nvar Colon = \"∷\";\nvar Colone = \"⩴\";\nvar colone = \"≔\";\nvar coloneq = \"≔\";\nvar comma = \",\";\nvar commat = \"@\";\nvar comp = \"∁\";\nvar compfn = \"∘\";\nvar complement = \"∁\";\nvar complexes = \"ℂ\";\nvar cong = \"≅\";\nvar congdot = \"⩭\";\nvar Congruent = \"≡\";\nvar conint = \"∮\";\nvar Conint = \"∯\";\nvar ContourIntegral = \"∮\";\nvar copf = \"𝕔\";\nvar Copf = \"ℂ\";\nvar coprod = \"∐\";\nvar Coproduct = \"∐\";\nvar copy$1 = \"©\";\nvar COPY$1 = \"©\";\nvar copysr = \"℗\";\nvar CounterClockwiseContourIntegral = \"∳\";\nvar crarr = \"↵\";\nvar cross = \"✗\";\nvar Cross = \"⨯\";\nvar Cscr = \"𝒞\";\nvar cscr = \"𝒸\";\nvar csub = \"⫏\";\nvar csube = \"⫑\";\nvar csup = \"⫐\";\nvar csupe = \"⫒\";\nvar ctdot = \"⋯\";\nvar cudarrl = \"⤸\";\nvar cudarrr = \"⤵\";\nvar cuepr = \"⋞\";\nvar cuesc = \"⋟\";\nvar cularr = \"↶\";\nvar cularrp = \"⤽\";\nvar cupbrcap = \"⩈\";\nvar cupcap = \"⩆\";\nvar CupCap = \"≍\";\nvar cup = \"∪\";\nvar Cup = \"⋓\";\nvar cupcup = \"⩊\";\nvar cupdot = \"⊍\";\nvar cupor = \"⩅\";\nvar cups = \"∪︀\";\nvar curarr = \"↷\";\nvar curarrm = \"⤼\";\nvar curlyeqprec = \"⋞\";\nvar curlyeqsucc = \"⋟\";\nvar curlyvee = \"⋎\";\nvar curlywedge = \"⋏\";\nvar curren$1 = \"¤\";\nvar curvearrowleft = \"↶\";\nvar curvearrowright = \"↷\";\nvar cuvee = \"⋎\";\nvar cuwed = \"⋏\";\nvar cwconint = \"∲\";\nvar cwint = \"∱\";\nvar cylcty = \"⌭\";\nvar dagger = \"†\";\nvar Dagger = \"‡\";\nvar daleth = \"ℸ\";\nvar darr = \"↓\";\nvar Darr = \"↡\";\nvar dArr = \"⇓\";\nvar dash = \"‐\";\nvar Dashv = \"⫤\";\nvar dashv = \"⊣\";\nvar dbkarow = \"⤏\";\nvar dblac = \"˝\";\nvar Dcaron = \"Ď\";\nvar dcaron = \"ď\";\nvar Dcy = \"Д\";\nvar dcy = \"д\";\nvar ddagger = \"‡\";\nvar ddarr = \"⇊\";\nvar DD = \"ⅅ\";\nvar dd = \"ⅆ\";\nvar DDotrahd = \"⤑\";\nvar ddotseq = \"⩷\";\nvar deg$1 = \"°\";\nvar Del = \"∇\";\nvar Delta = \"Δ\";\nvar delta = \"δ\";\nvar demptyv = \"⦱\";\nvar dfisht = \"⥿\";\nvar Dfr = \"𝔇\";\nvar dfr = \"𝔡\";\nvar dHar = \"⥥\";\nvar dharl = \"⇃\";\nvar dharr = \"⇂\";\nvar DiacriticalAcute = \"´\";\nvar DiacriticalDot = \"˙\";\nvar DiacriticalDoubleAcute = \"˝\";\nvar DiacriticalGrave = \"`\";\nvar DiacriticalTilde = \"˜\";\nvar diam = \"⋄\";\nvar diamond = \"⋄\";\nvar Diamond = \"⋄\";\nvar diamondsuit = \"♦\";\nvar diams = \"♦\";\nvar die = \"¨\";\nvar DifferentialD = \"ⅆ\";\nvar digamma = \"ϝ\";\nvar disin = \"⋲\";\nvar div = \"÷\";\nvar divide$1 = \"÷\";\nvar divideontimes = \"⋇\";\nvar divonx = \"⋇\";\nvar DJcy = \"Ђ\";\nvar djcy = \"ђ\";\nvar dlcorn = \"⌞\";\nvar dlcrop = \"⌍\";\nvar dollar = \"$\";\nvar Dopf = \"𝔻\";\nvar dopf = \"𝕕\";\nvar Dot = \"¨\";\nvar dot = \"˙\";\nvar DotDot = \"⃜\";\nvar doteq = \"≐\";\nvar doteqdot = \"≑\";\nvar DotEqual = \"≐\";\nvar dotminus = \"∸\";\nvar dotplus = \"∔\";\nvar dotsquare = \"⊡\";\nvar doublebarwedge = \"⌆\";\nvar DoubleContourIntegral = \"∯\";\nvar DoubleDot = \"¨\";\nvar DoubleDownArrow = \"⇓\";\nvar DoubleLeftArrow = \"⇐\";\nvar DoubleLeftRightArrow = \"⇔\";\nvar DoubleLeftTee = \"⫤\";\nvar DoubleLongLeftArrow = \"⟸\";\nvar DoubleLongLeftRightArrow = \"⟺\";\nvar DoubleLongRightArrow = \"⟹\";\nvar DoubleRightArrow = \"⇒\";\nvar DoubleRightTee = \"⊨\";\nvar DoubleUpArrow = \"⇑\";\nvar DoubleUpDownArrow = \"⇕\";\nvar DoubleVerticalBar = \"∥\";\nvar DownArrowBar = \"⤓\";\nvar downarrow = \"↓\";\nvar DownArrow = \"↓\";\nvar Downarrow = \"⇓\";\nvar DownArrowUpArrow = \"⇵\";\nvar DownBreve = \"̑\";\nvar downdownarrows = \"⇊\";\nvar downharpoonleft = \"⇃\";\nvar downharpoonright = \"⇂\";\nvar DownLeftRightVector = \"⥐\";\nvar DownLeftTeeVector = \"⥞\";\nvar DownLeftVectorBar = \"⥖\";\nvar DownLeftVector = \"↽\";\nvar DownRightTeeVector = \"⥟\";\nvar DownRightVectorBar = \"⥗\";\nvar DownRightVector = \"⇁\";\nvar DownTeeArrow = \"↧\";\nvar DownTee = \"⊤\";\nvar drbkarow = \"⤐\";\nvar drcorn = \"⌟\";\nvar drcrop = \"⌌\";\nvar Dscr = \"𝒟\";\nvar dscr = \"𝒹\";\nvar DScy = \"Ѕ\";\nvar dscy = \"ѕ\";\nvar dsol = \"⧶\";\nvar Dstrok = \"Đ\";\nvar dstrok = \"đ\";\nvar dtdot = \"⋱\";\nvar dtri = \"▿\";\nvar dtrif = \"▾\";\nvar duarr = \"⇵\";\nvar duhar = \"⥯\";\nvar dwangle = \"⦦\";\nvar DZcy = \"Џ\";\nvar dzcy = \"џ\";\nvar dzigrarr = \"⟿\";\nvar Eacute$1 = \"É\";\nvar eacute$1 = \"é\";\nvar easter = \"⩮\";\nvar Ecaron = \"Ě\";\nvar ecaron = \"ě\";\nvar Ecirc$1 = \"Ê\";\nvar ecirc$1 = \"ê\";\nvar ecir = \"≖\";\nvar ecolon = \"≕\";\nvar Ecy = \"Э\";\nvar ecy = \"э\";\nvar eDDot = \"⩷\";\nvar Edot = \"Ė\";\nvar edot = \"ė\";\nvar eDot = \"≑\";\nvar ee = \"ⅇ\";\nvar efDot = \"≒\";\nvar Efr = \"𝔈\";\nvar efr = \"𝔢\";\nvar eg = \"⪚\";\nvar Egrave$1 = \"È\";\nvar egrave$1 = \"è\";\nvar egs = \"⪖\";\nvar egsdot = \"⪘\";\nvar el = \"⪙\";\nvar Element$1 = \"∈\";\nvar elinters = \"⏧\";\nvar ell = \"ℓ\";\nvar els = \"⪕\";\nvar elsdot = \"⪗\";\nvar Emacr = \"Ē\";\nvar emacr = \"ē\";\nvar empty = \"∅\";\nvar emptyset = \"∅\";\nvar EmptySmallSquare = \"◻\";\nvar emptyv = \"∅\";\nvar EmptyVerySmallSquare = \"▫\";\nvar emsp13 = \" \";\nvar emsp14 = \" \";\nvar emsp = \" \";\nvar ENG = \"Ŋ\";\nvar eng = \"ŋ\";\nvar ensp = \" \";\nvar Eogon = \"Ę\";\nvar eogon = \"ę\";\nvar Eopf = \"𝔼\";\nvar eopf = \"𝕖\";\nvar epar = \"⋕\";\nvar eparsl = \"⧣\";\nvar eplus = \"⩱\";\nvar epsi = \"ε\";\nvar Epsilon = \"Ε\";\nvar epsilon = \"ε\";\nvar epsiv = \"ϵ\";\nvar eqcirc = \"≖\";\nvar eqcolon = \"≕\";\nvar eqsim = \"≂\";\nvar eqslantgtr = \"⪖\";\nvar eqslantless = \"⪕\";\nvar Equal = \"⩵\";\nvar equals = \"=\";\nvar EqualTilde = \"≂\";\nvar equest = \"≟\";\nvar Equilibrium = \"⇌\";\nvar equiv = \"≡\";\nvar equivDD = \"⩸\";\nvar eqvparsl = \"⧥\";\nvar erarr = \"⥱\";\nvar erDot = \"≓\";\nvar escr = \"ℯ\";\nvar Escr = \"ℰ\";\nvar esdot = \"≐\";\nvar Esim = \"⩳\";\nvar esim = \"≂\";\nvar Eta = \"Η\";\nvar eta = \"η\";\nvar ETH$1 = \"Ð\";\nvar eth$1 = \"ð\";\nvar Euml$1 = \"Ë\";\nvar euml$1 = \"ë\";\nvar euro = \"€\";\nvar excl = \"!\";\nvar exist = \"∃\";\nvar Exists = \"∃\";\nvar expectation = \"ℰ\";\nvar exponentiale = \"ⅇ\";\nvar ExponentialE = \"ⅇ\";\nvar fallingdotseq = \"≒\";\nvar Fcy = \"Ф\";\nvar fcy = \"ф\";\nvar female = \"♀\";\nvar ffilig = \"ﬃ\";\nvar fflig = \"ﬀ\";\nvar ffllig = \"ﬄ\";\nvar Ffr = \"𝔉\";\nvar ffr = \"𝔣\";\nvar filig = \"ﬁ\";\nvar FilledSmallSquare = \"◼\";\nvar FilledVerySmallSquare = \"▪\";\nvar fjlig = \"fj\";\nvar flat = \"♭\";\nvar fllig = \"ﬂ\";\nvar fltns = \"▱\";\nvar fnof = \"ƒ\";\nvar Fopf = \"𝔽\";\nvar fopf = \"𝕗\";\nvar forall = \"∀\";\nvar ForAll = \"∀\";\nvar fork = \"⋔\";\nvar forkv = \"⫙\";\nvar Fouriertrf = \"ℱ\";\nvar fpartint = \"⨍\";\nvar frac12$1 = \"½\";\nvar frac13 = \"⅓\";\nvar frac14$1 = \"¼\";\nvar frac15 = \"⅕\";\nvar frac16 = \"⅙\";\nvar frac18 = \"⅛\";\nvar frac23 = \"⅔\";\nvar frac25 = \"⅖\";\nvar frac34$1 = \"¾\";\nvar frac35 = \"⅗\";\nvar frac38 = \"⅜\";\nvar frac45 = \"⅘\";\nvar frac56 = \"⅚\";\nvar frac58 = \"⅝\";\nvar frac78 = \"⅞\";\nvar frasl = \"⁄\";\nvar frown = \"⌢\";\nvar fscr = \"𝒻\";\nvar Fscr = \"ℱ\";\nvar gacute = \"ǵ\";\nvar Gamma = \"Γ\";\nvar gamma = \"γ\";\nvar Gammad = \"Ϝ\";\nvar gammad = \"ϝ\";\nvar gap = \"⪆\";\nvar Gbreve = \"Ğ\";\nvar gbreve = \"ğ\";\nvar Gcedil = \"Ģ\";\nvar Gcirc = \"Ĝ\";\nvar gcirc = \"ĝ\";\nvar Gcy = \"Г\";\nvar gcy = \"г\";\nvar Gdot = \"Ġ\";\nvar gdot = \"ġ\";\nvar ge = \"≥\";\nvar gE = \"≧\";\nvar gEl = \"⪌\";\nvar gel = \"⋛\";\nvar geq = \"≥\";\nvar geqq = \"≧\";\nvar geqslant = \"⩾\";\nvar gescc = \"⪩\";\nvar ges = \"⩾\";\nvar gesdot = \"⪀\";\nvar gesdoto = \"⪂\";\nvar gesdotol = \"⪄\";\nvar gesl = \"⋛︀\";\nvar gesles = \"⪔\";\nvar Gfr = \"𝔊\";\nvar gfr = \"𝔤\";\nvar gg = \"≫\";\nvar Gg = \"⋙\";\nvar ggg = \"⋙\";\nvar gimel = \"ℷ\";\nvar GJcy = \"Ѓ\";\nvar gjcy = \"ѓ\";\nvar gla = \"⪥\";\nvar gl = \"≷\";\nvar glE = \"⪒\";\nvar glj = \"⪤\";\nvar gnap = \"⪊\";\nvar gnapprox = \"⪊\";\nvar gne = \"⪈\";\nvar gnE = \"≩\";\nvar gneq = \"⪈\";\nvar gneqq = \"≩\";\nvar gnsim = \"⋧\";\nvar Gopf = \"𝔾\";\nvar gopf = \"𝕘\";\nvar grave = \"`\";\nvar GreaterEqual = \"≥\";\nvar GreaterEqualLess = \"⋛\";\nvar GreaterFullEqual = \"≧\";\nvar GreaterGreater = \"⪢\";\nvar GreaterLess = \"≷\";\nvar GreaterSlantEqual = \"⩾\";\nvar GreaterTilde = \"≳\";\nvar Gscr = \"𝒢\";\nvar gscr = \"ℊ\";\nvar gsim = \"≳\";\nvar gsime = \"⪎\";\nvar gsiml = \"⪐\";\nvar gtcc = \"⪧\";\nvar gtcir = \"⩺\";\nvar gt$2 = \">\";\nvar GT$1 = \">\";\nvar Gt = \"≫\";\nvar gtdot = \"⋗\";\nvar gtlPar = \"⦕\";\nvar gtquest = \"⩼\";\nvar gtrapprox = \"⪆\";\nvar gtrarr = \"⥸\";\nvar gtrdot = \"⋗\";\nvar gtreqless = \"⋛\";\nvar gtreqqless = \"⪌\";\nvar gtrless = \"≷\";\nvar gtrsim = \"≳\";\nvar gvertneqq = \"≩︀\";\nvar gvnE = \"≩︀\";\nvar Hacek = \"ˇ\";\nvar hairsp = \" \";\nvar half = \"½\";\nvar hamilt = \"ℋ\";\nvar HARDcy = \"Ъ\";\nvar hardcy = \"ъ\";\nvar harrcir = \"⥈\";\nvar harr = \"↔\";\nvar hArr = \"⇔\";\nvar harrw = \"↭\";\nvar Hat = \"^\";\nvar hbar = \"ℏ\";\nvar Hcirc = \"Ĥ\";\nvar hcirc = \"ĥ\";\nvar hearts = \"♥\";\nvar heartsuit = \"♥\";\nvar hellip = \"…\";\nvar hercon = \"⊹\";\nvar hfr = \"𝔥\";\nvar Hfr = \"ℌ\";\nvar HilbertSpace = \"ℋ\";\nvar hksearow = \"⤥\";\nvar hkswarow = \"⤦\";\nvar hoarr = \"⇿\";\nvar homtht = \"∻\";\nvar hookleftarrow = \"↩\";\nvar hookrightarrow = \"↪\";\nvar hopf = \"𝕙\";\nvar Hopf = \"ℍ\";\nvar horbar = \"―\";\nvar HorizontalLine = \"─\";\nvar hscr = \"𝒽\";\nvar Hscr = \"ℋ\";\nvar hslash = \"ℏ\";\nvar Hstrok = \"Ħ\";\nvar hstrok = \"ħ\";\nvar HumpDownHump = \"≎\";\nvar HumpEqual = \"≏\";\nvar hybull = \"⁃\";\nvar hyphen = \"‐\";\nvar Iacute$1 = \"Í\";\nvar iacute$1 = \"í\";\nvar ic = \"⁣\";\nvar Icirc$1 = \"Î\";\nvar icirc$1 = \"î\";\nvar Icy = \"И\";\nvar icy = \"и\";\nvar Idot = \"İ\";\nvar IEcy = \"Е\";\nvar iecy = \"е\";\nvar iexcl$1 = \"¡\";\nvar iff = \"⇔\";\nvar ifr = \"𝔦\";\nvar Ifr = \"ℑ\";\nvar Igrave$1 = \"Ì\";\nvar igrave$1 = \"ì\";\nvar ii = \"ⅈ\";\nvar iiiint = \"⨌\";\nvar iiint = \"∭\";\nvar iinfin = \"⧜\";\nvar iiota = \"℩\";\nvar IJlig = \"Ĳ\";\nvar ijlig = \"ĳ\";\nvar Imacr = \"Ī\";\nvar imacr = \"ī\";\nvar image = \"ℑ\";\nvar ImaginaryI = \"ⅈ\";\nvar imagline = \"ℐ\";\nvar imagpart = \"ℑ\";\nvar imath = \"ı\";\nvar Im = \"ℑ\";\nvar imof = \"⊷\";\nvar imped = \"Ƶ\";\nvar Implies = \"⇒\";\nvar incare = \"℅\";\nvar infin = \"∞\";\nvar infintie = \"⧝\";\nvar inodot = \"ı\";\nvar intcal = \"⊺\";\nvar int = \"∫\";\nvar Int = \"∬\";\nvar integers = \"ℤ\";\nvar Integral = \"∫\";\nvar intercal = \"⊺\";\nvar Intersection = \"⋂\";\nvar intlarhk = \"⨗\";\nvar intprod = \"⨼\";\nvar InvisibleComma = \"⁣\";\nvar InvisibleTimes = \"⁢\";\nvar IOcy = \"Ё\";\nvar iocy = \"ё\";\nvar Iogon = \"Į\";\nvar iogon = \"į\";\nvar Iopf = \"𝕀\";\nvar iopf = \"𝕚\";\nvar Iota = \"Ι\";\nvar iota = \"ι\";\nvar iprod = \"⨼\";\nvar iquest$1 = \"¿\";\nvar iscr = \"𝒾\";\nvar Iscr = \"ℐ\";\nvar isin = \"∈\";\nvar isindot = \"⋵\";\nvar isinE = \"⋹\";\nvar isins = \"⋴\";\nvar isinsv = \"⋳\";\nvar isinv = \"∈\";\nvar it = \"⁢\";\nvar Itilde = \"Ĩ\";\nvar itilde = \"ĩ\";\nvar Iukcy = \"І\";\nvar iukcy = \"і\";\nvar Iuml$1 = \"Ï\";\nvar iuml$1 = \"ï\";\nvar Jcirc = \"Ĵ\";\nvar jcirc = \"ĵ\";\nvar Jcy = \"Й\";\nvar jcy = \"й\";\nvar Jfr = \"𝔍\";\nvar jfr = \"𝔧\";\nvar jmath = \"ȷ\";\nvar Jopf = \"𝕁\";\nvar jopf = \"𝕛\";\nvar Jscr = \"𝒥\";\nvar jscr = \"𝒿\";\nvar Jsercy = \"Ј\";\nvar jsercy = \"ј\";\nvar Jukcy = \"Є\";\nvar jukcy = \"є\";\nvar Kappa = \"Κ\";\nvar kappa = \"κ\";\nvar kappav = \"ϰ\";\nvar Kcedil = \"Ķ\";\nvar kcedil = \"ķ\";\nvar Kcy = \"К\";\nvar kcy = \"к\";\nvar Kfr = \"𝔎\";\nvar kfr = \"𝔨\";\nvar kgreen = \"ĸ\";\nvar KHcy = \"Х\";\nvar khcy = \"х\";\nvar KJcy = \"Ќ\";\nvar kjcy = \"ќ\";\nvar Kopf = \"𝕂\";\nvar kopf = \"𝕜\";\nvar Kscr = \"𝒦\";\nvar kscr = \"𝓀\";\nvar lAarr = \"⇚\";\nvar Lacute = \"Ĺ\";\nvar lacute = \"ĺ\";\nvar laemptyv = \"⦴\";\nvar lagran = \"ℒ\";\nvar Lambda = \"Λ\";\nvar lambda = \"λ\";\nvar lang = \"⟨\";\nvar Lang = \"⟪\";\nvar langd = \"⦑\";\nvar langle = \"⟨\";\nvar lap = \"⪅\";\nvar Laplacetrf = \"ℒ\";\nvar laquo$1 = \"«\";\nvar larrb = \"⇤\";\nvar larrbfs = \"⤟\";\nvar larr = \"←\";\nvar Larr = \"↞\";\nvar lArr = \"⇐\";\nvar larrfs = \"⤝\";\nvar larrhk = \"↩\";\nvar larrlp = \"↫\";\nvar larrpl = \"⤹\";\nvar larrsim = \"⥳\";\nvar larrtl = \"↢\";\nvar latail = \"⤙\";\nvar lAtail = \"⤛\";\nvar lat = \"⪫\";\nvar late = \"⪭\";\nvar lates = \"⪭︀\";\nvar lbarr = \"⤌\";\nvar lBarr = \"⤎\";\nvar lbbrk = \"❲\";\nvar lbrace = \"{\";\nvar lbrack = \"[\";\nvar lbrke = \"⦋\";\nvar lbrksld = \"⦏\";\nvar lbrkslu = \"⦍\";\nvar Lcaron = \"Ľ\";\nvar lcaron = \"ľ\";\nvar Lcedil = \"Ļ\";\nvar lcedil = \"ļ\";\nvar lceil = \"⌈\";\nvar lcub = \"{\";\nvar Lcy = \"Л\";\nvar lcy = \"л\";\nvar ldca = \"⤶\";\nvar ldquo = \"“\";\nvar ldquor = \"„\";\nvar ldrdhar = \"⥧\";\nvar ldrushar = \"⥋\";\nvar ldsh = \"↲\";\nvar le = \"≤\";\nvar lE = \"≦\";\nvar LeftAngleBracket = \"⟨\";\nvar LeftArrowBar = \"⇤\";\nvar leftarrow = \"←\";\nvar LeftArrow = \"←\";\nvar Leftarrow = \"⇐\";\nvar LeftArrowRightArrow = \"⇆\";\nvar leftarrowtail = \"↢\";\nvar LeftCeiling = \"⌈\";\nvar LeftDoubleBracket = \"⟦\";\nvar LeftDownTeeVector = \"⥡\";\nvar LeftDownVectorBar = \"⥙\";\nvar LeftDownVector = \"⇃\";\nvar LeftFloor = \"⌊\";\nvar leftharpoondown = \"↽\";\nvar leftharpoonup = \"↼\";\nvar leftleftarrows = \"⇇\";\nvar leftrightarrow = \"↔\";\nvar LeftRightArrow = \"↔\";\nvar Leftrightarrow = \"⇔\";\nvar leftrightarrows = \"⇆\";\nvar leftrightharpoons = \"⇋\";\nvar leftrightsquigarrow = \"↭\";\nvar LeftRightVector = \"⥎\";\nvar LeftTeeArrow = \"↤\";\nvar LeftTee = \"⊣\";\nvar LeftTeeVector = \"⥚\";\nvar leftthreetimes = \"⋋\";\nvar LeftTriangleBar = \"⧏\";\nvar LeftTriangle = \"⊲\";\nvar LeftTriangleEqual = \"⊴\";\nvar LeftUpDownVector = \"⥑\";\nvar LeftUpTeeVector = \"⥠\";\nvar LeftUpVectorBar = \"⥘\";\nvar LeftUpVector = \"↿\";\nvar LeftVectorBar = \"⥒\";\nvar LeftVector = \"↼\";\nvar lEg = \"⪋\";\nvar leg = \"⋚\";\nvar leq = \"≤\";\nvar leqq = \"≦\";\nvar leqslant = \"⩽\";\nvar lescc = \"⪨\";\nvar les = \"⩽\";\nvar lesdot = \"⩿\";\nvar lesdoto = \"⪁\";\nvar lesdotor = \"⪃\";\nvar lesg = \"⋚︀\";\nvar lesges = \"⪓\";\nvar lessapprox = \"⪅\";\nvar lessdot = \"⋖\";\nvar lesseqgtr = \"⋚\";\nvar lesseqqgtr = \"⪋\";\nvar LessEqualGreater = \"⋚\";\nvar LessFullEqual = \"≦\";\nvar LessGreater = \"≶\";\nvar lessgtr = \"≶\";\nvar LessLess = \"⪡\";\nvar lesssim = \"≲\";\nvar LessSlantEqual = \"⩽\";\nvar LessTilde = \"≲\";\nvar lfisht = \"⥼\";\nvar lfloor = \"⌊\";\nvar Lfr = \"𝔏\";\nvar lfr = \"𝔩\";\nvar lg = \"≶\";\nvar lgE = \"⪑\";\nvar lHar = \"⥢\";\nvar lhard = \"↽\";\nvar lharu = \"↼\";\nvar lharul = \"⥪\";\nvar lhblk = \"▄\";\nvar LJcy = \"Љ\";\nvar ljcy = \"љ\";\nvar llarr = \"⇇\";\nvar ll = \"≪\";\nvar Ll = \"⋘\";\nvar llcorner = \"⌞\";\nvar Lleftarrow = \"⇚\";\nvar llhard = \"⥫\";\nvar lltri = \"◺\";\nvar Lmidot = \"Ŀ\";\nvar lmidot = \"ŀ\";\nvar lmoustache = \"⎰\";\nvar lmoust = \"⎰\";\nvar lnap = \"⪉\";\nvar lnapprox = \"⪉\";\nvar lne = \"⪇\";\nvar lnE = \"≨\";\nvar lneq = \"⪇\";\nvar lneqq = \"≨\";\nvar lnsim = \"⋦\";\nvar loang = \"⟬\";\nvar loarr = \"⇽\";\nvar lobrk = \"⟦\";\nvar longleftarrow = \"⟵\";\nvar LongLeftArrow = \"⟵\";\nvar Longleftarrow = \"⟸\";\nvar longleftrightarrow = \"⟷\";\nvar LongLeftRightArrow = \"⟷\";\nvar Longleftrightarrow = \"⟺\";\nvar longmapsto = \"⟼\";\nvar longrightarrow = \"⟶\";\nvar LongRightArrow = \"⟶\";\nvar Longrightarrow = \"⟹\";\nvar looparrowleft = \"↫\";\nvar looparrowright = \"↬\";\nvar lopar = \"⦅\";\nvar Lopf = \"𝕃\";\nvar lopf = \"𝕝\";\nvar loplus = \"⨭\";\nvar lotimes = \"⨴\";\nvar lowast = \"∗\";\nvar lowbar = \"_\";\nvar LowerLeftArrow = \"↙\";\nvar LowerRightArrow = \"↘\";\nvar loz = \"◊\";\nvar lozenge = \"◊\";\nvar lozf = \"⧫\";\nvar lpar = \"(\";\nvar lparlt = \"⦓\";\nvar lrarr = \"⇆\";\nvar lrcorner = \"⌟\";\nvar lrhar = \"⇋\";\nvar lrhard = \"⥭\";\nvar lrm = \"‎\";\nvar lrtri = \"⊿\";\nvar lsaquo = \"‹\";\nvar lscr = \"𝓁\";\nvar Lscr = \"ℒ\";\nvar lsh = \"↰\";\nvar Lsh = \"↰\";\nvar lsim = \"≲\";\nvar lsime = \"⪍\";\nvar lsimg = \"⪏\";\nvar lsqb = \"[\";\nvar lsquo = \"‘\";\nvar lsquor = \"‚\";\nvar Lstrok = \"Ł\";\nvar lstrok = \"ł\";\nvar ltcc = \"⪦\";\nvar ltcir = \"⩹\";\nvar lt$2 = \"<\";\nvar LT$1 = \"<\";\nvar Lt = \"≪\";\nvar ltdot = \"⋖\";\nvar lthree = \"⋋\";\nvar ltimes = \"⋉\";\nvar ltlarr = \"⥶\";\nvar ltquest = \"⩻\";\nvar ltri = \"◃\";\nvar ltrie = \"⊴\";\nvar ltrif = \"◂\";\nvar ltrPar = \"⦖\";\nvar lurdshar = \"⥊\";\nvar luruhar = \"⥦\";\nvar lvertneqq = \"≨︀\";\nvar lvnE = \"≨︀\";\nvar macr$1 = \"¯\";\nvar male = \"♂\";\nvar malt = \"✠\";\nvar maltese = \"✠\";\nvar map = \"↦\";\nvar mapsto = \"↦\";\nvar mapstodown = \"↧\";\nvar mapstoleft = \"↤\";\nvar mapstoup = \"↥\";\nvar marker = \"▮\";\nvar mcomma = \"⨩\";\nvar Mcy = \"М\";\nvar mcy = \"м\";\nvar mdash = \"—\";\nvar mDDot = \"∺\";\nvar measuredangle = \"∡\";\nvar MediumSpace = \" \";\nvar Mellintrf = \"ℳ\";\nvar Mfr = \"𝔐\";\nvar mfr = \"𝔪\";\nvar mho = \"℧\";\nvar micro$1 = \"µ\";\nvar midast = \"*\";\nvar midcir = \"⫰\";\nvar mid = \"∣\";\nvar middot$1 = \"·\";\nvar minusb = \"⊟\";\nvar minus = \"−\";\nvar minusd = \"∸\";\nvar minusdu = \"⨪\";\nvar MinusPlus = \"∓\";\nvar mlcp = \"⫛\";\nvar mldr = \"…\";\nvar mnplus = \"∓\";\nvar models = \"⊧\";\nvar Mopf = \"𝕄\";\nvar mopf = \"𝕞\";\nvar mp = \"∓\";\nvar mscr = \"𝓂\";\nvar Mscr = \"ℳ\";\nvar mstpos = \"∾\";\nvar Mu = \"Μ\";\nvar mu = \"μ\";\nvar multimap = \"⊸\";\nvar mumap = \"⊸\";\nvar nabla = \"∇\";\nvar Nacute = \"Ń\";\nvar nacute = \"ń\";\nvar nang = \"∠⃒\";\nvar nap = \"≉\";\nvar napE = \"⩰̸\";\nvar napid = \"≋̸\";\nvar napos = \"ŉ\";\nvar napprox = \"≉\";\nvar natural = \"♮\";\nvar naturals = \"ℕ\";\nvar natur = \"♮\";\nvar nbsp$1 = \" \";\nvar nbump = \"≎̸\";\nvar nbumpe = \"≏̸\";\nvar ncap = \"⩃\";\nvar Ncaron = \"Ň\";\nvar ncaron = \"ň\";\nvar Ncedil = \"Ņ\";\nvar ncedil = \"ņ\";\nvar ncong = \"≇\";\nvar ncongdot = \"⩭̸\";\nvar ncup = \"⩂\";\nvar Ncy = \"Н\";\nvar ncy = \"н\";\nvar ndash = \"–\";\nvar nearhk = \"⤤\";\nvar nearr = \"↗\";\nvar neArr = \"⇗\";\nvar nearrow = \"↗\";\nvar ne = \"≠\";\nvar nedot = \"≐̸\";\nvar NegativeMediumSpace = \"​\";\nvar NegativeThickSpace = \"​\";\nvar NegativeThinSpace = \"​\";\nvar NegativeVeryThinSpace = \"​\";\nvar nequiv = \"≢\";\nvar nesear = \"⤨\";\nvar nesim = \"≂̸\";\nvar NestedGreaterGreater = \"≫\";\nvar NestedLessLess = \"≪\";\nvar NewLine = \"\\n\";\nvar nexist = \"∄\";\nvar nexists = \"∄\";\nvar Nfr = \"𝔑\";\nvar nfr = \"𝔫\";\nvar ngE = \"≧̸\";\nvar nge = \"≱\";\nvar ngeq = \"≱\";\nvar ngeqq = \"≧̸\";\nvar ngeqslant = \"⩾̸\";\nvar nges = \"⩾̸\";\nvar nGg = \"⋙̸\";\nvar ngsim = \"≵\";\nvar nGt = \"≫⃒\";\nvar ngt = \"≯\";\nvar ngtr = \"≯\";\nvar nGtv = \"≫̸\";\nvar nharr = \"↮\";\nvar nhArr = \"⇎\";\nvar nhpar = \"⫲\";\nvar ni = \"∋\";\nvar nis = \"⋼\";\nvar nisd = \"⋺\";\nvar niv = \"∋\";\nvar NJcy = \"Њ\";\nvar njcy = \"њ\";\nvar nlarr = \"↚\";\nvar nlArr = \"⇍\";\nvar nldr = \"‥\";\nvar nlE = \"≦̸\";\nvar nle = \"≰\";\nvar nleftarrow = \"↚\";\nvar nLeftarrow = \"⇍\";\nvar nleftrightarrow = \"↮\";\nvar nLeftrightarrow = \"⇎\";\nvar nleq = \"≰\";\nvar nleqq = \"≦̸\";\nvar nleqslant = \"⩽̸\";\nvar nles = \"⩽̸\";\nvar nless = \"≮\";\nvar nLl = \"⋘̸\";\nvar nlsim = \"≴\";\nvar nLt = \"≪⃒\";\nvar nlt = \"≮\";\nvar nltri = \"⋪\";\nvar nltrie = \"⋬\";\nvar nLtv = \"≪̸\";\nvar nmid = \"∤\";\nvar NoBreak = \"⁠\";\nvar NonBreakingSpace = \" \";\nvar nopf = \"𝕟\";\nvar Nopf = \"ℕ\";\nvar Not = \"⫬\";\nvar not$1 = \"¬\";\nvar NotCongruent = \"≢\";\nvar NotCupCap = \"≭\";\nvar NotDoubleVerticalBar = \"∦\";\nvar NotElement = \"∉\";\nvar NotEqual = \"≠\";\nvar NotEqualTilde = \"≂̸\";\nvar NotExists = \"∄\";\nvar NotGreater = \"≯\";\nvar NotGreaterEqual = \"≱\";\nvar NotGreaterFullEqual = \"≧̸\";\nvar NotGreaterGreater = \"≫̸\";\nvar NotGreaterLess = \"≹\";\nvar NotGreaterSlantEqual = \"⩾̸\";\nvar NotGreaterTilde = \"≵\";\nvar NotHumpDownHump = \"≎̸\";\nvar NotHumpEqual = \"≏̸\";\nvar notin = \"∉\";\nvar notindot = \"⋵̸\";\nvar notinE = \"⋹̸\";\nvar notinva = \"∉\";\nvar notinvb = \"⋷\";\nvar notinvc = \"⋶\";\nvar NotLeftTriangleBar = \"⧏̸\";\nvar NotLeftTriangle = \"⋪\";\nvar NotLeftTriangleEqual = \"⋬\";\nvar NotLess = \"≮\";\nvar NotLessEqual = \"≰\";\nvar NotLessGreater = \"≸\";\nvar NotLessLess = \"≪̸\";\nvar NotLessSlantEqual = \"⩽̸\";\nvar NotLessTilde = \"≴\";\nvar NotNestedGreaterGreater = \"⪢̸\";\nvar NotNestedLessLess = \"⪡̸\";\nvar notni = \"∌\";\nvar notniva = \"∌\";\nvar notnivb = \"⋾\";\nvar notnivc = \"⋽\";\nvar NotPrecedes = \"⊀\";\nvar NotPrecedesEqual = \"⪯̸\";\nvar NotPrecedesSlantEqual = \"⋠\";\nvar NotReverseElement = \"∌\";\nvar NotRightTriangleBar = \"⧐̸\";\nvar NotRightTriangle = \"⋫\";\nvar NotRightTriangleEqual = \"⋭\";\nvar NotSquareSubset = \"⊏̸\";\nvar NotSquareSubsetEqual = \"⋢\";\nvar NotSquareSuperset = \"⊐̸\";\nvar NotSquareSupersetEqual = \"⋣\";\nvar NotSubset = \"⊂⃒\";\nvar NotSubsetEqual = \"⊈\";\nvar NotSucceeds = \"⊁\";\nvar NotSucceedsEqual = \"⪰̸\";\nvar NotSucceedsSlantEqual = \"⋡\";\nvar NotSucceedsTilde = \"≿̸\";\nvar NotSuperset = \"⊃⃒\";\nvar NotSupersetEqual = \"⊉\";\nvar NotTilde = \"≁\";\nvar NotTildeEqual = \"≄\";\nvar NotTildeFullEqual = \"≇\";\nvar NotTildeTilde = \"≉\";\nvar NotVerticalBar = \"∤\";\nvar nparallel = \"∦\";\nvar npar = \"∦\";\nvar nparsl = \"⫽⃥\";\nvar npart = \"∂̸\";\nvar npolint = \"⨔\";\nvar npr = \"⊀\";\nvar nprcue = \"⋠\";\nvar nprec = \"⊀\";\nvar npreceq = \"⪯̸\";\nvar npre = \"⪯̸\";\nvar nrarrc = \"⤳̸\";\nvar nrarr = \"↛\";\nvar nrArr = \"⇏\";\nvar nrarrw = \"↝̸\";\nvar nrightarrow = \"↛\";\nvar nRightarrow = \"⇏\";\nvar nrtri = \"⋫\";\nvar nrtrie = \"⋭\";\nvar nsc = \"⊁\";\nvar nsccue = \"⋡\";\nvar nsce = \"⪰̸\";\nvar Nscr = \"𝒩\";\nvar nscr = \"𝓃\";\nvar nshortmid = \"∤\";\nvar nshortparallel = \"∦\";\nvar nsim = \"≁\";\nvar nsime = \"≄\";\nvar nsimeq = \"≄\";\nvar nsmid = \"∤\";\nvar nspar = \"∦\";\nvar nsqsube = \"⋢\";\nvar nsqsupe = \"⋣\";\nvar nsub = \"⊄\";\nvar nsubE = \"⫅̸\";\nvar nsube = \"⊈\";\nvar nsubset = \"⊂⃒\";\nvar nsubseteq = \"⊈\";\nvar nsubseteqq = \"⫅̸\";\nvar nsucc = \"⊁\";\nvar nsucceq = \"⪰̸\";\nvar nsup = \"⊅\";\nvar nsupE = \"⫆̸\";\nvar nsupe = \"⊉\";\nvar nsupset = \"⊃⃒\";\nvar nsupseteq = \"⊉\";\nvar nsupseteqq = \"⫆̸\";\nvar ntgl = \"≹\";\nvar Ntilde$1 = \"Ñ\";\nvar ntilde$1 = \"ñ\";\nvar ntlg = \"≸\";\nvar ntriangleleft = \"⋪\";\nvar ntrianglelefteq = \"⋬\";\nvar ntriangleright = \"⋫\";\nvar ntrianglerighteq = \"⋭\";\nvar Nu = \"Ν\";\nvar nu = \"ν\";\nvar num = \"#\";\nvar numero = \"№\";\nvar numsp = \" \";\nvar nvap = \"≍⃒\";\nvar nvdash = \"⊬\";\nvar nvDash = \"⊭\";\nvar nVdash = \"⊮\";\nvar nVDash = \"⊯\";\nvar nvge = \"≥⃒\";\nvar nvgt = \">⃒\";\nvar nvHarr = \"⤄\";\nvar nvinfin = \"⧞\";\nvar nvlArr = \"⤂\";\nvar nvle = \"≤⃒\";\nvar nvlt = \"<⃒\";\nvar nvltrie = \"⊴⃒\";\nvar nvrArr = \"⤃\";\nvar nvrtrie = \"⊵⃒\";\nvar nvsim = \"∼⃒\";\nvar nwarhk = \"⤣\";\nvar nwarr = \"↖\";\nvar nwArr = \"⇖\";\nvar nwarrow = \"↖\";\nvar nwnear = \"⤧\";\nvar Oacute$1 = \"Ó\";\nvar oacute$1 = \"ó\";\nvar oast = \"⊛\";\nvar Ocirc$1 = \"Ô\";\nvar ocirc$1 = \"ô\";\nvar ocir = \"⊚\";\nvar Ocy = \"О\";\nvar ocy = \"о\";\nvar odash = \"⊝\";\nvar Odblac = \"Ő\";\nvar odblac = \"ő\";\nvar odiv = \"⨸\";\nvar odot = \"⊙\";\nvar odsold = \"⦼\";\nvar OElig = \"Œ\";\nvar oelig = \"œ\";\nvar ofcir = \"⦿\";\nvar Ofr = \"𝔒\";\nvar ofr = \"𝔬\";\nvar ogon = \"˛\";\nvar Ograve$1 = \"Ò\";\nvar ograve$1 = \"ò\";\nvar ogt = \"⧁\";\nvar ohbar = \"⦵\";\nvar ohm = \"Ω\";\nvar oint = \"∮\";\nvar olarr = \"↺\";\nvar olcir = \"⦾\";\nvar olcross = \"⦻\";\nvar oline = \"‾\";\nvar olt = \"⧀\";\nvar Omacr = \"Ō\";\nvar omacr = \"ō\";\nvar Omega = \"Ω\";\nvar omega = \"ω\";\nvar Omicron = \"Ο\";\nvar omicron = \"ο\";\nvar omid = \"⦶\";\nvar ominus = \"⊖\";\nvar Oopf = \"𝕆\";\nvar oopf = \"𝕠\";\nvar opar = \"⦷\";\nvar OpenCurlyDoubleQuote = \"“\";\nvar OpenCurlyQuote = \"‘\";\nvar operp = \"⦹\";\nvar oplus = \"⊕\";\nvar orarr = \"↻\";\nvar Or = \"⩔\";\nvar or = \"∨\";\nvar ord = \"⩝\";\nvar order = \"ℴ\";\nvar orderof = \"ℴ\";\nvar ordf$1 = \"ª\";\nvar ordm$1 = \"º\";\nvar origof = \"⊶\";\nvar oror = \"⩖\";\nvar orslope = \"⩗\";\nvar orv = \"⩛\";\nvar oS = \"Ⓢ\";\nvar Oscr = \"𝒪\";\nvar oscr = \"ℴ\";\nvar Oslash$1 = \"Ø\";\nvar oslash$1 = \"ø\";\nvar osol = \"⊘\";\nvar Otilde$1 = \"Õ\";\nvar otilde$1 = \"õ\";\nvar otimesas = \"⨶\";\nvar Otimes = \"⨷\";\nvar otimes = \"⊗\";\nvar Ouml$1 = \"Ö\";\nvar ouml$1 = \"ö\";\nvar ovbar = \"⌽\";\nvar OverBar = \"‾\";\nvar OverBrace = \"⏞\";\nvar OverBracket = \"⎴\";\nvar OverParenthesis = \"⏜\";\nvar para$1 = \"¶\";\nvar parallel = \"∥\";\nvar par = \"∥\";\nvar parsim = \"⫳\";\nvar parsl = \"⫽\";\nvar part = \"∂\";\nvar PartialD = \"∂\";\nvar Pcy = \"П\";\nvar pcy = \"п\";\nvar percnt = \"%\";\nvar period = \".\";\nvar permil = \"‰\";\nvar perp = \"⊥\";\nvar pertenk = \"‱\";\nvar Pfr = \"𝔓\";\nvar pfr = \"𝔭\";\nvar Phi = \"Φ\";\nvar phi = \"φ\";\nvar phiv = \"ϕ\";\nvar phmmat = \"ℳ\";\nvar phone = \"☎\";\nvar Pi = \"Π\";\nvar pi = \"π\";\nvar pitchfork = \"⋔\";\nvar piv = \"ϖ\";\nvar planck = \"ℏ\";\nvar planckh = \"ℎ\";\nvar plankv = \"ℏ\";\nvar plusacir = \"⨣\";\nvar plusb = \"⊞\";\nvar pluscir = \"⨢\";\nvar plus = \"+\";\nvar plusdo = \"∔\";\nvar plusdu = \"⨥\";\nvar pluse = \"⩲\";\nvar PlusMinus = \"±\";\nvar plusmn$1 = \"±\";\nvar plussim = \"⨦\";\nvar plustwo = \"⨧\";\nvar pm = \"±\";\nvar Poincareplane = \"ℌ\";\nvar pointint = \"⨕\";\nvar popf = \"𝕡\";\nvar Popf = \"ℙ\";\nvar pound$1 = \"£\";\nvar prap = \"⪷\";\nvar Pr = \"⪻\";\nvar pr = \"≺\";\nvar prcue = \"≼\";\nvar precapprox = \"⪷\";\nvar prec = \"≺\";\nvar preccurlyeq = \"≼\";\nvar Precedes = \"≺\";\nvar PrecedesEqual = \"⪯\";\nvar PrecedesSlantEqual = \"≼\";\nvar PrecedesTilde = \"≾\";\nvar preceq = \"⪯\";\nvar precnapprox = \"⪹\";\nvar precneqq = \"⪵\";\nvar precnsim = \"⋨\";\nvar pre = \"⪯\";\nvar prE = \"⪳\";\nvar precsim = \"≾\";\nvar prime = \"′\";\nvar Prime = \"″\";\nvar primes = \"ℙ\";\nvar prnap = \"⪹\";\nvar prnE = \"⪵\";\nvar prnsim = \"⋨\";\nvar prod = \"∏\";\nvar Product = \"∏\";\nvar profalar = \"⌮\";\nvar profline = \"⌒\";\nvar profsurf = \"⌓\";\nvar prop = \"∝\";\nvar Proportional = \"∝\";\nvar Proportion = \"∷\";\nvar propto = \"∝\";\nvar prsim = \"≾\";\nvar prurel = \"⊰\";\nvar Pscr = \"𝒫\";\nvar pscr = \"𝓅\";\nvar Psi = \"Ψ\";\nvar psi = \"ψ\";\nvar puncsp = \" \";\nvar Qfr = \"𝔔\";\nvar qfr = \"𝔮\";\nvar qint = \"⨌\";\nvar qopf = \"𝕢\";\nvar Qopf = \"ℚ\";\nvar qprime = \"⁗\";\nvar Qscr = \"𝒬\";\nvar qscr = \"𝓆\";\nvar quaternions = \"ℍ\";\nvar quatint = \"⨖\";\nvar quest = \"?\";\nvar questeq = \"≟\";\nvar quot$2 = \"\\\"\";\nvar QUOT$1 = \"\\\"\";\nvar rAarr = \"⇛\";\nvar race = \"∽̱\";\nvar Racute = \"Ŕ\";\nvar racute = \"ŕ\";\nvar radic = \"√\";\nvar raemptyv = \"⦳\";\nvar rang = \"⟩\";\nvar Rang = \"⟫\";\nvar rangd = \"⦒\";\nvar range = \"⦥\";\nvar rangle = \"⟩\";\nvar raquo$1 = \"»\";\nvar rarrap = \"⥵\";\nvar rarrb = \"⇥\";\nvar rarrbfs = \"⤠\";\nvar rarrc = \"⤳\";\nvar rarr = \"→\";\nvar Rarr = \"↠\";\nvar rArr = \"⇒\";\nvar rarrfs = \"⤞\";\nvar rarrhk = \"↪\";\nvar rarrlp = \"↬\";\nvar rarrpl = \"⥅\";\nvar rarrsim = \"⥴\";\nvar Rarrtl = \"⤖\";\nvar rarrtl = \"↣\";\nvar rarrw = \"↝\";\nvar ratail = \"⤚\";\nvar rAtail = \"⤜\";\nvar ratio = \"∶\";\nvar rationals = \"ℚ\";\nvar rbarr = \"⤍\";\nvar rBarr = \"⤏\";\nvar RBarr = \"⤐\";\nvar rbbrk = \"❳\";\nvar rbrace = \"}\";\nvar rbrack = \"]\";\nvar rbrke = \"⦌\";\nvar rbrksld = \"⦎\";\nvar rbrkslu = \"⦐\";\nvar Rcaron = \"Ř\";\nvar rcaron = \"ř\";\nvar Rcedil = \"Ŗ\";\nvar rcedil = \"ŗ\";\nvar rceil = \"⌉\";\nvar rcub = \"}\";\nvar Rcy = \"Р\";\nvar rcy = \"р\";\nvar rdca = \"⤷\";\nvar rdldhar = \"⥩\";\nvar rdquo = \"”\";\nvar rdquor = \"”\";\nvar rdsh = \"↳\";\nvar real = \"ℜ\";\nvar realine = \"ℛ\";\nvar realpart = \"ℜ\";\nvar reals = \"ℝ\";\nvar Re = \"ℜ\";\nvar rect = \"▭\";\nvar reg$1 = \"®\";\nvar REG$1 = \"®\";\nvar ReverseElement = \"∋\";\nvar ReverseEquilibrium = \"⇋\";\nvar ReverseUpEquilibrium = \"⥯\";\nvar rfisht = \"⥽\";\nvar rfloor = \"⌋\";\nvar rfr = \"𝔯\";\nvar Rfr = \"ℜ\";\nvar rHar = \"⥤\";\nvar rhard = \"⇁\";\nvar rharu = \"⇀\";\nvar rharul = \"⥬\";\nvar Rho = \"Ρ\";\nvar rho = \"ρ\";\nvar rhov = \"ϱ\";\nvar RightAngleBracket = \"⟩\";\nvar RightArrowBar = \"⇥\";\nvar rightarrow = \"→\";\nvar RightArrow = \"→\";\nvar Rightarrow = \"⇒\";\nvar RightArrowLeftArrow = \"⇄\";\nvar rightarrowtail = \"↣\";\nvar RightCeiling = \"⌉\";\nvar RightDoubleBracket = \"⟧\";\nvar RightDownTeeVector = \"⥝\";\nvar RightDownVectorBar = \"⥕\";\nvar RightDownVector = \"⇂\";\nvar RightFloor = \"⌋\";\nvar rightharpoondown = \"⇁\";\nvar rightharpoonup = \"⇀\";\nvar rightleftarrows = \"⇄\";\nvar rightleftharpoons = \"⇌\";\nvar rightrightarrows = \"⇉\";\nvar rightsquigarrow = \"↝\";\nvar RightTeeArrow = \"↦\";\nvar RightTee = \"⊢\";\nvar RightTeeVector = \"⥛\";\nvar rightthreetimes = \"⋌\";\nvar RightTriangleBar = \"⧐\";\nvar RightTriangle = \"⊳\";\nvar RightTriangleEqual = \"⊵\";\nvar RightUpDownVector = \"⥏\";\nvar RightUpTeeVector = \"⥜\";\nvar RightUpVectorBar = \"⥔\";\nvar RightUpVector = \"↾\";\nvar RightVectorBar = \"⥓\";\nvar RightVector = \"⇀\";\nvar ring = \"˚\";\nvar risingdotseq = \"≓\";\nvar rlarr = \"⇄\";\nvar rlhar = \"⇌\";\nvar rlm = \"‏\";\nvar rmoustache = \"⎱\";\nvar rmoust = \"⎱\";\nvar rnmid = \"⫮\";\nvar roang = \"⟭\";\nvar roarr = \"⇾\";\nvar robrk = \"⟧\";\nvar ropar = \"⦆\";\nvar ropf = \"𝕣\";\nvar Ropf = \"ℝ\";\nvar roplus = \"⨮\";\nvar rotimes = \"⨵\";\nvar RoundImplies = \"⥰\";\nvar rpar = \")\";\nvar rpargt = \"⦔\";\nvar rppolint = \"⨒\";\nvar rrarr = \"⇉\";\nvar Rrightarrow = \"⇛\";\nvar rsaquo = \"›\";\nvar rscr = \"𝓇\";\nvar Rscr = \"ℛ\";\nvar rsh = \"↱\";\nvar Rsh = \"↱\";\nvar rsqb = \"]\";\nvar rsquo = \"’\";\nvar rsquor = \"’\";\nvar rthree = \"⋌\";\nvar rtimes = \"⋊\";\nvar rtri = \"▹\";\nvar rtrie = \"⊵\";\nvar rtrif = \"▸\";\nvar rtriltri = \"⧎\";\nvar RuleDelayed = \"⧴\";\nvar ruluhar = \"⥨\";\nvar rx = \"℞\";\nvar Sacute = \"Ś\";\nvar sacute = \"ś\";\nvar sbquo = \"‚\";\nvar scap = \"⪸\";\nvar Scaron = \"Š\";\nvar scaron = \"š\";\nvar Sc = \"⪼\";\nvar sc = \"≻\";\nvar sccue = \"≽\";\nvar sce = \"⪰\";\nvar scE = \"⪴\";\nvar Scedil = \"Ş\";\nvar scedil = \"ş\";\nvar Scirc = \"Ŝ\";\nvar scirc = \"ŝ\";\nvar scnap = \"⪺\";\nvar scnE = \"⪶\";\nvar scnsim = \"⋩\";\nvar scpolint = \"⨓\";\nvar scsim = \"≿\";\nvar Scy = \"С\";\nvar scy = \"с\";\nvar sdotb = \"⊡\";\nvar sdot = \"⋅\";\nvar sdote = \"⩦\";\nvar searhk = \"⤥\";\nvar searr = \"↘\";\nvar seArr = \"⇘\";\nvar searrow = \"↘\";\nvar sect$1 = \"§\";\nvar semi = \";\";\nvar seswar = \"⤩\";\nvar setminus = \"∖\";\nvar setmn = \"∖\";\nvar sext = \"✶\";\nvar Sfr = \"𝔖\";\nvar sfr = \"𝔰\";\nvar sfrown = \"⌢\";\nvar sharp = \"♯\";\nvar SHCHcy = \"Щ\";\nvar shchcy = \"щ\";\nvar SHcy = \"Ш\";\nvar shcy = \"ш\";\nvar ShortDownArrow = \"↓\";\nvar ShortLeftArrow = \"←\";\nvar shortmid = \"∣\";\nvar shortparallel = \"∥\";\nvar ShortRightArrow = \"→\";\nvar ShortUpArrow = \"↑\";\nvar shy$1 = \"­\";\nvar Sigma = \"Σ\";\nvar sigma = \"σ\";\nvar sigmaf = \"ς\";\nvar sigmav = \"ς\";\nvar sim = \"∼\";\nvar simdot = \"⩪\";\nvar sime = \"≃\";\nvar simeq = \"≃\";\nvar simg = \"⪞\";\nvar simgE = \"⪠\";\nvar siml = \"⪝\";\nvar simlE = \"⪟\";\nvar simne = \"≆\";\nvar simplus = \"⨤\";\nvar simrarr = \"⥲\";\nvar slarr = \"←\";\nvar SmallCircle = \"∘\";\nvar smallsetminus = \"∖\";\nvar smashp = \"⨳\";\nvar smeparsl = \"⧤\";\nvar smid = \"∣\";\nvar smile = \"⌣\";\nvar smt = \"⪪\";\nvar smte = \"⪬\";\nvar smtes = \"⪬︀\";\nvar SOFTcy = \"Ь\";\nvar softcy = \"ь\";\nvar solbar = \"⌿\";\nvar solb = \"⧄\";\nvar sol = \"/\";\nvar Sopf = \"𝕊\";\nvar sopf = \"𝕤\";\nvar spades = \"♠\";\nvar spadesuit = \"♠\";\nvar spar = \"∥\";\nvar sqcap = \"⊓\";\nvar sqcaps = \"⊓︀\";\nvar sqcup = \"⊔\";\nvar sqcups = \"⊔︀\";\nvar Sqrt = \"√\";\nvar sqsub = \"⊏\";\nvar sqsube = \"⊑\";\nvar sqsubset = \"⊏\";\nvar sqsubseteq = \"⊑\";\nvar sqsup = \"⊐\";\nvar sqsupe = \"⊒\";\nvar sqsupset = \"⊐\";\nvar sqsupseteq = \"⊒\";\nvar square = \"□\";\nvar Square = \"□\";\nvar SquareIntersection = \"⊓\";\nvar SquareSubset = \"⊏\";\nvar SquareSubsetEqual = \"⊑\";\nvar SquareSuperset = \"⊐\";\nvar SquareSupersetEqual = \"⊒\";\nvar SquareUnion = \"⊔\";\nvar squarf = \"▪\";\nvar squ = \"□\";\nvar squf = \"▪\";\nvar srarr = \"→\";\nvar Sscr = \"𝒮\";\nvar sscr = \"𝓈\";\nvar ssetmn = \"∖\";\nvar ssmile = \"⌣\";\nvar sstarf = \"⋆\";\nvar Star = \"⋆\";\nvar star = \"☆\";\nvar starf = \"★\";\nvar straightepsilon = \"ϵ\";\nvar straightphi = \"ϕ\";\nvar strns = \"¯\";\nvar sub = \"⊂\";\nvar Sub = \"⋐\";\nvar subdot = \"⪽\";\nvar subE = \"⫅\";\nvar sube = \"⊆\";\nvar subedot = \"⫃\";\nvar submult = \"⫁\";\nvar subnE = \"⫋\";\nvar subne = \"⊊\";\nvar subplus = \"⪿\";\nvar subrarr = \"⥹\";\nvar subset = \"⊂\";\nvar Subset = \"⋐\";\nvar subseteq = \"⊆\";\nvar subseteqq = \"⫅\";\nvar SubsetEqual = \"⊆\";\nvar subsetneq = \"⊊\";\nvar subsetneqq = \"⫋\";\nvar subsim = \"⫇\";\nvar subsub = \"⫕\";\nvar subsup = \"⫓\";\nvar succapprox = \"⪸\";\nvar succ = \"≻\";\nvar succcurlyeq = \"≽\";\nvar Succeeds = \"≻\";\nvar SucceedsEqual = \"⪰\";\nvar SucceedsSlantEqual = \"≽\";\nvar SucceedsTilde = \"≿\";\nvar succeq = \"⪰\";\nvar succnapprox = \"⪺\";\nvar succneqq = \"⪶\";\nvar succnsim = \"⋩\";\nvar succsim = \"≿\";\nvar SuchThat = \"∋\";\nvar sum = \"∑\";\nvar Sum = \"∑\";\nvar sung = \"♪\";\nvar sup1$1 = \"¹\";\nvar sup2$1 = \"²\";\nvar sup3$1 = \"³\";\nvar sup = \"⊃\";\nvar Sup = \"⋑\";\nvar supdot = \"⪾\";\nvar supdsub = \"⫘\";\nvar supE = \"⫆\";\nvar supe = \"⊇\";\nvar supedot = \"⫄\";\nvar Superset = \"⊃\";\nvar SupersetEqual = \"⊇\";\nvar suphsol = \"⟉\";\nvar suphsub = \"⫗\";\nvar suplarr = \"⥻\";\nvar supmult = \"⫂\";\nvar supnE = \"⫌\";\nvar supne = \"⊋\";\nvar supplus = \"⫀\";\nvar supset = \"⊃\";\nvar Supset = \"⋑\";\nvar supseteq = \"⊇\";\nvar supseteqq = \"⫆\";\nvar supsetneq = \"⊋\";\nvar supsetneqq = \"⫌\";\nvar supsim = \"⫈\";\nvar supsub = \"⫔\";\nvar supsup = \"⫖\";\nvar swarhk = \"⤦\";\nvar swarr = \"↙\";\nvar swArr = \"⇙\";\nvar swarrow = \"↙\";\nvar swnwar = \"⤪\";\nvar szlig$1 = \"ß\";\nvar Tab = \"\\t\";\nvar target = \"⌖\";\nvar Tau = \"Τ\";\nvar tau = \"τ\";\nvar tbrk = \"⎴\";\nvar Tcaron = \"Ť\";\nvar tcaron = \"ť\";\nvar Tcedil = \"Ţ\";\nvar tcedil = \"ţ\";\nvar Tcy = \"Т\";\nvar tcy = \"т\";\nvar tdot = \"⃛\";\nvar telrec = \"⌕\";\nvar Tfr = \"𝔗\";\nvar tfr = \"𝔱\";\nvar there4 = \"∴\";\nvar therefore = \"∴\";\nvar Therefore = \"∴\";\nvar Theta = \"Θ\";\nvar theta = \"θ\";\nvar thetasym = \"ϑ\";\nvar thetav = \"ϑ\";\nvar thickapprox = \"≈\";\nvar thicksim = \"∼\";\nvar ThickSpace = \"  \";\nvar ThinSpace = \" \";\nvar thinsp = \" \";\nvar thkap = \"≈\";\nvar thksim = \"∼\";\nvar THORN$1 = \"Þ\";\nvar thorn$1 = \"þ\";\nvar tilde = \"˜\";\nvar Tilde = \"∼\";\nvar TildeEqual = \"≃\";\nvar TildeFullEqual = \"≅\";\nvar TildeTilde = \"≈\";\nvar timesbar = \"⨱\";\nvar timesb = \"⊠\";\nvar times$1 = \"×\";\nvar timesd = \"⨰\";\nvar tint = \"∭\";\nvar toea = \"⤨\";\nvar topbot = \"⌶\";\nvar topcir = \"⫱\";\nvar top = \"⊤\";\nvar Topf = \"𝕋\";\nvar topf = \"𝕥\";\nvar topfork = \"⫚\";\nvar tosa = \"⤩\";\nvar tprime = \"‴\";\nvar trade = \"™\";\nvar TRADE = \"™\";\nvar triangle = \"▵\";\nvar triangledown = \"▿\";\nvar triangleleft = \"◃\";\nvar trianglelefteq = \"⊴\";\nvar triangleq = \"≜\";\nvar triangleright = \"▹\";\nvar trianglerighteq = \"⊵\";\nvar tridot = \"◬\";\nvar trie = \"≜\";\nvar triminus = \"⨺\";\nvar TripleDot = \"⃛\";\nvar triplus = \"⨹\";\nvar trisb = \"⧍\";\nvar tritime = \"⨻\";\nvar trpezium = \"⏢\";\nvar Tscr = \"𝒯\";\nvar tscr = \"𝓉\";\nvar TScy = \"Ц\";\nvar tscy = \"ц\";\nvar TSHcy = \"Ћ\";\nvar tshcy = \"ћ\";\nvar Tstrok = \"Ŧ\";\nvar tstrok = \"ŧ\";\nvar twixt = \"≬\";\nvar twoheadleftarrow = \"↞\";\nvar twoheadrightarrow = \"↠\";\nvar Uacute$1 = \"Ú\";\nvar uacute$1 = \"ú\";\nvar uarr = \"↑\";\nvar Uarr = \"↟\";\nvar uArr = \"⇑\";\nvar Uarrocir = \"⥉\";\nvar Ubrcy = \"Ў\";\nvar ubrcy = \"ў\";\nvar Ubreve = \"Ŭ\";\nvar ubreve = \"ŭ\";\nvar Ucirc$1 = \"Û\";\nvar ucirc$1 = \"û\";\nvar Ucy = \"У\";\nvar ucy = \"у\";\nvar udarr = \"⇅\";\nvar Udblac = \"Ű\";\nvar udblac = \"ű\";\nvar udhar = \"⥮\";\nvar ufisht = \"⥾\";\nvar Ufr = \"𝔘\";\nvar ufr = \"𝔲\";\nvar Ugrave$1 = \"Ù\";\nvar ugrave$1 = \"ù\";\nvar uHar = \"⥣\";\nvar uharl = \"↿\";\nvar uharr = \"↾\";\nvar uhblk = \"▀\";\nvar ulcorn = \"⌜\";\nvar ulcorner = \"⌜\";\nvar ulcrop = \"⌏\";\nvar ultri = \"◸\";\nvar Umacr = \"Ū\";\nvar umacr = \"ū\";\nvar uml$1 = \"¨\";\nvar UnderBar = \"_\";\nvar UnderBrace = \"⏟\";\nvar UnderBracket = \"⎵\";\nvar UnderParenthesis = \"⏝\";\nvar Union = \"⋃\";\nvar UnionPlus = \"⊎\";\nvar Uogon = \"Ų\";\nvar uogon = \"ų\";\nvar Uopf = \"𝕌\";\nvar uopf = \"𝕦\";\nvar UpArrowBar = \"⤒\";\nvar uparrow = \"↑\";\nvar UpArrow = \"↑\";\nvar Uparrow = \"⇑\";\nvar UpArrowDownArrow = \"⇅\";\nvar updownarrow = \"↕\";\nvar UpDownArrow = \"↕\";\nvar Updownarrow = \"⇕\";\nvar UpEquilibrium = \"⥮\";\nvar upharpoonleft = \"↿\";\nvar upharpoonright = \"↾\";\nvar uplus = \"⊎\";\nvar UpperLeftArrow = \"↖\";\nvar UpperRightArrow = \"↗\";\nvar upsi = \"υ\";\nvar Upsi = \"ϒ\";\nvar upsih = \"ϒ\";\nvar Upsilon = \"Υ\";\nvar upsilon = \"υ\";\nvar UpTeeArrow = \"↥\";\nvar UpTee = \"⊥\";\nvar upuparrows = \"⇈\";\nvar urcorn = \"⌝\";\nvar urcorner = \"⌝\";\nvar urcrop = \"⌎\";\nvar Uring = \"Ů\";\nvar uring = \"ů\";\nvar urtri = \"◹\";\nvar Uscr = \"𝒰\";\nvar uscr = \"𝓊\";\nvar utdot = \"⋰\";\nvar Utilde = \"Ũ\";\nvar utilde = \"ũ\";\nvar utri = \"▵\";\nvar utrif = \"▴\";\nvar uuarr = \"⇈\";\nvar Uuml$1 = \"Ü\";\nvar uuml$1 = \"ü\";\nvar uwangle = \"⦧\";\nvar vangrt = \"⦜\";\nvar varepsilon = \"ϵ\";\nvar varkappa = \"ϰ\";\nvar varnothing = \"∅\";\nvar varphi = \"ϕ\";\nvar varpi = \"ϖ\";\nvar varpropto = \"∝\";\nvar varr = \"↕\";\nvar vArr = \"⇕\";\nvar varrho = \"ϱ\";\nvar varsigma = \"ς\";\nvar varsubsetneq = \"⊊︀\";\nvar varsubsetneqq = \"⫋︀\";\nvar varsupsetneq = \"⊋︀\";\nvar varsupsetneqq = \"⫌︀\";\nvar vartheta = \"ϑ\";\nvar vartriangleleft = \"⊲\";\nvar vartriangleright = \"⊳\";\nvar vBar = \"⫨\";\nvar Vbar = \"⫫\";\nvar vBarv = \"⫩\";\nvar Vcy = \"В\";\nvar vcy = \"в\";\nvar vdash = \"⊢\";\nvar vDash = \"⊨\";\nvar Vdash = \"⊩\";\nvar VDash = \"⊫\";\nvar Vdashl = \"⫦\";\nvar veebar = \"⊻\";\nvar vee = \"∨\";\nvar Vee = \"⋁\";\nvar veeeq = \"≚\";\nvar vellip = \"⋮\";\nvar verbar = \"|\";\nvar Verbar = \"‖\";\nvar vert = \"|\";\nvar Vert = \"‖\";\nvar VerticalBar = \"∣\";\nvar VerticalLine = \"|\";\nvar VerticalSeparator = \"❘\";\nvar VerticalTilde = \"≀\";\nvar VeryThinSpace = \" \";\nvar Vfr = \"𝔙\";\nvar vfr = \"𝔳\";\nvar vltri = \"⊲\";\nvar vnsub = \"⊂⃒\";\nvar vnsup = \"⊃⃒\";\nvar Vopf = \"𝕍\";\nvar vopf = \"𝕧\";\nvar vprop = \"∝\";\nvar vrtri = \"⊳\";\nvar Vscr = \"𝒱\";\nvar vscr = \"𝓋\";\nvar vsubnE = \"⫋︀\";\nvar vsubne = \"⊊︀\";\nvar vsupnE = \"⫌︀\";\nvar vsupne = \"⊋︀\";\nvar Vvdash = \"⊪\";\nvar vzigzag = \"⦚\";\nvar Wcirc = \"Ŵ\";\nvar wcirc = \"ŵ\";\nvar wedbar = \"⩟\";\nvar wedge = \"∧\";\nvar Wedge = \"⋀\";\nvar wedgeq = \"≙\";\nvar weierp = \"℘\";\nvar Wfr = \"𝔚\";\nvar wfr = \"𝔴\";\nvar Wopf = \"𝕎\";\nvar wopf = \"𝕨\";\nvar wp = \"℘\";\nvar wr = \"≀\";\nvar wreath = \"≀\";\nvar Wscr = \"𝒲\";\nvar wscr = \"𝓌\";\nvar xcap = \"⋂\";\nvar xcirc = \"◯\";\nvar xcup = \"⋃\";\nvar xdtri = \"▽\";\nvar Xfr = \"𝔛\";\nvar xfr = \"𝔵\";\nvar xharr = \"⟷\";\nvar xhArr = \"⟺\";\nvar Xi = \"Ξ\";\nvar xi = \"ξ\";\nvar xlarr = \"⟵\";\nvar xlArr = \"⟸\";\nvar xmap = \"⟼\";\nvar xnis = \"⋻\";\nvar xodot = \"⨀\";\nvar Xopf = \"𝕏\";\nvar xopf = \"𝕩\";\nvar xoplus = \"⨁\";\nvar xotime = \"⨂\";\nvar xrarr = \"⟶\";\nvar xrArr = \"⟹\";\nvar Xscr = \"𝒳\";\nvar xscr = \"𝓍\";\nvar xsqcup = \"⨆\";\nvar xuplus = \"⨄\";\nvar xutri = \"△\";\nvar xvee = \"⋁\";\nvar xwedge = \"⋀\";\nvar Yacute$1 = \"Ý\";\nvar yacute$1 = \"ý\";\nvar YAcy = \"Я\";\nvar yacy = \"я\";\nvar Ycirc = \"Ŷ\";\nvar ycirc = \"ŷ\";\nvar Ycy = \"Ы\";\nvar ycy = \"ы\";\nvar yen$1 = \"¥\";\nvar Yfr = \"𝔜\";\nvar yfr = \"𝔶\";\nvar YIcy = \"Ї\";\nvar yicy = \"ї\";\nvar Yopf = \"𝕐\";\nvar yopf = \"𝕪\";\nvar Yscr = \"𝒴\";\nvar yscr = \"𝓎\";\nvar YUcy = \"Ю\";\nvar yucy = \"ю\";\nvar yuml$1 = \"ÿ\";\nvar Yuml = \"Ÿ\";\nvar Zacute = \"Ź\";\nvar zacute = \"ź\";\nvar Zcaron = \"Ž\";\nvar zcaron = \"ž\";\nvar Zcy = \"З\";\nvar zcy = \"з\";\nvar Zdot = \"Ż\";\nvar zdot = \"ż\";\nvar zeetrf = \"ℨ\";\nvar ZeroWidthSpace = \"​\";\nvar Zeta = \"Ζ\";\nvar zeta = \"ζ\";\nvar zfr = \"𝔷\";\nvar Zfr = \"ℨ\";\nvar ZHcy = \"Ж\";\nvar zhcy = \"ж\";\nvar zigrarr = \"⇝\";\nvar zopf = \"𝕫\";\nvar Zopf = \"ℤ\";\nvar Zscr = \"𝒵\";\nvar zscr = \"𝓏\";\nvar zwj = \"‍\";\nvar zwnj = \"‌\";\nvar require$$1$1 = {\n\tAacute: Aacute$1,\n\taacute: aacute$1,\n\tAbreve: Abreve,\n\tabreve: abreve,\n\tac: ac,\n\tacd: acd,\n\tacE: acE,\n\tAcirc: Acirc$1,\n\tacirc: acirc$1,\n\tacute: acute$1,\n\tAcy: Acy,\n\tacy: acy,\n\tAElig: AElig$1,\n\taelig: aelig$1,\n\taf: af,\n\tAfr: Afr,\n\tafr: afr,\n\tAgrave: Agrave$1,\n\tagrave: agrave$1,\n\talefsym: alefsym,\n\taleph: aleph,\n\tAlpha: Alpha,\n\talpha: alpha,\n\tAmacr: Amacr,\n\tamacr: amacr,\n\tamalg: amalg,\n\tamp: amp$2,\n\tAMP: AMP$1,\n\tandand: andand,\n\tAnd: And,\n\tand: and,\n\tandd: andd,\n\tandslope: andslope,\n\tandv: andv,\n\tang: ang,\n\tange: ange,\n\tangle: angle,\n\tangmsdaa: angmsdaa,\n\tangmsdab: angmsdab,\n\tangmsdac: angmsdac,\n\tangmsdad: angmsdad,\n\tangmsdae: angmsdae,\n\tangmsdaf: angmsdaf,\n\tangmsdag: angmsdag,\n\tangmsdah: angmsdah,\n\tangmsd: angmsd,\n\tangrt: angrt,\n\tangrtvb: angrtvb,\n\tangrtvbd: angrtvbd,\n\tangsph: angsph,\n\tangst: angst,\n\tangzarr: angzarr,\n\tAogon: Aogon,\n\taogon: aogon,\n\tAopf: Aopf,\n\taopf: aopf,\n\tapacir: apacir,\n\tap: ap,\n\tapE: apE,\n\tape: ape,\n\tapid: apid,\n\tapos: apos$1,\n\tApplyFunction: ApplyFunction,\n\tapprox: approx,\n\tapproxeq: approxeq,\n\tAring: Aring$1,\n\taring: aring$1,\n\tAscr: Ascr,\n\tascr: ascr,\n\tAssign: Assign,\n\tast: ast,\n\tasymp: asymp,\n\tasympeq: asympeq,\n\tAtilde: Atilde$1,\n\tatilde: atilde$1,\n\tAuml: Auml$1,\n\tauml: auml$1,\n\tawconint: awconint,\n\tawint: awint,\n\tbackcong: backcong,\n\tbackepsilon: backepsilon,\n\tbackprime: backprime,\n\tbacksim: backsim,\n\tbacksimeq: backsimeq,\n\tBackslash: Backslash,\n\tBarv: Barv,\n\tbarvee: barvee,\n\tbarwed: barwed,\n\tBarwed: Barwed,\n\tbarwedge: barwedge,\n\tbbrk: bbrk,\n\tbbrktbrk: bbrktbrk,\n\tbcong: bcong,\n\tBcy: Bcy,\n\tbcy: bcy,\n\tbdquo: bdquo,\n\tbecaus: becaus,\n\tbecause: because,\n\tBecause: Because,\n\tbemptyv: bemptyv,\n\tbepsi: bepsi,\n\tbernou: bernou,\n\tBernoullis: Bernoullis,\n\tBeta: Beta,\n\tbeta: beta,\n\tbeth: beth,\n\tbetween: between,\n\tBfr: Bfr,\n\tbfr: bfr,\n\tbigcap: bigcap,\n\tbigcirc: bigcirc,\n\tbigcup: bigcup,\n\tbigodot: bigodot,\n\tbigoplus: bigoplus,\n\tbigotimes: bigotimes,\n\tbigsqcup: bigsqcup,\n\tbigstar: bigstar,\n\tbigtriangledown: bigtriangledown,\n\tbigtriangleup: bigtriangleup,\n\tbiguplus: biguplus,\n\tbigvee: bigvee,\n\tbigwedge: bigwedge,\n\tbkarow: bkarow,\n\tblacklozenge: blacklozenge,\n\tblacksquare: blacksquare,\n\tblacktriangle: blacktriangle,\n\tblacktriangledown: blacktriangledown,\n\tblacktriangleleft: blacktriangleleft,\n\tblacktriangleright: blacktriangleright,\n\tblank: blank,\n\tblk12: blk12,\n\tblk14: blk14,\n\tblk34: blk34,\n\tblock: block,\n\tbne: bne,\n\tbnequiv: bnequiv,\n\tbNot: bNot,\n\tbnot: bnot,\n\tBopf: Bopf,\n\tbopf: bopf,\n\tbot: bot,\n\tbottom: bottom,\n\tbowtie: bowtie,\n\tboxbox: boxbox,\n\tboxdl: boxdl,\n\tboxdL: boxdL,\n\tboxDl: boxDl,\n\tboxDL: boxDL,\n\tboxdr: boxdr,\n\tboxdR: boxdR,\n\tboxDr: boxDr,\n\tboxDR: boxDR,\n\tboxh: boxh,\n\tboxH: boxH,\n\tboxhd: boxhd,\n\tboxHd: boxHd,\n\tboxhD: boxhD,\n\tboxHD: boxHD,\n\tboxhu: boxhu,\n\tboxHu: boxHu,\n\tboxhU: boxhU,\n\tboxHU: boxHU,\n\tboxminus: boxminus,\n\tboxplus: boxplus,\n\tboxtimes: boxtimes,\n\tboxul: boxul,\n\tboxuL: boxuL,\n\tboxUl: boxUl,\n\tboxUL: boxUL,\n\tboxur: boxur,\n\tboxuR: boxuR,\n\tboxUr: boxUr,\n\tboxUR: boxUR,\n\tboxv: boxv,\n\tboxV: boxV,\n\tboxvh: boxvh,\n\tboxvH: boxvH,\n\tboxVh: boxVh,\n\tboxVH: boxVH,\n\tboxvl: boxvl,\n\tboxvL: boxvL,\n\tboxVl: boxVl,\n\tboxVL: boxVL,\n\tboxvr: boxvr,\n\tboxvR: boxvR,\n\tboxVr: boxVr,\n\tboxVR: boxVR,\n\tbprime: bprime,\n\tbreve: breve,\n\tBreve: Breve,\n\tbrvbar: brvbar$1,\n\tbscr: bscr,\n\tBscr: Bscr,\n\tbsemi: bsemi,\n\tbsim: bsim,\n\tbsime: bsime,\n\tbsolb: bsolb,\n\tbsol: bsol,\n\tbsolhsub: bsolhsub,\n\tbull: bull,\n\tbullet: bullet,\n\tbump: bump,\n\tbumpE: bumpE,\n\tbumpe: bumpe,\n\tBumpeq: Bumpeq,\n\tbumpeq: bumpeq,\n\tCacute: Cacute,\n\tcacute: cacute,\n\tcapand: capand,\n\tcapbrcup: capbrcup,\n\tcapcap: capcap,\n\tcap: cap,\n\tCap: Cap,\n\tcapcup: capcup,\n\tcapdot: capdot,\n\tCapitalDifferentialD: CapitalDifferentialD,\n\tcaps: caps,\n\tcaret: caret,\n\tcaron: caron,\n\tCayleys: Cayleys,\n\tccaps: ccaps,\n\tCcaron: Ccaron,\n\tccaron: ccaron,\n\tCcedil: Ccedil$1,\n\tccedil: ccedil$1,\n\tCcirc: Ccirc,\n\tccirc: ccirc,\n\tCconint: Cconint,\n\tccups: ccups,\n\tccupssm: ccupssm,\n\tCdot: Cdot,\n\tcdot: cdot,\n\tcedil: cedil$1,\n\tCedilla: Cedilla,\n\tcemptyv: cemptyv,\n\tcent: cent$1,\n\tcenterdot: centerdot,\n\tCenterDot: CenterDot,\n\tcfr: cfr,\n\tCfr: Cfr,\n\tCHcy: CHcy,\n\tchcy: chcy,\n\tcheck: check,\n\tcheckmark: checkmark,\n\tChi: Chi,\n\tchi: chi,\n\tcirc: circ,\n\tcirceq: circeq,\n\tcirclearrowleft: circlearrowleft,\n\tcirclearrowright: circlearrowright,\n\tcircledast: circledast,\n\tcircledcirc: circledcirc,\n\tcircleddash: circleddash,\n\tCircleDot: CircleDot,\n\tcircledR: circledR,\n\tcircledS: circledS,\n\tCircleMinus: CircleMinus,\n\tCirclePlus: CirclePlus,\n\tCircleTimes: CircleTimes,\n\tcir: cir,\n\tcirE: cirE,\n\tcire: cire,\n\tcirfnint: cirfnint,\n\tcirmid: cirmid,\n\tcirscir: cirscir,\n\tClockwiseContourIntegral: ClockwiseContourIntegral,\n\tCloseCurlyDoubleQuote: CloseCurlyDoubleQuote,\n\tCloseCurlyQuote: CloseCurlyQuote,\n\tclubs: clubs,\n\tclubsuit: clubsuit,\n\tcolon: colon,\n\tColon: Colon,\n\tColone: Colone,\n\tcolone: colone,\n\tcoloneq: coloneq,\n\tcomma: comma,\n\tcommat: commat,\n\tcomp: comp,\n\tcompfn: compfn,\n\tcomplement: complement,\n\tcomplexes: complexes,\n\tcong: cong,\n\tcongdot: congdot,\n\tCongruent: Congruent,\n\tconint: conint,\n\tConint: Conint,\n\tContourIntegral: ContourIntegral,\n\tcopf: copf,\n\tCopf: Copf,\n\tcoprod: coprod,\n\tCoproduct: Coproduct,\n\tcopy: copy$1,\n\tCOPY: COPY$1,\n\tcopysr: copysr,\n\tCounterClockwiseContourIntegral: CounterClockwiseContourIntegral,\n\tcrarr: crarr,\n\tcross: cross,\n\tCross: Cross,\n\tCscr: Cscr,\n\tcscr: cscr,\n\tcsub: csub,\n\tcsube: csube,\n\tcsup: csup,\n\tcsupe: csupe,\n\tctdot: ctdot,\n\tcudarrl: cudarrl,\n\tcudarrr: cudarrr,\n\tcuepr: cuepr,\n\tcuesc: cuesc,\n\tcularr: cularr,\n\tcularrp: cularrp,\n\tcupbrcap: cupbrcap,\n\tcupcap: cupcap,\n\tCupCap: CupCap,\n\tcup: cup,\n\tCup: Cup,\n\tcupcup: cupcup,\n\tcupdot: cupdot,\n\tcupor: cupor,\n\tcups: cups,\n\tcurarr: curarr,\n\tcurarrm: curarrm,\n\tcurlyeqprec: curlyeqprec,\n\tcurlyeqsucc: curlyeqsucc,\n\tcurlyvee: curlyvee,\n\tcurlywedge: curlywedge,\n\tcurren: curren$1,\n\tcurvearrowleft: curvearrowleft,\n\tcurvearrowright: curvearrowright,\n\tcuvee: cuvee,\n\tcuwed: cuwed,\n\tcwconint: cwconint,\n\tcwint: cwint,\n\tcylcty: cylcty,\n\tdagger: dagger,\n\tDagger: Dagger,\n\tdaleth: daleth,\n\tdarr: darr,\n\tDarr: Darr,\n\tdArr: dArr,\n\tdash: dash,\n\tDashv: Dashv,\n\tdashv: dashv,\n\tdbkarow: dbkarow,\n\tdblac: dblac,\n\tDcaron: Dcaron,\n\tdcaron: dcaron,\n\tDcy: Dcy,\n\tdcy: dcy,\n\tddagger: ddagger,\n\tddarr: ddarr,\n\tDD: DD,\n\tdd: dd,\n\tDDotrahd: DDotrahd,\n\tddotseq: ddotseq,\n\tdeg: deg$1,\n\tDel: Del,\n\tDelta: Delta,\n\tdelta: delta,\n\tdemptyv: demptyv,\n\tdfisht: dfisht,\n\tDfr: Dfr,\n\tdfr: dfr,\n\tdHar: dHar,\n\tdharl: dharl,\n\tdharr: dharr,\n\tDiacriticalAcute: DiacriticalAcute,\n\tDiacriticalDot: DiacriticalDot,\n\tDiacriticalDoubleAcute: DiacriticalDoubleAcute,\n\tDiacriticalGrave: DiacriticalGrave,\n\tDiacriticalTilde: DiacriticalTilde,\n\tdiam: diam,\n\tdiamond: diamond,\n\tDiamond: Diamond,\n\tdiamondsuit: diamondsuit,\n\tdiams: diams,\n\tdie: die,\n\tDifferentialD: DifferentialD,\n\tdigamma: digamma,\n\tdisin: disin,\n\tdiv: div,\n\tdivide: divide$1,\n\tdivideontimes: divideontimes,\n\tdivonx: divonx,\n\tDJcy: DJcy,\n\tdjcy: djcy,\n\tdlcorn: dlcorn,\n\tdlcrop: dlcrop,\n\tdollar: dollar,\n\tDopf: Dopf,\n\tdopf: dopf,\n\tDot: Dot,\n\tdot: dot,\n\tDotDot: DotDot,\n\tdoteq: doteq,\n\tdoteqdot: doteqdot,\n\tDotEqual: DotEqual,\n\tdotminus: dotminus,\n\tdotplus: dotplus,\n\tdotsquare: dotsquare,\n\tdoublebarwedge: doublebarwedge,\n\tDoubleContourIntegral: DoubleContourIntegral,\n\tDoubleDot: DoubleDot,\n\tDoubleDownArrow: DoubleDownArrow,\n\tDoubleLeftArrow: DoubleLeftArrow,\n\tDoubleLeftRightArrow: DoubleLeftRightArrow,\n\tDoubleLeftTee: DoubleLeftTee,\n\tDoubleLongLeftArrow: DoubleLongLeftArrow,\n\tDoubleLongLeftRightArrow: DoubleLongLeftRightArrow,\n\tDoubleLongRightArrow: DoubleLongRightArrow,\n\tDoubleRightArrow: DoubleRightArrow,\n\tDoubleRightTee: DoubleRightTee,\n\tDoubleUpArrow: DoubleUpArrow,\n\tDoubleUpDownArrow: DoubleUpDownArrow,\n\tDoubleVerticalBar: DoubleVerticalBar,\n\tDownArrowBar: DownArrowBar,\n\tdownarrow: downarrow,\n\tDownArrow: DownArrow,\n\tDownarrow: Downarrow,\n\tDownArrowUpArrow: DownArrowUpArrow,\n\tDownBreve: DownBreve,\n\tdowndownarrows: downdownarrows,\n\tdownharpoonleft: downharpoonleft,\n\tdownharpoonright: downharpoonright,\n\tDownLeftRightVector: DownLeftRightVector,\n\tDownLeftTeeVector: DownLeftTeeVector,\n\tDownLeftVectorBar: DownLeftVectorBar,\n\tDownLeftVector: DownLeftVector,\n\tDownRightTeeVector: DownRightTeeVector,\n\tDownRightVectorBar: DownRightVectorBar,\n\tDownRightVector: DownRightVector,\n\tDownTeeArrow: DownTeeArrow,\n\tDownTee: DownTee,\n\tdrbkarow: drbkarow,\n\tdrcorn: drcorn,\n\tdrcrop: drcrop,\n\tDscr: Dscr,\n\tdscr: dscr,\n\tDScy: DScy,\n\tdscy: dscy,\n\tdsol: dsol,\n\tDstrok: Dstrok,\n\tdstrok: dstrok,\n\tdtdot: dtdot,\n\tdtri: dtri,\n\tdtrif: dtrif,\n\tduarr: duarr,\n\tduhar: duhar,\n\tdwangle: dwangle,\n\tDZcy: DZcy,\n\tdzcy: dzcy,\n\tdzigrarr: dzigrarr,\n\tEacute: Eacute$1,\n\teacute: eacute$1,\n\teaster: easter,\n\tEcaron: Ecaron,\n\tecaron: ecaron,\n\tEcirc: Ecirc$1,\n\tecirc: ecirc$1,\n\tecir: ecir,\n\tecolon: ecolon,\n\tEcy: Ecy,\n\tecy: ecy,\n\teDDot: eDDot,\n\tEdot: Edot,\n\tedot: edot,\n\teDot: eDot,\n\tee: ee,\n\tefDot: efDot,\n\tEfr: Efr,\n\tefr: efr,\n\teg: eg,\n\tEgrave: Egrave$1,\n\tegrave: egrave$1,\n\tegs: egs,\n\tegsdot: egsdot,\n\tel: el,\n\tElement: Element$1,\n\telinters: elinters,\n\tell: ell,\n\tels: els,\n\telsdot: elsdot,\n\tEmacr: Emacr,\n\temacr: emacr,\n\tempty: empty,\n\temptyset: emptyset,\n\tEmptySmallSquare: EmptySmallSquare,\n\temptyv: emptyv,\n\tEmptyVerySmallSquare: EmptyVerySmallSquare,\n\temsp13: emsp13,\n\temsp14: emsp14,\n\temsp: emsp,\n\tENG: ENG,\n\teng: eng,\n\tensp: ensp,\n\tEogon: Eogon,\n\teogon: eogon,\n\tEopf: Eopf,\n\teopf: eopf,\n\tepar: epar,\n\teparsl: eparsl,\n\teplus: eplus,\n\tepsi: epsi,\n\tEpsilon: Epsilon,\n\tepsilon: epsilon,\n\tepsiv: epsiv,\n\teqcirc: eqcirc,\n\teqcolon: eqcolon,\n\teqsim: eqsim,\n\teqslantgtr: eqslantgtr,\n\teqslantless: eqslantless,\n\tEqual: Equal,\n\tequals: equals,\n\tEqualTilde: EqualTilde,\n\tequest: equest,\n\tEquilibrium: Equilibrium,\n\tequiv: equiv,\n\tequivDD: equivDD,\n\teqvparsl: eqvparsl,\n\terarr: erarr,\n\terDot: erDot,\n\tescr: escr,\n\tEscr: Escr,\n\tesdot: esdot,\n\tEsim: Esim,\n\tesim: esim,\n\tEta: Eta,\n\teta: eta,\n\tETH: ETH$1,\n\teth: eth$1,\n\tEuml: Euml$1,\n\teuml: euml$1,\n\teuro: euro,\n\texcl: excl,\n\texist: exist,\n\tExists: Exists,\n\texpectation: expectation,\n\texponentiale: exponentiale,\n\tExponentialE: ExponentialE,\n\tfallingdotseq: fallingdotseq,\n\tFcy: Fcy,\n\tfcy: fcy,\n\tfemale: female,\n\tffilig: ffilig,\n\tfflig: fflig,\n\tffllig: ffllig,\n\tFfr: Ffr,\n\tffr: ffr,\n\tfilig: filig,\n\tFilledSmallSquare: FilledSmallSquare,\n\tFilledVerySmallSquare: FilledVerySmallSquare,\n\tfjlig: fjlig,\n\tflat: flat,\n\tfllig: fllig,\n\tfltns: fltns,\n\tfnof: fnof,\n\tFopf: Fopf,\n\tfopf: fopf,\n\tforall: forall,\n\tForAll: ForAll,\n\tfork: fork,\n\tforkv: forkv,\n\tFouriertrf: Fouriertrf,\n\tfpartint: fpartint,\n\tfrac12: frac12$1,\n\tfrac13: frac13,\n\tfrac14: frac14$1,\n\tfrac15: frac15,\n\tfrac16: frac16,\n\tfrac18: frac18,\n\tfrac23: frac23,\n\tfrac25: frac25,\n\tfrac34: frac34$1,\n\tfrac35: frac35,\n\tfrac38: frac38,\n\tfrac45: frac45,\n\tfrac56: frac56,\n\tfrac58: frac58,\n\tfrac78: frac78,\n\tfrasl: frasl,\n\tfrown: frown,\n\tfscr: fscr,\n\tFscr: Fscr,\n\tgacute: gacute,\n\tGamma: Gamma,\n\tgamma: gamma,\n\tGammad: Gammad,\n\tgammad: gammad,\n\tgap: gap,\n\tGbreve: Gbreve,\n\tgbreve: gbreve,\n\tGcedil: Gcedil,\n\tGcirc: Gcirc,\n\tgcirc: gcirc,\n\tGcy: Gcy,\n\tgcy: gcy,\n\tGdot: Gdot,\n\tgdot: gdot,\n\tge: ge,\n\tgE: gE,\n\tgEl: gEl,\n\tgel: gel,\n\tgeq: geq,\n\tgeqq: geqq,\n\tgeqslant: geqslant,\n\tgescc: gescc,\n\tges: ges,\n\tgesdot: gesdot,\n\tgesdoto: gesdoto,\n\tgesdotol: gesdotol,\n\tgesl: gesl,\n\tgesles: gesles,\n\tGfr: Gfr,\n\tgfr: gfr,\n\tgg: gg,\n\tGg: Gg,\n\tggg: ggg,\n\tgimel: gimel,\n\tGJcy: GJcy,\n\tgjcy: gjcy,\n\tgla: gla,\n\tgl: gl,\n\tglE: glE,\n\tglj: glj,\n\tgnap: gnap,\n\tgnapprox: gnapprox,\n\tgne: gne,\n\tgnE: gnE,\n\tgneq: gneq,\n\tgneqq: gneqq,\n\tgnsim: gnsim,\n\tGopf: Gopf,\n\tgopf: gopf,\n\tgrave: grave,\n\tGreaterEqual: GreaterEqual,\n\tGreaterEqualLess: GreaterEqualLess,\n\tGreaterFullEqual: GreaterFullEqual,\n\tGreaterGreater: GreaterGreater,\n\tGreaterLess: GreaterLess,\n\tGreaterSlantEqual: GreaterSlantEqual,\n\tGreaterTilde: GreaterTilde,\n\tGscr: Gscr,\n\tgscr: gscr,\n\tgsim: gsim,\n\tgsime: gsime,\n\tgsiml: gsiml,\n\tgtcc: gtcc,\n\tgtcir: gtcir,\n\tgt: gt$2,\n\tGT: GT$1,\n\tGt: Gt,\n\tgtdot: gtdot,\n\tgtlPar: gtlPar,\n\tgtquest: gtquest,\n\tgtrapprox: gtrapprox,\n\tgtrarr: gtrarr,\n\tgtrdot: gtrdot,\n\tgtreqless: gtreqless,\n\tgtreqqless: gtreqqless,\n\tgtrless: gtrless,\n\tgtrsim: gtrsim,\n\tgvertneqq: gvertneqq,\n\tgvnE: gvnE,\n\tHacek: Hacek,\n\thairsp: hairsp,\n\thalf: half,\n\thamilt: hamilt,\n\tHARDcy: HARDcy,\n\thardcy: hardcy,\n\tharrcir: harrcir,\n\tharr: harr,\n\thArr: hArr,\n\tharrw: harrw,\n\tHat: Hat,\n\thbar: hbar,\n\tHcirc: Hcirc,\n\thcirc: hcirc,\n\thearts: hearts,\n\theartsuit: heartsuit,\n\thellip: hellip,\n\thercon: hercon,\n\thfr: hfr,\n\tHfr: Hfr,\n\tHilbertSpace: HilbertSpace,\n\thksearow: hksearow,\n\thkswarow: hkswarow,\n\thoarr: hoarr,\n\thomtht: homtht,\n\thookleftarrow: hookleftarrow,\n\thookrightarrow: hookrightarrow,\n\thopf: hopf,\n\tHopf: Hopf,\n\thorbar: horbar,\n\tHorizontalLine: HorizontalLine,\n\thscr: hscr,\n\tHscr: Hscr,\n\thslash: hslash,\n\tHstrok: Hstrok,\n\thstrok: hstrok,\n\tHumpDownHump: HumpDownHump,\n\tHumpEqual: HumpEqual,\n\thybull: hybull,\n\thyphen: hyphen,\n\tIacute: Iacute$1,\n\tiacute: iacute$1,\n\tic: ic,\n\tIcirc: Icirc$1,\n\ticirc: icirc$1,\n\tIcy: Icy,\n\ticy: icy,\n\tIdot: Idot,\n\tIEcy: IEcy,\n\tiecy: iecy,\n\tiexcl: iexcl$1,\n\tiff: iff,\n\tifr: ifr,\n\tIfr: Ifr,\n\tIgrave: Igrave$1,\n\tigrave: igrave$1,\n\tii: ii,\n\tiiiint: iiiint,\n\tiiint: iiint,\n\tiinfin: iinfin,\n\tiiota: iiota,\n\tIJlig: IJlig,\n\tijlig: ijlig,\n\tImacr: Imacr,\n\timacr: imacr,\n\timage: image,\n\tImaginaryI: ImaginaryI,\n\timagline: imagline,\n\timagpart: imagpart,\n\timath: imath,\n\tIm: Im,\n\timof: imof,\n\timped: imped,\n\tImplies: Implies,\n\tincare: incare,\n\t\"in\": \"∈\",\n\tinfin: infin,\n\tinfintie: infintie,\n\tinodot: inodot,\n\tintcal: intcal,\n\tint: int,\n\tInt: Int,\n\tintegers: integers,\n\tIntegral: Integral,\n\tintercal: intercal,\n\tIntersection: Intersection,\n\tintlarhk: intlarhk,\n\tintprod: intprod,\n\tInvisibleComma: InvisibleComma,\n\tInvisibleTimes: InvisibleTimes,\n\tIOcy: IOcy,\n\tiocy: iocy,\n\tIogon: Iogon,\n\tiogon: iogon,\n\tIopf: Iopf,\n\tiopf: iopf,\n\tIota: Iota,\n\tiota: iota,\n\tiprod: iprod,\n\tiquest: iquest$1,\n\tiscr: iscr,\n\tIscr: Iscr,\n\tisin: isin,\n\tisindot: isindot,\n\tisinE: isinE,\n\tisins: isins,\n\tisinsv: isinsv,\n\tisinv: isinv,\n\tit: it,\n\tItilde: Itilde,\n\titilde: itilde,\n\tIukcy: Iukcy,\n\tiukcy: iukcy,\n\tIuml: Iuml$1,\n\tiuml: iuml$1,\n\tJcirc: Jcirc,\n\tjcirc: jcirc,\n\tJcy: Jcy,\n\tjcy: jcy,\n\tJfr: Jfr,\n\tjfr: jfr,\n\tjmath: jmath,\n\tJopf: Jopf,\n\tjopf: jopf,\n\tJscr: Jscr,\n\tjscr: jscr,\n\tJsercy: Jsercy,\n\tjsercy: jsercy,\n\tJukcy: Jukcy,\n\tjukcy: jukcy,\n\tKappa: Kappa,\n\tkappa: kappa,\n\tkappav: kappav,\n\tKcedil: Kcedil,\n\tkcedil: kcedil,\n\tKcy: Kcy,\n\tkcy: kcy,\n\tKfr: Kfr,\n\tkfr: kfr,\n\tkgreen: kgreen,\n\tKHcy: KHcy,\n\tkhcy: khcy,\n\tKJcy: KJcy,\n\tkjcy: kjcy,\n\tKopf: Kopf,\n\tkopf: kopf,\n\tKscr: Kscr,\n\tkscr: kscr,\n\tlAarr: lAarr,\n\tLacute: Lacute,\n\tlacute: lacute,\n\tlaemptyv: laemptyv,\n\tlagran: lagran,\n\tLambda: Lambda,\n\tlambda: lambda,\n\tlang: lang,\n\tLang: Lang,\n\tlangd: langd,\n\tlangle: langle,\n\tlap: lap,\n\tLaplacetrf: Laplacetrf,\n\tlaquo: laquo$1,\n\tlarrb: larrb,\n\tlarrbfs: larrbfs,\n\tlarr: larr,\n\tLarr: Larr,\n\tlArr: lArr,\n\tlarrfs: larrfs,\n\tlarrhk: larrhk,\n\tlarrlp: larrlp,\n\tlarrpl: larrpl,\n\tlarrsim: larrsim,\n\tlarrtl: larrtl,\n\tlatail: latail,\n\tlAtail: lAtail,\n\tlat: lat,\n\tlate: late,\n\tlates: lates,\n\tlbarr: lbarr,\n\tlBarr: lBarr,\n\tlbbrk: lbbrk,\n\tlbrace: lbrace,\n\tlbrack: lbrack,\n\tlbrke: lbrke,\n\tlbrksld: lbrksld,\n\tlbrkslu: lbrkslu,\n\tLcaron: Lcaron,\n\tlcaron: lcaron,\n\tLcedil: Lcedil,\n\tlcedil: lcedil,\n\tlceil: lceil,\n\tlcub: lcub,\n\tLcy: Lcy,\n\tlcy: lcy,\n\tldca: ldca,\n\tldquo: ldquo,\n\tldquor: ldquor,\n\tldrdhar: ldrdhar,\n\tldrushar: ldrushar,\n\tldsh: ldsh,\n\tle: le,\n\tlE: lE,\n\tLeftAngleBracket: LeftAngleBracket,\n\tLeftArrowBar: LeftArrowBar,\n\tleftarrow: leftarrow,\n\tLeftArrow: LeftArrow,\n\tLeftarrow: Leftarrow,\n\tLeftArrowRightArrow: LeftArrowRightArrow,\n\tleftarrowtail: leftarrowtail,\n\tLeftCeiling: LeftCeiling,\n\tLeftDoubleBracket: LeftDoubleBracket,\n\tLeftDownTeeVector: LeftDownTeeVector,\n\tLeftDownVectorBar: LeftDownVectorBar,\n\tLeftDownVector: LeftDownVector,\n\tLeftFloor: LeftFloor,\n\tleftharpoondown: leftharpoondown,\n\tleftharpoonup: leftharpoonup,\n\tleftleftarrows: leftleftarrows,\n\tleftrightarrow: leftrightarrow,\n\tLeftRightArrow: LeftRightArrow,\n\tLeftrightarrow: Leftrightarrow,\n\tleftrightarrows: leftrightarrows,\n\tleftrightharpoons: leftrightharpoons,\n\tleftrightsquigarrow: leftrightsquigarrow,\n\tLeftRightVector: LeftRightVector,\n\tLeftTeeArrow: LeftTeeArrow,\n\tLeftTee: LeftTee,\n\tLeftTeeVector: LeftTeeVector,\n\tleftthreetimes: leftthreetimes,\n\tLeftTriangleBar: LeftTriangleBar,\n\tLeftTriangle: LeftTriangle,\n\tLeftTriangleEqual: LeftTriangleEqual,\n\tLeftUpDownVector: LeftUpDownVector,\n\tLeftUpTeeVector: LeftUpTeeVector,\n\tLeftUpVectorBar: LeftUpVectorBar,\n\tLeftUpVector: LeftUpVector,\n\tLeftVectorBar: LeftVectorBar,\n\tLeftVector: LeftVector,\n\tlEg: lEg,\n\tleg: leg,\n\tleq: leq,\n\tleqq: leqq,\n\tleqslant: leqslant,\n\tlescc: lescc,\n\tles: les,\n\tlesdot: lesdot,\n\tlesdoto: lesdoto,\n\tlesdotor: lesdotor,\n\tlesg: lesg,\n\tlesges: lesges,\n\tlessapprox: lessapprox,\n\tlessdot: lessdot,\n\tlesseqgtr: lesseqgtr,\n\tlesseqqgtr: lesseqqgtr,\n\tLessEqualGreater: LessEqualGreater,\n\tLessFullEqual: LessFullEqual,\n\tLessGreater: LessGreater,\n\tlessgtr: lessgtr,\n\tLessLess: LessLess,\n\tlesssim: lesssim,\n\tLessSlantEqual: LessSlantEqual,\n\tLessTilde: LessTilde,\n\tlfisht: lfisht,\n\tlfloor: lfloor,\n\tLfr: Lfr,\n\tlfr: lfr,\n\tlg: lg,\n\tlgE: lgE,\n\tlHar: lHar,\n\tlhard: lhard,\n\tlharu: lharu,\n\tlharul: lharul,\n\tlhblk: lhblk,\n\tLJcy: LJcy,\n\tljcy: ljcy,\n\tllarr: llarr,\n\tll: ll,\n\tLl: Ll,\n\tllcorner: llcorner,\n\tLleftarrow: Lleftarrow,\n\tllhard: llhard,\n\tlltri: lltri,\n\tLmidot: Lmidot,\n\tlmidot: lmidot,\n\tlmoustache: lmoustache,\n\tlmoust: lmoust,\n\tlnap: lnap,\n\tlnapprox: lnapprox,\n\tlne: lne,\n\tlnE: lnE,\n\tlneq: lneq,\n\tlneqq: lneqq,\n\tlnsim: lnsim,\n\tloang: loang,\n\tloarr: loarr,\n\tlobrk: lobrk,\n\tlongleftarrow: longleftarrow,\n\tLongLeftArrow: LongLeftArrow,\n\tLongleftarrow: Longleftarrow,\n\tlongleftrightarrow: longleftrightarrow,\n\tLongLeftRightArrow: LongLeftRightArrow,\n\tLongleftrightarrow: Longleftrightarrow,\n\tlongmapsto: longmapsto,\n\tlongrightarrow: longrightarrow,\n\tLongRightArrow: LongRightArrow,\n\tLongrightarrow: Longrightarrow,\n\tlooparrowleft: looparrowleft,\n\tlooparrowright: looparrowright,\n\tlopar: lopar,\n\tLopf: Lopf,\n\tlopf: lopf,\n\tloplus: loplus,\n\tlotimes: lotimes,\n\tlowast: lowast,\n\tlowbar: lowbar,\n\tLowerLeftArrow: LowerLeftArrow,\n\tLowerRightArrow: LowerRightArrow,\n\tloz: loz,\n\tlozenge: lozenge,\n\tlozf: lozf,\n\tlpar: lpar,\n\tlparlt: lparlt,\n\tlrarr: lrarr,\n\tlrcorner: lrcorner,\n\tlrhar: lrhar,\n\tlrhard: lrhard,\n\tlrm: lrm,\n\tlrtri: lrtri,\n\tlsaquo: lsaquo,\n\tlscr: lscr,\n\tLscr: Lscr,\n\tlsh: lsh,\n\tLsh: Lsh,\n\tlsim: lsim,\n\tlsime: lsime,\n\tlsimg: lsimg,\n\tlsqb: lsqb,\n\tlsquo: lsquo,\n\tlsquor: lsquor,\n\tLstrok: Lstrok,\n\tlstrok: lstrok,\n\tltcc: ltcc,\n\tltcir: ltcir,\n\tlt: lt$2,\n\tLT: LT$1,\n\tLt: Lt,\n\tltdot: ltdot,\n\tlthree: lthree,\n\tltimes: ltimes,\n\tltlarr: ltlarr,\n\tltquest: ltquest,\n\tltri: ltri,\n\tltrie: ltrie,\n\tltrif: ltrif,\n\tltrPar: ltrPar,\n\tlurdshar: lurdshar,\n\tluruhar: luruhar,\n\tlvertneqq: lvertneqq,\n\tlvnE: lvnE,\n\tmacr: macr$1,\n\tmale: male,\n\tmalt: malt,\n\tmaltese: maltese,\n\t\"Map\": \"⤅\",\n\tmap: map,\n\tmapsto: mapsto,\n\tmapstodown: mapstodown,\n\tmapstoleft: mapstoleft,\n\tmapstoup: mapstoup,\n\tmarker: marker,\n\tmcomma: mcomma,\n\tMcy: Mcy,\n\tmcy: mcy,\n\tmdash: mdash,\n\tmDDot: mDDot,\n\tmeasuredangle: measuredangle,\n\tMediumSpace: MediumSpace,\n\tMellintrf: Mellintrf,\n\tMfr: Mfr,\n\tmfr: mfr,\n\tmho: mho,\n\tmicro: micro$1,\n\tmidast: midast,\n\tmidcir: midcir,\n\tmid: mid,\n\tmiddot: middot$1,\n\tminusb: minusb,\n\tminus: minus,\n\tminusd: minusd,\n\tminusdu: minusdu,\n\tMinusPlus: MinusPlus,\n\tmlcp: mlcp,\n\tmldr: mldr,\n\tmnplus: mnplus,\n\tmodels: models,\n\tMopf: Mopf,\n\tmopf: mopf,\n\tmp: mp,\n\tmscr: mscr,\n\tMscr: Mscr,\n\tmstpos: mstpos,\n\tMu: Mu,\n\tmu: mu,\n\tmultimap: multimap,\n\tmumap: mumap,\n\tnabla: nabla,\n\tNacute: Nacute,\n\tnacute: nacute,\n\tnang: nang,\n\tnap: nap,\n\tnapE: napE,\n\tnapid: napid,\n\tnapos: napos,\n\tnapprox: napprox,\n\tnatural: natural,\n\tnaturals: naturals,\n\tnatur: natur,\n\tnbsp: nbsp$1,\n\tnbump: nbump,\n\tnbumpe: nbumpe,\n\tncap: ncap,\n\tNcaron: Ncaron,\n\tncaron: ncaron,\n\tNcedil: Ncedil,\n\tncedil: ncedil,\n\tncong: ncong,\n\tncongdot: ncongdot,\n\tncup: ncup,\n\tNcy: Ncy,\n\tncy: ncy,\n\tndash: ndash,\n\tnearhk: nearhk,\n\tnearr: nearr,\n\tneArr: neArr,\n\tnearrow: nearrow,\n\tne: ne,\n\tnedot: nedot,\n\tNegativeMediumSpace: NegativeMediumSpace,\n\tNegativeThickSpace: NegativeThickSpace,\n\tNegativeThinSpace: NegativeThinSpace,\n\tNegativeVeryThinSpace: NegativeVeryThinSpace,\n\tnequiv: nequiv,\n\tnesear: nesear,\n\tnesim: nesim,\n\tNestedGreaterGreater: NestedGreaterGreater,\n\tNestedLessLess: NestedLessLess,\n\tNewLine: NewLine,\n\tnexist: nexist,\n\tnexists: nexists,\n\tNfr: Nfr,\n\tnfr: nfr,\n\tngE: ngE,\n\tnge: nge,\n\tngeq: ngeq,\n\tngeqq: ngeqq,\n\tngeqslant: ngeqslant,\n\tnges: nges,\n\tnGg: nGg,\n\tngsim: ngsim,\n\tnGt: nGt,\n\tngt: ngt,\n\tngtr: ngtr,\n\tnGtv: nGtv,\n\tnharr: nharr,\n\tnhArr: nhArr,\n\tnhpar: nhpar,\n\tni: ni,\n\tnis: nis,\n\tnisd: nisd,\n\tniv: niv,\n\tNJcy: NJcy,\n\tnjcy: njcy,\n\tnlarr: nlarr,\n\tnlArr: nlArr,\n\tnldr: nldr,\n\tnlE: nlE,\n\tnle: nle,\n\tnleftarrow: nleftarrow,\n\tnLeftarrow: nLeftarrow,\n\tnleftrightarrow: nleftrightarrow,\n\tnLeftrightarrow: nLeftrightarrow,\n\tnleq: nleq,\n\tnleqq: nleqq,\n\tnleqslant: nleqslant,\n\tnles: nles,\n\tnless: nless,\n\tnLl: nLl,\n\tnlsim: nlsim,\n\tnLt: nLt,\n\tnlt: nlt,\n\tnltri: nltri,\n\tnltrie: nltrie,\n\tnLtv: nLtv,\n\tnmid: nmid,\n\tNoBreak: NoBreak,\n\tNonBreakingSpace: NonBreakingSpace,\n\tnopf: nopf,\n\tNopf: Nopf,\n\tNot: Not,\n\tnot: not$1,\n\tNotCongruent: NotCongruent,\n\tNotCupCap: NotCupCap,\n\tNotDoubleVerticalBar: NotDoubleVerticalBar,\n\tNotElement: NotElement,\n\tNotEqual: NotEqual,\n\tNotEqualTilde: NotEqualTilde,\n\tNotExists: NotExists,\n\tNotGreater: NotGreater,\n\tNotGreaterEqual: NotGreaterEqual,\n\tNotGreaterFullEqual: NotGreaterFullEqual,\n\tNotGreaterGreater: NotGreaterGreater,\n\tNotGreaterLess: NotGreaterLess,\n\tNotGreaterSlantEqual: NotGreaterSlantEqual,\n\tNotGreaterTilde: NotGreaterTilde,\n\tNotHumpDownHump: NotHumpDownHump,\n\tNotHumpEqual: NotHumpEqual,\n\tnotin: notin,\n\tnotindot: notindot,\n\tnotinE: notinE,\n\tnotinva: notinva,\n\tnotinvb: notinvb,\n\tnotinvc: notinvc,\n\tNotLeftTriangleBar: NotLeftTriangleBar,\n\tNotLeftTriangle: NotLeftTriangle,\n\tNotLeftTriangleEqual: NotLeftTriangleEqual,\n\tNotLess: NotLess,\n\tNotLessEqual: NotLessEqual,\n\tNotLessGreater: NotLessGreater,\n\tNotLessLess: NotLessLess,\n\tNotLessSlantEqual: NotLessSlantEqual,\n\tNotLessTilde: NotLessTilde,\n\tNotNestedGreaterGreater: NotNestedGreaterGreater,\n\tNotNestedLessLess: NotNestedLessLess,\n\tnotni: notni,\n\tnotniva: notniva,\n\tnotnivb: notnivb,\n\tnotnivc: notnivc,\n\tNotPrecedes: NotPrecedes,\n\tNotPrecedesEqual: NotPrecedesEqual,\n\tNotPrecedesSlantEqual: NotPrecedesSlantEqual,\n\tNotReverseElement: NotReverseElement,\n\tNotRightTriangleBar: NotRightTriangleBar,\n\tNotRightTriangle: NotRightTriangle,\n\tNotRightTriangleEqual: NotRightTriangleEqual,\n\tNotSquareSubset: NotSquareSubset,\n\tNotSquareSubsetEqual: NotSquareSubsetEqual,\n\tNotSquareSuperset: NotSquareSuperset,\n\tNotSquareSupersetEqual: NotSquareSupersetEqual,\n\tNotSubset: NotSubset,\n\tNotSubsetEqual: NotSubsetEqual,\n\tNotSucceeds: NotSucceeds,\n\tNotSucceedsEqual: NotSucceedsEqual,\n\tNotSucceedsSlantEqual: NotSucceedsSlantEqual,\n\tNotSucceedsTilde: NotSucceedsTilde,\n\tNotSuperset: NotSuperset,\n\tNotSupersetEqual: NotSupersetEqual,\n\tNotTilde: NotTilde,\n\tNotTildeEqual: NotTildeEqual,\n\tNotTildeFullEqual: NotTildeFullEqual,\n\tNotTildeTilde: NotTildeTilde,\n\tNotVerticalBar: NotVerticalBar,\n\tnparallel: nparallel,\n\tnpar: npar,\n\tnparsl: nparsl,\n\tnpart: npart,\n\tnpolint: npolint,\n\tnpr: npr,\n\tnprcue: nprcue,\n\tnprec: nprec,\n\tnpreceq: npreceq,\n\tnpre: npre,\n\tnrarrc: nrarrc,\n\tnrarr: nrarr,\n\tnrArr: nrArr,\n\tnrarrw: nrarrw,\n\tnrightarrow: nrightarrow,\n\tnRightarrow: nRightarrow,\n\tnrtri: nrtri,\n\tnrtrie: nrtrie,\n\tnsc: nsc,\n\tnsccue: nsccue,\n\tnsce: nsce,\n\tNscr: Nscr,\n\tnscr: nscr,\n\tnshortmid: nshortmid,\n\tnshortparallel: nshortparallel,\n\tnsim: nsim,\n\tnsime: nsime,\n\tnsimeq: nsimeq,\n\tnsmid: nsmid,\n\tnspar: nspar,\n\tnsqsube: nsqsube,\n\tnsqsupe: nsqsupe,\n\tnsub: nsub,\n\tnsubE: nsubE,\n\tnsube: nsube,\n\tnsubset: nsubset,\n\tnsubseteq: nsubseteq,\n\tnsubseteqq: nsubseteqq,\n\tnsucc: nsucc,\n\tnsucceq: nsucceq,\n\tnsup: nsup,\n\tnsupE: nsupE,\n\tnsupe: nsupe,\n\tnsupset: nsupset,\n\tnsupseteq: nsupseteq,\n\tnsupseteqq: nsupseteqq,\n\tntgl: ntgl,\n\tNtilde: Ntilde$1,\n\tntilde: ntilde$1,\n\tntlg: ntlg,\n\tntriangleleft: ntriangleleft,\n\tntrianglelefteq: ntrianglelefteq,\n\tntriangleright: ntriangleright,\n\tntrianglerighteq: ntrianglerighteq,\n\tNu: Nu,\n\tnu: nu,\n\tnum: num,\n\tnumero: numero,\n\tnumsp: numsp,\n\tnvap: nvap,\n\tnvdash: nvdash,\n\tnvDash: nvDash,\n\tnVdash: nVdash,\n\tnVDash: nVDash,\n\tnvge: nvge,\n\tnvgt: nvgt,\n\tnvHarr: nvHarr,\n\tnvinfin: nvinfin,\n\tnvlArr: nvlArr,\n\tnvle: nvle,\n\tnvlt: nvlt,\n\tnvltrie: nvltrie,\n\tnvrArr: nvrArr,\n\tnvrtrie: nvrtrie,\n\tnvsim: nvsim,\n\tnwarhk: nwarhk,\n\tnwarr: nwarr,\n\tnwArr: nwArr,\n\tnwarrow: nwarrow,\n\tnwnear: nwnear,\n\tOacute: Oacute$1,\n\toacute: oacute$1,\n\toast: oast,\n\tOcirc: Ocirc$1,\n\tocirc: ocirc$1,\n\tocir: ocir,\n\tOcy: Ocy,\n\tocy: ocy,\n\todash: odash,\n\tOdblac: Odblac,\n\todblac: odblac,\n\todiv: odiv,\n\todot: odot,\n\todsold: odsold,\n\tOElig: OElig,\n\toelig: oelig,\n\tofcir: ofcir,\n\tOfr: Ofr,\n\tofr: ofr,\n\togon: ogon,\n\tOgrave: Ograve$1,\n\tograve: ograve$1,\n\togt: ogt,\n\tohbar: ohbar,\n\tohm: ohm,\n\toint: oint,\n\tolarr: olarr,\n\tolcir: olcir,\n\tolcross: olcross,\n\toline: oline,\n\tolt: olt,\n\tOmacr: Omacr,\n\tomacr: omacr,\n\tOmega: Omega,\n\tomega: omega,\n\tOmicron: Omicron,\n\tomicron: omicron,\n\tomid: omid,\n\tominus: ominus,\n\tOopf: Oopf,\n\toopf: oopf,\n\topar: opar,\n\tOpenCurlyDoubleQuote: OpenCurlyDoubleQuote,\n\tOpenCurlyQuote: OpenCurlyQuote,\n\toperp: operp,\n\toplus: oplus,\n\torarr: orarr,\n\tOr: Or,\n\tor: or,\n\tord: ord,\n\torder: order,\n\torderof: orderof,\n\tordf: ordf$1,\n\tordm: ordm$1,\n\torigof: origof,\n\toror: oror,\n\torslope: orslope,\n\torv: orv,\n\toS: oS,\n\tOscr: Oscr,\n\toscr: oscr,\n\tOslash: Oslash$1,\n\toslash: oslash$1,\n\tosol: osol,\n\tOtilde: Otilde$1,\n\totilde: otilde$1,\n\totimesas: otimesas,\n\tOtimes: Otimes,\n\totimes: otimes,\n\tOuml: Ouml$1,\n\touml: ouml$1,\n\tovbar: ovbar,\n\tOverBar: OverBar,\n\tOverBrace: OverBrace,\n\tOverBracket: OverBracket,\n\tOverParenthesis: OverParenthesis,\n\tpara: para$1,\n\tparallel: parallel,\n\tpar: par,\n\tparsim: parsim,\n\tparsl: parsl,\n\tpart: part,\n\tPartialD: PartialD,\n\tPcy: Pcy,\n\tpcy: pcy,\n\tpercnt: percnt,\n\tperiod: period,\n\tpermil: permil,\n\tperp: perp,\n\tpertenk: pertenk,\n\tPfr: Pfr,\n\tpfr: pfr,\n\tPhi: Phi,\n\tphi: phi,\n\tphiv: phiv,\n\tphmmat: phmmat,\n\tphone: phone,\n\tPi: Pi,\n\tpi: pi,\n\tpitchfork: pitchfork,\n\tpiv: piv,\n\tplanck: planck,\n\tplanckh: planckh,\n\tplankv: plankv,\n\tplusacir: plusacir,\n\tplusb: plusb,\n\tpluscir: pluscir,\n\tplus: plus,\n\tplusdo: plusdo,\n\tplusdu: plusdu,\n\tpluse: pluse,\n\tPlusMinus: PlusMinus,\n\tplusmn: plusmn$1,\n\tplussim: plussim,\n\tplustwo: plustwo,\n\tpm: pm,\n\tPoincareplane: Poincareplane,\n\tpointint: pointint,\n\tpopf: popf,\n\tPopf: Popf,\n\tpound: pound$1,\n\tprap: prap,\n\tPr: Pr,\n\tpr: pr,\n\tprcue: prcue,\n\tprecapprox: precapprox,\n\tprec: prec,\n\tpreccurlyeq: preccurlyeq,\n\tPrecedes: Precedes,\n\tPrecedesEqual: PrecedesEqual,\n\tPrecedesSlantEqual: PrecedesSlantEqual,\n\tPrecedesTilde: PrecedesTilde,\n\tpreceq: preceq,\n\tprecnapprox: precnapprox,\n\tprecneqq: precneqq,\n\tprecnsim: precnsim,\n\tpre: pre,\n\tprE: prE,\n\tprecsim: precsim,\n\tprime: prime,\n\tPrime: Prime,\n\tprimes: primes,\n\tprnap: prnap,\n\tprnE: prnE,\n\tprnsim: prnsim,\n\tprod: prod,\n\tProduct: Product,\n\tprofalar: profalar,\n\tprofline: profline,\n\tprofsurf: profsurf,\n\tprop: prop,\n\tProportional: Proportional,\n\tProportion: Proportion,\n\tpropto: propto,\n\tprsim: prsim,\n\tprurel: prurel,\n\tPscr: Pscr,\n\tpscr: pscr,\n\tPsi: Psi,\n\tpsi: psi,\n\tpuncsp: puncsp,\n\tQfr: Qfr,\n\tqfr: qfr,\n\tqint: qint,\n\tqopf: qopf,\n\tQopf: Qopf,\n\tqprime: qprime,\n\tQscr: Qscr,\n\tqscr: qscr,\n\tquaternions: quaternions,\n\tquatint: quatint,\n\tquest: quest,\n\tquesteq: questeq,\n\tquot: quot$2,\n\tQUOT: QUOT$1,\n\trAarr: rAarr,\n\trace: race,\n\tRacute: Racute,\n\tracute: racute,\n\tradic: radic,\n\traemptyv: raemptyv,\n\trang: rang,\n\tRang: Rang,\n\trangd: rangd,\n\trange: range,\n\trangle: rangle,\n\traquo: raquo$1,\n\trarrap: rarrap,\n\trarrb: rarrb,\n\trarrbfs: rarrbfs,\n\trarrc: rarrc,\n\trarr: rarr,\n\tRarr: Rarr,\n\trArr: rArr,\n\trarrfs: rarrfs,\n\trarrhk: rarrhk,\n\trarrlp: rarrlp,\n\trarrpl: rarrpl,\n\trarrsim: rarrsim,\n\tRarrtl: Rarrtl,\n\trarrtl: rarrtl,\n\trarrw: rarrw,\n\tratail: ratail,\n\trAtail: rAtail,\n\tratio: ratio,\n\trationals: rationals,\n\trbarr: rbarr,\n\trBarr: rBarr,\n\tRBarr: RBarr,\n\trbbrk: rbbrk,\n\trbrace: rbrace,\n\trbrack: rbrack,\n\trbrke: rbrke,\n\trbrksld: rbrksld,\n\trbrkslu: rbrkslu,\n\tRcaron: Rcaron,\n\trcaron: rcaron,\n\tRcedil: Rcedil,\n\trcedil: rcedil,\n\trceil: rceil,\n\trcub: rcub,\n\tRcy: Rcy,\n\trcy: rcy,\n\trdca: rdca,\n\trdldhar: rdldhar,\n\trdquo: rdquo,\n\trdquor: rdquor,\n\trdsh: rdsh,\n\treal: real,\n\trealine: realine,\n\trealpart: realpart,\n\treals: reals,\n\tRe: Re,\n\trect: rect,\n\treg: reg$1,\n\tREG: REG$1,\n\tReverseElement: ReverseElement,\n\tReverseEquilibrium: ReverseEquilibrium,\n\tReverseUpEquilibrium: ReverseUpEquilibrium,\n\trfisht: rfisht,\n\trfloor: rfloor,\n\trfr: rfr,\n\tRfr: Rfr,\n\trHar: rHar,\n\trhard: rhard,\n\trharu: rharu,\n\trharul: rharul,\n\tRho: Rho,\n\trho: rho,\n\trhov: rhov,\n\tRightAngleBracket: RightAngleBracket,\n\tRightArrowBar: RightArrowBar,\n\trightarrow: rightarrow,\n\tRightArrow: RightArrow,\n\tRightarrow: Rightarrow,\n\tRightArrowLeftArrow: RightArrowLeftArrow,\n\trightarrowtail: rightarrowtail,\n\tRightCeiling: RightCeiling,\n\tRightDoubleBracket: RightDoubleBracket,\n\tRightDownTeeVector: RightDownTeeVector,\n\tRightDownVectorBar: RightDownVectorBar,\n\tRightDownVector: RightDownVector,\n\tRightFloor: RightFloor,\n\trightharpoondown: rightharpoondown,\n\trightharpoonup: rightharpoonup,\n\trightleftarrows: rightleftarrows,\n\trightleftharpoons: rightleftharpoons,\n\trightrightarrows: rightrightarrows,\n\trightsquigarrow: rightsquigarrow,\n\tRightTeeArrow: RightTeeArrow,\n\tRightTee: RightTee,\n\tRightTeeVector: RightTeeVector,\n\trightthreetimes: rightthreetimes,\n\tRightTriangleBar: RightTriangleBar,\n\tRightTriangle: RightTriangle,\n\tRightTriangleEqual: RightTriangleEqual,\n\tRightUpDownVector: RightUpDownVector,\n\tRightUpTeeVector: RightUpTeeVector,\n\tRightUpVectorBar: RightUpVectorBar,\n\tRightUpVector: RightUpVector,\n\tRightVectorBar: RightVectorBar,\n\tRightVector: RightVector,\n\tring: ring,\n\trisingdotseq: risingdotseq,\n\trlarr: rlarr,\n\trlhar: rlhar,\n\trlm: rlm,\n\trmoustache: rmoustache,\n\trmoust: rmoust,\n\trnmid: rnmid,\n\troang: roang,\n\troarr: roarr,\n\trobrk: robrk,\n\tropar: ropar,\n\tropf: ropf,\n\tRopf: Ropf,\n\troplus: roplus,\n\trotimes: rotimes,\n\tRoundImplies: RoundImplies,\n\trpar: rpar,\n\trpargt: rpargt,\n\trppolint: rppolint,\n\trrarr: rrarr,\n\tRrightarrow: Rrightarrow,\n\trsaquo: rsaquo,\n\trscr: rscr,\n\tRscr: Rscr,\n\trsh: rsh,\n\tRsh: Rsh,\n\trsqb: rsqb,\n\trsquo: rsquo,\n\trsquor: rsquor,\n\trthree: rthree,\n\trtimes: rtimes,\n\trtri: rtri,\n\trtrie: rtrie,\n\trtrif: rtrif,\n\trtriltri: rtriltri,\n\tRuleDelayed: RuleDelayed,\n\truluhar: ruluhar,\n\trx: rx,\n\tSacute: Sacute,\n\tsacute: sacute,\n\tsbquo: sbquo,\n\tscap: scap,\n\tScaron: Scaron,\n\tscaron: scaron,\n\tSc: Sc,\n\tsc: sc,\n\tsccue: sccue,\n\tsce: sce,\n\tscE: scE,\n\tScedil: Scedil,\n\tscedil: scedil,\n\tScirc: Scirc,\n\tscirc: scirc,\n\tscnap: scnap,\n\tscnE: scnE,\n\tscnsim: scnsim,\n\tscpolint: scpolint,\n\tscsim: scsim,\n\tScy: Scy,\n\tscy: scy,\n\tsdotb: sdotb,\n\tsdot: sdot,\n\tsdote: sdote,\n\tsearhk: searhk,\n\tsearr: searr,\n\tseArr: seArr,\n\tsearrow: searrow,\n\tsect: sect$1,\n\tsemi: semi,\n\tseswar: seswar,\n\tsetminus: setminus,\n\tsetmn: setmn,\n\tsext: sext,\n\tSfr: Sfr,\n\tsfr: sfr,\n\tsfrown: sfrown,\n\tsharp: sharp,\n\tSHCHcy: SHCHcy,\n\tshchcy: shchcy,\n\tSHcy: SHcy,\n\tshcy: shcy,\n\tShortDownArrow: ShortDownArrow,\n\tShortLeftArrow: ShortLeftArrow,\n\tshortmid: shortmid,\n\tshortparallel: shortparallel,\n\tShortRightArrow: ShortRightArrow,\n\tShortUpArrow: ShortUpArrow,\n\tshy: shy$1,\n\tSigma: Sigma,\n\tsigma: sigma,\n\tsigmaf: sigmaf,\n\tsigmav: sigmav,\n\tsim: sim,\n\tsimdot: simdot,\n\tsime: sime,\n\tsimeq: simeq,\n\tsimg: simg,\n\tsimgE: simgE,\n\tsiml: siml,\n\tsimlE: simlE,\n\tsimne: simne,\n\tsimplus: simplus,\n\tsimrarr: simrarr,\n\tslarr: slarr,\n\tSmallCircle: SmallCircle,\n\tsmallsetminus: smallsetminus,\n\tsmashp: smashp,\n\tsmeparsl: smeparsl,\n\tsmid: smid,\n\tsmile: smile,\n\tsmt: smt,\n\tsmte: smte,\n\tsmtes: smtes,\n\tSOFTcy: SOFTcy,\n\tsoftcy: softcy,\n\tsolbar: solbar,\n\tsolb: solb,\n\tsol: sol,\n\tSopf: Sopf,\n\tsopf: sopf,\n\tspades: spades,\n\tspadesuit: spadesuit,\n\tspar: spar,\n\tsqcap: sqcap,\n\tsqcaps: sqcaps,\n\tsqcup: sqcup,\n\tsqcups: sqcups,\n\tSqrt: Sqrt,\n\tsqsub: sqsub,\n\tsqsube: sqsube,\n\tsqsubset: sqsubset,\n\tsqsubseteq: sqsubseteq,\n\tsqsup: sqsup,\n\tsqsupe: sqsupe,\n\tsqsupset: sqsupset,\n\tsqsupseteq: sqsupseteq,\n\tsquare: square,\n\tSquare: Square,\n\tSquareIntersection: SquareIntersection,\n\tSquareSubset: SquareSubset,\n\tSquareSubsetEqual: SquareSubsetEqual,\n\tSquareSuperset: SquareSuperset,\n\tSquareSupersetEqual: SquareSupersetEqual,\n\tSquareUnion: SquareUnion,\n\tsquarf: squarf,\n\tsqu: squ,\n\tsquf: squf,\n\tsrarr: srarr,\n\tSscr: Sscr,\n\tsscr: sscr,\n\tssetmn: ssetmn,\n\tssmile: ssmile,\n\tsstarf: sstarf,\n\tStar: Star,\n\tstar: star,\n\tstarf: starf,\n\tstraightepsilon: straightepsilon,\n\tstraightphi: straightphi,\n\tstrns: strns,\n\tsub: sub,\n\tSub: Sub,\n\tsubdot: subdot,\n\tsubE: subE,\n\tsube: sube,\n\tsubedot: subedot,\n\tsubmult: submult,\n\tsubnE: subnE,\n\tsubne: subne,\n\tsubplus: subplus,\n\tsubrarr: subrarr,\n\tsubset: subset,\n\tSubset: Subset,\n\tsubseteq: subseteq,\n\tsubseteqq: subseteqq,\n\tSubsetEqual: SubsetEqual,\n\tsubsetneq: subsetneq,\n\tsubsetneqq: subsetneqq,\n\tsubsim: subsim,\n\tsubsub: subsub,\n\tsubsup: subsup,\n\tsuccapprox: succapprox,\n\tsucc: succ,\n\tsucccurlyeq: succcurlyeq,\n\tSucceeds: Succeeds,\n\tSucceedsEqual: SucceedsEqual,\n\tSucceedsSlantEqual: SucceedsSlantEqual,\n\tSucceedsTilde: SucceedsTilde,\n\tsucceq: succeq,\n\tsuccnapprox: succnapprox,\n\tsuccneqq: succneqq,\n\tsuccnsim: succnsim,\n\tsuccsim: succsim,\n\tSuchThat: SuchThat,\n\tsum: sum,\n\tSum: Sum,\n\tsung: sung,\n\tsup1: sup1$1,\n\tsup2: sup2$1,\n\tsup3: sup3$1,\n\tsup: sup,\n\tSup: Sup,\n\tsupdot: supdot,\n\tsupdsub: supdsub,\n\tsupE: supE,\n\tsupe: supe,\n\tsupedot: supedot,\n\tSuperset: Superset,\n\tSupersetEqual: SupersetEqual,\n\tsuphsol: suphsol,\n\tsuphsub: suphsub,\n\tsuplarr: suplarr,\n\tsupmult: supmult,\n\tsupnE: supnE,\n\tsupne: supne,\n\tsupplus: supplus,\n\tsupset: supset,\n\tSupset: Supset,\n\tsupseteq: supseteq,\n\tsupseteqq: supseteqq,\n\tsupsetneq: supsetneq,\n\tsupsetneqq: supsetneqq,\n\tsupsim: supsim,\n\tsupsub: supsub,\n\tsupsup: supsup,\n\tswarhk: swarhk,\n\tswarr: swarr,\n\tswArr: swArr,\n\tswarrow: swarrow,\n\tswnwar: swnwar,\n\tszlig: szlig$1,\n\tTab: Tab,\n\ttarget: target,\n\tTau: Tau,\n\ttau: tau,\n\ttbrk: tbrk,\n\tTcaron: Tcaron,\n\ttcaron: tcaron,\n\tTcedil: Tcedil,\n\ttcedil: tcedil,\n\tTcy: Tcy,\n\ttcy: tcy,\n\ttdot: tdot,\n\ttelrec: telrec,\n\tTfr: Tfr,\n\ttfr: tfr,\n\tthere4: there4,\n\ttherefore: therefore,\n\tTherefore: Therefore,\n\tTheta: Theta,\n\ttheta: theta,\n\tthetasym: thetasym,\n\tthetav: thetav,\n\tthickapprox: thickapprox,\n\tthicksim: thicksim,\n\tThickSpace: ThickSpace,\n\tThinSpace: ThinSpace,\n\tthinsp: thinsp,\n\tthkap: thkap,\n\tthksim: thksim,\n\tTHORN: THORN$1,\n\tthorn: thorn$1,\n\ttilde: tilde,\n\tTilde: Tilde,\n\tTildeEqual: TildeEqual,\n\tTildeFullEqual: TildeFullEqual,\n\tTildeTilde: TildeTilde,\n\ttimesbar: timesbar,\n\ttimesb: timesb,\n\ttimes: times$1,\n\ttimesd: timesd,\n\ttint: tint,\n\ttoea: toea,\n\ttopbot: topbot,\n\ttopcir: topcir,\n\ttop: top,\n\tTopf: Topf,\n\ttopf: topf,\n\ttopfork: topfork,\n\ttosa: tosa,\n\ttprime: tprime,\n\ttrade: trade,\n\tTRADE: TRADE,\n\ttriangle: triangle,\n\ttriangledown: triangledown,\n\ttriangleleft: triangleleft,\n\ttrianglelefteq: trianglelefteq,\n\ttriangleq: triangleq,\n\ttriangleright: triangleright,\n\ttrianglerighteq: trianglerighteq,\n\ttridot: tridot,\n\ttrie: trie,\n\ttriminus: triminus,\n\tTripleDot: TripleDot,\n\ttriplus: triplus,\n\ttrisb: trisb,\n\ttritime: tritime,\n\ttrpezium: trpezium,\n\tTscr: Tscr,\n\ttscr: tscr,\n\tTScy: TScy,\n\ttscy: tscy,\n\tTSHcy: TSHcy,\n\ttshcy: tshcy,\n\tTstrok: Tstrok,\n\ttstrok: tstrok,\n\ttwixt: twixt,\n\ttwoheadleftarrow: twoheadleftarrow,\n\ttwoheadrightarrow: twoheadrightarrow,\n\tUacute: Uacute$1,\n\tuacute: uacute$1,\n\tuarr: uarr,\n\tUarr: Uarr,\n\tuArr: uArr,\n\tUarrocir: Uarrocir,\n\tUbrcy: Ubrcy,\n\tubrcy: ubrcy,\n\tUbreve: Ubreve,\n\tubreve: ubreve,\n\tUcirc: Ucirc$1,\n\tucirc: ucirc$1,\n\tUcy: Ucy,\n\tucy: ucy,\n\tudarr: udarr,\n\tUdblac: Udblac,\n\tudblac: udblac,\n\tudhar: udhar,\n\tufisht: ufisht,\n\tUfr: Ufr,\n\tufr: ufr,\n\tUgrave: Ugrave$1,\n\tugrave: ugrave$1,\n\tuHar: uHar,\n\tuharl: uharl,\n\tuharr: uharr,\n\tuhblk: uhblk,\n\tulcorn: ulcorn,\n\tulcorner: ulcorner,\n\tulcrop: ulcrop,\n\tultri: ultri,\n\tUmacr: Umacr,\n\tumacr: umacr,\n\tuml: uml$1,\n\tUnderBar: UnderBar,\n\tUnderBrace: UnderBrace,\n\tUnderBracket: UnderBracket,\n\tUnderParenthesis: UnderParenthesis,\n\tUnion: Union,\n\tUnionPlus: UnionPlus,\n\tUogon: Uogon,\n\tuogon: uogon,\n\tUopf: Uopf,\n\tuopf: uopf,\n\tUpArrowBar: UpArrowBar,\n\tuparrow: uparrow,\n\tUpArrow: UpArrow,\n\tUparrow: Uparrow,\n\tUpArrowDownArrow: UpArrowDownArrow,\n\tupdownarrow: updownarrow,\n\tUpDownArrow: UpDownArrow,\n\tUpdownarrow: Updownarrow,\n\tUpEquilibrium: UpEquilibrium,\n\tupharpoonleft: upharpoonleft,\n\tupharpoonright: upharpoonright,\n\tuplus: uplus,\n\tUpperLeftArrow: UpperLeftArrow,\n\tUpperRightArrow: UpperRightArrow,\n\tupsi: upsi,\n\tUpsi: Upsi,\n\tupsih: upsih,\n\tUpsilon: Upsilon,\n\tupsilon: upsilon,\n\tUpTeeArrow: UpTeeArrow,\n\tUpTee: UpTee,\n\tupuparrows: upuparrows,\n\turcorn: urcorn,\n\turcorner: urcorner,\n\turcrop: urcrop,\n\tUring: Uring,\n\turing: uring,\n\turtri: urtri,\n\tUscr: Uscr,\n\tuscr: uscr,\n\tutdot: utdot,\n\tUtilde: Utilde,\n\tutilde: utilde,\n\tutri: utri,\n\tutrif: utrif,\n\tuuarr: uuarr,\n\tUuml: Uuml$1,\n\tuuml: uuml$1,\n\tuwangle: uwangle,\n\tvangrt: vangrt,\n\tvarepsilon: varepsilon,\n\tvarkappa: varkappa,\n\tvarnothing: varnothing,\n\tvarphi: varphi,\n\tvarpi: varpi,\n\tvarpropto: varpropto,\n\tvarr: varr,\n\tvArr: vArr,\n\tvarrho: varrho,\n\tvarsigma: varsigma,\n\tvarsubsetneq: varsubsetneq,\n\tvarsubsetneqq: varsubsetneqq,\n\tvarsupsetneq: varsupsetneq,\n\tvarsupsetneqq: varsupsetneqq,\n\tvartheta: vartheta,\n\tvartriangleleft: vartriangleleft,\n\tvartriangleright: vartriangleright,\n\tvBar: vBar,\n\tVbar: Vbar,\n\tvBarv: vBarv,\n\tVcy: Vcy,\n\tvcy: vcy,\n\tvdash: vdash,\n\tvDash: vDash,\n\tVdash: Vdash,\n\tVDash: VDash,\n\tVdashl: Vdashl,\n\tveebar: veebar,\n\tvee: vee,\n\tVee: Vee,\n\tveeeq: veeeq,\n\tvellip: vellip,\n\tverbar: verbar,\n\tVerbar: Verbar,\n\tvert: vert,\n\tVert: Vert,\n\tVerticalBar: VerticalBar,\n\tVerticalLine: VerticalLine,\n\tVerticalSeparator: VerticalSeparator,\n\tVerticalTilde: VerticalTilde,\n\tVeryThinSpace: VeryThinSpace,\n\tVfr: Vfr,\n\tvfr: vfr,\n\tvltri: vltri,\n\tvnsub: vnsub,\n\tvnsup: vnsup,\n\tVopf: Vopf,\n\tvopf: vopf,\n\tvprop: vprop,\n\tvrtri: vrtri,\n\tVscr: Vscr,\n\tvscr: vscr,\n\tvsubnE: vsubnE,\n\tvsubne: vsubne,\n\tvsupnE: vsupnE,\n\tvsupne: vsupne,\n\tVvdash: Vvdash,\n\tvzigzag: vzigzag,\n\tWcirc: Wcirc,\n\twcirc: wcirc,\n\twedbar: wedbar,\n\twedge: wedge,\n\tWedge: Wedge,\n\twedgeq: wedgeq,\n\tweierp: weierp,\n\tWfr: Wfr,\n\twfr: wfr,\n\tWopf: Wopf,\n\twopf: wopf,\n\twp: wp,\n\twr: wr,\n\twreath: wreath,\n\tWscr: Wscr,\n\twscr: wscr,\n\txcap: xcap,\n\txcirc: xcirc,\n\txcup: xcup,\n\txdtri: xdtri,\n\tXfr: Xfr,\n\txfr: xfr,\n\txharr: xharr,\n\txhArr: xhArr,\n\tXi: Xi,\n\txi: xi,\n\txlarr: xlarr,\n\txlArr: xlArr,\n\txmap: xmap,\n\txnis: xnis,\n\txodot: xodot,\n\tXopf: Xopf,\n\txopf: xopf,\n\txoplus: xoplus,\n\txotime: xotime,\n\txrarr: xrarr,\n\txrArr: xrArr,\n\tXscr: Xscr,\n\txscr: xscr,\n\txsqcup: xsqcup,\n\txuplus: xuplus,\n\txutri: xutri,\n\txvee: xvee,\n\txwedge: xwedge,\n\tYacute: Yacute$1,\n\tyacute: yacute$1,\n\tYAcy: YAcy,\n\tyacy: yacy,\n\tYcirc: Ycirc,\n\tycirc: ycirc,\n\tYcy: Ycy,\n\tycy: ycy,\n\tyen: yen$1,\n\tYfr: Yfr,\n\tyfr: yfr,\n\tYIcy: YIcy,\n\tyicy: yicy,\n\tYopf: Yopf,\n\tyopf: yopf,\n\tYscr: Yscr,\n\tyscr: yscr,\n\tYUcy: YUcy,\n\tyucy: yucy,\n\tyuml: yuml$1,\n\tYuml: Yuml,\n\tZacute: Zacute,\n\tzacute: zacute,\n\tZcaron: Zcaron,\n\tzcaron: zcaron,\n\tZcy: Zcy,\n\tzcy: zcy,\n\tZdot: Zdot,\n\tzdot: zdot,\n\tzeetrf: zeetrf,\n\tZeroWidthSpace: ZeroWidthSpace,\n\tZeta: Zeta,\n\tzeta: zeta,\n\tzfr: zfr,\n\tZfr: Zfr,\n\tZHcy: ZHcy,\n\tzhcy: zhcy,\n\tzigrarr: zigrarr,\n\tzopf: zopf,\n\tZopf: Zopf,\n\tZscr: Zscr,\n\tzscr: zscr,\n\tzwj: zwj,\n\tzwnj: zwnj\n};\n\nvar Aacute = \"Á\";\nvar aacute = \"á\";\nvar Acirc = \"Â\";\nvar acirc = \"â\";\nvar acute = \"´\";\nvar AElig = \"Æ\";\nvar aelig = \"æ\";\nvar Agrave = \"À\";\nvar agrave = \"à\";\nvar amp$1 = \"&\";\nvar AMP = \"&\";\nvar Aring = \"Å\";\nvar aring = \"å\";\nvar Atilde = \"Ã\";\nvar atilde = \"ã\";\nvar Auml = \"Ä\";\nvar auml = \"ä\";\nvar brvbar = \"¦\";\nvar Ccedil = \"Ç\";\nvar ccedil = \"ç\";\nvar cedil = \"¸\";\nvar cent = \"¢\";\nvar copy = \"©\";\nvar COPY = \"©\";\nvar curren = \"¤\";\nvar deg = \"°\";\nvar divide = \"÷\";\nvar Eacute = \"É\";\nvar eacute = \"é\";\nvar Ecirc = \"Ê\";\nvar ecirc = \"ê\";\nvar Egrave = \"È\";\nvar egrave = \"è\";\nvar ETH = \"Ð\";\nvar eth = \"ð\";\nvar Euml = \"Ë\";\nvar euml = \"ë\";\nvar frac12 = \"½\";\nvar frac14 = \"¼\";\nvar frac34 = \"¾\";\nvar gt$1 = \">\";\nvar GT = \">\";\nvar Iacute = \"Í\";\nvar iacute = \"í\";\nvar Icirc = \"Î\";\nvar icirc = \"î\";\nvar iexcl = \"¡\";\nvar Igrave = \"Ì\";\nvar igrave = \"ì\";\nvar iquest = \"¿\";\nvar Iuml = \"Ï\";\nvar iuml = \"ï\";\nvar laquo = \"«\";\nvar lt$1 = \"<\";\nvar LT = \"<\";\nvar macr = \"¯\";\nvar micro = \"µ\";\nvar middot = \"·\";\nvar nbsp = \" \";\nvar not = \"¬\";\nvar Ntilde = \"Ñ\";\nvar ntilde = \"ñ\";\nvar Oacute = \"Ó\";\nvar oacute = \"ó\";\nvar Ocirc = \"Ô\";\nvar ocirc = \"ô\";\nvar Ograve = \"Ò\";\nvar ograve = \"ò\";\nvar ordf = \"ª\";\nvar ordm = \"º\";\nvar Oslash = \"Ø\";\nvar oslash = \"ø\";\nvar Otilde = \"Õ\";\nvar otilde = \"õ\";\nvar Ouml = \"Ö\";\nvar ouml = \"ö\";\nvar para = \"¶\";\nvar plusmn = \"±\";\nvar pound = \"£\";\nvar quot$1 = \"\\\"\";\nvar QUOT = \"\\\"\";\nvar raquo = \"»\";\nvar reg = \"®\";\nvar REG = \"®\";\nvar sect = \"§\";\nvar shy = \"­\";\nvar sup1 = \"¹\";\nvar sup2 = \"²\";\nvar sup3 = \"³\";\nvar szlig = \"ß\";\nvar THORN = \"Þ\";\nvar thorn = \"þ\";\nvar times = \"×\";\nvar Uacute = \"Ú\";\nvar uacute = \"ú\";\nvar Ucirc = \"Û\";\nvar ucirc = \"û\";\nvar Ugrave = \"Ù\";\nvar ugrave = \"ù\";\nvar uml = \"¨\";\nvar Uuml = \"Ü\";\nvar uuml = \"ü\";\nvar Yacute = \"Ý\";\nvar yacute = \"ý\";\nvar yen = \"¥\";\nvar yuml = \"ÿ\";\nvar require$$1 = {\n\tAacute: Aacute,\n\taacute: aacute,\n\tAcirc: Acirc,\n\tacirc: acirc,\n\tacute: acute,\n\tAElig: AElig,\n\taelig: aelig,\n\tAgrave: Agrave,\n\tagrave: agrave,\n\tamp: amp$1,\n\tAMP: AMP,\n\tAring: Aring,\n\taring: aring,\n\tAtilde: Atilde,\n\tatilde: atilde,\n\tAuml: Auml,\n\tauml: auml,\n\tbrvbar: brvbar,\n\tCcedil: Ccedil,\n\tccedil: ccedil,\n\tcedil: cedil,\n\tcent: cent,\n\tcopy: copy,\n\tCOPY: COPY,\n\tcurren: curren,\n\tdeg: deg,\n\tdivide: divide,\n\tEacute: Eacute,\n\teacute: eacute,\n\tEcirc: Ecirc,\n\tecirc: ecirc,\n\tEgrave: Egrave,\n\tegrave: egrave,\n\tETH: ETH,\n\teth: eth,\n\tEuml: Euml,\n\teuml: euml,\n\tfrac12: frac12,\n\tfrac14: frac14,\n\tfrac34: frac34,\n\tgt: gt$1,\n\tGT: GT,\n\tIacute: Iacute,\n\tiacute: iacute,\n\tIcirc: Icirc,\n\ticirc: icirc,\n\tiexcl: iexcl,\n\tIgrave: Igrave,\n\tigrave: igrave,\n\tiquest: iquest,\n\tIuml: Iuml,\n\tiuml: iuml,\n\tlaquo: laquo,\n\tlt: lt$1,\n\tLT: LT,\n\tmacr: macr,\n\tmicro: micro,\n\tmiddot: middot,\n\tnbsp: nbsp,\n\tnot: not,\n\tNtilde: Ntilde,\n\tntilde: ntilde,\n\tOacute: Oacute,\n\toacute: oacute,\n\tOcirc: Ocirc,\n\tocirc: ocirc,\n\tOgrave: Ograve,\n\tograve: ograve,\n\tordf: ordf,\n\tordm: ordm,\n\tOslash: Oslash,\n\toslash: oslash,\n\tOtilde: Otilde,\n\totilde: otilde,\n\tOuml: Ouml,\n\touml: ouml,\n\tpara: para,\n\tplusmn: plusmn,\n\tpound: pound,\n\tquot: quot$1,\n\tQUOT: QUOT,\n\traquo: raquo,\n\treg: reg,\n\tREG: REG,\n\tsect: sect,\n\tshy: shy,\n\tsup1: sup1,\n\tsup2: sup2,\n\tsup3: sup3,\n\tszlig: szlig,\n\tTHORN: THORN,\n\tthorn: thorn,\n\ttimes: times,\n\tUacute: Uacute,\n\tuacute: uacute,\n\tUcirc: Ucirc,\n\tucirc: ucirc,\n\tUgrave: Ugrave,\n\tugrave: ugrave,\n\tuml: uml,\n\tUuml: Uuml,\n\tuuml: uuml,\n\tYacute: Yacute,\n\tyacute: yacute,\n\tyen: yen,\n\tyuml: yuml\n};\n\nvar amp = \"&\";\nvar apos = \"'\";\nvar gt = \">\";\nvar lt = \"<\";\nvar quot = \"\\\"\";\nvar require$$0$1 = {\n\tamp: amp,\n\tapos: apos,\n\tgt: gt,\n\tlt: lt,\n\tquot: quot\n};\n\nvar decode_codepoint = {};\n\nvar require$$0 = {\n\t\"0\": 65533,\n\t\"128\": 8364,\n\t\"130\": 8218,\n\t\"131\": 402,\n\t\"132\": 8222,\n\t\"133\": 8230,\n\t\"134\": 8224,\n\t\"135\": 8225,\n\t\"136\": 710,\n\t\"137\": 8240,\n\t\"138\": 352,\n\t\"139\": 8249,\n\t\"140\": 338,\n\t\"142\": 381,\n\t\"145\": 8216,\n\t\"146\": 8217,\n\t\"147\": 8220,\n\t\"148\": 8221,\n\t\"149\": 8226,\n\t\"150\": 8211,\n\t\"151\": 8212,\n\t\"152\": 732,\n\t\"153\": 8482,\n\t\"154\": 353,\n\t\"155\": 8250,\n\t\"156\": 339,\n\t\"158\": 382,\n\t\"159\": 376\n};\n\nvar __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(decode_codepoint, \"__esModule\", { value: true });\nvar decode_json_1 = __importDefault$2(require$$0);\n// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119\nvar fromCodePoint$2 = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.fromCodePoint ||\n    function (codePoint) {\n        var output = \"\";\n        if (codePoint > 0xffff) {\n            codePoint -= 0x10000;\n            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);\n            codePoint = 0xdc00 | (codePoint & 0x3ff);\n        }\n        output += String.fromCharCode(codePoint);\n        return output;\n    };\nfunction decodeCodePoint(codePoint) {\n    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {\n        return \"\\uFFFD\";\n    }\n    if (codePoint in decode_json_1.default) {\n        codePoint = decode_json_1.default[codePoint];\n    }\n    return fromCodePoint$2(codePoint);\n}\ndecode_codepoint.default = decodeCodePoint;\n\nvar __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(decode, \"__esModule\", { value: true });\ndecode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;\nvar entities_json_1$1 = __importDefault$1(require$$1$1);\nvar legacy_json_1 = __importDefault$1(require$$1);\nvar xml_json_1$1 = __importDefault$1(require$$0$1);\nvar decode_codepoint_1 = __importDefault$1(decode_codepoint);\nvar strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\\da-fA-F]+|#\\d+);/g;\ndecode.decodeXML = getStrictDecoder(xml_json_1$1.default);\ndecode.decodeHTMLStrict = getStrictDecoder(entities_json_1$1.default);\nfunction getStrictDecoder(map) {\n    var replace = getReplacer(map);\n    return function (str) { return String(str).replace(strictEntityRe, replace); };\n}\nvar sorter = function (a, b) { return (a < b ? 1 : -1); };\ndecode.decodeHTML = (function () {\n    var legacy = Object.keys(legacy_json_1.default).sort(sorter);\n    var keys = Object.keys(entities_json_1$1.default).sort(sorter);\n    for (var i = 0, j = 0; i < keys.length; i++) {\n        if (legacy[j] === keys[i]) {\n            keys[i] += \";?\";\n            j++;\n        }\n        else {\n            keys[i] += \";\";\n        }\n    }\n    var re = new RegExp(\"&(?:\" + keys.join(\"|\") + \"|#[xX][\\\\da-fA-F]+;?|#\\\\d+;?)\", \"g\");\n    var replace = getReplacer(entities_json_1$1.default);\n    function replacer(str) {\n        if (str.substr(-1) !== \";\")\n            str += \";\";\n        return replace(str);\n    }\n    // TODO consider creating a merged map\n    return function (str) { return String(str).replace(re, replacer); };\n})();\nfunction getReplacer(map) {\n    return function replace(str) {\n        if (str.charAt(1) === \"#\") {\n            var secondChar = str.charAt(2);\n            if (secondChar === \"X\" || secondChar === \"x\") {\n                return decode_codepoint_1.default(parseInt(str.substr(3), 16));\n            }\n            return decode_codepoint_1.default(parseInt(str.substr(2), 10));\n        }\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        return map[str.slice(1, -1)] || str;\n    };\n}\n\nvar encode = {};\n\nvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(encode, \"__esModule\", { value: true });\nencode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;\nvar xml_json_1 = __importDefault(require$$0$1);\nvar inverseXML = getInverseObj(xml_json_1.default);\nvar xmlReplacer = getInverseReplacer(inverseXML);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeXML = getASCIIEncoder(inverseXML);\nvar entities_json_1 = __importDefault(require$$1$1);\nvar inverseHTML = getInverseObj(entities_json_1.default);\nvar htmlReplacer = getInverseReplacer(inverseHTML);\n/**\n * Encodes all entities and non-ASCII characters in the input.\n *\n * This includes characters that are valid ASCII characters in HTML documents.\n * For example `#` will be encoded as `&num;`. To get a more compact output,\n * consider using the `encodeNonAsciiHTML` function.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeHTML = getInverse(inverseHTML, htmlReplacer);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);\nfunction getInverseObj(obj) {\n    return Object.keys(obj)\n        .sort()\n        .reduce(function (inverse, name) {\n        inverse[obj[name]] = \"&\" + name + \";\";\n        return inverse;\n    }, {});\n}\nfunction getInverseReplacer(inverse) {\n    var single = [];\n    var multiple = [];\n    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {\n        var k = _a[_i];\n        if (k.length === 1) {\n            // Add value to single array\n            single.push(\"\\\\\" + k);\n        }\n        else {\n            // Add value to multiple array\n            multiple.push(k);\n        }\n    }\n    // Add ranges to single characters.\n    single.sort();\n    for (var start = 0; start < single.length - 1; start++) {\n        // Find the end of a run of characters\n        var end = start;\n        while (end < single.length - 1 &&\n            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {\n            end += 1;\n        }\n        var count = 1 + end - start;\n        // We want to replace at least three characters\n        if (count < 3)\n            continue;\n        single.splice(start, count, single[start] + \"-\" + single[end]);\n    }\n    multiple.unshift(\"[\" + single.join(\"\") + \"]\");\n    return new RegExp(multiple.join(\"|\"), \"g\");\n}\n// /[^\\0-\\x7F]/gu\nvar reNonASCII = /(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;\nvar getCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null\n    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        function (str) { return str.codePointAt(0); }\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        function (c) {\n            return (c.charCodeAt(0) - 0xd800) * 0x400 +\n                c.charCodeAt(1) -\n                0xdc00 +\n                0x10000;\n        };\nfunction singleCharReplacer(c) {\n    return \"&#x\" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))\n        .toString(16)\n        .toUpperCase() + \";\";\n}\nfunction getInverse(inverse, re) {\n    return function (data) {\n        return data\n            .replace(re, function (name) { return inverse[name]; })\n            .replace(reNonASCII, singleCharReplacer);\n    };\n}\nvar reEscapeChars = new RegExp(xmlReplacer.source + \"|\" + reNonASCII.source, \"g\");\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nfunction escape(data) {\n    return data.replace(reEscapeChars, singleCharReplacer);\n}\nencode.escape = escape;\n/**\n * Encodes all characters not valid in XML documents using numeric hexadecimal\n * reference (eg. `&#xfc;`).\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nfunction escapeUTF8(data) {\n    return data.replace(xmlReplacer, singleCharReplacer);\n}\nencode.escapeUTF8 = escapeUTF8;\nfunction getASCIIEncoder(obj) {\n    return function (data) {\n        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });\n    };\n}\n\n(function (exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;\nvar decode_1 = decode;\nvar encode_1 = encode;\n/**\n * Decodes a string with entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `decodeXML` or `decodeHTML` directly.\n */\nfunction decode$1(data, level) {\n    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);\n}\nexports.decode = decode$1;\n/**\n * Decodes a string with entities. Does not allow missing trailing semicolons for entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.\n */\nfunction decodeStrict(data, level) {\n    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);\n}\nexports.decodeStrict = decodeStrict;\n/**\n * Encodes a string with entities.\n *\n * @param data String to encode.\n * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.\n */\nfunction encode$1(data, level) {\n    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);\n}\nexports.encode = encode$1;\nvar encode_2 = encode;\nObject.defineProperty(exports, \"encodeXML\", { enumerable: true, get: function () { return encode_2.encodeXML; } });\nObject.defineProperty(exports, \"encodeHTML\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\nObject.defineProperty(exports, \"encodeNonAsciiHTML\", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });\nObject.defineProperty(exports, \"escape\", { enumerable: true, get: function () { return encode_2.escape; } });\nObject.defineProperty(exports, \"escapeUTF8\", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, \"encodeHTML4\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\nObject.defineProperty(exports, \"encodeHTML5\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\nvar decode_2 = decode;\nObject.defineProperty(exports, \"decodeXML\", { enumerable: true, get: function () { return decode_2.decodeXML; } });\nObject.defineProperty(exports, \"decodeHTML\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\nObject.defineProperty(exports, \"decodeHTMLStrict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, \"decodeHTML4\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\nObject.defineProperty(exports, \"decodeHTML5\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\nObject.defineProperty(exports, \"decodeHTML4Strict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\nObject.defineProperty(exports, \"decodeHTML5Strict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\nObject.defineProperty(exports, \"decodeXMLStrict\", { enumerable: true, get: function () { return decode_2.decodeXML; } });\n}(lib));\n\nvar ENTITY = '&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});';\nvar C_BACKSLASH$1 = 92;\nvar reBackslashOrAmp = /[\\\\&]/;\nvar ESCAPABLE = '[!\"#$%&\\'()*+,./:;<=>?@[\\\\\\\\\\\\]^_`{|}~-]';\nvar reEntityOrEscapedChar = new RegExp(\"\\\\\\\\\" + ESCAPABLE + \"|\" + ENTITY, 'gi');\nvar XMLSPECIAL = '[&<>\"]';\nvar reXmlSpecial = new RegExp(XMLSPECIAL, 'g');\nvar unescapeChar = function (s) {\n    if (s.charCodeAt(0) === C_BACKSLASH$1) {\n        return s.charAt(1);\n    }\n    return lib.decodeHTML(s);\n};\n// Replace entities and backslash escapes with literal characters.\nfunction unescapeString(s) {\n    if (reBackslashOrAmp.test(s)) {\n        return s.replace(reEntityOrEscapedChar, unescapeChar);\n    }\n    return s;\n}\nfunction normalizeURI(uri) {\n    try {\n        return encode_1(uri);\n    }\n    catch (err) {\n        return uri;\n    }\n}\nfunction replaceUnsafeChar(s) {\n    switch (s) {\n        case '&':\n            return '&amp;';\n        case '<':\n            return '&lt;';\n        case '>':\n            return '&gt;';\n        case '\"':\n            return '&quot;';\n        default:\n            return s;\n    }\n}\nfunction escapeXml(s) {\n    if (reXmlSpecial.test(s)) {\n        return s.replace(reXmlSpecial, replaceUnsafeChar);\n    }\n    return s;\n}\nfunction repeat(str, count) {\n    var arr = [];\n    for (var i = 0; i < count; i++) {\n        arr.push(str);\n    }\n    return arr.join('');\n}\nfunction isEmpty(str) {\n    if (!str) {\n        return true;\n    }\n    return !/[^ \\t]+/.test(str);\n}\n\nvar NodeWalker = /** @class */ (function () {\n    function NodeWalker(root) {\n        this.current = root;\n        this.root = root;\n        this.entering = true;\n    }\n    NodeWalker.prototype.next = function () {\n        var cur = this.current;\n        var entering = this.entering;\n        if (cur === null) {\n            return null;\n        }\n        var container = isContainer$1(cur);\n        if (entering && container) {\n            if (cur.firstChild) {\n                this.current = cur.firstChild;\n                this.entering = true;\n            }\n            else {\n                // stay on node but exit\n                this.entering = false;\n            }\n        }\n        else if (cur === this.root) {\n            this.current = null;\n        }\n        else if (cur.next === null) {\n            this.current = cur.parent;\n            this.entering = false;\n        }\n        else {\n            this.current = cur.next;\n            this.entering = true;\n        }\n        return { entering: entering, node: cur };\n    };\n    NodeWalker.prototype.resumeAt = function (node, entering) {\n        this.current = node;\n        this.entering = entering === true;\n    };\n    return NodeWalker;\n}());\n\nfunction isContainer$1(node) {\n    switch (node.type) {\n        case 'document':\n        case 'blockQuote':\n        case 'list':\n        case 'item':\n        case 'paragraph':\n        case 'heading':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'table':\n        case 'tableHead':\n        case 'tableBody':\n        case 'tableRow':\n        case 'tableCell':\n        case 'tableDelimRow':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nvar lastNodeId = 1;\nvar nodeMap = {};\nfunction getNodeById(id) {\n    return nodeMap[id];\n}\nfunction removeNodeById(id) {\n    delete nodeMap[id];\n}\nfunction removeAllNode() {\n    nodeMap = {};\n}\nvar Node$1 = /** @class */ (function () {\n    function Node(nodeType, sourcepos) {\n        this.parent = null;\n        this.prev = null;\n        this.next = null;\n        // only for container node\n        this.firstChild = null;\n        this.lastChild = null;\n        // only for leaf node\n        this.literal = null;\n        if (nodeType === 'document') {\n            this.id = -1;\n        }\n        else {\n            this.id = lastNodeId++;\n        }\n        this.type = nodeType;\n        this.sourcepos = sourcepos;\n        nodeMap[this.id] = this;\n    }\n    Node.prototype.isContainer = function () {\n        return isContainer$1(this);\n    };\n    Node.prototype.unlink = function () {\n        if (this.prev) {\n            this.prev.next = this.next;\n        }\n        else if (this.parent) {\n            this.parent.firstChild = this.next;\n        }\n        if (this.next) {\n            this.next.prev = this.prev;\n        }\n        else if (this.parent) {\n            this.parent.lastChild = this.prev;\n        }\n        this.parent = null;\n        this.next = null;\n        this.prev = null;\n    };\n    Node.prototype.replaceWith = function (node) {\n        this.insertBefore(node);\n        this.unlink();\n    };\n    Node.prototype.insertAfter = function (sibling) {\n        sibling.unlink();\n        sibling.next = this.next;\n        if (sibling.next) {\n            sibling.next.prev = sibling;\n        }\n        sibling.prev = this;\n        this.next = sibling;\n        if (this.parent) {\n            sibling.parent = this.parent;\n            if (!sibling.next) {\n                sibling.parent.lastChild = sibling;\n            }\n        }\n    };\n    Node.prototype.insertBefore = function (sibling) {\n        sibling.unlink();\n        sibling.prev = this.prev;\n        if (sibling.prev) {\n            sibling.prev.next = sibling;\n        }\n        sibling.next = this;\n        this.prev = sibling;\n        sibling.parent = this.parent;\n        if (!sibling.prev) {\n            sibling.parent.firstChild = sibling;\n        }\n    };\n    Node.prototype.appendChild = function (child) {\n        child.unlink();\n        child.parent = this;\n        if (this.lastChild) {\n            this.lastChild.next = child;\n            child.prev = this.lastChild;\n            this.lastChild = child;\n        }\n        else {\n            this.firstChild = child;\n            this.lastChild = child;\n        }\n    };\n    Node.prototype.prependChild = function (child) {\n        child.unlink();\n        child.parent = this;\n        if (this.firstChild) {\n            this.firstChild.prev = child;\n            child.next = this.firstChild;\n            this.firstChild = child;\n        }\n        else {\n            this.firstChild = child;\n            this.lastChild = child;\n        }\n    };\n    Node.prototype.walker = function () {\n        return new NodeWalker(this);\n    };\n    return Node;\n}());\nvar BlockNode = /** @class */ (function (_super) {\n    __extends(BlockNode, _super);\n    function BlockNode(nodeType, sourcepos) {\n        var _this = _super.call(this, nodeType, sourcepos) || this;\n        // temporal data (for parsing)\n        _this.open = true;\n        _this.lineOffsets = null;\n        _this.stringContent = null;\n        _this.lastLineBlank = false;\n        _this.lastLineChecked = false;\n        _this.type = nodeType;\n        return _this;\n    }\n    return BlockNode;\n}(Node$1));\nvar ListNode = /** @class */ (function (_super) {\n    __extends(ListNode, _super);\n    function ListNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.listData = null;\n        return _this;\n    }\n    return ListNode;\n}(BlockNode));\nvar HeadingNode = /** @class */ (function (_super) {\n    __extends(HeadingNode, _super);\n    function HeadingNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.level = 0;\n        _this.headingType = 'atx';\n        return _this;\n    }\n    return HeadingNode;\n}(BlockNode));\nvar CodeBlockNode = /** @class */ (function (_super) {\n    __extends(CodeBlockNode, _super);\n    function CodeBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isFenced = false;\n        _this.fenceChar = null;\n        _this.fenceLength = 0;\n        _this.fenceOffset = -1;\n        _this.info = null;\n        _this.infoPadding = 0;\n        return _this;\n    }\n    return CodeBlockNode;\n}(BlockNode));\nvar TableNode = /** @class */ (function (_super) {\n    __extends(TableNode, _super);\n    function TableNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.columns = [];\n        return _this;\n    }\n    return TableNode;\n}(BlockNode));\nvar TableCellNode = /** @class */ (function (_super) {\n    __extends(TableCellNode, _super);\n    function TableCellNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.startIdx = 0;\n        _this.endIdx = 0;\n        _this.paddingLeft = 0;\n        _this.paddingRight = 0;\n        _this.ignored = false;\n        return _this;\n    }\n    return TableCellNode;\n}(BlockNode));\nvar RefDefNode = /** @class */ (function (_super) {\n    __extends(RefDefNode, _super);\n    function RefDefNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.title = '';\n        _this.dest = '';\n        _this.label = '';\n        return _this;\n    }\n    return RefDefNode;\n}(BlockNode));\nvar CustomBlockNode = /** @class */ (function (_super) {\n    __extends(CustomBlockNode, _super);\n    function CustomBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.syntaxLength = 0;\n        _this.offset = -1;\n        _this.info = '';\n        return _this;\n    }\n    return CustomBlockNode;\n}(BlockNode));\nvar HtmlBlockNode = /** @class */ (function (_super) {\n    __extends(HtmlBlockNode, _super);\n    function HtmlBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.htmlBlockType = -1;\n        return _this;\n    }\n    return HtmlBlockNode;\n}(BlockNode));\nvar LinkNode = /** @class */ (function (_super) {\n    __extends(LinkNode, _super);\n    function LinkNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.destination = null;\n        _this.title = null;\n        _this.extendedAutolink = false;\n        return _this;\n    }\n    return LinkNode;\n}(Node$1));\nvar CodeNode = /** @class */ (function (_super) {\n    __extends(CodeNode, _super);\n    function CodeNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.tickCount = 0;\n        return _this;\n    }\n    return CodeNode;\n}(Node$1));\nvar CustomInlineNode = /** @class */ (function (_super) {\n    __extends(CustomInlineNode, _super);\n    function CustomInlineNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.info = '';\n        return _this;\n    }\n    return CustomInlineNode;\n}(Node$1));\nfunction createNode$1(type, sourcepos) {\n    switch (type) {\n        case 'heading':\n            return new HeadingNode(type, sourcepos);\n        case 'list':\n        case 'item':\n            return new ListNode(type, sourcepos);\n        case 'link':\n        case 'image':\n            return new LinkNode(type, sourcepos);\n        case 'codeBlock':\n            return new CodeBlockNode(type, sourcepos);\n        case 'htmlBlock':\n            return new HtmlBlockNode(type, sourcepos);\n        case 'table':\n            return new TableNode(type, sourcepos);\n        case 'tableCell':\n            return new TableCellNode(type, sourcepos);\n        case 'document':\n        case 'paragraph':\n        case 'blockQuote':\n        case 'thematicBreak':\n        case 'tableRow':\n        case 'tableBody':\n        case 'tableHead':\n        case 'frontMatter':\n            return new BlockNode(type, sourcepos);\n        case 'code':\n            return new CodeNode(type, sourcepos);\n        case 'refDef':\n            return new RefDefNode(type, sourcepos);\n        case 'customBlock':\n            return new CustomBlockNode(type, sourcepos);\n        case 'customInline':\n            return new CustomInlineNode(type, sourcepos);\n        default:\n            return new Node$1(type, sourcepos);\n    }\n}\nfunction isCodeBlock(node) {\n    return node.type === 'codeBlock';\n}\nfunction isHtmlBlock(node) {\n    return node.type === 'htmlBlock';\n}\nfunction isHeading(node) {\n    return node.type === 'heading';\n}\nfunction isList(node) {\n    return node.type === 'list';\n}\nfunction isTable(node) {\n    return node.type === 'table';\n}\nfunction isRefDef(node) {\n    return node.type === 'refDef';\n}\nfunction isCustomBlock(node) {\n    return node.type === 'customBlock';\n}\nfunction isCustomInline(node) {\n    return node.type === 'customInline';\n}\nfunction text$1(s, sourcepos) {\n    var node = createNode$1('text', sourcepos);\n    node.literal = s;\n    return node;\n}\n\nvar TAGNAME = '[A-Za-z][A-Za-z0-9-]*';\nvar ATTRIBUTENAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\nvar UNQUOTEDVALUE = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar SINGLEQUOTEDVALUE = \"'[^']*'\";\nvar DOUBLEQUOTEDVALUE = '\"[^\"]*\"';\nvar ATTRIBUTEVALUE = \"(?:\" + UNQUOTEDVALUE + \"|\" + SINGLEQUOTEDVALUE + \"|\" + DOUBLEQUOTEDVALUE + \")\";\nvar ATTRIBUTEVALUESPEC = \"\" + '(?:\\\\s*=\\\\s*' + ATTRIBUTEVALUE + \")\";\nvar ATTRIBUTE = \"\" + '(?:\\\\s+' + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + \"?)\";\nvar OPENTAG = \"<\" + TAGNAME + ATTRIBUTE + \"*\\\\s*/?>\";\nvar CLOSETAG = \"</\" + TAGNAME + \"\\\\s*[>]\";\nvar HTMLCOMMENT = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';\nvar PROCESSINGINSTRUCTION = '[<][?].*?[?][>]';\nvar DECLARATION = '<![A-Z]+\\\\s+[^>]*>';\nvar CDATA = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>';\nvar HTMLTAG = \"(?:\" + OPENTAG + \"|\" + CLOSETAG + \"|\" + HTMLCOMMENT + \"|\" + PROCESSINGINSTRUCTION + \"|\" + DECLARATION + \"|\" + CDATA + \")\";\nvar reHtmlTag = new RegExp(\"^\" + HTMLTAG, 'i');\n\n// derived from https://github.com/mathiasbynens/String.fromCodePoint\n/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */\nvar fromCodePoint;\nif (String.fromCodePoint) {\n    fromCodePoint = function (_) {\n        try {\n            return String.fromCodePoint(_);\n        }\n        catch (e) {\n            if (e instanceof RangeError) {\n                return String.fromCharCode(0xfffd);\n            }\n            throw e;\n        }\n    };\n}\nelse {\n    var stringFromCharCode_1 = String.fromCharCode;\n    var floor_1 = Math.floor;\n    fromCodePoint = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = args.length;\n        if (!length) {\n            return '';\n        }\n        var result = '';\n        while (++index < length) {\n            var codePoint = Number(args[index]);\n            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                codePoint < 0 || // not a valid Unicode code point\n                codePoint > 0x10ffff || // not a valid Unicode code point\n                floor_1(codePoint) !== codePoint // not an integer\n            ) {\n                return String.fromCharCode(0xfffd);\n            }\n            if (codePoint <= 0xffff) {\n                // BMP code point\n                codeUnits.push(codePoint);\n            }\n            else {\n                // Astral code point; split in surrogate halves\n                // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                codePoint -= 0x10000;\n                highSurrogate = (codePoint >> 10) + 0xd800;\n                lowSurrogate = (codePoint % 0x400) + 0xdc00;\n                codeUnits.push(highSurrogate, lowSurrogate);\n            }\n            if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                result += stringFromCharCode_1.apply(void 0, codeUnits);\n                codeUnits.length = 0;\n            }\n        }\n        return result;\n    };\n}\nvar fromCodePoint$1 = fromCodePoint;\n\nvar DOMAIN = '(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+';\nvar PATH = '[^<\\\\s]*[^<?!.,:*_?~\\\\s]';\nvar EMAIL = '[\\\\w.+-]+@(?:[\\\\w-]+\\\\.)+[\\\\w-]+';\nfunction trimUnmatchedTrailingParens(source) {\n    var trailingParen = /\\)+$/.exec(source);\n    if (trailingParen) {\n        var count = 0;\n        for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {\n            var ch = source_1[_i];\n            if (ch === '(') {\n                if (count < 0) {\n                    count = 1;\n                }\n                else {\n                    count += 1;\n                }\n            }\n            else if (ch === ')') {\n                count -= 1;\n            }\n        }\n        if (count < 0) {\n            var trimCount = Math.min(-count, trailingParen[0].length);\n            return source.substring(0, source.length - trimCount);\n        }\n    }\n    return source;\n}\nfunction trimTrailingEntity(source) {\n    return source.replace(/&[A-Za-z0-9]+;$/, '');\n}\nfunction parseEmailLink(source) {\n    var reEmailLink = new RegExp(EMAIL, 'g');\n    var result = [];\n    var m;\n    while ((m = reEmailLink.exec(source))) {\n        var text_1 = m[0];\n        if (!/[_-]+$/.test(text_1)) {\n            result.push({\n                text: text_1,\n                range: [m.index, m.index + text_1.length - 1],\n                url: \"mailto:\" + text_1,\n            });\n        }\n    }\n    return result;\n}\nfunction parseUrlLink(source) {\n    var reWwwAutolink = new RegExp(\"(www|https?://).\" + DOMAIN + PATH, 'g');\n    var result = [];\n    var m;\n    while ((m = reWwwAutolink.exec(source))) {\n        var text_2 = trimTrailingEntity(trimUnmatchedTrailingParens(m[0]));\n        var scheme = m[1] === 'www' ? 'http://' : '';\n        result.push({\n            text: text_2,\n            range: [m.index, m.index + text_2.length - 1],\n            url: \"\" + scheme + text_2,\n        });\n    }\n    return result;\n}\nfunction baseAutolinkParser(source) {\n    return __spreadArray(__spreadArray([], parseUrlLink(source)), parseEmailLink(source)).sort(function (a, b) { return a.range[0] - b.range[0]; });\n}\nfunction convertExtAutoLinks(walker, autolinkParser) {\n    if (typeof autolinkParser === 'boolean') {\n        autolinkParser = baseAutolinkParser;\n    }\n    var event;\n    var _loop_1 = function () {\n        var entering = event.entering, node = event.node;\n        if (entering && node.type === 'text' && node.parent.type !== 'link') {\n            var literal = node.literal;\n            var linkInfos = autolinkParser(literal);\n            if (!linkInfos || !linkInfos.length) {\n                return \"continue\";\n            }\n            var lastIdx = 0;\n            var _a = node.sourcepos[0], lineNum_1 = _a[0], chPos_1 = _a[1];\n            var sourcepos = function (startIdx, endIdx) { return [\n                [lineNum_1, chPos_1 + startIdx],\n                [lineNum_1, chPos_1 + endIdx],\n            ]; };\n            var newNodes = [];\n            for (var _i = 0, linkInfos_1 = linkInfos; _i < linkInfos_1.length; _i++) {\n                var _b = linkInfos_1[_i], range = _b.range, url = _b.url, linkText = _b.text;\n                if (range[0] > lastIdx) {\n                    newNodes.push(text$1(literal.substring(lastIdx, range[0]), sourcepos(lastIdx, range[0] - 1)));\n                }\n                var linkNode = createNode$1('link', sourcepos.apply(void 0, range));\n                linkNode.appendChild(text$1(linkText, sourcepos.apply(void 0, range)));\n                linkNode.destination = url;\n                linkNode.extendedAutolink = true;\n                newNodes.push(linkNode);\n                lastIdx = range[1] + 1;\n            }\n            if (lastIdx < literal.length) {\n                newNodes.push(text$1(literal.substring(lastIdx), sourcepos(lastIdx, literal.length - 1)));\n            }\n            for (var _c = 0, newNodes_1 = newNodes; _c < newNodes_1.length; _c++) {\n                var newNode = newNodes_1[_c];\n                node.insertBefore(newNode);\n            }\n            node.unlink();\n        }\n    };\n    while ((event = walker.next())) {\n        _loop_1();\n    }\n}\n\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n// normalize a reference in reference link (remove []s, trim,\n// collapse internal space, unicode case fold.\n// See commonmark/commonmark.js#168.\nfunction normalizeReference(str) {\n    return str\n        .slice(1, str.length - 1)\n        .trim()\n        .replace(/[ \\t\\r\\n]+/, ' ')\n        .toLowerCase()\n        .toUpperCase();\n}\nfunction iterateObject(obj, iteratee) {\n    Object.keys(obj).forEach(function (key) {\n        iteratee(key, obj[key]);\n    });\n}\nfunction omit(obj) {\n    var propNames = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        propNames[_i - 1] = arguments[_i];\n    }\n    var resultMap = __assign({}, obj);\n    propNames.forEach(function (key) {\n        delete resultMap[key];\n    });\n    return resultMap;\n}\nfunction isEmptyObj(obj) {\n    return !Object.keys(obj).length;\n}\nfunction clearObj(obj) {\n    Object.keys(obj).forEach(function (key) {\n        delete obj[key];\n    });\n}\n\nvar C_NEWLINE = 10;\nvar C_ASTERISK = 42;\nvar C_UNDERSCORE = 95;\nvar C_BACKTICK = 96;\nvar C_OPEN_BRACKET$1 = 91;\nvar C_CLOSE_BRACKET = 93;\nvar C_TILDE = 126;\nvar C_LESSTHAN$1 = 60;\nvar C_BANG = 33;\nvar C_BACKSLASH = 92;\nvar C_AMPERSAND = 38;\nvar C_OPEN_PAREN = 40;\nvar C_CLOSE_PAREN = 41;\nvar C_COLON = 58;\nvar C_SINGLEQUOTE = 39;\nvar C_DOUBLEQUOTE = 34;\nvar C_DOLLAR = 36;\n// Some regexps used in inline parser:\nvar ESCAPED_CHAR = \"\\\\\\\\\" + ESCAPABLE;\nvar rePunctuation = new RegExp(/[!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E42\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC9\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDF3C-\\uDF3E]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]/);\nvar reLinkTitle = new RegExp(\"^(?:\\\"(\" + ESCAPED_CHAR + \"|[^\\\"\\\\x00])*\\\"\" +\n    \"|\" +\n    (\"'(\" + ESCAPED_CHAR + \"|[^'\\\\x00])*'\") +\n    \"|\" +\n    (\"\\\\((\" + ESCAPED_CHAR + \"|[^()\\\\x00])*\\\\))\"));\nvar reLinkDestinationBraces = /^(?:<(?:[^<>\\n\\\\\\x00]|\\\\.)*>)/;\nvar reEscapable = new RegExp(\"^\" + ESCAPABLE);\nvar reEntityHere = new RegExp(\"^\" + ENTITY, 'i');\nvar reTicks = /`+/;\nvar reTicksHere = /^`+/;\nvar reEllipses = /\\.\\.\\./g;\nvar reDash = /--+/g;\nvar reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\\x00-\\x20]*>/i;\nvar reSpnl = /^ *(?:\\n *)?/;\nvar reWhitespaceChar = /^[ \\t\\n\\x0b\\x0c\\x0d]/;\nvar reUnicodeWhitespaceChar = /^\\s/;\nvar reFinalSpace = / *$/;\nvar reInitialSpace = /^ */;\nvar reSpaceAtEndOfLine = /^ *(?:\\n|$)/;\nvar reLinkLabel = /^\\[(?:[^\\\\\\[\\]]|\\\\.){0,1000}\\]/;\n// Matches a string of non-special characters.\nvar reMain = /^[^\\n`\\[\\]\\\\!<&*_'\"~$]+/m;\nvar InlineParser = /** @class */ (function () {\n    function InlineParser(options) {\n        // An InlineParser keeps track of a subject (a string to be parsed)\n        // and a position in that subject.\n        this.subject = '';\n        this.delimiters = null; // used by handleDelim method\n        this.brackets = null;\n        this.pos = 0;\n        this.lineStartNum = 0;\n        this.lineIdx = 0;\n        this.lineOffsets = [0];\n        this.linePosOffset = 0;\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.options = options;\n    }\n    InlineParser.prototype.sourcepos = function (start, end) {\n        var linePosOffset = this.linePosOffset + this.lineOffsets[this.lineIdx];\n        var lineNum = this.lineStartNum + this.lineIdx;\n        var startpos = [lineNum, start + linePosOffset];\n        if (typeof end === 'number') {\n            return [startpos, [lineNum, end + linePosOffset]];\n        }\n        return startpos;\n    };\n    InlineParser.prototype.nextLine = function () {\n        this.lineIdx += 1;\n        this.linePosOffset = -this.pos;\n    };\n    // If re matches at current position in the subject, advance\n    // position in subject and return the match; otherwise return null.\n    InlineParser.prototype.match = function (re) {\n        var m = re.exec(this.subject.slice(this.pos));\n        if (m === null) {\n            return null;\n        }\n        this.pos += m.index + m[0].length;\n        return m[0];\n    };\n    // Returns the code for the character at the current subject position, or -1\n    // there are no more characters.\n    InlineParser.prototype.peek = function () {\n        if (this.pos < this.subject.length) {\n            return this.subject.charCodeAt(this.pos);\n        }\n        return -1;\n    };\n    // Parse zero or more space characters, including at most one newline\n    InlineParser.prototype.spnl = function () {\n        this.match(reSpnl);\n        return true;\n    };\n    // All of the parsers below try to match something at the current position\n    // in the subject.  If they succeed in matching anything, they\n    // return the inline matched, advancing the subject.\n    // Attempt to parse backticks, adding either a backtick code span or a\n    // literal sequence of backticks.\n    InlineParser.prototype.parseBackticks = function (block) {\n        var startpos = this.pos + 1;\n        var ticks = this.match(reTicksHere);\n        if (ticks === null) {\n            return false;\n        }\n        var afterOpenTicks = this.pos;\n        var matched;\n        while ((matched = this.match(reTicks)) !== null) {\n            if (matched === ticks) {\n                var contents = this.subject.slice(afterOpenTicks, this.pos - ticks.length);\n                var sourcepos = this.sourcepos(startpos, this.pos);\n                var lines = contents.split('\\n');\n                if (lines.length > 1) {\n                    var lastLine = last(lines);\n                    this.lineIdx += lines.length - 1;\n                    this.linePosOffset = -(this.pos - lastLine.length - ticks.length);\n                    sourcepos[1] = this.sourcepos(this.pos);\n                    contents = lines.join(' ');\n                }\n                var node = createNode$1('code', sourcepos);\n                if (contents.length > 0 &&\n                    contents.match(/[^ ]/) !== null &&\n                    contents[0] == ' ' &&\n                    contents[contents.length - 1] == ' ') {\n                    node.literal = contents.slice(1, contents.length - 1);\n                }\n                else {\n                    node.literal = contents;\n                }\n                node.tickCount = ticks.length;\n                block.appendChild(node);\n                return true;\n            }\n        }\n        // If we got here, we didn't match a closing backtick sequence.\n        this.pos = afterOpenTicks;\n        block.appendChild(text$1(ticks, this.sourcepos(startpos, this.pos - 1)));\n        return true;\n    };\n    // Parse a backslash-escaped special character, adding either the escaped\n    // character, a hard line break (if the backslash is followed by a newline),\n    // or a literal backslash to the block's children.  Assumes current character\n    // is a backslash.\n    InlineParser.prototype.parseBackslash = function (block) {\n        var subj = this.subject;\n        var node;\n        this.pos += 1;\n        var startpos = this.pos;\n        if (this.peek() === C_NEWLINE) {\n            this.pos += 1;\n            node = createNode$1('linebreak', this.sourcepos(this.pos - 1, this.pos));\n            block.appendChild(node);\n            this.nextLine();\n        }\n        else if (reEscapable.test(subj.charAt(this.pos))) {\n            block.appendChild(text$1(subj.charAt(this.pos), this.sourcepos(startpos, this.pos)));\n            this.pos += 1;\n        }\n        else {\n            block.appendChild(text$1('\\\\', this.sourcepos(startpos, startpos)));\n        }\n        return true;\n    };\n    // Attempt to parse an autolink (URL or email in pointy brackets).\n    InlineParser.prototype.parseAutolink = function (block) {\n        var m;\n        var dest;\n        var node;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reEmailAutolink))) {\n            dest = m.slice(1, m.length - 1);\n            node = createNode$1('link', this.sourcepos(startpos, this.pos));\n            node.destination = normalizeURI(\"mailto:\" + dest);\n            node.title = '';\n            node.appendChild(text$1(dest, this.sourcepos(startpos + 1, this.pos - 1)));\n            block.appendChild(node);\n            return true;\n        }\n        if ((m = this.match(reAutolink))) {\n            dest = m.slice(1, m.length - 1);\n            node = createNode$1('link', this.sourcepos(startpos, this.pos));\n            node.destination = normalizeURI(dest);\n            node.title = '';\n            node.appendChild(text$1(dest, this.sourcepos(startpos + 1, this.pos - 1)));\n            block.appendChild(node);\n            return true;\n        }\n        return false;\n    };\n    // Attempt to parse a raw HTML tag.\n    InlineParser.prototype.parseHtmlTag = function (block) {\n        var startpos = this.pos + 1;\n        var m = this.match(reHtmlTag);\n        if (m === null) {\n            return false;\n        }\n        var node = createNode$1('htmlInline', this.sourcepos(startpos, this.pos));\n        node.literal = m;\n        block.appendChild(node);\n        return true;\n    };\n    // Scan a sequence of characters with code cc, and return information about\n    // the number of delimiters and whether they are positioned such that\n    // they can open and/or close emphasis or strong emphasis.  A utility\n    // function for strong/emph parsing.\n    InlineParser.prototype.scanDelims = function (cc) {\n        var numdelims = 0;\n        var startpos = this.pos;\n        if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {\n            numdelims++;\n            this.pos++;\n        }\n        else {\n            while (this.peek() === cc) {\n                numdelims++;\n                this.pos++;\n            }\n        }\n        if (numdelims === 0 || (numdelims < 2 && (cc === C_TILDE || cc === C_DOLLAR))) {\n            this.pos = startpos;\n            return null;\n        }\n        var charBefore = startpos === 0 ? '\\n' : this.subject.charAt(startpos - 1);\n        var ccAfter = this.peek();\n        var charAfter;\n        if (ccAfter === -1) {\n            charAfter = '\\n';\n        }\n        else {\n            charAfter = fromCodePoint$1(ccAfter);\n        }\n        var afterIsWhitespace = reUnicodeWhitespaceChar.test(charAfter);\n        var afterIsPunctuation = rePunctuation.test(charAfter);\n        var beforeIsWhitespace = reUnicodeWhitespaceChar.test(charBefore);\n        var beforeIsPunctuation = rePunctuation.test(charBefore);\n        var leftFlanking = !afterIsWhitespace && (!afterIsPunctuation || beforeIsWhitespace || beforeIsPunctuation);\n        var rightFlanking = !beforeIsWhitespace && (!beforeIsPunctuation || afterIsWhitespace || afterIsPunctuation);\n        var canOpen;\n        var canClose;\n        if (cc === C_UNDERSCORE) {\n            canOpen = leftFlanking && (!rightFlanking || beforeIsPunctuation);\n            canClose = rightFlanking && (!leftFlanking || afterIsPunctuation);\n        }\n        else if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {\n            canOpen = leftFlanking && !rightFlanking;\n            canClose = rightFlanking;\n        }\n        else if (cc === C_DOLLAR) {\n            canOpen = !afterIsWhitespace;\n            canClose = !beforeIsWhitespace;\n        }\n        else {\n            canOpen = leftFlanking;\n            canClose = rightFlanking;\n        }\n        this.pos = startpos;\n        return { numdelims: numdelims, canOpen: canOpen, canClose: canClose };\n    };\n    // Handle a delimiter marker for emphasis or a quote.\n    InlineParser.prototype.handleDelim = function (cc, block) {\n        var res = this.scanDelims(cc);\n        if (!res) {\n            return false;\n        }\n        var numdelims = res.numdelims;\n        var startpos = this.pos + 1;\n        var contents;\n        this.pos += numdelims;\n        if (cc === C_SINGLEQUOTE) {\n            contents = '\\u2019';\n        }\n        else if (cc === C_DOUBLEQUOTE) {\n            contents = '\\u201C';\n        }\n        else {\n            contents = this.subject.slice(startpos - 1, this.pos);\n        }\n        var node = text$1(contents, this.sourcepos(startpos, this.pos));\n        block.appendChild(node);\n        // Add entry to stack for this opener\n        if ((res.canOpen || res.canClose) &&\n            (this.options.smart || (cc !== C_SINGLEQUOTE && cc !== C_DOUBLEQUOTE))) {\n            this.delimiters = {\n                cc: cc,\n                numdelims: numdelims,\n                origdelims: numdelims,\n                node: node,\n                previous: this.delimiters,\n                next: null,\n                canOpen: res.canOpen,\n                canClose: res.canClose,\n            };\n            if (this.delimiters.previous) {\n                this.delimiters.previous.next = this.delimiters;\n            }\n        }\n        return true;\n    };\n    InlineParser.prototype.removeDelimiter = function (delim) {\n        if (delim.previous !== null) {\n            delim.previous.next = delim.next;\n        }\n        if (delim.next === null) {\n            // top of stack\n            this.delimiters = delim.previous;\n        }\n        else {\n            delim.next.previous = delim.previous;\n        }\n    };\n    InlineParser.prototype.removeDelimitersBetween = function (bottom, top) {\n        if (bottom.next !== top) {\n            bottom.next = top;\n            top.previous = bottom;\n        }\n    };\n    /**\n     * Process all delimiters - emphasis, strong emphasis, strikethrough(gfm)\n     * If the smart punctuation options is true,\n     * convert single/double quotes to corresponding unicode characters.\n     **/\n    InlineParser.prototype.processEmphasis = function (stackBottom) {\n        var _a;\n        var opener;\n        var closer;\n        var oldCloser;\n        var openerInl, closerInl;\n        var openerFound;\n        var oddMatch = false;\n        var openersBottom = (_a = {},\n            _a[C_UNDERSCORE] = [stackBottom, stackBottom, stackBottom],\n            _a[C_ASTERISK] = [stackBottom, stackBottom, stackBottom],\n            _a[C_SINGLEQUOTE] = [stackBottom],\n            _a[C_DOUBLEQUOTE] = [stackBottom],\n            _a[C_TILDE] = [stackBottom],\n            _a[C_DOLLAR] = [stackBottom],\n            _a);\n        // find first closer above stackBottom:\n        closer = this.delimiters;\n        while (closer !== null && closer.previous !== stackBottom) {\n            closer = closer.previous;\n        }\n        // move forward, looking for closers, and handling each\n        while (closer !== null) {\n            var closercc = closer.cc;\n            var closerEmph = closercc === C_UNDERSCORE || closercc === C_ASTERISK;\n            if (!closer.canClose) {\n                closer = closer.next;\n            }\n            else {\n                // found emphasis closer. now look back for first matching opener:\n                opener = closer.previous;\n                openerFound = false;\n                while (opener !== null &&\n                    opener !== stackBottom &&\n                    opener !== openersBottom[closercc][closerEmph ? closer.origdelims % 3 : 0]) {\n                    oddMatch =\n                        closerEmph &&\n                            (closer.canOpen || opener.canClose) &&\n                            closer.origdelims % 3 !== 0 &&\n                            (opener.origdelims + closer.origdelims) % 3 === 0;\n                    if (opener.cc === closer.cc && opener.canOpen && !oddMatch) {\n                        openerFound = true;\n                        break;\n                    }\n                    opener = opener.previous;\n                }\n                oldCloser = closer;\n                if (closerEmph || closercc === C_TILDE || closercc === C_DOLLAR) {\n                    if (!openerFound) {\n                        closer = closer.next;\n                    }\n                    else if (opener) {\n                        // (null opener check for type narrowing)\n                        // calculate actual number of delimiters used from closer\n                        var useDelims = closer.numdelims >= 2 && opener.numdelims >= 2 ? 2 : 1;\n                        var emptyDelims = closerEmph ? 0 : 1;\n                        openerInl = opener.node;\n                        closerInl = closer.node;\n                        // build contents for new emph element\n                        var nodeType = closerEmph\n                            ? useDelims === 1\n                                ? 'emph'\n                                : 'strong'\n                            : 'strike';\n                        if (closercc === C_DOLLAR) {\n                            nodeType = 'customInline';\n                        }\n                        var newNode = createNode$1(nodeType);\n                        var openerEndPos = openerInl.sourcepos[1];\n                        var closerStartPos = closerInl.sourcepos[0];\n                        newNode.sourcepos = [\n                            [openerEndPos[0], openerEndPos[1] - useDelims + 1],\n                            [closerStartPos[0], closerStartPos[1] + useDelims - 1],\n                        ];\n                        openerInl.sourcepos[1][1] -= useDelims;\n                        closerInl.sourcepos[0][1] += useDelims;\n                        openerInl.literal = openerInl.literal.slice(useDelims);\n                        closerInl.literal = closerInl.literal.slice(useDelims);\n                        opener.numdelims -= useDelims;\n                        closer.numdelims -= useDelims;\n                        // remove used delimiters from stack elts and inlines\n                        var tmp = openerInl.next;\n                        var next = void 0;\n                        while (tmp && tmp !== closerInl) {\n                            next = tmp.next;\n                            tmp.unlink();\n                            newNode.appendChild(tmp);\n                            tmp = next;\n                        }\n                        // build custom inline node\n                        if (closercc === C_DOLLAR) {\n                            var textNode = newNode.firstChild;\n                            var literal = textNode.literal || '';\n                            var info = literal.split(/\\s/)[0];\n                            newNode.info = info;\n                            if (literal.length <= info.length) {\n                                textNode.unlink();\n                            }\n                            else {\n                                textNode.sourcepos[0][1] += info.length;\n                                textNode.literal = literal.replace(info + \" \", '');\n                            }\n                        }\n                        openerInl.insertAfter(newNode);\n                        // remove elts between opener and closer in delimiters stack\n                        this.removeDelimitersBetween(opener, closer);\n                        // if opener has 0 delims, remove it and the inline\n                        // if opener has 1 delims and character is tilde, remove delimiter only\n                        if (opener.numdelims <= emptyDelims) {\n                            if (opener.numdelims === 0) {\n                                openerInl.unlink();\n                            }\n                            this.removeDelimiter(opener);\n                        }\n                        // if closer has 0 delims, remove it and the inline\n                        // if closer has 1 delims and character is tilde, remove delimiter only\n                        if (closer.numdelims <= emptyDelims) {\n                            if (closer.numdelims === 0) {\n                                closerInl.unlink();\n                            }\n                            var tempstack = closer.next;\n                            this.removeDelimiter(closer);\n                            closer = tempstack;\n                        }\n                    }\n                }\n                else if (closercc === C_SINGLEQUOTE) {\n                    closer.node.literal = '\\u2019';\n                    if (openerFound) {\n                        opener.node.literal = '\\u2018';\n                    }\n                    closer = closer.next;\n                }\n                else if (closercc === C_DOUBLEQUOTE) {\n                    closer.node.literal = '\\u201D';\n                    if (openerFound) {\n                        opener.node.literal = '\\u201C';\n                    }\n                    closer = closer.next;\n                }\n                if (!openerFound) {\n                    // Set lower bound for future searches for openers:\n                    openersBottom[closercc][closerEmph ? oldCloser.origdelims % 3 : 0] = oldCloser.previous;\n                    if (!oldCloser.canOpen) {\n                        // We can remove a closer that can't be an opener,\n                        // once we've seen there's no matching opener:\n                        this.removeDelimiter(oldCloser);\n                    }\n                }\n            }\n        }\n        // remove all delimiters\n        while (this.delimiters !== null && this.delimiters !== stackBottom) {\n            this.removeDelimiter(this.delimiters);\n        }\n    };\n    // Attempt to parse link title (sans quotes), returning the string\n    // or null if no match.\n    InlineParser.prototype.parseLinkTitle = function () {\n        var title = this.match(reLinkTitle);\n        if (title === null) {\n            return null;\n        }\n        // chop off quotes from title and unescape:\n        return unescapeString(title.substr(1, title.length - 2));\n    };\n    // Attempt to parse link destination, returning the string or null if no match.\n    InlineParser.prototype.parseLinkDestination = function () {\n        var res = this.match(reLinkDestinationBraces);\n        if (res === null) {\n            if (this.peek() === C_LESSTHAN$1) {\n                return null;\n            }\n            // @TODO handrolled parser; res should be null or the string\n            var savepos = this.pos;\n            var openparens = 0;\n            var c = void 0;\n            while ((c = this.peek()) !== -1) {\n                if (c === C_BACKSLASH && reEscapable.test(this.subject.charAt(this.pos + 1))) {\n                    this.pos += 1;\n                    if (this.peek() !== -1) {\n                        this.pos += 1;\n                    }\n                }\n                else if (c === C_OPEN_PAREN) {\n                    this.pos += 1;\n                    openparens += 1;\n                }\n                else if (c === C_CLOSE_PAREN) {\n                    if (openparens < 1) {\n                        break;\n                    }\n                    else {\n                        this.pos += 1;\n                        openparens -= 1;\n                    }\n                }\n                else if (reWhitespaceChar.exec(fromCodePoint$1(c)) !== null) {\n                    break;\n                }\n                else {\n                    this.pos += 1;\n                }\n            }\n            if (this.pos === savepos && c !== C_CLOSE_PAREN) {\n                return null;\n            }\n            if (openparens !== 0) {\n                return null;\n            }\n            res = this.subject.substr(savepos, this.pos - savepos);\n            return normalizeURI(unescapeString(res));\n        } // chop off surrounding <..>:\n        return normalizeURI(unescapeString(res.substr(1, res.length - 2)));\n    };\n    // Attempt to parse a link label, returning number of characters parsed.\n    InlineParser.prototype.parseLinkLabel = function () {\n        var m = this.match(reLinkLabel);\n        if (m === null || m.length > 1001) {\n            return 0;\n        }\n        return m.length;\n    };\n    // Add open bracket to delimiter stack and add a text node to block's children.\n    InlineParser.prototype.parseOpenBracket = function (block) {\n        var startpos = this.pos;\n        this.pos += 1;\n        var node = text$1('[', this.sourcepos(this.pos, this.pos));\n        block.appendChild(node);\n        // Add entry to stack for this opener\n        this.addBracket(node, startpos, false);\n        return true;\n    };\n    // IF next character is [, and ! delimiter to delimiter stack and\n    // add a text node to block's children.  Otherwise just add a text node.\n    InlineParser.prototype.parseBang = function (block) {\n        var startpos = this.pos;\n        this.pos += 1;\n        if (this.peek() === C_OPEN_BRACKET$1) {\n            this.pos += 1;\n            var node = text$1('![', this.sourcepos(this.pos - 1, this.pos));\n            block.appendChild(node);\n            // Add entry to stack for this opener\n            this.addBracket(node, startpos + 1, true);\n        }\n        else {\n            var node = text$1('!', this.sourcepos(this.pos, this.pos));\n            block.appendChild(node);\n        }\n        return true;\n    };\n    // Try to match close bracket against an opening in the delimiter\n    // stack.  Add either a link or image, or a plain [ character,\n    // to block's children.  If there is a matching delimiter,\n    // remove it from the delimiter stack.\n    InlineParser.prototype.parseCloseBracket = function (block) {\n        var dest = null;\n        var title = null;\n        var matched = false;\n        this.pos += 1;\n        var startpos = this.pos;\n        // get last [ or ![\n        var opener = this.brackets;\n        if (opener === null) {\n            // no matched opener, just return a literal\n            block.appendChild(text$1(']', this.sourcepos(startpos, startpos)));\n            return true;\n        }\n        if (!opener.active) {\n            // no matched opener, just return a literal\n            block.appendChild(text$1(']', this.sourcepos(startpos, startpos)));\n            // take opener off brackets stack\n            this.removeBracket();\n            return true;\n        }\n        // If we got here, open is a potential opener\n        var isImage = opener.image;\n        // Check to see if we have a link/image\n        var savepos = this.pos;\n        // Inline link?\n        if (this.peek() === C_OPEN_PAREN) {\n            this.pos++;\n            if (this.spnl() &&\n                (dest = this.parseLinkDestination()) !== null &&\n                this.spnl() &&\n                // make sure there's a space before the title:\n                ((reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) &&\n                    (title = this.parseLinkTitle())) ||\n                    true) &&\n                this.spnl() &&\n                this.peek() === C_CLOSE_PAREN) {\n                this.pos += 1;\n                matched = true;\n            }\n            else {\n                this.pos = savepos;\n            }\n        }\n        var refLabel = '';\n        if (!matched) {\n            // Next, see if there's a link label\n            var beforelabel = this.pos;\n            var n = this.parseLinkLabel();\n            if (n > 2) {\n                refLabel = this.subject.slice(beforelabel, beforelabel + n);\n            }\n            else if (!opener.bracketAfter) {\n                // Empty or missing second label means to use the first label as the reference.\n                // The reference must not contain a bracket. If we know there's a bracket, we don't even bother checking it.\n                refLabel = this.subject.slice(opener.index, startpos);\n            }\n            if (n === 0) {\n                // If shortcut reference link, rewind before spaces we skipped.\n                this.pos = savepos;\n            }\n            if (refLabel) {\n                refLabel = normalizeReference(refLabel);\n                // lookup rawlabel in refMap\n                var link = this.refMap[refLabel];\n                if (link) {\n                    dest = link.destination;\n                    title = link.title;\n                    matched = true;\n                }\n            }\n        }\n        if (matched) {\n            var node = createNode$1(isImage ? 'image' : 'link');\n            node.destination = dest;\n            node.title = title || '';\n            node.sourcepos = [opener.startpos, this.sourcepos(this.pos)];\n            var tmp = opener.node.next;\n            var next = void 0;\n            while (tmp) {\n                next = tmp.next;\n                tmp.unlink();\n                node.appendChild(tmp);\n                tmp = next;\n            }\n            block.appendChild(node);\n            this.processEmphasis(opener.previousDelimiter);\n            this.removeBracket();\n            opener.node.unlink();\n            // We remove this bracket and processEmphasis will remove later delimiters.\n            // Now, for a link, we also deactivate earlier link openers.\n            // (no links in links)\n            if (!isImage) {\n                opener = this.brackets;\n                while (opener !== null) {\n                    if (!opener.image) {\n                        opener.active = false; // deactivate this opener\n                    }\n                    opener = opener.previous;\n                }\n            }\n            if (this.options.referenceDefinition) {\n                this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };\n            }\n            return true;\n        } // no match\n        this.removeBracket(); // remove this opener from stack\n        this.pos = startpos;\n        block.appendChild(text$1(']', this.sourcepos(startpos, startpos)));\n        if (this.options.referenceDefinition) {\n            this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };\n        }\n        return true;\n    };\n    InlineParser.prototype.addBracket = function (node, index, image) {\n        if (this.brackets !== null) {\n            this.brackets.bracketAfter = true;\n        }\n        this.brackets = {\n            node: node,\n            startpos: this.sourcepos(index + (image ? 0 : 1)),\n            previous: this.brackets,\n            previousDelimiter: this.delimiters,\n            index: index,\n            image: image,\n            active: true,\n        };\n    };\n    InlineParser.prototype.removeBracket = function () {\n        if (this.brackets) {\n            this.brackets = this.brackets.previous;\n        }\n    };\n    // Attempt to parse an entity.\n    InlineParser.prototype.parseEntity = function (block) {\n        var m;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reEntityHere))) {\n            block.appendChild(text$1(lib.decodeHTML(m), this.sourcepos(startpos, this.pos)));\n            return true;\n        }\n        return false;\n    };\n    // Parse a run of ordinary characters, or a single character with\n    // a special meaning in markdown, as a plain string.\n    InlineParser.prototype.parseString = function (block) {\n        var m;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reMain))) {\n            if (this.options.smart) {\n                var lit = m.replace(reEllipses, '\\u2026').replace(reDash, function (chars) {\n                    var enCount = 0;\n                    var emCount = 0;\n                    if (chars.length % 3 === 0) {\n                        // If divisible by 3, use all em dashes\n                        emCount = chars.length / 3;\n                    }\n                    else if (chars.length % 2 === 0) {\n                        // If divisible by 2, use all en dashes\n                        enCount = chars.length / 2;\n                    }\n                    else if (chars.length % 3 === 2) {\n                        // If 2 extra dashes, use en dash for last 2; em dashes for rest\n                        enCount = 1;\n                        emCount = (chars.length - 2) / 3;\n                    }\n                    else {\n                        // Use en dashes for last 4 hyphens; em dashes for rest\n                        enCount = 2;\n                        emCount = (chars.length - 4) / 3;\n                    }\n                    return repeat('\\u2014', emCount) + repeat('\\u2013', enCount);\n                });\n                block.appendChild(text$1(lit, this.sourcepos(startpos, this.pos)));\n            }\n            else {\n                var node = text$1(m, this.sourcepos(startpos, this.pos));\n                block.appendChild(node);\n            }\n            return true;\n        }\n        return false;\n    };\n    // Parse a newline.  If it was preceded by two spaces, return a hard\n    // line break; otherwise a soft line break.\n    InlineParser.prototype.parseNewline = function (block) {\n        this.pos += 1; // assume we're at a \\n\n        // check previous node for trailing spaces\n        var lastc = block.lastChild;\n        if (lastc && lastc.type === 'text' && lastc.literal[lastc.literal.length - 1] === ' ') {\n            var hardbreak = lastc.literal[lastc.literal.length - 2] === ' ';\n            var litLen = lastc.literal.length;\n            lastc.literal = lastc.literal.replace(reFinalSpace, '');\n            var finalSpaceLen = litLen - lastc.literal.length;\n            lastc.sourcepos[1][1] -= finalSpaceLen;\n            block.appendChild(createNode$1(hardbreak ? 'linebreak' : 'softbreak', this.sourcepos(this.pos - finalSpaceLen, this.pos)));\n        }\n        else {\n            block.appendChild(createNode$1('softbreak', this.sourcepos(this.pos, this.pos)));\n        }\n        this.nextLine();\n        this.match(reInitialSpace); // gobble leading spaces in next line\n        return true;\n    };\n    // Attempt to parse a link reference, modifying refmap.\n    InlineParser.prototype.parseReference = function (block, refMap) {\n        if (!this.options.referenceDefinition) {\n            return 0;\n        }\n        this.subject = block.stringContent;\n        this.pos = 0;\n        var title = null;\n        var startpos = this.pos;\n        // label:\n        var matchChars = this.parseLinkLabel();\n        if (matchChars === 0) {\n            return 0;\n        }\n        var rawlabel = this.subject.substr(0, matchChars);\n        // colon:\n        if (this.peek() === C_COLON) {\n            this.pos++;\n        }\n        else {\n            this.pos = startpos;\n            return 0;\n        }\n        //  link url\n        this.spnl();\n        var dest = this.parseLinkDestination();\n        if (dest === null) {\n            this.pos = startpos;\n            return 0;\n        }\n        var beforetitle = this.pos;\n        this.spnl();\n        if (this.pos !== beforetitle) {\n            title = this.parseLinkTitle();\n        }\n        if (title === null) {\n            title = '';\n            // rewind before spaces\n            this.pos = beforetitle;\n        }\n        // make sure we're at line end:\n        var atLineEnd = true;\n        if (this.match(reSpaceAtEndOfLine) === null) {\n            if (title === '') {\n                atLineEnd = false;\n            }\n            else {\n                // the potential title we found is not at the line end,\n                // but it could still be a legal link reference if we\n                // discard the title\n                title = '';\n                // rewind before spaces\n                this.pos = beforetitle;\n                // and instead check if the link URL is at the line end\n                atLineEnd = this.match(reSpaceAtEndOfLine) !== null;\n            }\n        }\n        if (!atLineEnd) {\n            this.pos = startpos;\n            return 0;\n        }\n        var normalLabel = normalizeReference(rawlabel);\n        if (normalLabel === '') {\n            // label must contain non-whitespace characters\n            this.pos = startpos;\n            return 0;\n        }\n        var sourcepos = this.getReferenceDefSourcepos(block);\n        block.sourcepos[0][0] = sourcepos[1][0] + 1;\n        var node = createNode$1('refDef', sourcepos);\n        node.title = title;\n        node.dest = dest;\n        node.label = normalLabel;\n        block.insertBefore(node);\n        if (!refMap[normalLabel]) {\n            refMap[normalLabel] = createRefDefState(node);\n        }\n        else {\n            this.refDefCandidateMap[node.id] = node;\n        }\n        return this.pos - startpos;\n    };\n    InlineParser.prototype.mergeTextNodes = function (walker) {\n        var event;\n        var textNodes = [];\n        while ((event = walker.next())) {\n            var entering = event.entering, node = event.node;\n            if (entering && node.type === 'text') {\n                textNodes.push(node);\n            }\n            else if (textNodes.length === 1) {\n                textNodes = [];\n            }\n            else if (textNodes.length > 1) {\n                var firstNode = textNodes[0];\n                var lastNode = textNodes[textNodes.length - 1];\n                if (firstNode.sourcepos && lastNode.sourcepos) {\n                    firstNode.sourcepos[1] = lastNode.sourcepos[1];\n                }\n                firstNode.next = lastNode.next;\n                if (firstNode.next) {\n                    firstNode.next.prev = firstNode;\n                }\n                for (var i = 1; i < textNodes.length; i += 1) {\n                    firstNode.literal += textNodes[i].literal;\n                    textNodes[i].unlink();\n                }\n                textNodes = [];\n            }\n        }\n    };\n    InlineParser.prototype.getReferenceDefSourcepos = function (block) {\n        var lines = block.stringContent.split(/\\n|\\r\\n/);\n        var passedUrlLine = false;\n        var quotationCount = 0;\n        var lastLineOffset = { line: 0, ch: 0 };\n        for (var i = 0; i < lines.length; i += 1) {\n            var line = lines[i];\n            if (reWhitespaceChar.test(line)) {\n                break;\n            }\n            if (/\\:/.test(line) && quotationCount === 0) {\n                if (passedUrlLine) {\n                    break;\n                }\n                var lineOffset = line.indexOf(':') === line.length - 1 ? i + 1 : i;\n                lastLineOffset = { line: lineOffset, ch: lines[lineOffset].length };\n                passedUrlLine = true;\n            }\n            // should consider extendable title\n            var matched = line.match(/'|\"/g);\n            if (matched) {\n                quotationCount += matched.length;\n            }\n            if (quotationCount === 2) {\n                lastLineOffset = { line: i, ch: line.length };\n                break;\n            }\n        }\n        return [\n            [block.sourcepos[0][0], block.sourcepos[0][1]],\n            [block.sourcepos[0][0] + lastLineOffset.line, lastLineOffset.ch],\n        ];\n    };\n    // Parse the next inline element in subject, advancing subject position.\n    // On success, add the result to block's children and return true.\n    // On failure, return false.\n    InlineParser.prototype.parseInline = function (block) {\n        var _a;\n        var res = false;\n        var c = this.peek();\n        if (c === -1) {\n            return false;\n        }\n        switch (c) {\n            case C_NEWLINE:\n                res = this.parseNewline(block);\n                break;\n            case C_BACKSLASH:\n                res = this.parseBackslash(block);\n                break;\n            case C_BACKTICK:\n                res = this.parseBackticks(block);\n                break;\n            case C_ASTERISK:\n            case C_UNDERSCORE:\n            case C_TILDE:\n            case C_DOLLAR:\n                res = this.handleDelim(c, block);\n                break;\n            case C_SINGLEQUOTE:\n            case C_DOUBLEQUOTE:\n                res = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.smart) && this.handleDelim(c, block);\n                break;\n            case C_OPEN_BRACKET$1:\n                res = this.parseOpenBracket(block);\n                break;\n            case C_BANG:\n                res = this.parseBang(block);\n                break;\n            case C_CLOSE_BRACKET:\n                res = this.parseCloseBracket(block);\n                break;\n            case C_LESSTHAN$1:\n                res = this.parseAutolink(block) || this.parseHtmlTag(block);\n                break;\n            case C_AMPERSAND:\n                if (!block.disabledEntityParse) {\n                    res = this.parseEntity(block);\n                }\n                break;\n            default:\n                res = this.parseString(block);\n                break;\n        }\n        if (!res) {\n            this.pos += 1;\n            block.appendChild(text$1(fromCodePoint$1(c), this.sourcepos(this.pos, this.pos + 1)));\n        }\n        return true;\n    };\n    // Parse string content in block into inline children,\n    // using refmap to resolve references.\n    InlineParser.prototype.parse = function (block) {\n        this.subject = block.stringContent.trim();\n        this.pos = 0;\n        this.delimiters = null;\n        this.brackets = null;\n        this.lineOffsets = block.lineOffsets || [0];\n        this.lineIdx = 0;\n        this.linePosOffset = 0;\n        this.lineStartNum = block.sourcepos[0][0];\n        if (isHeading(block)) {\n            this.lineOffsets[0] += block.level + 1;\n        }\n        while (this.parseInline(block)) { }\n        block.stringContent = null; // allow raw string to be garbage collected\n        this.processEmphasis(null);\n        this.mergeTextNodes(block.walker());\n        var _a = this.options, extendedAutolinks = _a.extendedAutolinks, customParser = _a.customParser;\n        if (extendedAutolinks) {\n            convertExtAutoLinks(block.walker(), extendedAutolinks);\n        }\n        if (customParser && block.firstChild) {\n            var event_1;\n            var walker = block.firstChild.walker();\n            while ((event_1 = walker.next())) {\n                var node = event_1.node, entering = event_1.entering;\n                if (customParser[node.type]) {\n                    customParser[node.type](node, { entering: entering, options: this.options });\n                }\n            }\n        }\n    };\n    return InlineParser;\n}());\n\nvar reTaskListItemMarker = /^\\[([ \\txX])\\][ \\t]+/;\n// finalize for block handler\nfunction taskListItemFinalize(_, block) {\n    if (block.firstChild && block.firstChild.type === 'paragraph') {\n        var p = block.firstChild;\n        var m = p.stringContent.match(reTaskListItemMarker);\n        if (m) {\n            var mLen = m[0].length;\n            p.stringContent = p.stringContent.substring(mLen - 1);\n            p.sourcepos[0][1] += mLen;\n            p.lineOffsets[0] += mLen;\n            block.listData.task = true;\n            block.listData.checked = /[xX]/.test(m[1]);\n        }\n    }\n}\n\nvar table = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableHead' || t === 'tableBody';\n    },\n    acceptsLines: false,\n};\nvar tableBody$1 = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableRow';\n    },\n    acceptsLines: false,\n};\nvar tableHead$1 = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableRow' || t === 'tableDelimRow';\n    },\n    acceptsLines: false,\n};\nvar tableDelimRow = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableDelimCell';\n    },\n    acceptsLines: false,\n};\nvar tableDelimCell = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar tableRow = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableCell';\n    },\n    acceptsLines: false,\n};\nvar tableCell = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\n\nvar CODE_INDENT = 4;\nvar C_TAB = 9;\nvar C_GREATERTHAN = 62;\nvar C_LESSTHAN = 60;\nvar C_SPACE = 32;\nvar C_OPEN_BRACKET = 91;\nvar reNonSpace = /[^ \\t\\f\\v\\r\\n]/;\nvar reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;\n// Returns true if block ends with a blank line, descending if needed\n// into lists and sublists.\nfunction endsWithBlankLine(block) {\n    var curBlock = block;\n    while (curBlock) {\n        if (curBlock.lastLineBlank) {\n            return true;\n        }\n        var t = curBlock.type;\n        if (!curBlock.lastLineChecked && (t === 'list' || t === 'item')) {\n            curBlock.lastLineChecked = true;\n            curBlock = curBlock.lastChild;\n        }\n        else {\n            curBlock.lastLineChecked = true;\n            break;\n        }\n    }\n    return false;\n}\nfunction peek(ln, pos) {\n    if (pos < ln.length) {\n        return ln.charCodeAt(pos);\n    }\n    return -1;\n}\n// Returns true if string contains only space characters.\nfunction isBlank(s) {\n    return !reNonSpace.test(s);\n}\nfunction isSpaceOrTab(c) {\n    return c === C_SPACE || c === C_TAB;\n}\n\nvar reClosingCustomBlock = /^\\$\\$$/;\nvar customBlock$1 = {\n    continue: function (parser, container) {\n        var line = parser.currentLine;\n        var match = line.match(reClosingCustomBlock);\n        if (match) {\n            // closing custom block\n            parser.lastLineLength = match[0].length;\n            parser.finalize(container, parser.lineNumber);\n            return 2 /* Finished */;\n        }\n        // skip optional spaces of custom block offset\n        var i = container.offset;\n        while (i > 0 && isSpaceOrTab(peek(line, parser.offset))) {\n            parser.advanceOffset(1, true);\n            i--;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        // first line becomes info string\n        var content = block.stringContent;\n        var newlinePos = content.indexOf('\\n');\n        var firstLine = content.slice(0, newlinePos);\n        var rest = content.slice(newlinePos + 1);\n        var infoString = firstLine.match(/^(\\s*)(.*)/);\n        block.info = unescapeString(infoString[2].trim());\n        block.literal = rest;\n        block.stringContent = null;\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\n\nvar noop = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar document$1 = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar list = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var item = block.firstChild;\n        while (item) {\n            // check for non-final list item ending with blank line:\n            if (endsWithBlankLine(item) && item.next) {\n                block.listData.tight = false;\n                break;\n            }\n            // recurse into children of list item, to see if there are\n            // spaces between any of them:\n            var subitem = item.firstChild;\n            while (subitem) {\n                if (endsWithBlankLine(subitem) && (item.next || subitem.next)) {\n                    block.listData.tight = false;\n                    break;\n                }\n                subitem = subitem.next;\n            }\n            item = item.next;\n        }\n    },\n    canContain: function (t) {\n        return t === 'item';\n    },\n    acceptsLines: false,\n};\nvar blockQuote$1 = {\n    continue: function (parser) {\n        var ln = parser.currentLine;\n        if (!parser.indented && peek(ln, parser.nextNonspace) === C_GREATERTHAN) {\n            parser.advanceNextNonspace();\n            parser.advanceOffset(1, false);\n            if (isSpaceOrTab(peek(ln, parser.offset))) {\n                parser.advanceOffset(1, true);\n            }\n        }\n        else {\n            return 1 /* Stop */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar item = {\n    continue: function (parser, container) {\n        if (parser.blank) {\n            if (container.firstChild === null) {\n                // Blank line after empty list item\n                return 1 /* Stop */;\n            }\n            parser.advanceNextNonspace();\n        }\n        else if (parser.indent >= container.listData.markerOffset + container.listData.padding) {\n            parser.advanceOffset(container.listData.markerOffset + container.listData.padding, true);\n        }\n        else {\n            return 1 /* Stop */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: taskListItemFinalize,\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar heading = {\n    continue: function () {\n        // a heading can never container > 1 line, so fail to match:\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar thematicBreak$1 = {\n    continue: function () {\n        // a thematic break can never container > 1 line, so fail to match:\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar codeBlock = {\n    continue: function (parser, container) {\n        var ln = parser.currentLine;\n        var indent = parser.indent;\n        if (container.isFenced) {\n            // fenced\n            var match = indent <= 3 &&\n                ln.charAt(parser.nextNonspace) === container.fenceChar &&\n                ln.slice(parser.nextNonspace).match(reClosingCodeFence);\n            if (match && match[0].length >= container.fenceLength) {\n                // closing fence - we're at end of line, so we can return\n                parser.lastLineLength = parser.offset + indent + match[0].length;\n                parser.finalize(container, parser.lineNumber);\n                return 2 /* Finished */;\n            }\n            // skip optional spaces of fence offset\n            var i = container.fenceOffset;\n            while (i > 0 && isSpaceOrTab(peek(ln, parser.offset))) {\n                parser.advanceOffset(1, true);\n                i--;\n            }\n        }\n        else {\n            // indented\n            if (indent >= CODE_INDENT) {\n                parser.advanceOffset(CODE_INDENT, true);\n            }\n            else if (parser.blank) {\n                parser.advanceNextNonspace();\n            }\n            else {\n                return 1 /* Stop */;\n            }\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var _a;\n        if (block.stringContent === null) {\n            return;\n        }\n        if (block.isFenced) {\n            // fenced\n            // first line becomes info string\n            var content = block.stringContent;\n            var newlinePos = content.indexOf('\\n');\n            var firstLine = content.slice(0, newlinePos);\n            var rest = content.slice(newlinePos + 1);\n            var infoString = firstLine.match(/^(\\s*)(.*)/);\n            block.infoPadding = infoString[1].length;\n            block.info = unescapeString(infoString[2].trim());\n            block.literal = rest;\n        }\n        else {\n            // indented\n            block.literal = (_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\\n *)+$/, '\\n');\n        }\n        block.stringContent = null; // allow GC\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar htmlBlock$1 = {\n    continue: function (parser, container) {\n        return parser.blank && (container.htmlBlockType === 6 || container.htmlBlockType === 7)\n            ? 1 /* Stop */\n            : 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var _a;\n        block.literal = ((_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\\n *)+$/, '')) || null;\n        block.stringContent = null; // allow GC\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar paragraph = {\n    continue: function (parser) {\n        return parser.blank ? 1 /* Stop */ : 0 /* Go */;\n    },\n    finalize: function (parser, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        var pos;\n        var hasReferenceDefs = false;\n        // try parsing the beginning as link reference definitions:\n        while (peek(block.stringContent, 0) === C_OPEN_BRACKET &&\n            (pos = parser.inlineParser.parseReference(block, parser.refMap))) {\n            block.stringContent = block.stringContent.slice(pos);\n            hasReferenceDefs = true;\n        }\n        if (hasReferenceDefs && isBlank(block.stringContent)) {\n            block.unlink();\n        }\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar refDef = noop;\nvar frontMatter$2 = noop;\nvar blockHandlers = {\n    document: document$1,\n    list: list,\n    blockQuote: blockQuote$1,\n    item: item,\n    heading: heading,\n    thematicBreak: thematicBreak$1,\n    codeBlock: codeBlock,\n    htmlBlock: htmlBlock$1,\n    paragraph: paragraph,\n    table: table,\n    tableBody: tableBody$1,\n    tableHead: tableHead$1,\n    tableRow: tableRow,\n    tableCell: tableCell,\n    tableDelimRow: tableDelimRow,\n    tableDelimCell: tableDelimCell,\n    refDef: refDef,\n    customBlock: customBlock$1,\n    frontMatter: frontMatter$2,\n};\n\nfunction parseRowContent(content) {\n    var startIdx = 0;\n    var offset = 0;\n    var cells = [];\n    for (var i = 0; i < content.length; i += 1) {\n        if (content[i] === '|' && content[i - 1] !== '\\\\') {\n            var cell = content.substring(startIdx, i);\n            if (startIdx === 0 && isEmpty(cell)) {\n                offset = i + 1;\n            }\n            else {\n                cells.push(cell);\n            }\n            startIdx = i + 1;\n        }\n    }\n    if (startIdx < content.length) {\n        var cell = content.substring(startIdx, content.length);\n        if (!isEmpty(cell)) {\n            cells.push(cell);\n        }\n    }\n    return [offset, cells];\n}\nfunction generateTableCells(cellType, contents, lineNum, chPos) {\n    var cells = [];\n    for (var _i = 0, contents_1 = contents; _i < contents_1.length; _i++) {\n        var content = contents_1[_i];\n        var preSpaces = content.match(/^[ \\t]+/);\n        var paddingLeft = preSpaces ? preSpaces[0].length : 0;\n        var paddingRight = void 0, trimmed = void 0;\n        if (paddingLeft === content.length) {\n            paddingLeft = 0;\n            paddingRight = 0;\n            trimmed = '';\n        }\n        else {\n            var postSpaces = content.match(/[ \\t]+$/);\n            paddingRight = postSpaces ? postSpaces[0].length : 0;\n            trimmed = content.slice(paddingLeft, content.length - paddingRight);\n        }\n        var chPosStart = chPos + paddingLeft;\n        var tableCell = createNode$1(cellType, [\n            [lineNum, chPos],\n            [lineNum, chPos + content.length - 1],\n        ]);\n        tableCell.stringContent = trimmed.replace(/\\\\\\|/g, '|'); // replace esacped pipe(\\|)\n        tableCell.startIdx = cells.length;\n        tableCell.endIdx = cells.length;\n        tableCell.lineOffsets = [chPosStart - 1];\n        tableCell.paddingLeft = paddingLeft;\n        tableCell.paddingRight = paddingRight;\n        cells.push(tableCell);\n        chPos += content.length + 1;\n    }\n    return cells;\n}\nfunction getColumnFromDelimCell(cellNode) {\n    var align = null;\n    var content = cellNode.stringContent;\n    var firstCh = content[0];\n    var lastCh = content[content.length - 1];\n    if (lastCh === ':') {\n        align = firstCh === ':' ? 'center' : 'right';\n    }\n    else if (firstCh === ':') {\n        align = 'left';\n    }\n    return { align: align };\n}\nvar tableHead = function (parser, container) {\n    var stringContent = container.stringContent;\n    if (container.type === 'paragraph' && !parser.indented && !parser.blank) {\n        var lastNewLineIdx = stringContent.length - 1;\n        var lastLineStartIdx = stringContent.lastIndexOf('\\n', lastNewLineIdx - 1) + 1;\n        var headerContent = stringContent.slice(lastLineStartIdx, lastNewLineIdx);\n        var delimContent = parser.currentLine.slice(parser.nextNonspace);\n        var _a = parseRowContent(headerContent), headerOffset = _a[0], headerCells = _a[1];\n        var _b = parseRowContent(delimContent), delimOffset = _b[0], delimCells = _b[1];\n        var reValidDelimCell_1 = /^[ \\t]*:?-+:?[ \\t]*$/;\n        if (\n        // not checking if the number of header cells and delimiter cells are the same\n        // to consider the case of merged-column (via plugin)\n        !headerCells.length ||\n            !delimCells.length ||\n            delimCells.some(function (cell) { return !reValidDelimCell_1.test(cell); }) ||\n            // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option\n            (delimCells.length === 1 && delimContent.indexOf('|') !== 0)) {\n            return 0 /* None */;\n        }\n        var lineOffsets = container.lineOffsets;\n        var firstLineNum = parser.lineNumber - 1;\n        var firstLineStart = last(lineOffsets) + 1;\n        var table = createNode$1('table', [\n            [firstLineNum, firstLineStart],\n            [parser.lineNumber, parser.offset],\n        ]);\n        // eslint-disable-next-line arrow-body-style\n        table.columns = delimCells.map(function () { return ({ align: null }); });\n        container.insertAfter(table);\n        if (lineOffsets.length === 1) {\n            container.unlink();\n        }\n        else {\n            container.stringContent = stringContent.slice(0, lastLineStartIdx);\n            var paraLastLineStartIdx = stringContent.lastIndexOf('\\n', lastLineStartIdx - 2) + 1;\n            var paraLastLineLen = lastLineStartIdx - paraLastLineStartIdx - 1;\n            parser.lastLineLength = lineOffsets[lineOffsets.length - 2] + paraLastLineLen;\n            parser.finalize(container, firstLineNum - 1);\n        }\n        parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n        var tableHead_1 = createNode$1('tableHead', [\n            [firstLineNum, firstLineStart],\n            [parser.lineNumber, parser.offset],\n        ]);\n        table.appendChild(tableHead_1);\n        var tableHeadRow_1 = createNode$1('tableRow', [\n            [firstLineNum, firstLineStart],\n            [firstLineNum, firstLineStart + headerContent.length - 1],\n        ]);\n        var tableDelimRow_1 = createNode$1('tableDelimRow', [\n            [parser.lineNumber, parser.nextNonspace + 1],\n            [parser.lineNumber, parser.offset],\n        ]);\n        tableHead_1.appendChild(tableHeadRow_1);\n        tableHead_1.appendChild(tableDelimRow_1);\n        generateTableCells('tableCell', headerCells, firstLineNum, firstLineStart + headerOffset).forEach(function (cellNode) {\n            tableHeadRow_1.appendChild(cellNode);\n        });\n        var delimCellNodes = generateTableCells('tableDelimCell', delimCells, parser.lineNumber, parser.nextNonspace + 1 + delimOffset);\n        delimCellNodes.forEach(function (cellNode) {\n            tableDelimRow_1.appendChild(cellNode);\n        });\n        table.columns = delimCellNodes.map(getColumnFromDelimCell);\n        parser.tip = table;\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar tableBody = function (parser, container) {\n    if ((container.type !== 'table' && container.type !== 'tableBody') ||\n        (!parser.blank && parser.currentLine.indexOf('|') === -1)) {\n        return 0 /* None */;\n    }\n    parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n    if (parser.blank) {\n        var table_1 = container;\n        if (container.type === 'tableBody') {\n            table_1 = container.parent;\n            parser.finalize(container, parser.lineNumber - 1);\n        }\n        parser.finalize(table_1, parser.lineNumber - 1);\n        return 0 /* None */;\n    }\n    var tableBody = container;\n    if (container.type === 'table') {\n        tableBody = parser.addChild('tableBody', parser.nextNonspace);\n        tableBody.stringContent = null;\n    }\n    var tableRow = createNode$1('tableRow', [\n        [parser.lineNumber, parser.nextNonspace + 1],\n        [parser.lineNumber, parser.currentLine.length],\n    ]);\n    tableBody.appendChild(tableRow);\n    var table = tableBody.parent;\n    var content = parser.currentLine.slice(parser.nextNonspace);\n    var _a = parseRowContent(content), offset = _a[0], cellContents = _a[1];\n    generateTableCells('tableCell', cellContents, parser.lineNumber, parser.nextNonspace + 1 + offset).forEach(function (cellNode, idx) {\n        if (idx >= table.columns.length) {\n            cellNode.ignored = true;\n        }\n        tableRow.appendChild(cellNode);\n    });\n    return 2 /* Leaf */;\n};\n\nvar reCustomBlock = /^(\\$\\$)(\\s*[a-zA-Z])+/;\nvar reCanBeCustomInline = /^(\\$\\$)(\\s*[a-zA-Z])+.*(\\$\\$)/;\nvar customBlock = function (parser) {\n    var match;\n    if (!parser.indented &&\n        !reCanBeCustomInline.test(parser.currentLine) &&\n        (match = parser.currentLine.match(reCustomBlock))) {\n        var syntaxLength = match[1].length;\n        parser.closeUnmatchedBlocks();\n        var container = parser.addChild('customBlock', parser.nextNonspace);\n        container.syntaxLength = syntaxLength;\n        container.offset = parser.indent;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(syntaxLength, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\n\nvar reCodeFence = /^`{3,}(?!.*`)|^~{3,}/;\nvar reHtmlBlockOpen = [\n    /./,\n    /^<(?:script|pre|style)(?:\\s|>|$)/i,\n    /^<!--/,\n    /^<[?]/,\n    /^<![A-Z]/,\n    /^<!\\[CDATA\\[/,\n    /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|[/]?[>]|$)/i,\n    new RegExp(\"^(?:\" + OPENTAG + \"|\" + CLOSETAG + \")\\\\s*$\", 'i'),\n];\nvar reSetextHeadingLine = /^(?:=+|-+)[ \\t]*$/;\nvar reATXHeadingMarker = /^#{1,6}(?:[ \\t]+|$)/;\nvar reThematicBreak = /^(?:(?:\\*[ \\t]*){3,}|(?:_[ \\t]*){3,}|(?:-[ \\t]*){3,})[ \\t]*$/;\nvar reBulletListMarker = /^[*+-]/;\nvar reOrderedListMarker = /^(\\d{1,9})([.)])/;\n// Parse a list marker and return data on the marker (type,\n// start, delimiter, bullet character, padding) or null.\nfunction parseListMarker(parser, container) {\n    var rest = parser.currentLine.slice(parser.nextNonspace);\n    var match;\n    var nextc;\n    var data = {\n        type: 'bullet',\n        tight: true,\n        bulletChar: '',\n        start: 0,\n        delimiter: '',\n        padding: 0,\n        markerOffset: parser.indent,\n        // GFM: Task List Item\n        task: false,\n        checked: false,\n    };\n    if (parser.indent >= 4) {\n        return null;\n    }\n    if ((match = rest.match(reBulletListMarker))) {\n        data.type = 'bullet';\n        data.bulletChar = match[0][0];\n    }\n    else if ((match = rest.match(reOrderedListMarker)) &&\n        (container.type !== 'paragraph' || match[1] === '1')) {\n        data.type = 'ordered';\n        data.start = parseInt(match[1], 10);\n        data.delimiter = match[2];\n    }\n    else {\n        return null;\n    }\n    // make sure we have spaces after\n    nextc = peek(parser.currentLine, parser.nextNonspace + match[0].length);\n    if (!(nextc === -1 || nextc === C_TAB || nextc === C_SPACE)) {\n        return null;\n    }\n    // if it interrupts paragraph, make sure first line isn't blank\n    if (container.type === 'paragraph' &&\n        !parser.currentLine.slice(parser.nextNonspace + match[0].length).match(reNonSpace)) {\n        return null;\n    }\n    // we've got a match! advance offset and calculate padding\n    parser.advanceNextNonspace(); // to start of marker\n    parser.advanceOffset(match[0].length, true); // to end of marker\n    var spacesStartCol = parser.column;\n    var spacesStartOffset = parser.offset;\n    do {\n        parser.advanceOffset(1, true);\n        nextc = peek(parser.currentLine, parser.offset);\n    } while (parser.column - spacesStartCol < 5 && isSpaceOrTab(nextc));\n    var blankItem = peek(parser.currentLine, parser.offset) === -1;\n    var spacesAfterMarker = parser.column - spacesStartCol;\n    if (spacesAfterMarker >= 5 || spacesAfterMarker < 1 || blankItem) {\n        data.padding = match[0].length + 1;\n        parser.column = spacesStartCol;\n        parser.offset = spacesStartOffset;\n        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n            parser.advanceOffset(1, true);\n        }\n    }\n    else {\n        data.padding = match[0].length + spacesAfterMarker;\n    }\n    return data;\n}\n// Returns true if the two list items are of the same type,\n// with the same delimiter and bullet character.  This is used\n// in agglomerating list items into lists.\nfunction listsMatch(listData, itemData) {\n    return (listData.type === itemData.type &&\n        listData.delimiter === itemData.delimiter &&\n        listData.bulletChar === itemData.bulletChar);\n}\nfunction isDisallowedDeepHeading(parser, node) {\n    return parser.options.disallowDeepHeading && (node.type === 'blockQuote' || node.type === 'item');\n}\nvar blockQuote = function (parser) {\n    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN) {\n        parser.advanceNextNonspace();\n        parser.advanceOffset(1, false);\n        // optional following space\n        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n            parser.advanceOffset(1, true);\n        }\n        parser.closeUnmatchedBlocks();\n        parser.addChild('blockQuote', parser.nextNonspace);\n        return 1 /* Container */;\n    }\n    return 0 /* None */;\n};\nvar atxHeading = function (parser, container) {\n    var match;\n    if (!parser.indented &&\n        // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option\n        !isDisallowedDeepHeading(parser, container) &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeadingMarker))) {\n        parser.advanceNextNonspace();\n        parser.advanceOffset(match[0].length, false);\n        parser.closeUnmatchedBlocks();\n        var heading = parser.addChild('heading', parser.nextNonspace);\n        heading.level = match[0].trim().length; // number of #s\n        heading.headingType = 'atx';\n        // remove trailing ###s:\n        heading.stringContent = parser.currentLine\n            .slice(parser.offset)\n            .replace(/^[ \\t]*#+[ \\t]*$/, '')\n            .replace(/[ \\t]+#+[ \\t]*$/, '');\n        parser.advanceOffset(parser.currentLine.length - parser.offset);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar fencedCodeBlock = function (parser) {\n    var match;\n    if (!parser.indented &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence))) {\n        var fenceLength = match[0].length;\n        parser.closeUnmatchedBlocks();\n        var container = parser.addChild('codeBlock', parser.nextNonspace);\n        container.isFenced = true;\n        container.fenceLength = fenceLength;\n        container.fenceChar = match[0][0];\n        container.fenceOffset = parser.indent;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(fenceLength, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar htmlBlock = function (parser, container) {\n    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_LESSTHAN) {\n        var s = parser.currentLine.slice(parser.nextNonspace);\n        var disallowedTags = parser.options.disallowedHtmlBlockTags;\n        var blockType = void 0;\n        for (blockType = 1; blockType <= 7; blockType++) {\n            var matched = s.match(reHtmlBlockOpen[blockType]);\n            if (matched) {\n                if (blockType === 7) {\n                    if (container.type === 'paragraph') {\n                        return 0 /* None */;\n                    }\n                    if (disallowedTags.length > 0) {\n                        var reDisallowedTags = new RegExp(\"</?(?:\" + disallowedTags.join('|') + \")\", 'i');\n                        if (reDisallowedTags.test(matched[0])) {\n                            return 0 /* None */;\n                        }\n                    }\n                }\n                parser.closeUnmatchedBlocks();\n                // We don't adjust parser.offset;\n                // spaces are part of the HTML block:\n                var b = parser.addChild('htmlBlock', parser.offset);\n                b.htmlBlockType = blockType;\n                return 2 /* Leaf */;\n            }\n        }\n    }\n    return 0 /* None */;\n};\nvar seTextHeading = function (parser, container) {\n    var match;\n    if (container.stringContent !== null &&\n        !parser.indented &&\n        container.type === 'paragraph' &&\n        // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option\n        !isDisallowedDeepHeading(parser, container.parent) &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeadingLine))) {\n        parser.closeUnmatchedBlocks();\n        // resolve reference link definitions\n        var pos = void 0;\n        while (peek(container.stringContent, 0) === C_OPEN_BRACKET &&\n            (pos = parser.inlineParser.parseReference(container, parser.refMap))) {\n            container.stringContent = container.stringContent.slice(pos);\n        }\n        if (container.stringContent.length > 0) {\n            var heading = createNode$1('heading', container.sourcepos);\n            heading.level = match[0][0] === '=' ? 1 : 2;\n            heading.headingType = 'setext';\n            heading.stringContent = container.stringContent;\n            container.insertAfter(heading);\n            container.unlink();\n            parser.tip = heading;\n            parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n            return 2 /* Leaf */;\n        }\n        return 0 /* None */;\n    }\n    return 0 /* None */;\n};\nvar thematicBreak = function (parser) {\n    if (!parser.indented && reThematicBreak.test(parser.currentLine.slice(parser.nextNonspace))) {\n        parser.closeUnmatchedBlocks();\n        parser.addChild('thematicBreak', parser.nextNonspace);\n        parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar listItem = function (parser, container) {\n    var data;\n    var currNode = container;\n    if ((!parser.indented || container.type === 'list') &&\n        (data = parseListMarker(parser, currNode))) {\n        parser.closeUnmatchedBlocks();\n        // add the list if needed\n        if (parser.tip.type !== 'list' || !listsMatch(currNode.listData, data)) {\n            currNode = parser.addChild('list', parser.nextNonspace);\n            currNode.listData = data;\n        }\n        // add the list item\n        currNode = parser.addChild('item', parser.nextNonspace);\n        currNode.listData = data;\n        return 1 /* Container */;\n    }\n    return 0 /* None */;\n};\n// indented code block\nvar indentedCodeBlock = function (parser) {\n    if (parser.indented && parser.tip.type !== 'paragraph' && !parser.blank) {\n        // indented code\n        parser.advanceOffset(CODE_INDENT, true);\n        parser.closeUnmatchedBlocks();\n        parser.addChild('codeBlock', parser.offset);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar blockStarts = [\n    blockQuote,\n    atxHeading,\n    fencedCodeBlock,\n    htmlBlock,\n    seTextHeading,\n    thematicBreak,\n    listItem,\n    indentedCodeBlock,\n    tableHead,\n    tableBody,\n    customBlock,\n];\n\n// `---` for YAML, `+++` for TOML, `;;;` for JSON\nvar reFrontMatter = /^(-{3}|\\+{3}|;{3})$/;\nvar frontMatter$1 = function (parser, container) {\n    var currentLine = parser.currentLine, lineNumber = parser.lineNumber, indented = parser.indented;\n    if (lineNumber === 1 &&\n        !indented &&\n        container.type === 'document' &&\n        reFrontMatter.test(currentLine)) {\n        parser.closeUnmatchedBlocks();\n        var frontMatter_1 = parser.addChild('frontMatter', parser.nextNonspace);\n        frontMatter_1.stringContent = currentLine;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(currentLine.length, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\n\nvar frontMatter = {\n    continue: function (parser, container) {\n        var line = parser.currentLine;\n        var match = line.match(reFrontMatter);\n        if (container.type === 'frontMatter' && match) {\n            container.stringContent += line;\n            parser.lastLineLength = match[0].length;\n            parser.finalize(container, parser.lineNumber);\n            return 2 /* Finished */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        block.literal = block.stringContent;\n        block.stringContent = null;\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\n\nvar reHtmlBlockClose = [\n    /./,\n    /<\\/(?:script|pre|style)>/i,\n    /-->/,\n    /\\?>/,\n    />/,\n    /\\]\\]>/,\n];\nvar reMaybeSpecial = /^[#`~*+_=<>0-9-;$]/;\nvar reLineEnding$1 = /\\r\\n|\\n|\\r/;\nfunction document$2() {\n    return createNode$1('document', [\n        [1, 1],\n        [0, 0],\n    ]);\n}\nvar defaultOptions$1 = {\n    smart: false,\n    tagFilter: false,\n    extendedAutolinks: false,\n    disallowedHtmlBlockTags: [],\n    referenceDefinition: false,\n    disallowDeepHeading: false,\n    customParser: null,\n    frontMatter: false,\n};\nvar Parser = /** @class */ (function () {\n    function Parser(options) {\n        this.options = __assign(__assign({}, defaultOptions$1), options);\n        this.doc = document$2();\n        this.tip = this.doc;\n        this.oldtip = this.doc;\n        this.lineNumber = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.nextNonspace = 0;\n        this.nextNonspaceColumn = 0;\n        this.indent = 0;\n        this.currentLine = '';\n        this.indented = false;\n        this.blank = false;\n        this.partiallyConsumedTab = false;\n        this.allClosed = true;\n        this.lastMatchedContainer = this.doc;\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.lastLineLength = 0;\n        this.lines = [];\n        if (this.options.frontMatter) {\n            blockHandlers.frontMatter = frontMatter;\n            blockStarts.unshift(frontMatter$1);\n        }\n        this.inlineParser = new InlineParser(this.options);\n    }\n    Parser.prototype.advanceOffset = function (count, columns) {\n        if (columns === void 0) { columns = false; }\n        var currentLine = this.currentLine;\n        var charsToTab, charsToAdvance;\n        var c;\n        while (count > 0 && (c = currentLine[this.offset])) {\n            if (c === '\\t') {\n                charsToTab = 4 - (this.column % 4);\n                if (columns) {\n                    this.partiallyConsumedTab = charsToTab > count;\n                    charsToAdvance = charsToTab > count ? count : charsToTab;\n                    this.column += charsToAdvance;\n                    this.offset += this.partiallyConsumedTab ? 0 : 1;\n                    count -= charsToAdvance;\n                }\n                else {\n                    this.partiallyConsumedTab = false;\n                    this.column += charsToTab;\n                    this.offset += 1;\n                    count -= 1;\n                }\n            }\n            else {\n                this.partiallyConsumedTab = false;\n                this.offset += 1;\n                this.column += 1; // assume ascii; block starts are ascii\n                count -= 1;\n            }\n        }\n    };\n    Parser.prototype.advanceNextNonspace = function () {\n        this.offset = this.nextNonspace;\n        this.column = this.nextNonspaceColumn;\n        this.partiallyConsumedTab = false;\n    };\n    Parser.prototype.findNextNonspace = function () {\n        var currentLine = this.currentLine;\n        var i = this.offset;\n        var cols = this.column;\n        var c;\n        while ((c = currentLine.charAt(i)) !== '') {\n            if (c === ' ') {\n                i++;\n                cols++;\n            }\n            else if (c === '\\t') {\n                i++;\n                cols += 4 - (cols % 4);\n            }\n            else {\n                break;\n            }\n        }\n        this.blank = c === '\\n' || c === '\\r' || c === '';\n        this.nextNonspace = i;\n        this.nextNonspaceColumn = cols;\n        this.indent = this.nextNonspaceColumn - this.column;\n        this.indented = this.indent >= CODE_INDENT;\n    };\n    // Add a line to the block at the tip.  We assume the tip\n    // can accept lines -- that check should be done before calling this.\n    Parser.prototype.addLine = function () {\n        if (this.partiallyConsumedTab) {\n            this.offset += 1; // skip over tab\n            // add space characters:\n            var charsToTab = 4 - (this.column % 4);\n            this.tip.stringContent += repeat(' ', charsToTab);\n        }\n        if (this.tip.lineOffsets) {\n            this.tip.lineOffsets.push(this.offset);\n        }\n        else {\n            this.tip.lineOffsets = [this.offset];\n        }\n        this.tip.stringContent += this.currentLine.slice(this.offset) + \"\\n\";\n    };\n    // Add block of type tag as a child of the tip.  If the tip can't\n    // accept children, close and finalize it and try its parent,\n    // and so on til we find a block that can accept children.\n    Parser.prototype.addChild = function (tag, offset) {\n        while (!blockHandlers[this.tip.type].canContain(tag)) {\n            this.finalize(this.tip, this.lineNumber - 1);\n        }\n        var columnNumber = offset + 1; // offset 0 = column 1\n        var newBlock = createNode$1(tag, [\n            [this.lineNumber, columnNumber],\n            [0, 0],\n        ]);\n        newBlock.stringContent = '';\n        this.tip.appendChild(newBlock);\n        this.tip = newBlock;\n        return newBlock;\n    };\n    // Finalize and close any unmatched blocks.\n    Parser.prototype.closeUnmatchedBlocks = function () {\n        if (!this.allClosed) {\n            // finalize any blocks not matched\n            while (this.oldtip !== this.lastMatchedContainer) {\n                var parent_1 = this.oldtip.parent;\n                this.finalize(this.oldtip, this.lineNumber - 1);\n                this.oldtip = parent_1;\n            }\n            this.allClosed = true;\n        }\n    };\n    // Finalize a block.  Close it and do any necessary postprocessing,\n    // e.g. creating stringContent from strings, setting the 'tight'\n    // or 'loose' status of a list, and parsing the beginnings\n    // of paragraphs for reference definitions.  Reset the tip to the\n    // parent of the closed block.\n    Parser.prototype.finalize = function (block, lineNumber) {\n        var above = block.parent;\n        block.open = false;\n        block.sourcepos[1] = [lineNumber, this.lastLineLength];\n        blockHandlers[block.type].finalize(this, block);\n        this.tip = above;\n    };\n    // Walk through a block & children recursively, parsing string content\n    // into inline content where appropriate.\n    Parser.prototype.processInlines = function (block) {\n        var event;\n        var customParser = this.options.customParser;\n        var walker = block.walker();\n        this.inlineParser.refMap = this.refMap;\n        this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap;\n        this.inlineParser.refDefCandidateMap = this.refDefCandidateMap;\n        this.inlineParser.options = this.options;\n        while ((event = walker.next())) {\n            var node = event.node, entering = event.entering;\n            var t = node.type;\n            if (customParser && customParser[t]) {\n                customParser[t](node, { entering: entering, options: this.options });\n            }\n            if (!entering &&\n                (t === 'paragraph' ||\n                    t === 'heading' ||\n                    (t === 'tableCell' && !node.ignored))) {\n                this.inlineParser.parse(node);\n            }\n        }\n    };\n    // Analyze a line of text and update the document appropriately.\n    // We parse markdown text by calling this on each line of input,\n    // then finalizing the document.\n    Parser.prototype.incorporateLine = function (ln) {\n        var container = this.doc;\n        this.oldtip = this.tip;\n        this.offset = 0;\n        this.column = 0;\n        this.blank = false;\n        this.partiallyConsumedTab = false;\n        this.lineNumber += 1;\n        // replace NUL characters for security\n        if (ln.indexOf('\\u0000') !== -1) {\n            ln = ln.replace(/\\0/g, '\\uFFFD');\n        }\n        this.currentLine = ln;\n        // For each containing block, try to parse the associated line start.\n        // Bail out on failure: container will point to the last matching block.\n        // Set allMatched to false if not all containers match.\n        var allMatched = true;\n        var lastChild;\n        while ((lastChild = container.lastChild) && lastChild.open) {\n            container = lastChild;\n            this.findNextNonspace();\n            switch (blockHandlers[container.type]['continue'](this, container)) {\n                case 0 /* Go */: // we've matched, keep going\n                    break;\n                case 1 /* Stop */: // we've failed to match a block\n                    allMatched = false;\n                    break;\n                case 2 /* Finished */: // we've hit end of line for fenced code close and can return\n                    this.lastLineLength = ln.length;\n                    return;\n                default:\n                    throw new Error('continue returned illegal value, must be 0, 1, or 2');\n            }\n            if (!allMatched) {\n                container = container.parent; // back up to last matching block\n                break;\n            }\n        }\n        this.allClosed = container === this.oldtip;\n        this.lastMatchedContainer = container;\n        var matchedLeaf = container.type !== 'paragraph' && blockHandlers[container.type].acceptsLines;\n        var blockStartsLen = blockStarts.length;\n        // Unless last matched container is a code block, try new container starts,\n        // adding children to the last matched container:\n        while (!matchedLeaf) {\n            this.findNextNonspace();\n            // this is a little performance optimization:\n            if (container.type !== 'table' &&\n                container.type !== 'tableBody' &&\n                container.type !== 'paragraph' &&\n                !this.indented &&\n                !reMaybeSpecial.test(ln.slice(this.nextNonspace))) {\n                this.advanceNextNonspace();\n                break;\n            }\n            var i = 0;\n            while (i < blockStartsLen) {\n                var res = blockStarts[i](this, container);\n                if (res === 1 /* Container */) {\n                    container = this.tip;\n                    break;\n                }\n                else if (res === 2 /* Leaf */) {\n                    container = this.tip;\n                    matchedLeaf = true;\n                    break;\n                }\n                else {\n                    i++;\n                }\n            }\n            if (i === blockStartsLen) {\n                // nothing matched\n                this.advanceNextNonspace();\n                break;\n            }\n        }\n        // What remains at the offset is a text line.  Add the text to the\n        // appropriate container.\n        // First check for a lazy paragraph continuation:\n        if (!this.allClosed && !this.blank && this.tip.type === 'paragraph') {\n            // lazy paragraph continuation\n            this.addLine();\n        }\n        else {\n            // not a lazy continuation\n            // finalize any blocks not matched\n            this.closeUnmatchedBlocks();\n            if (this.blank && container.lastChild) {\n                container.lastChild.lastLineBlank = true;\n            }\n            var t = container.type;\n            // Block quote lines are never blank as they start with >\n            // and we don't count blanks in fenced code for purposes of tight/loose\n            // lists or breaking out of lists. We also don't set _lastLineBlank\n            // on an empty list item, or if we just closed a fenced block.\n            var lastLineBlank = this.blank &&\n                !(t === 'blockQuote' ||\n                    (isCodeBlock(container) && container.isFenced) ||\n                    (t === 'item' && !container.firstChild && container.sourcepos[0][0] === this.lineNumber));\n            // propagate lastLineBlank up through parents:\n            var cont = container;\n            while (cont) {\n                cont.lastLineBlank = lastLineBlank;\n                cont = cont.parent;\n            }\n            if (blockHandlers[t].acceptsLines) {\n                this.addLine();\n                // if HtmlBlock, check for end condition\n                if (isHtmlBlock(container) &&\n                    container.htmlBlockType >= 1 &&\n                    container.htmlBlockType <= 5 &&\n                    reHtmlBlockClose[container.htmlBlockType].test(this.currentLine.slice(this.offset))) {\n                    this.lastLineLength = ln.length;\n                    this.finalize(container, this.lineNumber);\n                }\n            }\n            else if (this.offset < ln.length && !this.blank) {\n                // create paragraph container for line\n                container = this.addChild('paragraph', this.offset);\n                this.advanceNextNonspace();\n                this.addLine();\n            }\n        }\n        this.lastLineLength = ln.length;\n    };\n    // The main parsing function.  Returns a parsed document AST.\n    Parser.prototype.parse = function (input, lineTexts) {\n        this.doc = document$2();\n        this.tip = this.doc;\n        this.lineNumber = 0;\n        this.lastLineLength = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.lastMatchedContainer = this.doc;\n        this.currentLine = '';\n        var lines = input.split(reLineEnding$1);\n        var len = lines.length;\n        this.lines = lineTexts ? lineTexts : lines;\n        if (this.options.referenceDefinition) {\n            this.clearRefMaps();\n        }\n        if (input.charCodeAt(input.length - 1) === C_NEWLINE) {\n            // ignore last blank line created by final newline\n            len -= 1;\n        }\n        for (var i = 0; i < len; i++) {\n            this.incorporateLine(lines[i]);\n        }\n        while (this.tip) {\n            this.finalize(this.tip, len);\n        }\n        this.processInlines(this.doc);\n        return this.doc;\n    };\n    Parser.prototype.partialParseStart = function (lineNumber, lines) {\n        this.doc = document$2();\n        this.tip = this.doc;\n        this.lineNumber = lineNumber - 1;\n        this.lastLineLength = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.lastMatchedContainer = this.doc;\n        this.currentLine = '';\n        var len = lines.length;\n        for (var i = 0; i < len; i++) {\n            this.incorporateLine(lines[i]);\n        }\n        return this.doc;\n    };\n    Parser.prototype.partialParseExtends = function (lines) {\n        for (var i = 0; i < lines.length; i++) {\n            this.incorporateLine(lines[i]);\n        }\n    };\n    Parser.prototype.partialParseFinish = function () {\n        while (this.tip) {\n            this.finalize(this.tip, this.lineNumber);\n        }\n        this.processInlines(this.doc);\n    };\n    Parser.prototype.setRefMaps = function (refMap, refLinkCandidateMap, refDefCandidateMap) {\n        this.refMap = refMap;\n        this.refLinkCandidateMap = refLinkCandidateMap;\n        this.refDefCandidateMap = refDefCandidateMap;\n    };\n    Parser.prototype.clearRefMaps = function () {\n        [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (map) {\n            clearObj(map);\n        });\n    };\n    return Parser;\n}());\n\nfunction comparePos(p1, p2) {\n    if (p1[0] < p2[0]) {\n        return 1 /* LT */;\n    }\n    if (p1[0] > p2[0]) {\n        return -1 /* GT */;\n    }\n    if (p1[1] < p2[1]) {\n        return 1 /* LT */;\n    }\n    if (p1[1] > p2[1]) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction compareRangeAndPos(_a, pos) {\n    var startPos = _a[0], endPos = _a[1];\n    if (comparePos(endPos, pos) === 1 /* LT */) {\n        return 1 /* LT */;\n    }\n    if (comparePos(startPos, pos) === -1 /* GT */) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction removeNextUntil(node, last) {\n    if (node.parent !== last.parent || node === last) {\n        return;\n    }\n    var next = node.next;\n    while (next && next !== last) {\n        var temp = next.next;\n        for (var _i = 0, _a = ['parent', 'prev', 'next']; _i < _a.length; _i++) {\n            var type = _a[_i];\n            if (next[type]) {\n                removeNodeById(next[type].id);\n                next[type] = null;\n            }\n        }\n        next = temp;\n    }\n    node.next = last.next;\n    if (last.next) {\n        last.next.prev = node;\n    }\n    else {\n        node.parent.lastChild = node;\n    }\n}\nfunction getChildNodes(parent) {\n    var nodes = [];\n    var curr = parent.firstChild;\n    while (curr) {\n        nodes.push(curr);\n        curr = curr.next;\n    }\n    return nodes;\n}\nfunction insertNodesBefore(target, nodes) {\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var node = nodes_1[_i];\n        target.insertBefore(node);\n    }\n}\nfunction prependChildNodes(parent, nodes) {\n    for (var i = nodes.length - 1; i >= 0; i -= 1) {\n        parent.prependChild(nodes[i]);\n    }\n}\nfunction updateNextLineNumbers(base, diff) {\n    if (!base || !base.parent || diff === 0) {\n        return;\n    }\n    var walker = base.parent.walker();\n    walker.resumeAt(base, true);\n    var event;\n    while ((event = walker.next())) {\n        var node = event.node, entering = event.entering;\n        if (entering) {\n            node.sourcepos[0][0] += diff;\n            node.sourcepos[1][0] += diff;\n        }\n    }\n}\nfunction compareRangeAndLine(_a, line) {\n    var startPos = _a[0], endPos = _a[1];\n    if (endPos[0] < line) {\n        return 1 /* LT */;\n    }\n    if (startPos[0] > line) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction findChildNodeAtLine(parent, line) {\n    var node = parent.firstChild;\n    while (node) {\n        var comp = compareRangeAndLine(node.sourcepos, line);\n        if (comp === 0 /* EQ */) {\n            return node;\n        }\n        if (comp === -1 /* GT */) {\n            // To consider that top line is blank line\n            return node.prev || node;\n        }\n        node = node.next;\n    }\n    return parent.lastChild;\n}\nfunction lastLeafNode(node) {\n    while (node.lastChild) {\n        node = node.lastChild;\n    }\n    return node;\n}\nfunction sameLineTopAncestor(node) {\n    while (node.parent &&\n        node.parent.type !== 'document' &&\n        node.parent.sourcepos[0][0] === node.sourcepos[0][0]) {\n        node = node.parent;\n    }\n    return node;\n}\nfunction findFirstNodeAtLine(parent, line) {\n    var node = parent.firstChild;\n    var prev = null;\n    while (node) {\n        var comp = compareRangeAndLine(node.sourcepos, line);\n        if (comp === 0 /* EQ */) {\n            if (node.sourcepos[0][0] === line || !node.firstChild) {\n                return node;\n            }\n            prev = node;\n            node = node.firstChild;\n        }\n        else if (comp === -1 /* GT */) {\n            break;\n        }\n        else {\n            prev = node;\n            node = node.next;\n        }\n    }\n    if (prev) {\n        return sameLineTopAncestor(lastLeafNode(prev));\n    }\n    return null;\n}\nfunction findNodeAtPosition(parent, pos) {\n    var node = parent;\n    var prev = null;\n    while (node) {\n        var comp = compareRangeAndPos(node.sourcepos, pos);\n        if (comp === 0 /* EQ */) {\n            if (node.firstChild) {\n                prev = node;\n                node = node.firstChild;\n            }\n            else {\n                return node;\n            }\n        }\n        else if (comp === -1 /* GT */) {\n            return prev;\n        }\n        else if (node.next) {\n            node = node.next;\n        }\n        else {\n            return prev;\n        }\n    }\n    return node;\n}\nfunction findNodeById(id) {\n    return getNodeById(id) || null;\n}\nfunction invokeNextUntil(callback, start, end) {\n    if (end === void 0) { end = null; }\n    if (start) {\n        var walker = start.walker();\n        while (start && start !== end) {\n            callback(start);\n            var next = walker.next();\n            if (next) {\n                start = next.node;\n            }\n            else {\n                break;\n            }\n        }\n    }\n}\nfunction isUnlinked(id) {\n    var node = findNodeById(id);\n    if (!node) {\n        return true;\n    }\n    while (node && node.type !== 'document') {\n        // eslint-disable-next-line no-loop-func\n        if (!node.parent && !node.prev && !node.next) {\n            return true;\n        }\n        node = node.parent;\n    }\n    return false;\n}\n\nvar reLineEnding = /\\r\\n|\\n|\\r/;\nfunction canBeContinuedListItem(lineText) {\n    var spaceMatch = lineText.match(/^[ \\t]+/);\n    if (spaceMatch && (spaceMatch[0].length >= 2 || /\\t/.test(spaceMatch[0]))) {\n        return true;\n    }\n    var leftTrimmed = spaceMatch ? lineText.slice(spaceMatch.length) : lineText;\n    return reBulletListMarker.test(leftTrimmed) || reOrderedListMarker.test(leftTrimmed);\n}\nfunction canBeContinuedTableBody(lineText) {\n    return !isBlank(lineText) && lineText.indexOf('|') !== -1;\n}\nfunction createRefDefState(node) {\n    var id = node.id, title = node.title, sourcepos = node.sourcepos, dest = node.dest;\n    return {\n        id: id,\n        title: title,\n        sourcepos: sourcepos,\n        unlinked: false,\n        destination: dest,\n    };\n}\nvar ToastMark = /** @class */ (function () {\n    function ToastMark(contents, options) {\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.referenceDefinition = !!(options === null || options === void 0 ? void 0 : options.referenceDefinition);\n        this.parser = new Parser(options);\n        this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap);\n        this.eventHandlerMap = { change: [] };\n        contents = contents || '';\n        this.lineTexts = contents.split(reLineEnding);\n        this.root = this.parser.parse(contents, this.lineTexts);\n    }\n    ToastMark.prototype.updateLineTexts = function (startPos, endPos, newText) {\n        var _a;\n        var startLine = startPos[0], startCol = startPos[1];\n        var endLine = endPos[0], endCol = endPos[1];\n        var newLines = newText.split(reLineEnding);\n        var newLineLen = newLines.length;\n        var startLineText = this.lineTexts[startLine - 1];\n        var endLineText = this.lineTexts[endLine - 1];\n        newLines[0] = startLineText.slice(0, startCol - 1) + newLines[0];\n        newLines[newLineLen - 1] = newLines[newLineLen - 1] + endLineText.slice(endCol - 1);\n        var removedLineLen = endLine - startLine + 1;\n        (_a = this.lineTexts).splice.apply(_a, __spreadArray([startLine - 1, removedLineLen], newLines));\n        return newLineLen - removedLineLen;\n    };\n    ToastMark.prototype.updateRootNodeState = function () {\n        if (this.lineTexts.length === 1 && this.lineTexts[0] === '') {\n            this.root.lastLineBlank = true;\n            this.root.sourcepos = [\n                [1, 1],\n                [1, 0],\n            ];\n            return;\n        }\n        if (this.root.lastChild) {\n            this.root.lastLineBlank = this.root.lastChild.lastLineBlank;\n        }\n        var lineTexts = this.lineTexts;\n        var idx = lineTexts.length - 1;\n        while (lineTexts[idx] === '') {\n            idx -= 1;\n        }\n        if (lineTexts.length - 2 > idx) {\n            idx += 1;\n        }\n        this.root.sourcepos[1] = [idx + 1, lineTexts[idx].length];\n    };\n    ToastMark.prototype.replaceRangeNodes = function (startNode, endNode, newNodes) {\n        if (!startNode) {\n            if (endNode) {\n                insertNodesBefore(endNode, newNodes);\n                removeNodeById(endNode.id);\n                endNode.unlink();\n            }\n            else {\n                prependChildNodes(this.root, newNodes);\n            }\n        }\n        else {\n            insertNodesBefore(startNode, newNodes);\n            removeNextUntil(startNode, endNode);\n            [startNode.id, endNode.id].forEach(function (id) { return removeNodeById(id); });\n            startNode.unlink();\n        }\n    };\n    ToastMark.prototype.getNodeRange = function (startPos, endPos) {\n        var startNode = findChildNodeAtLine(this.root, startPos[0]);\n        var endNode = findChildNodeAtLine(this.root, endPos[0]);\n        // extend node range to include a following block which doesn't have preceding blank line\n        if (endNode && endNode.next && endPos[0] + 1 === endNode.next.sourcepos[0][0]) {\n            endNode = endNode.next;\n        }\n        return [startNode, endNode];\n    };\n    ToastMark.prototype.trigger = function (eventName, param) {\n        this.eventHandlerMap[eventName].forEach(function (handler) {\n            handler(param);\n        });\n    };\n    ToastMark.prototype.extendEndLine = function (line) {\n        while (this.lineTexts[line] === '') {\n            line += 1;\n        }\n        return line;\n    };\n    ToastMark.prototype.parseRange = function (startNode, endNode, startLine, endLine) {\n        // extends starting range if the first node can be a continued list item\n        if (startNode &&\n            startNode.prev &&\n            ((isList(startNode.prev) && canBeContinuedListItem(this.lineTexts[startLine - 1])) ||\n                (isTable(startNode.prev) && canBeContinuedTableBody(this.lineTexts[startLine - 1])))) {\n            startNode = startNode.prev;\n            startLine = startNode.sourcepos[0][0];\n        }\n        var editedLines = this.lineTexts.slice(startLine - 1, endLine);\n        var root = this.parser.partialParseStart(startLine, editedLines);\n        // extends ending range if the following node can be a fenced code block or a continued list item\n        var nextNode = endNode ? endNode.next : this.root.firstChild;\n        var lastChild = root.lastChild;\n        var isOpenedLastChildCodeBlock = lastChild && isCodeBlock(lastChild) && lastChild.open;\n        var isOpenedLastChildCustomBlock = lastChild && isCustomBlock(lastChild) && lastChild.open;\n        var isLastChildList = lastChild && isList(lastChild);\n        while (((isOpenedLastChildCodeBlock || isOpenedLastChildCustomBlock) && nextNode) ||\n            (isLastChildList && nextNode && (nextNode.type === 'list' || nextNode.sourcepos[0][1] >= 2))) {\n            var newEndLine = this.extendEndLine(nextNode.sourcepos[1][0]);\n            this.parser.partialParseExtends(this.lineTexts.slice(endLine, newEndLine));\n            if (!startNode) {\n                startNode = endNode;\n            }\n            endNode = nextNode;\n            endLine = newEndLine;\n            nextNode = nextNode.next;\n        }\n        this.parser.partialParseFinish();\n        var newNodes = getChildNodes(root);\n        return { newNodes: newNodes, extStartNode: startNode, extEndNode: endNode };\n    };\n    ToastMark.prototype.getRemovedNodeRange = function (extStartNode, extEndNode) {\n        if (!extStartNode ||\n            (extStartNode && isRefDef(extStartNode)) ||\n            (extEndNode && isRefDef(extEndNode))) {\n            return null;\n        }\n        return {\n            id: [extStartNode.id, extEndNode.id],\n            line: [extStartNode.sourcepos[0][0] - 1, extEndNode.sourcepos[1][0] - 1],\n        };\n    };\n    ToastMark.prototype.markDeletedRefMap = function (extStartNode, extEndNode) {\n        var _this = this;\n        if (!isEmptyObj(this.refMap)) {\n            var markDeleted = function (node) {\n                if (isRefDef(node)) {\n                    var refDefState = _this.refMap[node.label];\n                    if (refDefState && node.id === refDefState.id) {\n                        refDefState.unlinked = true;\n                    }\n                }\n            };\n            if (extStartNode) {\n                invokeNextUntil(markDeleted, extStartNode.parent, extEndNode);\n            }\n            if (extEndNode) {\n                invokeNextUntil(markDeleted, extEndNode);\n            }\n        }\n    };\n    ToastMark.prototype.replaceWithNewRefDefState = function (nodes) {\n        var _this = this;\n        if (!isEmptyObj(this.refMap)) {\n            var replaceWith_1 = function (node) {\n                if (isRefDef(node)) {\n                    var label = node.label;\n                    var refDefState = _this.refMap[label];\n                    if (!refDefState || refDefState.unlinked) {\n                        _this.refMap[label] = createRefDefState(node);\n                    }\n                }\n            };\n            nodes.forEach(function (node) {\n                invokeNextUntil(replaceWith_1, node);\n            });\n        }\n    };\n    ToastMark.prototype.replaceWithRefDefCandidate = function () {\n        var _this = this;\n        if (!isEmptyObj(this.refDefCandidateMap)) {\n            iterateObject(this.refDefCandidateMap, function (_, candidate) {\n                var label = candidate.label, sourcepos = candidate.sourcepos;\n                var refDefState = _this.refMap[label];\n                if (!refDefState ||\n                    refDefState.unlinked ||\n                    refDefState.sourcepos[0][0] > sourcepos[0][0]) {\n                    _this.refMap[label] = createRefDefState(candidate);\n                }\n            });\n        }\n    };\n    ToastMark.prototype.getRangeWithRefDef = function (startLine, endLine, startNode, endNode, lineDiff) {\n        if (this.referenceDefinition && !isEmptyObj(this.refMap)) {\n            var prevNode = findChildNodeAtLine(this.root, startLine - 1);\n            var nextNode = findChildNodeAtLine(this.root, endLine + 1);\n            if (prevNode && isRefDef(prevNode) && prevNode !== startNode && prevNode !== endNode) {\n                startNode = prevNode;\n                startLine = startNode.sourcepos[0][0];\n            }\n            if (nextNode && isRefDef(nextNode) && nextNode !== startNode && nextNode !== endNode) {\n                endNode = nextNode;\n                endLine = this.extendEndLine(endNode.sourcepos[1][0] + lineDiff);\n            }\n        }\n        return [startNode, endNode, startLine, endLine];\n    };\n    ToastMark.prototype.parse = function (startPos, endPos, lineDiff) {\n        if (lineDiff === void 0) { lineDiff = 0; }\n        var range = this.getNodeRange(startPos, endPos);\n        var startNode = range[0], endNode = range[1];\n        var startLine = startNode ? Math.min(startNode.sourcepos[0][0], startPos[0]) : startPos[0];\n        var endLine = this.extendEndLine((endNode ? Math.max(endNode.sourcepos[1][0], endPos[0]) : endPos[0]) + lineDiff);\n        var parseResult = this.parseRange.apply(this, this.getRangeWithRefDef(startLine, endLine, startNode, endNode, lineDiff));\n        var newNodes = parseResult.newNodes, extStartNode = parseResult.extStartNode, extEndNode = parseResult.extEndNode;\n        var removedNodeRange = this.getRemovedNodeRange(extStartNode, extEndNode);\n        var nextNode = extEndNode ? extEndNode.next : this.root.firstChild;\n        if (this.referenceDefinition) {\n            this.markDeletedRefMap(extStartNode, extEndNode);\n            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);\n            this.replaceWithNewRefDefState(newNodes);\n        }\n        else {\n            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);\n        }\n        return { nodes: newNodes, removedNodeRange: removedNodeRange, nextNode: nextNode };\n    };\n    ToastMark.prototype.parseRefLink = function () {\n        var _this = this;\n        var result = [];\n        if (!isEmptyObj(this.refMap)) {\n            iterateObject(this.refMap, function (label, value) {\n                if (value.unlinked) {\n                    delete _this.refMap[label];\n                }\n                iterateObject(_this.refLinkCandidateMap, function (_, candidate) {\n                    var node = candidate.node, refLabel = candidate.refLabel;\n                    if (refLabel === label) {\n                        result.push(_this.parse(node.sourcepos[0], node.sourcepos[1]));\n                    }\n                });\n            });\n        }\n        return result;\n    };\n    ToastMark.prototype.removeUnlinkedCandidate = function () {\n        if (!isEmptyObj(this.refDefCandidateMap)) {\n            [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (candidateMap) {\n                iterateObject(candidateMap, function (id) {\n                    if (isUnlinked(id)) {\n                        delete candidateMap[id];\n                    }\n                });\n            });\n        }\n    };\n    ToastMark.prototype.editMarkdown = function (startPos, endPos, newText) {\n        var lineDiff = this.updateLineTexts(startPos, endPos, newText);\n        var parseResult = this.parse(startPos, endPos, lineDiff);\n        var editResult = omit(parseResult, 'nextNode');\n        updateNextLineNumbers(parseResult.nextNode, lineDiff);\n        this.updateRootNodeState();\n        var result = [editResult];\n        if (this.referenceDefinition) {\n            this.removeUnlinkedCandidate();\n            this.replaceWithRefDefCandidate();\n            result = result.concat(this.parseRefLink());\n        }\n        this.trigger('change', result);\n        return result;\n    };\n    ToastMark.prototype.getLineTexts = function () {\n        return this.lineTexts;\n    };\n    ToastMark.prototype.getRootNode = function () {\n        return this.root;\n    };\n    ToastMark.prototype.findNodeAtPosition = function (pos) {\n        var node = findNodeAtPosition(this.root, pos);\n        if (!node || node === this.root) {\n            return null;\n        }\n        return node;\n    };\n    ToastMark.prototype.findFirstNodeAtLine = function (line) {\n        return findFirstNodeAtLine(this.root, line);\n    };\n    ToastMark.prototype.on = function (eventName, callback) {\n        this.eventHandlerMap[eventName].push(callback);\n    };\n    ToastMark.prototype.off = function (eventName, callback) {\n        var handlers = this.eventHandlerMap[eventName];\n        var idx = handlers.indexOf(callback);\n        handlers.splice(idx, 1);\n    };\n    ToastMark.prototype.findNodeById = function (id) {\n        return findNodeById(id);\n    };\n    ToastMark.prototype.removeAllNode = function () {\n        removeAllNode();\n    };\n    return ToastMark;\n}());\n\nvar disallowedTags = [\n    'title',\n    'textarea',\n    'style',\n    'xmp',\n    'iframe',\n    'noembed',\n    'noframes',\n    'script',\n    'plaintext',\n];\nvar reDisallowedTag = new RegExp(\"<(/?(?:\" + disallowedTags.join('|') + \")[^>]*>)\", 'ig');\nfunction filterDisallowedTags(str) {\n    if (reDisallowedTag.test(str)) {\n        return str.replace(reDisallowedTag, function (_, group) { return \"&lt;\" + group; });\n    }\n    return str;\n}\n\nvar baseConvertors$1 = {\n    heading: function (node, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: \"h\" + node.level,\n            outerNewLine: true,\n        };\n    },\n    text: function (node) {\n        return {\n            type: 'text',\n            content: node.literal,\n        };\n    },\n    softbreak: function (_, _a) {\n        var options = _a.options;\n        return {\n            type: 'html',\n            content: options.softbreak,\n        };\n    },\n    linebreak: function () {\n        return {\n            type: 'html',\n            content: '<br />\\n',\n        };\n    },\n    emph: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'em',\n        };\n    },\n    strong: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'strong',\n        };\n    },\n    paragraph: function (node, _a) {\n        var _b;\n        var entering = _a.entering;\n        var grandparent = (_b = node.parent) === null || _b === void 0 ? void 0 : _b.parent;\n        if (grandparent && grandparent.type === 'list') {\n            if (grandparent.listData.tight) {\n                return null;\n            }\n        }\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'p',\n            outerNewLine: true,\n        };\n    },\n    thematicBreak: function () {\n        return {\n            type: 'openTag',\n            tagName: 'hr',\n            outerNewLine: true,\n            selfClose: true,\n        };\n    },\n    blockQuote: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'blockquote',\n            outerNewLine: true,\n            innerNewLine: true,\n        };\n    },\n    list: function (node, _a) {\n        var entering = _a.entering;\n        var _b = node.listData, type = _b.type, start = _b.start;\n        var tagName = type === 'bullet' ? 'ul' : 'ol';\n        var attributes = {};\n        if (tagName === 'ol' && start !== null && start !== 1) {\n            attributes.start = start.toString();\n        }\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: tagName,\n            attributes: attributes,\n            outerNewLine: true,\n        };\n    },\n    item: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    htmlInline: function (node, _a) {\n        var options = _a.options;\n        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;\n        return { type: 'html', content: content };\n    },\n    htmlBlock: function (node, _a) {\n        var options = _a.options;\n        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;\n        if (options.nodeId) {\n            return [\n                { type: 'openTag', tagName: 'div', outerNewLine: true },\n                { type: 'html', content: content },\n                { type: 'closeTag', tagName: 'div', outerNewLine: true },\n            ];\n        }\n        return { type: 'html', content: content, outerNewLine: true };\n    },\n    code: function (node) {\n        return [\n            { type: 'openTag', tagName: 'code' },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n        ];\n    },\n    codeBlock: function (node) {\n        var infoStr = node.info;\n        var infoWords = infoStr ? infoStr.split(/\\s+/) : [];\n        var codeClassNames = [];\n        if (infoWords.length > 0 && infoWords[0].length > 0) {\n            codeClassNames.push(\"language-\" + escapeXml(infoWords[0]));\n        }\n        return [\n            { type: 'openTag', tagName: 'pre', outerNewLine: true },\n            { type: 'openTag', tagName: 'code', classNames: codeClassNames },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n            { type: 'closeTag', tagName: 'pre', outerNewLine: true },\n        ];\n    },\n    link: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            var _b = node, title = _b.title, destination = _b.destination;\n            return {\n                type: 'openTag',\n                tagName: 'a',\n                attributes: __assign({ href: escapeXml(destination) }, (title && { title: escapeXml(title) })),\n            };\n        }\n        return { type: 'closeTag', tagName: 'a' };\n    },\n    image: function (node, _a) {\n        var getChildrenText = _a.getChildrenText, skipChildren = _a.skipChildren;\n        var _b = node, title = _b.title, destination = _b.destination;\n        skipChildren();\n        return {\n            type: 'openTag',\n            tagName: 'img',\n            selfClose: true,\n            attributes: __assign({ src: escapeXml(destination), alt: getChildrenText(node) }, (title && { title: escapeXml(title) })),\n        };\n    },\n    customBlock: function (node, context, convertors) {\n        var info = node.info.trim().toLowerCase();\n        var customConvertor = convertors[info];\n        if (customConvertor) {\n            try {\n                return customConvertor(node, context);\n            }\n            catch (e) {\n                console.warn(\"[@toast-ui/editor] - The error occurred when \" + info + \" block node was parsed in markdown renderer: \" + e);\n            }\n        }\n        return [\n            { type: 'openTag', tagName: 'div', outerNewLine: true },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'div', outerNewLine: true },\n        ];\n    },\n    frontMatter: function (node) {\n        return [\n            {\n                type: 'openTag',\n                tagName: 'div',\n                outerNewLine: true,\n                // Because front matter is metadata, it should not be render.\n                attributes: { style: 'white-space: pre; display: none;' },\n            },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'div', outerNewLine: true },\n        ];\n    },\n    customInline: function (node, context, convertors) {\n        var _a = node, info = _a.info, firstChild = _a.firstChild;\n        var nomalizedInfo = info.trim().toLowerCase();\n        var customConvertor = convertors[nomalizedInfo];\n        var entering = context.entering;\n        if (customConvertor) {\n            try {\n                return customConvertor(node, context);\n            }\n            catch (e) {\n                console.warn(\"[@toast-ui/editor] - The error occurred when \" + nomalizedInfo + \" inline node was parsed in markdown renderer: \" + e);\n            }\n        }\n        return entering\n            ? [\n                { type: 'openTag', tagName: 'span' },\n                { type: 'text', content: \"$$\" + info + (firstChild ? ' ' : '') },\n            ]\n            : [\n                { type: 'text', content: '$$' },\n                { type: 'closeTag', tagName: 'span' },\n            ];\n    },\n};\n\nvar gfmConvertors = {\n    strike: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'del',\n        };\n    },\n    item: function (node, _a) {\n        var entering = _a.entering;\n        var _b = node.listData, checked = _b.checked, task = _b.task;\n        if (entering) {\n            var itemTag = {\n                type: 'openTag',\n                tagName: 'li',\n                outerNewLine: true,\n            };\n            if (task) {\n                return [\n                    itemTag,\n                    {\n                        type: 'openTag',\n                        tagName: 'input',\n                        selfClose: true,\n                        attributes: __assign(__assign({}, (checked && { checked: '' })), { disabled: '', type: 'checkbox' }),\n                    },\n                    {\n                        type: 'text',\n                        content: ' ',\n                    },\n                ];\n            }\n            return itemTag;\n        }\n        return {\n            type: 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    table: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'table',\n            outerNewLine: true,\n        };\n    },\n    tableHead: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'thead',\n            outerNewLine: true,\n        };\n    },\n    tableBody: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'tbody',\n            outerNewLine: true,\n        };\n    },\n    tableRow: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            return {\n                type: 'openTag',\n                tagName: 'tr',\n                outerNewLine: true,\n            };\n        }\n        var result = [];\n        if (node.lastChild) {\n            var columnLen = node.parent.parent.columns.length;\n            var lastColIdx = node.lastChild.endIdx;\n            for (var i = lastColIdx + 1; i < columnLen; i += 1) {\n                result.push({\n                    type: 'openTag',\n                    tagName: 'td',\n                    outerNewLine: true,\n                }, {\n                    type: 'closeTag',\n                    tagName: 'td',\n                    outerNewLine: true,\n                });\n            }\n        }\n        result.push({\n            type: 'closeTag',\n            tagName: 'tr',\n            outerNewLine: true,\n        });\n        return result;\n    },\n    tableCell: function (node, _a) {\n        var entering = _a.entering;\n        if (node.ignored) {\n            return {\n                type: 'text',\n                content: '',\n            };\n        }\n        var tablePart = node.parent.parent;\n        var tagName = tablePart.type === 'tableHead' ? 'th' : 'td';\n        var table = tablePart.parent;\n        var columnInfo = table.columns[node.startIdx];\n        var attributes = (columnInfo === null || columnInfo === void 0 ? void 0 : columnInfo.align) ? { align: columnInfo.align } : null;\n        if (entering) {\n            return __assign({ type: 'openTag', tagName: tagName, outerNewLine: true }, (attributes && { attributes: attributes }));\n        }\n        return {\n            type: 'closeTag',\n            tagName: tagName,\n            outerNewLine: true,\n        };\n    },\n};\n\nvar defaultOptions = {\n    softbreak: '\\n',\n    gfm: false,\n    tagFilter: false,\n    nodeId: false,\n};\nfunction getChildrenText(node) {\n    var buffer = [];\n    var walker = node.walker();\n    var event = null;\n    while ((event = walker.next())) {\n        var node_1 = event.node;\n        if (node_1.type === 'text') {\n            buffer.push(node_1.literal);\n        }\n    }\n    return buffer.join('');\n}\nvar Renderer = /** @class */ (function () {\n    function Renderer(customOptions) {\n        this.buffer = [];\n        this.options = __assign(__assign({}, defaultOptions), customOptions);\n        this.convertors = this.createConvertors();\n        delete this.options.convertors;\n    }\n    Renderer.prototype.createConvertors = function () {\n        var convertors = __assign({}, baseConvertors$1);\n        if (this.options.gfm) {\n            convertors = __assign(__assign({}, convertors), gfmConvertors);\n        }\n        if (this.options.convertors) {\n            var customConvertors_1 = this.options.convertors;\n            var nodeTypes = Object.keys(customConvertors_1);\n            var defaultConvertors_1 = __assign(__assign({}, baseConvertors$1), gfmConvertors);\n            nodeTypes.forEach(function (nodeType) {\n                var orgConvertor = convertors[nodeType];\n                var convertor = customConvertors_1[nodeType];\n                var convertorType = Object.keys(defaultConvertors_1).indexOf(nodeType) === -1\n                    ? nodeType.toLowerCase()\n                    : nodeType;\n                if (orgConvertor) {\n                    convertors[convertorType] = function (node, context, convertors) {\n                        context.origin = function () { return orgConvertor(node, context, convertors); };\n                        return convertor(node, context);\n                    };\n                }\n                else {\n                    convertors[convertorType] = convertor;\n                }\n            });\n        }\n        return convertors;\n    };\n    Renderer.prototype.getConvertors = function () {\n        return this.convertors;\n    };\n    Renderer.prototype.getOptions = function () {\n        return this.options;\n    };\n    Renderer.prototype.render = function (rootNode) {\n        var _this = this;\n        this.buffer = [];\n        var walker = rootNode.walker();\n        var event = null;\n        var _loop_1 = function () {\n            var node = event.node, entering = event.entering;\n            var convertor = this_1.convertors[node.type];\n            if (!convertor) {\n                return \"continue\";\n            }\n            var skipped = false;\n            var context = {\n                entering: entering,\n                leaf: !isContainer$1(node),\n                options: this_1.options,\n                getChildrenText: getChildrenText,\n                skipChildren: function () {\n                    skipped = true;\n                },\n            };\n            var converted = isCustomBlock(node) || isCustomInline(node)\n                ? convertor(node, context, this_1.convertors)\n                : convertor(node, context);\n            if (converted) {\n                var htmlNodes = Array.isArray(converted) ? converted : [converted];\n                htmlNodes.forEach(function (htmlNode, index) {\n                    if (htmlNode.type === 'openTag' && _this.options.nodeId && index === 0) {\n                        if (!htmlNode.attributes) {\n                            htmlNode.attributes = {};\n                        }\n                        htmlNode.attributes['data-nodeid'] = String(node.id);\n                    }\n                    _this.renderHTMLNode(htmlNode);\n                });\n                if (skipped) {\n                    walker.resumeAt(node, false);\n                    walker.next();\n                }\n            }\n        };\n        var this_1 = this;\n        while ((event = walker.next())) {\n            _loop_1();\n        }\n        this.addNewLine();\n        return this.buffer.join('');\n    };\n    Renderer.prototype.renderHTMLNode = function (node) {\n        switch (node.type) {\n            case 'openTag':\n            case 'closeTag':\n                this.renderElementNode(node);\n                break;\n            case 'text':\n                this.renderTextNode(node);\n                break;\n            case 'html':\n                this.renderRawHtmlNode(node);\n                break;\n            // no-default-case\n        }\n    };\n    Renderer.prototype.generateOpenTagString = function (node) {\n        var _this = this;\n        var tagName = node.tagName, classNames = node.classNames, attributes = node.attributes;\n        this.buffer.push(\"<\" + tagName);\n        if (classNames && classNames.length > 0) {\n            this.buffer.push(\" class=\\\"\" + classNames.join(' ') + \"\\\"\");\n        }\n        if (attributes) {\n            Object.keys(attributes).forEach(function (attrName) {\n                var attrValue = attributes[attrName];\n                _this.buffer.push(\" \" + attrName + \"=\\\"\" + attrValue + \"\\\"\");\n            });\n        }\n        if (node.selfClose) {\n            this.buffer.push(' /');\n        }\n        this.buffer.push('>');\n    };\n    Renderer.prototype.generateCloseTagString = function (_a) {\n        var tagName = _a.tagName;\n        this.buffer.push(\"</\" + tagName + \">\");\n    };\n    Renderer.prototype.addNewLine = function () {\n        if (this.buffer.length && last(last(this.buffer)) !== '\\n') {\n            this.buffer.push('\\n');\n        }\n    };\n    Renderer.prototype.addOuterNewLine = function (node) {\n        if (node.outerNewLine) {\n            this.addNewLine();\n        }\n    };\n    Renderer.prototype.addInnerNewLine = function (node) {\n        if (node.innerNewLine) {\n            this.addNewLine();\n        }\n    };\n    Renderer.prototype.renderTextNode = function (node) {\n        this.buffer.push(escapeXml(node.content));\n    };\n    Renderer.prototype.renderRawHtmlNode = function (node) {\n        this.addOuterNewLine(node);\n        this.buffer.push(node.content);\n        this.addOuterNewLine(node);\n    };\n    Renderer.prototype.renderElementNode = function (node) {\n        if (node.type === 'openTag') {\n            this.addOuterNewLine(node);\n            this.generateOpenTagString(node);\n            if (node.selfClose) {\n                this.addOuterNewLine(node);\n            }\n            else {\n                this.addInnerNewLine(node);\n            }\n        }\n        else {\n            this.addInnerNewLine(node);\n            this.generateCloseTagString(node);\n            this.addOuterNewLine(node);\n        }\n    };\n    return Renderer;\n}());\n\n/*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar hasOwnProperty = Object.hasOwnProperty,\n    setPrototypeOf = Object.setPrototypeOf,\n    isFrozen = Object.isFrozen,\n    getPrototypeOf = Object.getPrototypeOf,\n    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar freeze = Object.freeze,\n    seal = Object.seal,\n    create = Object.create; // eslint-disable-line import/no-mutable-exports\n\nvar _ref = typeof Reflect !== 'undefined' && Reflect,\n    apply = _ref.apply,\n    construct = _ref.construct;\n\nif (!apply) {\n  apply = function apply(fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\n\nif (!freeze) {\n  freeze = function freeze(x) {\n    return x;\n  };\n}\n\nif (!seal) {\n  seal = function seal(x) {\n    return x;\n  };\n}\n\nif (!construct) {\n  construct = function construct(Func, args) {\n    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n  };\n}\n\nvar arrayForEach = unapply(Array.prototype.forEach);\nvar arrayPop = unapply(Array.prototype.pop);\nvar arrayPush = unapply(Array.prototype.push);\n\nvar stringToLowerCase = unapply(String.prototype.toLowerCase);\nvar stringMatch = unapply(String.prototype.match);\nvar stringReplace = unapply(String.prototype.replace);\nvar stringIndexOf = unapply(String.prototype.indexOf);\nvar stringTrim = unapply(String.prototype.trim);\n\nvar regExpTest = unapply(RegExp.prototype.test);\n\nvar typeErrorCreate = unconstruct(TypeError);\n\nfunction unapply(func) {\n  return function (thisArg) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return apply(func, thisArg, args);\n  };\n}\n\nfunction unconstruct(func) {\n  return function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return construct(func, args);\n  };\n}\n\n/* Add properties to a lookup table */\nfunction addToSet(set, array) {\n  if (setPrototypeOf) {\n    // Make 'in' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n\n  var l = array.length;\n  while (l--) {\n    var element = array[l];\n    if (typeof element === 'string') {\n      var lcElement = stringToLowerCase(element);\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!isFrozen(array)) {\n          array[l] = lcElement;\n        }\n\n        element = lcElement;\n      }\n    }\n\n    set[element] = true;\n  }\n\n  return set;\n}\n\n/* Shallow clone an object */\nfunction clone(object) {\n  var newObject = create(null);\n\n  var property = void 0;\n  for (property in object) {\n    if (apply(hasOwnProperty, object, [property])) {\n      newObject[property] = object[property];\n    }\n  }\n\n  return newObject;\n}\n\n/* IE10 doesn't support __lookupGetter__ so lets'\n * simulate it. It also automatically checks\n * if the prop is function or getter and behaves\n * accordingly. */\nfunction lookupGetter(object, prop) {\n  while (object !== null) {\n    var desc = getOwnPropertyDescriptor(object, prop);\n    if (desc) {\n      if (desc.get) {\n        return unapply(desc.get);\n      }\n\n      if (typeof desc.value === 'function') {\n        return unapply(desc.value);\n      }\n    }\n\n    object = getPrototypeOf(object);\n  }\n\n  function fallbackValue(element) {\n    console.warn('fallback value for', element);\n    return null;\n  }\n\n  return fallbackValue;\n}\n\nvar html$2 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n// SVG\nvar svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n\nvar svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nvar svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n\nvar mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nvar mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n\nvar text = freeze(['#text']);\n\nvar html$1$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n\nvar svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n\nvar mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n\nvar xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n// eslint-disable-next-line unicorn/better-regex\nvar MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nvar ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\nvar DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\nvar ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nvar IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nvar IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nvar ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar getGlobal = function getGlobal() {\n  return typeof window === 'undefined' ? null : window;\n};\n\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n * @param {Document} document The document object (to determine policy name suffix)\n * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n * are not supported).\n */\nvar _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n    return null;\n  }\n\n  // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n  var suffix = null;\n  var ATTR_NAME = 'data-tt-policy-suffix';\n  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n    suffix = document.currentScript.getAttribute(ATTR_NAME);\n  }\n\n  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML: function createHTML(html$$1) {\n        return html$$1;\n      }\n    });\n  } catch (_) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n    return null;\n  }\n};\n\nfunction createDOMPurify() {\n  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n  var DOMPurify = function DOMPurify(root) {\n    return createDOMPurify(root);\n  };\n\n  /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */\n  DOMPurify.version = '2.3.3';\n\n  /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */\n  DOMPurify.removed = [];\n\n  if (!window || !window.document || window.document.nodeType !== 9) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n\n    return DOMPurify;\n  }\n\n  var originalDocument = window.document;\n\n  var document = window.document;\n  var DocumentFragment = window.DocumentFragment,\n      HTMLTemplateElement = window.HTMLTemplateElement,\n      Node = window.Node,\n      Element = window.Element,\n      NodeFilter = window.NodeFilter,\n      _window$NamedNodeMap = window.NamedNodeMap,\n      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n      Text = window.Text,\n      Comment = window.Comment,\n      DOMParser = window.DOMParser,\n      trustedTypes = window.trustedTypes;\n\n\n  var ElementPrototype = Element.prototype;\n\n  var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n  var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n  var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n  var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n  // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n  if (typeof HTMLTemplateElement === 'function') {\n    var template = document.createElement('template');\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n\n  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n  var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';\n\n  var _document = document,\n      implementation = _document.implementation,\n      createNodeIterator = _document.createNodeIterator,\n      createDocumentFragment = _document.createDocumentFragment,\n      getElementsByTagName = _document.getElementsByTagName;\n  var importNode = originalDocument.importNode;\n\n\n  var documentMode = {};\n  try {\n    documentMode = clone(document).documentMode ? document.documentMode : {};\n  } catch (_) {}\n\n  var hooks = {};\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n\n  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n      ERB_EXPR$$1 = ERB_EXPR,\n      DATA_ATTR$$1 = DATA_ATTR,\n      ARIA_ATTR$$1 = ARIA_ATTR,\n      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */\n\n  /* allowed element names */\n\n  var ALLOWED_TAGS = null;\n  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html$2), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n\n  /* Allowed attribute names */\n  var ALLOWED_ATTR = null;\n  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n  var FORBID_TAGS = null;\n\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n  var FORBID_ATTR = null;\n\n  /* Decide if ARIA attributes are okay */\n  var ALLOW_ARIA_ATTR = true;\n\n  /* Decide if custom data attributes are okay */\n  var ALLOW_DATA_ATTR = true;\n\n  /* Decide if unknown protocols are okay */\n  var ALLOW_UNKNOWN_PROTOCOLS = false;\n\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n  var SAFE_FOR_TEMPLATES = false;\n\n  /* Decide if document with <html>... should be returned */\n  var WHOLE_DOCUMENT = false;\n\n  /* Track whether config is already set on this instance of DOMPurify. */\n  var SET_CONFIG = false;\n\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n  var FORCE_BODY = false;\n\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n  var RETURN_DOM = false;\n\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n  var RETURN_DOM_FRAGMENT = false;\n\n  /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n   * `Node` is imported into the current `Document`. If this flag is not enabled the\n   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n   * DOMPurify.\n   *\n   * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`\n   * might cause XSS from attacks hidden in closed shadowroots in case the browser\n   * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/\n   */\n  var RETURN_DOM_IMPORT = true;\n\n  /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */\n  var RETURN_TRUSTED_TYPE = false;\n\n  /* Output should be free from DOM clobbering attacks? */\n  var SANITIZE_DOM = true;\n\n  /* Keep element content when removing element? */\n  var KEEP_CONTENT = true;\n\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n  var IN_PLACE = false;\n\n  /* Allow usage of profiles like html, svg and mathMl */\n  var USE_PROFILES = {};\n\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n  var FORBID_CONTENTS = null;\n  var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n  /* Tags that are safe for data: URIs */\n  var DATA_URI_TAGS = null;\n  var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n  /* Attributes safe for values like \"javascript:\" */\n  var URI_SAFE_ATTRIBUTES = null;\n  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n\n  var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n  var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n  /* Document namespace */\n  var NAMESPACE = HTML_NAMESPACE;\n  var IS_EMPTY_INPUT = false;\n\n  /* Parsing of strict XHTML documents */\n  var PARSER_MEDIA_TYPE = void 0;\n  var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n  var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n  var transformCaseFunc = void 0;\n\n  /* Keep a reference to config to pass to hooks */\n  var CONFIG = null;\n\n  /* Ideally, do not touch anything below this line */\n  /* ______________________________________________ */\n\n  var formElement = document.createElement('form');\n\n  /**\n   * _parseConfig\n   *\n   * @param  {Object} cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n  var _parseConfig = function _parseConfig(cfg) {\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n\n    /* Shield configuration object from tampering */\n    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n      cfg = {};\n    }\n\n    /* Shield configuration object from prototype pollution */\n    cfg = clone(cfg);\n\n    /* Set configuration parameters */\n    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n    DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n    FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;\n    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n\n    PARSER_MEDIA_TYPE =\n    // eslint-disable-next-line unicorn/prefer-includes\n    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n\n    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {\n      return x;\n    } : stringToLowerCase;\n\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n\n    /* Parse profile info */\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, html$2);\n        addToSet(ALLOWED_ATTR, html$1$1);\n      }\n\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, svg);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, svgFilters);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, mathMl);\n        addToSet(ALLOWED_ATTR, mathMl$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n    }\n\n    /* Merge configuration parameters */\n    if (cfg.ADD_TAGS) {\n      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n        ALLOWED_TAGS = clone(ALLOWED_TAGS);\n      }\n\n      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n    }\n\n    if (cfg.ADD_ATTR) {\n      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n        ALLOWED_ATTR = clone(ALLOWED_ATTR);\n      }\n\n      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n    }\n\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n    }\n\n    if (cfg.FORBID_CONTENTS) {\n      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n        FORBID_CONTENTS = clone(FORBID_CONTENTS);\n      }\n\n      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);\n    }\n\n    /* Add #text in case KEEP_CONTENT is set to true */\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS['#text'] = true;\n    }\n\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n    }\n\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, ['tbody']);\n      delete FORBID_TAGS.tbody;\n    }\n\n    // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n    if (freeze) {\n      freeze(cfg);\n    }\n\n    CONFIG = cfg;\n  };\n\n  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n\n  var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);\n\n  /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */\n  var ALL_SVG_TAGS = addToSet({}, svg);\n  addToSet(ALL_SVG_TAGS, svgFilters);\n  addToSet(ALL_SVG_TAGS, svgDisallowed);\n\n  var ALL_MATHML_TAGS = addToSet({}, mathMl);\n  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n\n  /**\n   *\n   *\n   * @param  {Element} element a DOM element whose namespace is being checked\n   * @returns {boolean} Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */\n  var _checkValidNamespace = function _checkValidNamespace(element) {\n    var parent = getParentNode(element);\n\n    // In JSDOM, if we're inside shadow DOM, then parentNode\n    // can be null. We just simulate parent in this case.\n    if (!parent || !parent.tagName) {\n      parent = {\n        namespaceURI: HTML_NAMESPACE,\n        tagName: 'template'\n      };\n    }\n\n    var tagName = stringToLowerCase(element.tagName);\n    var parentTagName = stringToLowerCase(parent.tagName);\n\n    if (element.namespaceURI === SVG_NAMESPACE) {\n      // The only way to switch from HTML namespace to SVG\n      // is via <svg>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'svg';\n      }\n\n      // The only way to switch from MathML to SVG is via\n      // svg if parent is either <annotation-xml> or MathML\n      // text integration points.\n      if (parent.namespaceURI === MATHML_NAMESPACE) {\n        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n      }\n\n      // We only allow elements that are defined in SVG\n      // spec. All others are disallowed in SVG namespace.\n      return Boolean(ALL_SVG_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === MATHML_NAMESPACE) {\n      // The only way to switch from HTML namespace to MathML\n      // is via <math>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'math';\n      }\n\n      // The only way to switch from SVG to MathML is via\n      // <math> and HTML integration points\n      if (parent.namespaceURI === SVG_NAMESPACE) {\n        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n      }\n\n      // We only allow elements that are defined in MathML\n      // spec. All others are disallowed in MathML namespace.\n      return Boolean(ALL_MATHML_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === HTML_NAMESPACE) {\n      // The only way to switch from SVG to HTML is via\n      // HTML integration points, and from MathML to HTML\n      // is via MathML text integration points\n      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n\n      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n\n      // Certain elements are allowed in both SVG and HTML\n      // namespace. We need to specify them explicitly\n      // so that they don't get erronously deleted from\n      // HTML namespace.\n      var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n\n      // We disallow tags that are specific for MathML\n      // or SVG and should never appear in HTML namespace\n      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);\n    }\n\n    // The code should never reach this place (this means\n    // that the element somehow got namespace that is not\n    // HTML, SVG or MathML). Return false just in case.\n    return false;\n  };\n\n  /**\n   * _forceRemove\n   *\n   * @param  {Node} node a DOM node\n   */\n  var _forceRemove = function _forceRemove(node) {\n    arrayPush(DOMPurify.removed, { element: node });\n    try {\n      // eslint-disable-next-line unicorn/prefer-dom-node-remove\n      node.parentNode.removeChild(node);\n    } catch (_) {\n      try {\n        node.outerHTML = emptyHTML;\n      } catch (_) {\n        node.remove();\n      }\n    }\n  };\n\n  /**\n   * _removeAttribute\n   *\n   * @param  {String} name an Attribute name\n   * @param  {Node} node a DOM node\n   */\n  var _removeAttribute = function _removeAttribute(name, node) {\n    try {\n      arrayPush(DOMPurify.removed, {\n        attribute: node.getAttributeNode(name),\n        from: node\n      });\n    } catch (_) {\n      arrayPush(DOMPurify.removed, {\n        attribute: null,\n        from: node\n      });\n    }\n\n    node.removeAttribute(name);\n\n    // We void attribute values for unremovable \"is\"\" attributes\n    if (name === 'is' && !ALLOWED_ATTR[name]) {\n      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n        try {\n          _forceRemove(node);\n        } catch (_) {}\n      } else {\n        try {\n          node.setAttribute(name, '');\n        } catch (_) {}\n      }\n    }\n  };\n\n  /**\n   * _initDocument\n   *\n   * @param  {String} dirty a string of dirty markup\n   * @return {Document} a DOM, filled with the dirty markup\n   */\n  var _initDocument = function _initDocument(dirty) {\n    /* Create a HTML document */\n    var doc = void 0;\n    var leadingWhitespace = void 0;\n\n    if (FORCE_BODY) {\n      dirty = '<remove></remove>' + dirty;\n    } else {\n      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n      var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n      leadingWhitespace = matches && matches[0];\n    }\n\n    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {\n      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n      dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n    }\n\n    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n    /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      try {\n        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n      } catch (_) {}\n    }\n\n    /* Use createHTMLDocument in case DOMParser is not available */\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createDocument(NAMESPACE, 'template', null);\n      try {\n        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;\n      } catch (_) {\n        // Syntax error if dirtyPayload is invalid xml\n      }\n    }\n\n    var body = doc.body || doc.documentElement;\n\n    if (dirty && leadingWhitespace) {\n      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n    }\n\n    /* Work on whole document or just its body */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n    }\n\n    return WHOLE_DOCUMENT ? doc.documentElement : body;\n  };\n\n  /**\n   * _createIterator\n   *\n   * @param  {Document} root document/fragment to create iterator for\n   * @return {Iterator} iterator instance\n   */\n  var _createIterator = function _createIterator(root) {\n    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n  };\n\n  /**\n   * _isClobbered\n   *\n   * @param  {Node} elm element to check for clobbering attacks\n   * @return {Boolean} true if clobbered, false if safe\n   */\n  var _isClobbered = function _isClobbered(elm) {\n    if (elm instanceof Text || elm instanceof Comment) {\n      return false;\n    }\n\n    if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * _isNode\n   *\n   * @param  {Node} obj object to check whether it's a DOM node\n   * @return {Boolean} true is object is a DOM node\n   */\n  var _isNode = function _isNode(object) {\n    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n  };\n\n  /**\n   * _executeHook\n   * Execute user configurable hooks\n   *\n   * @param  {String} entryPoint  Name of the hook's entry point\n   * @param  {Node} currentNode node to work on with the hook\n   * @param  {Object} data additional hook parameters\n   */\n  var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n    if (!hooks[entryPoint]) {\n      return;\n    }\n\n    arrayForEach(hooks[entryPoint], function (hook) {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  };\n\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   *\n   * @param   {Node} currentNode to check for permission to exist\n   * @return  {Boolean} true if node was killed, false if left alive\n   */\n  var _sanitizeElements = function _sanitizeElements(currentNode) {\n    var content = void 0;\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeElements', currentNode, null);\n\n    /* Check if element is clobbered or can clobber */\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check if tagname contains Unicode */\n    if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Now let's check the element's type and name */\n    var tagName = transformCaseFunc(currentNode.nodeName);\n\n    /* Execute a hook if present */\n    _executeHook('uponSanitizeElement', currentNode, {\n      tagName: tagName,\n      allowedTags: ALLOWED_TAGS\n    });\n\n    /* Detect mXSS attempts abusing namespace confusion */\n    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Mitigate a problem with templates inside select */\n    if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove element if anything forbids its presence */\n    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n      /* Keep content except for bad-listed elements */\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n        var parentNode = getParentNode(currentNode) || currentNode.parentNode;\n        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n        if (childNodes && parentNode) {\n          var childCount = childNodes.length;\n\n          for (var i = childCount - 1; i >= 0; --i) {\n            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n          }\n        }\n      }\n\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check whether element has a valid namespace */\n    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Sanitize element content to be template-safe */\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n      /* Get the element's text content */\n      content = currentNode.textContent;\n      content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n      content = stringReplace(content, ERB_EXPR$$1, ' ');\n      if (currentNode.textContent !== content) {\n        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n        currentNode.textContent = content;\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeElements', currentNode, null);\n\n    return false;\n  };\n\n  /**\n   * _isValidAttribute\n   *\n   * @param  {string} lcTag Lowercase tag name of containing element.\n   * @param  {string} lcName Lowercase attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n    /* Make sure attribute cannot clobber */\n    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n      return false;\n    }\n\n    /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */\n    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      return false;\n\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {\n      return false;\n    }\n\n    return true;\n  };\n\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param  {Node} currentNode to sanitize\n   */\n  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n    var attr = void 0;\n    var value = void 0;\n    var lcName = void 0;\n    var l = void 0;\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n    var attributes = currentNode.attributes;\n\n    /* Check if we have attributes; if not we might have a text node */\n\n    if (!attributes) {\n      return;\n    }\n\n    var hookEvent = {\n      attrName: '',\n      attrValue: '',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR\n    };\n    l = attributes.length;\n\n    /* Go backwards over all attributes; safely remove bad ones */\n    while (l--) {\n      attr = attributes[l];\n      var _attr = attr,\n          name = _attr.name,\n          namespaceURI = _attr.namespaceURI;\n\n      value = stringTrim(attr.value);\n      lcName = transformCaseFunc(name);\n\n      /* Execute a hook if present */\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n      value = hookEvent.attrValue;\n      /* Did the hooks approve of the attribute? */\n      if (hookEvent.forceKeepAttr) {\n        continue;\n      }\n\n      /* Remove attribute */\n      _removeAttribute(name, currentNode);\n\n      /* Did the hooks approve of the attribute? */\n      if (!hookEvent.keepAttr) {\n        continue;\n      }\n\n      /* Work around a security issue in jQuery 3.0 */\n      if (regExpTest(/\\/>/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Sanitize attribute content to be template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n        value = stringReplace(value, ERB_EXPR$$1, ' ');\n      }\n\n      /* Is `value` valid for this attribute? */\n      var lcTag = transformCaseFunc(currentNode.nodeName);\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        continue;\n      }\n\n      /* Handle invalid data-* attribute set by try-catching it */\n      try {\n        if (namespaceURI) {\n          currentNode.setAttributeNS(namespaceURI, name, value);\n        } else {\n          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n          currentNode.setAttribute(name, value);\n        }\n\n        arrayPop(DOMPurify.removed);\n      } catch (_) {}\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeAttributes', currentNode, null);\n  };\n\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param  {DocumentFragment} fragment to iterate over recursively\n   */\n  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n    var shadowNode = void 0;\n    var shadowIterator = _createIterator(fragment);\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n    while (shadowNode = shadowIterator.nextNode()) {\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(shadowNode)) {\n        continue;\n      }\n\n      /* Deep shadow DOM detected */\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(shadowNode);\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeShadowDOM', fragment, null);\n  };\n\n  /**\n   * Sanitize\n   * Public method providing core sanitation functionality\n   *\n   * @param {String|Node} dirty string or DOM node\n   * @param {Object} configuration object\n   */\n  // eslint-disable-next-line complexity\n  DOMPurify.sanitize = function (dirty, cfg) {\n    var body = void 0;\n    var importedNode = void 0;\n    var currentNode = void 0;\n    var oldNode = void 0;\n    var returnNode = void 0;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n    IS_EMPTY_INPUT = !dirty;\n    if (IS_EMPTY_INPUT) {\n      dirty = '<!-->';\n    }\n\n    /* Stringify, in case dirty is an object */\n    if (typeof dirty !== 'string' && !_isNode(dirty)) {\n      // eslint-disable-next-line no-negated-condition\n      if (typeof dirty.toString !== 'function') {\n        throw typeErrorCreate('toString is not a function');\n      } else {\n        dirty = dirty.toString();\n        if (typeof dirty !== 'string') {\n          throw typeErrorCreate('dirty is not a string, aborting');\n        }\n      }\n    }\n\n    /* Check we can run. Otherwise fall back or ignore */\n    if (!DOMPurify.isSupported) {\n      if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n        if (typeof dirty === 'string') {\n          return window.toStaticHTML(dirty);\n        }\n\n        if (_isNode(dirty)) {\n          return window.toStaticHTML(dirty.outerHTML);\n        }\n      }\n\n      return dirty;\n    }\n\n    /* Assign config vars */\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n\n    /* Clean up removed elements */\n    DOMPurify.removed = [];\n\n    /* Check if dirty is correctly typed for IN_PLACE */\n    if (typeof dirty === 'string') {\n      IN_PLACE = false;\n    }\n\n    if (IN_PLACE) ; else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument('<!---->');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === 'HTML') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-dom-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n      // eslint-disable-next-line unicorn/prefer-includes\n      dirty.indexOf('<') === -1) {\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      }\n\n      /* Initialize the document to work on */\n      body = _initDocument(dirty);\n\n      /* Check we have a DOM node from the data */\n      if (!body) {\n        return RETURN_DOM ? null : emptyHTML;\n      }\n    }\n\n    /* Remove first element node (ours) if FORCE_BODY is set */\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n\n    /* Get node iterator */\n    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n    /* Now start iterating over the created document */\n    while (currentNode = nodeIterator.nextNode()) {\n      /* Fix IE's strange behavior with manipulated textNodes #89 */\n      if (currentNode.nodeType === 3 && currentNode === oldNode) {\n        continue;\n      }\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(currentNode)) {\n        continue;\n      }\n\n      /* Shadow DOM detected, sanitize it */\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(currentNode);\n\n      oldNode = currentNode;\n    }\n\n    oldNode = null;\n\n    /* If we sanitized `dirty` in-place, return it. */\n    if (IN_PLACE) {\n      return dirty;\n    }\n\n    /* Return sanitized string or DOM */\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n\n      if (RETURN_DOM_IMPORT) {\n        /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n\n      return returnNode;\n    }\n\n    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n    /* Sanitize final string template-safe */\n    if (SAFE_FOR_TEMPLATES) {\n      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n    }\n\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n  };\n\n  /**\n   * Public method to set the configuration once\n   * setConfig\n   *\n   * @param {Object} cfg configuration object\n   */\n  DOMPurify.setConfig = function (cfg) {\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n\n  /**\n   * Public method to remove the configuration\n   * clearConfig\n   *\n   */\n  DOMPurify.clearConfig = function () {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n\n  /**\n   * Public method to check if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   * isValidAttribute\n   *\n   * @param  {string} tag Tag name of containing element.\n   * @param  {string} attr Attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n   */\n  DOMPurify.isValidAttribute = function (tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n\n    var lcTag = transformCaseFunc(tag);\n    var lcName = transformCaseFunc(attr);\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n\n  /**\n   * AddHook\n   * Public method to add DOMPurify hooks\n   *\n   * @param {String} entryPoint entry point for the hook to add\n   * @param {Function} hookFunction function to execute\n   */\n  DOMPurify.addHook = function (entryPoint, hookFunction) {\n    if (typeof hookFunction !== 'function') {\n      return;\n    }\n\n    hooks[entryPoint] = hooks[entryPoint] || [];\n    arrayPush(hooks[entryPoint], hookFunction);\n  };\n\n  /**\n   * RemoveHook\n   * Public method to remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if more are present)\n   *\n   * @param {String} entryPoint entry point for the hook to remove\n   */\n  DOMPurify.removeHook = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      arrayPop(hooks[entryPoint]);\n    }\n  };\n\n  /**\n   * RemoveHooks\n   * Public method to remove all DOMPurify hooks at a given entryPoint\n   *\n   * @param  {String} entryPoint entry point for the hooks to remove\n   */\n  DOMPurify.removeHooks = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint] = [];\n    }\n  };\n\n  /**\n   * RemoveAllHooks\n   * Public method to remove all DOMPurify hooks\n   *\n   */\n  DOMPurify.removeAllHooks = function () {\n    hooks = {};\n  };\n\n  return DOMPurify;\n}\n\nvar purify = createDOMPurify();\n\nvar CAN_BE_WHITE_TAG_LIST = ['iframe', 'embed'];\nvar whiteTagList = [];\nfunction registerTagWhitelistIfPossible(tagName) {\n    if (includes(CAN_BE_WHITE_TAG_LIST, tagName)) {\n        whiteTagList.push(tagName.toLowerCase());\n    }\n}\nfunction sanitizeHTML(html, options) {\n    return purify.sanitize(html, __assign$1({ ADD_TAGS: whiteTagList, ADD_ATTR: ['rel', 'target', 'hreflang', 'type'], FORBID_TAGS: [\n            'input',\n            'script',\n            'textarea',\n            'form',\n            'button',\n            'select',\n            'meta',\n            'style',\n            'link',\n            'title',\n            'object',\n            'base',\n        ] }, options));\n}\n\nfunction getChildrenHTML(node, typeName) {\n    return node\n        .literal.replace(new RegExp(\"(<\\\\s*\" + typeName + \"[^>]*>)|(</\" + typeName + \"\\\\s*[>])\", 'ig'), '')\n        .trim();\n}\nfunction getHTMLAttrsByHTMLString(html) {\n    html = html.match(reHTMLTag)[0];\n    var attrs = html.match(new RegExp(ATTRIBUTE$1, 'g'));\n    return attrs\n        ? attrs.reduce(function (acc, attr) {\n            var _a = attr.trim().split('='), name = _a[0], values = _a.slice(1);\n            if (values.length) {\n                acc[name] = values.join('=').replace(/'|\"/g, '').trim();\n            }\n            return acc;\n        }, {})\n        : {};\n}\nfunction getHTMLAttrs(dom) {\n    return toArray_1(dom.attributes).reduce(function (acc, attr) {\n        acc[attr.nodeName] = attr.nodeValue;\n        return acc;\n    }, {});\n}\nfunction sanitizeDOM(node, typeName, sanitizer, wwToDOMAdaptor) {\n    var dom = wwToDOMAdaptor.getToDOMNode(typeName)(node);\n    var html = sanitizer(dom.outerHTML);\n    var container = document.createElement('div');\n    container.innerHTML = html;\n    dom = container.firstChild;\n    var htmlAttrs = getHTMLAttrs(dom);\n    return { dom: dom, htmlAttrs: htmlAttrs };\n}\nvar schemaFactory = {\n    htmlBlock: function (typeName, sanitizeHTML, wwToDOMAdaptor) {\n        return {\n            atom: true,\n            content: 'block+',\n            group: 'block',\n            attrs: {\n                htmlAttrs: { default: {} },\n                childrenHTML: { default: '' },\n                htmlBlock: { default: true },\n            },\n            parseDOM: [\n                {\n                    tag: typeName,\n                    getAttrs: function (dom) {\n                        return {\n                            htmlAttrs: getHTMLAttrs(dom),\n                            childrenHTML: dom.innerHTML,\n                        };\n                    },\n                },\n            ],\n            toDOM: function (node) {\n                var _a = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor), dom = _a.dom, htmlAttrs = _a.htmlAttrs;\n                htmlAttrs.class = htmlAttrs.class ? htmlAttrs.class + \" html-block\" : 'html-block';\n                return __spreadArray$1([typeName, htmlAttrs], toArray_1(dom.childNodes));\n            },\n        };\n    },\n    htmlInline: function (typeName, sanitizeHTML, wwToDOMAdaptor) {\n        return {\n            attrs: {\n                htmlAttrs: { default: {} },\n                htmlInline: { default: true },\n            },\n            parseDOM: [\n                {\n                    tag: typeName,\n                    getAttrs: function (dom) {\n                        return {\n                            htmlAttrs: getHTMLAttrs(dom),\n                        };\n                    },\n                },\n            ],\n            toDOM: function (node) {\n                var htmlAttrs = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor).htmlAttrs;\n                return [typeName, htmlAttrs, 0];\n            },\n        };\n    },\n};\nfunction createHTMLSchemaMap(convertorMap, sanitizeHTML, wwToDOMAdaptor) {\n    var htmlSchemaMap = { nodes: {}, marks: {} };\n    ['htmlBlock', 'htmlInline'].forEach(function (htmlType) {\n        if (convertorMap[htmlType]) {\n            Object.keys(convertorMap[htmlType]).forEach(function (type) {\n                var targetType = htmlType === 'htmlBlock' ? 'nodes' : 'marks';\n                // register tag white list for preventing to remove the html in sanitizer\n                registerTagWhitelistIfPossible(type);\n                htmlSchemaMap[targetType][type] = schemaFactory[htmlType](type, sanitizeHTML, wwToDOMAdaptor);\n            });\n        }\n    });\n    return htmlSchemaMap;\n}\n\nvar reCloseTag = /^\\s*<\\s*\\//;\nvar baseConvertors = {\n    paragraph: function (_, _a) {\n        var entering = _a.entering, origin = _a.origin, options = _a.options;\n        if (options.nodeId) {\n            return {\n                type: entering ? 'openTag' : 'closeTag',\n                outerNewLine: true,\n                tagName: 'p',\n            };\n        }\n        return origin();\n    },\n    softbreak: function (node) {\n        var isPrevNodeHTML = node.prev && node.prev.type === 'htmlInline';\n        var isPrevBR = isPrevNodeHTML && /<br ?\\/?>/.test(node.prev.literal);\n        var content = isPrevBR ? '\\n' : '<br>\\n';\n        return { type: 'html', content: content };\n    },\n    item: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            var attributes = {};\n            var classNames = [];\n            if (node.listData.task) {\n                attributes['data-task'] = '';\n                classNames.push('task-list-item');\n                if (node.listData.checked) {\n                    classNames.push('checked');\n                    attributes['data-task-checked'] = '';\n                }\n            }\n            return {\n                type: 'openTag',\n                tagName: 'li',\n                classNames: classNames,\n                attributes: attributes,\n                outerNewLine: true,\n            };\n        }\n        return {\n            type: 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    code: function (node) {\n        var attributes = { 'data-backticks': String(node.tickCount) };\n        return [\n            { type: 'openTag', tagName: 'code', attributes: attributes },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n        ];\n    },\n    codeBlock: function (node) {\n        var _a = node, fenceLength = _a.fenceLength, info = _a.info;\n        var infoWords = info ? info.split(/\\s+/) : [];\n        var preClasses = [];\n        var codeAttrs = {};\n        if (fenceLength > 3) {\n            codeAttrs['data-backticks'] = fenceLength;\n        }\n        if (infoWords.length > 0 && infoWords[0].length > 0) {\n            var lang = infoWords[0];\n            preClasses.push(\"lang-\" + lang);\n            codeAttrs['data-language'] = lang;\n        }\n        return [\n            { type: 'openTag', tagName: 'pre', classNames: preClasses },\n            { type: 'openTag', tagName: 'code', attributes: codeAttrs },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n            { type: 'closeTag', tagName: 'pre' },\n        ];\n    },\n    customInline: function (node, _a) {\n        var origin = _a.origin, entering = _a.entering, skipChildren = _a.skipChildren;\n        var info = node.info;\n        if (info.indexOf('widget') !== -1 && entering) {\n            skipChildren();\n            var content = getWidgetContent(node);\n            var htmlInline = widgetToDOM(info, content).outerHTML;\n            return [\n                { type: 'openTag', tagName: 'span', classNames: ['tui-widget'] },\n                { type: 'html', content: htmlInline },\n                { type: 'closeTag', tagName: 'span' },\n            ];\n        }\n        return origin();\n    },\n};\nfunction getHTMLRenderConvertors(linkAttributes, customConvertors) {\n    var convertors = __assign$1({}, baseConvertors);\n    if (linkAttributes) {\n        convertors.link = function (_, _a) {\n            var entering = _a.entering, origin = _a.origin;\n            var result = origin();\n            if (entering) {\n                result.attributes = __assign$1(__assign$1({}, result.attributes), linkAttributes);\n            }\n            return result;\n        };\n    }\n    if (customConvertors) {\n        Object.keys(customConvertors).forEach(function (nodeType) {\n            var orgConvertor = convertors[nodeType];\n            var customConvertor = customConvertors[nodeType];\n            if (orgConvertor && isFunction_1(customConvertor)) {\n                convertors[nodeType] = function (node, context) {\n                    var newContext = __assign$1({}, context);\n                    newContext.origin = function () { return orgConvertor(node, context); };\n                    return customConvertor(node, newContext);\n                };\n            }\n            else if (includes(['htmlBlock', 'htmlInline'], nodeType) && !isFunction_1(customConvertor)) {\n                convertors[nodeType] = function (node, context) {\n                    var matched = node.literal.match(reHTMLTag);\n                    if (matched) {\n                        var rootHTML = matched[0], openTagName = matched[1], closeTagName = matched[3];\n                        var typeName = (openTagName || closeTagName).toLowerCase();\n                        var htmlConvertor = customConvertor[typeName];\n                        var childrenHTML = getChildrenHTML(node, typeName);\n                        if (htmlConvertor) {\n                            // copy for preventing to overwrite the originial property\n                            var newNode = __assign$1({}, node);\n                            newNode.attrs = getHTMLAttrsByHTMLString(rootHTML);\n                            newNode.childrenHTML = childrenHTML;\n                            newNode.type = typeName;\n                            context.entering = !reCloseTag.test(node.literal);\n                            return htmlConvertor(newNode, context);\n                        }\n                    }\n                    return context.origin();\n                };\n            }\n            else {\n                convertors[nodeType] = customConvertor;\n            }\n        });\n    }\n    return convertors;\n}\n\nvar nestableTypes = ['list', 'item', 'blockQuote'];\nvar nestableTagNames = ['UL', 'OL', 'BLOCKQUOTE'];\nfunction isBlankLine(doc, index) {\n    var _a;\n    var pmNode = doc.child(index);\n    return !pmNode.childCount || (pmNode.childCount === 1 && !((_a = pmNode.firstChild.text) === null || _a === void 0 ? void 0 : _a.trim()));\n}\nfunction getEditorRangeHeightInfo(doc, mdNode, children) {\n    var start = getMdStartLine(mdNode) - 1;\n    var end = getMdEndLine(mdNode) - 1;\n    var rect = children[start].getBoundingClientRect();\n    var height = children[end].offsetTop -\n        children[start].offsetTop +\n        children[end].clientHeight;\n    return {\n        height: height <= 0\n            ? children[start].clientHeight\n            : height + getBlankLinesHeight(doc, children, Math.min(end + 1, doc.childCount - 1)),\n        rect: rect,\n    };\n}\nfunction getBlankLinesHeight(doc, children, start) {\n    var end = doc.childCount - 1;\n    var height = 0;\n    while (start <= end && isBlankLine(doc, start)) {\n        height += children[start].clientHeight;\n        start += 1;\n    }\n    return height;\n}\nfunction findAncestorHavingId(el, root) {\n    while (!el.getAttribute('data-nodeid') && el.parentElement !== root) {\n        el = el.parentElement;\n    }\n    return el;\n}\nfunction getTotalOffsetTop(el, root) {\n    var offsetTop = 0;\n    while (el && el !== root) {\n        if (!includes(nestableTagNames, el.tagName)) {\n            offsetTop += el.offsetTop;\n        }\n        if (el.offsetParent === root.offsetParent) {\n            break;\n        }\n        el = el.parentElement;\n    }\n    return offsetTop;\n}\nfunction findAdjacentElementToScrollTop(scrollTop, root) {\n    var el = root;\n    var prev = null;\n    while (el) {\n        var firstElementChild = el.firstElementChild;\n        if (!firstElementChild) {\n            break;\n        }\n        var lastSibling = findLastSiblingElementToScrollTop(firstElementChild, scrollTop, getTotalOffsetTop(el, root));\n        prev = el;\n        el = lastSibling;\n    }\n    var adjacentEl = el || prev;\n    return adjacentEl === root ? null : adjacentEl;\n}\nfunction findLastSiblingElementToScrollTop(el, scrollTop, offsetTop) {\n    if (el && scrollTop > offsetTop + el.offsetTop) {\n        return (findLastSiblingElementToScrollTop(el.nextElementSibling, scrollTop, offsetTop) || el);\n    }\n    return null;\n}\nfunction getAdditionalPos(scrollTop, offsetTop, height, targetNodeHeight) {\n    var ratio = Math.min((scrollTop - offsetTop) / height, 1);\n    return ratio * targetNodeHeight;\n}\nfunction getParentNodeObj(previewContent, mdNode) {\n    var el = previewContent.querySelector(\"[data-nodeid=\\\"\" + mdNode.id + \"\\\"]\");\n    while (!el || isStyledInlineNode(mdNode)) {\n        mdNode = mdNode.parent;\n        el = previewContent.querySelector(\"[data-nodeid=\\\"\" + mdNode.id + \"\\\"]\");\n    }\n    return getNonNestableNodeObj({ mdNode: mdNode, el: el });\n}\nfunction getNonNestableNodeObj(_a) {\n    var mdNode = _a.mdNode, el = _a.el;\n    while ((includes(nestableTypes, mdNode.type) || mdNode.type === 'table') && mdNode.firstChild) {\n        mdNode = mdNode.firstChild;\n        el = el.firstElementChild;\n    }\n    return { mdNode: mdNode, el: el };\n}\n\nvar offsetInfoMap = {};\nfunction setHeight(id, height) {\n    offsetInfoMap[id] = offsetInfoMap[id] || {};\n    offsetInfoMap[id].height = height;\n}\nfunction setOffsetTop(id, offsetTop) {\n    offsetInfoMap[id] = offsetInfoMap[id] || {};\n    offsetInfoMap[id].offsetTop = offsetTop;\n}\nfunction getHeight(id) {\n    return offsetInfoMap[id] && offsetInfoMap[id].height;\n}\nfunction getOffsetTop(id) {\n    return offsetInfoMap[id] && offsetInfoMap[id].offsetTop;\n}\nfunction removeOffsetInfoByNode(node) {\n    if (node) {\n        delete offsetInfoMap[Number(node.getAttribute('data-nodeid'))];\n        toArray_1(node.children).forEach(function (child) {\n            removeOffsetInfoByNode(child);\n        });\n    }\n}\nfunction getAndSaveOffsetInfo(node, root, mdNodeId) {\n    var cachedHeight = getHeight(mdNodeId);\n    var cachedTop = getOffsetTop(mdNodeId);\n    var nodeHeight = cachedHeight || node.clientHeight;\n    var offsetTop = cachedTop || getTotalOffsetTop(node, root) || node.offsetTop;\n    if (!cachedHeight) {\n        setHeight(mdNodeId, nodeHeight);\n    }\n    if (!cachedTop) {\n        setOffsetTop(mdNodeId, offsetTop);\n    }\n    return { nodeHeight: nodeHeight, offsetTop: offsetTop };\n}\n\nvar CLASS_HIGHLIGHT = cls('md-preview-highlight');\nfunction findTableCell(tableRow, chOffset) {\n    var cell = tableRow.firstChild;\n    while (cell && cell.next) {\n        if (getMdStartCh(cell.next) > chOffset + 1) {\n            break;\n        }\n        cell = cell.next;\n    }\n    return cell;\n}\n/**\n * Class Markdown Preview\n * @param {HTMLElement} el - base element\n * @param {eventEmitter} eventEmitter - event manager\n * @param {object} options\n * @param {boolean} options.isViewer - true for view-only mode\n * @param {boolean} options.highlight - true for using live-highlight feature\n * @param {object} opitons.linkAttributes - attributes for link element\n * @param {object} opitons.customHTMLRenderer - map of custom HTML render functions\n *\n * @ignore\n */\nvar MarkdownPreview = /** @class */ (function () {\n    function MarkdownPreview(eventEmitter, options) {\n        var el = document.createElement('div');\n        this.el = el;\n        this.eventEmitter = eventEmitter;\n        this.isViewer = !!options.isViewer;\n        this.el.className = cls('md-preview');\n        var linkAttributes = options.linkAttributes, customHTMLRenderer = options.customHTMLRenderer, sanitizer = options.sanitizer, _a = options.highlight, highlight = _a === void 0 ? false : _a;\n        this.renderer = new Renderer({\n            gfm: true,\n            nodeId: true,\n            convertors: getHTMLRenderConvertors(linkAttributes, customHTMLRenderer),\n        });\n        this.cursorNodeId = null;\n        this.sanitizer = sanitizer;\n        this.initEvent(highlight);\n        this.initContentSection();\n        // To prevent overflowing contents in the viewer\n        if (this.isViewer) {\n            this.previewContent.style.overflowWrap = 'break-word';\n        }\n    }\n    MarkdownPreview.prototype.initContentSection = function () {\n        this.previewContent = createElementWith(\"<div class=\\\"\" + cls('contents') + \"\\\"></div>\");\n        if (!this.isViewer) {\n            this.el.appendChild(this.previewContent);\n        }\n    };\n    MarkdownPreview.prototype.toggleActive = function (active) {\n        toggleClass(this.el, 'active', active);\n    };\n    MarkdownPreview.prototype.initEvent = function (highlight) {\n        var _this = this;\n        this.eventEmitter.listen('updatePreview', this.update.bind(this));\n        if (this.isViewer) {\n            return;\n        }\n        if (highlight) {\n            this.eventEmitter.listen('changeToolbarState', function (_a) {\n                var mdNode = _a.mdNode, cursorPos = _a.cursorPos;\n                _this.updateCursorNode(mdNode, cursorPos);\n            });\n            this.eventEmitter.listen('blur', function () {\n                _this.removeHighlight();\n            });\n        }\n        on_1(this.el, 'scroll', function (event) {\n            _this.eventEmitter.emit('scroll', 'preview', findAdjacentElementToScrollTop(event.target.scrollTop, _this.previewContent));\n        });\n        this.eventEmitter.listen('changePreviewTabPreview', function () { return _this.toggleActive(true); });\n        this.eventEmitter.listen('changePreviewTabWrite', function () { return _this.toggleActive(false); });\n    };\n    MarkdownPreview.prototype.removeHighlight = function () {\n        if (this.cursorNodeId) {\n            var currentEl = this.getElementByNodeId(this.cursorNodeId);\n            if (currentEl) {\n                removeClass_1(currentEl, CLASS_HIGHLIGHT);\n            }\n        }\n    };\n    MarkdownPreview.prototype.updateCursorNode = function (cursorNode, cursorPos) {\n        if (cursorNode) {\n            cursorNode = findClosestNode(cursorNode, function (mdNode) { return !isInlineNode$1(mdNode); });\n            if (cursorNode.type === 'tableRow') {\n                cursorNode = findTableCell(cursorNode, cursorPos[1]);\n            }\n            else if (cursorNode.type === 'tableBody') {\n                // empty line next to table\n                cursorNode = null;\n            }\n        }\n        var cursorNodeId = cursorNode ? cursorNode.id : null;\n        if (this.cursorNodeId === cursorNodeId) {\n            return;\n        }\n        var oldEL = this.getElementByNodeId(this.cursorNodeId);\n        var newEL = this.getElementByNodeId(cursorNodeId);\n        if (oldEL) {\n            removeClass_1(oldEL, CLASS_HIGHLIGHT);\n        }\n        if (newEL) {\n            addClass_1(newEL, CLASS_HIGHLIGHT);\n        }\n        this.cursorNodeId = cursorNodeId;\n    };\n    MarkdownPreview.prototype.getElementByNodeId = function (nodeId) {\n        return nodeId\n            ? this.previewContent.querySelector(\"[data-nodeid=\\\"\" + nodeId + \"\\\"]\")\n            : null;\n    };\n    MarkdownPreview.prototype.update = function (changed) {\n        var _this = this;\n        changed.forEach(function (editResult) { return _this.replaceRangeNodes(editResult); });\n        this.eventEmitter.emit('afterPreviewRender', this);\n    };\n    MarkdownPreview.prototype.replaceRangeNodes = function (editResult) {\n        var _this = this;\n        var nodes = editResult.nodes, removedNodeRange = editResult.removedNodeRange;\n        var contentEl = this.previewContent;\n        var newHtml = this.eventEmitter.emitReduce('beforePreviewRender', this.sanitizer(nodes.map(function (node) { return _this.renderer.render(node); }).join('')));\n        if (!removedNodeRange) {\n            contentEl.insertAdjacentHTML('afterbegin', newHtml);\n        }\n        else {\n            var _a = removedNodeRange.id, startNodeId = _a[0], endNodeId = _a[1];\n            var startEl = this.getElementByNodeId(startNodeId);\n            var endEl = this.getElementByNodeId(endNodeId);\n            if (startEl) {\n                startEl.insertAdjacentHTML('beforebegin', newHtml);\n                var el = startEl;\n                while (el && el !== endEl) {\n                    var nextEl = el.nextElementSibling;\n                    removeNode$1(el);\n                    removeOffsetInfoByNode(el);\n                    el = nextEl;\n                }\n                if (el === null || el === void 0 ? void 0 : el.parentNode) {\n                    removeNode$1(el);\n                    removeOffsetInfoByNode(el);\n                }\n            }\n        }\n    };\n    MarkdownPreview.prototype.getRenderer = function () {\n        return this.renderer;\n    };\n    MarkdownPreview.prototype.destroy = function () {\n        off_1(this.el, 'scroll');\n        this.el = null;\n    };\n    MarkdownPreview.prototype.getElement = function () {\n        return this.el;\n    };\n    MarkdownPreview.prototype.getHTML = function () {\n        return removeProseMirrorHackNodes(this.previewContent.innerHTML);\n    };\n    MarkdownPreview.prototype.setHTML = function (html) {\n        this.previewContent.innerHTML = html;\n    };\n    MarkdownPreview.prototype.setHeight = function (height) {\n        css_1(this.el, { height: height + \"px\" });\n    };\n    MarkdownPreview.prototype.setMinHeight = function (minHeight) {\n        css_1(this.el, { minHeight: minHeight + \"px\" });\n    };\n    return MarkdownPreview;\n}());\n\nfunction findNodeBy(pos, condition) {\n    var depth = pos.depth;\n    while (depth) {\n        var node = pos.node(depth);\n        if (condition(node, depth)) {\n            return {\n                node: node,\n                depth: depth,\n                offset: depth > 0 ? pos.before(depth) : 0,\n            };\n        }\n        depth -= 1;\n    }\n    return null;\n}\nfunction isInListNode(pos) {\n    return !!findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'listItem' || type.name === 'bulletList' || type.name === 'orderedList';\n    });\n}\nfunction isInTableNode(pos) {\n    return !!findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';\n    });\n}\nfunction findListItem(pos) {\n    return findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'listItem';\n    });\n}\nfunction createDOMInfoParsedRawHTML(tag) {\n    return {\n        tag: tag,\n        getAttrs: function (dom) {\n            var rawHTML = dom.getAttribute('data-raw-html');\n            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n        },\n    };\n}\nfunction createCellAttrs(attrs) {\n    return Object.keys(attrs).reduce(function (acc, attrName) {\n        if (attrName !== 'rawHTML' && attrs[attrName]) {\n            attrName = attrName === 'className' ? 'class' : attrName;\n            acc[attrName] = attrs[attrName];\n        }\n        return acc;\n    }, {});\n}\nfunction createParsedCellDOM(tag) {\n    return {\n        tag: tag,\n        getAttrs: function (dom) {\n            return ['rawHTML', 'colspan', 'rowspan', 'extended'].reduce(function (acc, attrName) {\n                var attrNameInDOM = attrName === 'rawHTML' ? 'data-raw-html' : attrName;\n                var attrValue = dom.getAttribute(attrNameInDOM);\n                if (attrValue) {\n                    acc[attrName] = includes(['rawHTML', 'extended'], attrName)\n                        ? attrValue\n                        : Number(attrValue);\n                }\n                return acc;\n            }, {});\n        },\n    };\n}\nfunction getDefaultCustomAttrs() {\n    return {\n        htmlAttrs: { default: null },\n        classNames: { default: null },\n    };\n}\nfunction getCustomAttrs(attrs) {\n    var htmlAttrs = attrs.htmlAttrs, classNames = attrs.classNames;\n    return __assign$1(__assign$1({}, htmlAttrs), { class: classNames ? classNames.join(' ') : null });\n}\n\nfunction findWrappingOutside(range, type) {\n    var parent = range.parent, startIndex = range.startIndex, endIndex = range.endIndex;\n    var around = parent.contentMatchAt(startIndex).findWrapping(type);\n    if (around) {\n        var outer = around.length ? around[0] : type;\n        return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n    }\n    return null;\n}\nfunction findWrappingInside(range, type) {\n    var parent = range.parent, startIndex = range.startIndex, endIndex = range.endIndex;\n    var inner = parent.child(startIndex);\n    var inside = type.contentMatch.findWrapping(inner.type);\n    if (inside) {\n        var lastType = inside.length ? inside[inside.length - 1] : type;\n        var innerMatch = lastType.contentMatch;\n        for (var i = startIndex; innerMatch && i < endIndex; i += 1) {\n            innerMatch = innerMatch.matchType(parent.child(i).type);\n        }\n        if (innerMatch && innerMatch.validEnd) {\n            return inside;\n        }\n    }\n    return null;\n}\nfunction findWrappers(range, innerRange, nodeType, attrs) {\n    var around = findWrappingOutside(range, nodeType);\n    var inner = findWrappingInside(innerRange, nodeType);\n    if (around && inner) {\n        var aroundNodes = around.map(function (type) {\n            return { type: type };\n        });\n        var innerNodes = inner.map(function (type) {\n            return { type: type, attrs: attrs };\n        });\n        return aroundNodes.concat({ type: nodeType }).concat(innerNodes);\n    }\n    return null;\n}\nfunction wrapInList(tr, _a, wrappers, joinBefore, list) {\n    var start = _a.start, end = _a.end, startIndex = _a.startIndex, endIndex = _a.endIndex, parent = _a.parent;\n    var content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n    for (var i = wrappers.length - 1; i >= 0; i -= 1) {\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    }\n    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(start - (joinBefore ? 2 : 0), end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(content, 0, 0), wrappers.length, true));\n    var foundListIndex = 0;\n    for (var i = 0; i < wrappers.length; i += 1) {\n        if (wrappers[i].type === list) {\n            foundListIndex = i + 1;\n            break;\n        }\n    }\n    var splitDepth = wrappers.length - foundListIndex;\n    var splitPos = start + wrappers.length - (joinBefore ? 2 : 0);\n    for (var i = startIndex, len = endIndex; i < len; i += 1) {\n        var first = i === startIndex;\n        if (!first && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.canSplit)(tr.doc, splitPos, splitDepth)) {\n            tr.split(splitPos, splitDepth);\n            splitPos += splitDepth * 2;\n        }\n        splitPos += parent.child(i).nodeSize;\n    }\n    return tr;\n}\nfunction changeToList(tr, range, list, attrs) {\n    var $from = range.$from, $to = range.$to, depth = range.depth;\n    var outerRange = range;\n    var joinBefore = false;\n    if (depth >= 2 &&\n        $from.node(depth - 1).type.compatibleContent(list) &&\n        range.startIndex === 0 &&\n        $from.index(depth - 1)) {\n        var start = tr.doc.resolve(range.start - 2);\n        outerRange = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange(start, start, depth);\n        if (range.endIndex < range.parent.childCount) {\n            range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange($from, tr.doc.resolve($to.end(depth)), depth);\n        }\n        joinBefore = true;\n    }\n    var wrappers = findWrappers(outerRange, range, list, attrs);\n    if (wrappers) {\n        return wrapInList(tr, range, wrappers, joinBefore, list);\n    }\n    return tr;\n}\nfunction getBeforeLineListItem(doc, offset) {\n    var endListItemPos = doc.resolve(offset);\n    while (endListItemPos.node().type.name !== 'paragraph') {\n        offset -= 2; // The position value of </li></ul>\n        endListItemPos = doc.resolve(offset);\n    }\n    return findListItem(endListItemPos);\n}\nfunction toggleTaskListItems(tr, _a) {\n    var $from = _a.$from, $to = _a.$to;\n    var startListItem = findListItem($from);\n    var endListItem = findListItem($to);\n    if (startListItem && endListItem) {\n        while (endListItem) {\n            var offset = endListItem.offset, node = endListItem.node;\n            var attrs = { task: !node.attrs.task, checked: false };\n            tr.setNodeMarkup(offset, null, attrs);\n            if (offset === startListItem.offset) {\n                break;\n            }\n            endListItem = getBeforeLineListItem(tr.doc, offset);\n        }\n    }\n    return tr;\n}\nfunction changeListType(tr, _a, list) {\n    var $from = _a.$from, $to = _a.$to;\n    var startListItem = findListItem($from);\n    var endListItem = findListItem($to);\n    if (startListItem && endListItem) {\n        while (endListItem) {\n            var offset = endListItem.offset, node = endListItem.node, depth = endListItem.depth;\n            if (node.attrs.task) {\n                tr.setNodeMarkup(offset, null, { task: false, checked: false });\n            }\n            var resolvedPos = tr.doc.resolve(offset);\n            if (resolvedPos.parent.type !== list) {\n                var parentOffset = resolvedPos.before(depth - 1);\n                tr.setNodeMarkup(parentOffset, list);\n            }\n            if (offset === startListItem.offset) {\n                break;\n            }\n            endListItem = getBeforeLineListItem(tr.doc, offset);\n        }\n    }\n    return tr;\n}\nfunction changeList(list) {\n    return function (_a, dispatch) {\n        var selection = _a.selection, tr = _a.tr;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range) {\n            var newTr = isInListNode($from)\n                ? changeListType(tr, range, list)\n                : changeToList(tr, range, list);\n            dispatch(newTr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction toggleTask() {\n    return function (_a, dispatch) {\n        var selection = _a.selection, tr = _a.tr, schema = _a.schema;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range) {\n            var newTr = isInListNode($from)\n                ? toggleTaskListItems(tr, range)\n                : changeToList(tr, range, schema.nodes.bulletList, { task: true });\n            dispatch(newTr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction sinkListItem(listItem) {\n    return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to, function (_a) {\n            var childCount = _a.childCount, firstChild = _a.firstChild;\n            return !!childCount && firstChild.type === listItem;\n        });\n        if (range && range.startIndex > 0) {\n            var parent_1 = range.parent;\n            var nodeBefore = parent_1.child(range.startIndex - 1);\n            if (nodeBefore.type !== listItem) {\n                return false;\n            }\n            var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type === parent_1.type;\n            var inner = nestedBefore ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.create()) : null;\n            var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(parent_1.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n            var before = range.start;\n            var after = range.end;\n            tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true));\n            dispatch(tr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction liftToOuterList(tr, range, listItem) {\n    var $from = range.$from, $to = range.$to, end = range.end, depth = range.depth, parent = range.parent;\n    var endOfList = $to.end(depth);\n    if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.create(null, parent.copy())), 1, 0), 1, true));\n        range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange(tr.doc.resolve($from.pos), tr.doc.resolve(endOfList), depth);\n    }\n    tr.lift(range, (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.liftTarget)(range));\n    return tr;\n}\nfunction liftOutOfList(tr, range) {\n    var list = range.parent;\n    var pos = range.end;\n    // Merge the list items into a single big item\n    for (var i = range.endIndex - 1, len = range.startIndex; i > len; i -= 1) {\n        pos -= list.child(i).nodeSize;\n        tr.delete(pos - 1, pos + 1);\n    }\n    var startPos = tr.doc.resolve(range.start);\n    var listItem = startPos.nodeAfter;\n    var atStart = range.startIndex === 0;\n    var atEnd = range.endIndex === list.childCount;\n    var parent = startPos.node(-1);\n    var indexBefore = startPos.index(-1);\n    var canReplaceParent = parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, listItem === null || listItem === void 0 ? void 0 : listItem.content.append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list)));\n    if (listItem && canReplaceParent) {\n        var start = startPos.pos;\n        var end = start + listItem.nodeSize;\n        // Strip off the surrounding list. At the sides where we're not at\n        // the end of the list, the existing list is closed. At sides where\n        // this is the end, it is overwritten to its end.\n        tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice((atStart ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty))).append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n    }\n    return tr;\n}\nfunction liftListItem(listItem) {\n    return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to, function (_a) {\n            var childCount = _a.childCount, firstChild = _a.firstChild;\n            return !!childCount && firstChild.type === listItem;\n        });\n        if (range) {\n            var topListItem = $from.node(range.depth - 1).type === listItem;\n            var newTr = topListItem ? liftToOuterList(tr, range, listItem) : liftOutOfList(tr, range);\n            dispatch(newTr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction splitListItem(listItem) {\n    return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var $from = selection.$from, $to = selection.$to;\n        if ($from.depth < 2 || !$from.sameParent($to)) {\n            return false;\n        }\n        var grandParent = $from.node(-1);\n        if (grandParent.type !== listItem) {\n            return false;\n        }\n        if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth === 2 ||\n                $from.node(-3).type !== listItem ||\n                $from.index(-2) !== $from.node(-2).childCount - 1) {\n                return false;\n            }\n            var keepItem = $from.index(-1) > 0;\n            var wrapper = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n            // Build a fragment containing empty versions of the structure\n            // from the outer list item to the parent node of the cursor\n            for (var depth = $from.depth - (keepItem ? 1 : 2); depth >= $from.depth - 3; depth -= 1) {\n                wrapper = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from($from.node(depth).copy(wrapper));\n            }\n            // Add a second list item with an empty default start node\n            wrapper = wrapper.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.createAndFill()));\n            tr.replace(keepItem ? $from.before() : $from.before(-1), $from.after(-3), new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(wrapper, keepItem ? 3 : 2, 2));\n            tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2))));\n            dispatch(tr);\n            return true;\n        }\n        var nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        var types = nextType && [null, { type: nextType }];\n        tr.delete($from.pos, $to.pos);\n        if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.canSplit)(tr.doc, $from.pos, 2, types)) {\n            tr.split($from.pos, 2, types);\n            dispatch(tr);\n            return true;\n        }\n        return false;\n    };\n}\n\nfunction indent() {\n    return function () { return function (state, dispatch) {\n        var selection = state.selection, schema = state.schema;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range && isInListNode($from)) {\n            return sinkListItem(schema.nodes.listItem)(state, dispatch);\n        }\n        return false;\n    }; };\n}\nfunction outdent() {\n    return function () { return function (state, dispatch) {\n        var selection = state.selection, schema = state.schema;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range && isInListNode($from)) {\n            return liftListItem(schema.nodes.listItem)(state, dispatch);\n        }\n        return false;\n    }; };\n}\nfunction getWwCommands() {\n    return {\n        indent: indent(),\n        outdent: outdent(),\n    };\n}\n\nvar cache = new Map();\n/* eslint-disable @typescript-eslint/no-unused-vars */\nvar TableOffsetMap = /** @class */ (function () {\n    function TableOffsetMap(table, tableRows, tableStartPos, rowInfo) {\n        this.table = table;\n        this.tableRows = tableRows;\n        this.tableStartPos = tableStartPos;\n        this.rowInfo = rowInfo;\n    }\n    TableOffsetMap.create = function (cellPos) {\n        var table = findNodeBy(cellPos, function (_a) {\n            var type = _a.type;\n            return type.name === 'table';\n        });\n        if (table) {\n            var node = table.node, depth = table.depth, offset = table.offset;\n            var cached = cache.get(node);\n            if ((cached === null || cached === void 0 ? void 0 : cached.tableStartPos) === offset + 1) {\n                return cached;\n            }\n            var rows_1 = [];\n            var tablePos = cellPos.start(depth);\n            var thead = node.child(0);\n            var tbody = node.child(1);\n            var theadCellInfo = createOffsetMap(thead, tablePos);\n            var tbodyCellInfo = createOffsetMap(tbody, tablePos + thead.nodeSize);\n            thead.forEach(function (row) { return rows_1.push(row); });\n            tbody.forEach(function (row) { return rows_1.push(row); });\n            var map = new TableOffsetMap(node, rows_1, tablePos, theadCellInfo.concat(tbodyCellInfo));\n            cache.set(node, map);\n            return map;\n        }\n        return null;\n    };\n    Object.defineProperty(TableOffsetMap.prototype, \"totalRowCount\", {\n        get: function () {\n            return this.rowInfo.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"totalColumnCount\", {\n        get: function () {\n            return this.rowInfo[0].length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"tableStartOffset\", {\n        get: function () {\n            return this.tableStartPos;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"tableEndOffset\", {\n        get: function () {\n            return this.tableStartPos + this.table.nodeSize - 1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    TableOffsetMap.prototype.getCellInfo = function (rowIdx, colIdx) {\n        return this.rowInfo[rowIdx][colIdx];\n    };\n    TableOffsetMap.prototype.posAt = function (rowIdx, colIdx) {\n        for (var i = 0, rowStart = this.tableStartPos;; i += 1) {\n            var rowEnd = rowStart + this.tableRows[i].nodeSize;\n            if (i === rowIdx) {\n                var index = colIdx;\n                // Skip the cells from previous row(via rowspan)\n                while (index < this.totalColumnCount && this.rowInfo[i][index].offset < rowStart) {\n                    index += 1;\n                }\n                return index === this.totalColumnCount ? rowEnd : this.rowInfo[i][index].offset;\n            }\n            rowStart = rowEnd;\n        }\n    };\n    TableOffsetMap.prototype.getNodeAndPos = function (rowIdx, colIdx) {\n        var cellInfo = this.rowInfo[rowIdx][colIdx];\n        return {\n            node: this.table.nodeAt(cellInfo.offset - this.tableStartOffset),\n            pos: cellInfo.offset,\n        };\n    };\n    TableOffsetMap.prototype.extendedRowspan = function (rowIdx, colIdx) {\n        return false;\n    };\n    TableOffsetMap.prototype.extendedColspan = function (rowIdx, colIdx) {\n        return false;\n    };\n    TableOffsetMap.prototype.getRowspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.getColspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.decreaseColspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.decreaseRowspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.getColspanStartInfo = function (rowIdx, colIdx) {\n        return null;\n    };\n    TableOffsetMap.prototype.getRowspanStartInfo = function (rowIdx, colIdx) {\n        return null;\n    };\n    TableOffsetMap.prototype.getCellStartOffset = function (rowIdx, colIdx) {\n        var offset = this.rowInfo[rowIdx][colIdx].offset;\n        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset;\n    };\n    TableOffsetMap.prototype.getCellEndOffset = function (rowIdx, colIdx) {\n        var _a = this.rowInfo[rowIdx][colIdx], offset = _a.offset, nodeSize = _a.nodeSize;\n        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset + nodeSize;\n    };\n    TableOffsetMap.prototype.getCellIndex = function (cellPos) {\n        for (var rowIdx = 0; rowIdx < this.totalRowCount; rowIdx += 1) {\n            var rowInfo = this.rowInfo[rowIdx];\n            for (var colIdx = 0; colIdx < this.totalColumnCount; colIdx += 1) {\n                if (rowInfo[colIdx].offset + 1 > cellPos.pos) {\n                    return [rowIdx, colIdx];\n                }\n            }\n        }\n        return [0, 0];\n    };\n    TableOffsetMap.prototype.getRectOffsets = function (startCellPos, endCellPos) {\n        var _a, _b, _c;\n        if (endCellPos === void 0) { endCellPos = startCellPos; }\n        if (startCellPos.pos > endCellPos.pos) {\n            _a = [endCellPos, startCellPos], startCellPos = _a[0], endCellPos = _a[1];\n        }\n        var _d = this.getCellIndex(startCellPos), startRowIdx = _d[0], startColIdx = _d[1];\n        var _e = this.getCellIndex(endCellPos), endRowIdx = _e[0], endColIdx = _e[1];\n        _b = getSortedNumPair(startRowIdx, endRowIdx), startRowIdx = _b[0], endRowIdx = _b[1];\n        _c = getSortedNumPair(startColIdx, endColIdx), startColIdx = _c[0], endColIdx = _c[1];\n        return this.getSpannedOffsets({ startRowIdx: startRowIdx, startColIdx: startColIdx, endRowIdx: endRowIdx, endColIdx: endColIdx });\n    };\n    TableOffsetMap.prototype.getSpannedOffsets = function (selectionInfo) {\n        return selectionInfo;\n    };\n    return TableOffsetMap;\n}());\n/* eslint-enable @typescript-eslint/no-unused-vars */\nvar createOffsetMap = function (headOrBody, startOffset) {\n    var cellInfoMatrix = [];\n    headOrBody.forEach(function (row, rowOffset) {\n        // get row index based on table(not table head or table body)\n        var rowInfo = { rowspanMap: {}, colspanMap: {}, length: 0 };\n        row.forEach(function (_a, cellOffset) {\n            var nodeSize = _a.nodeSize;\n            var colIdx = 0;\n            while (rowInfo[colIdx]) {\n                colIdx += 1;\n            }\n            rowInfo[colIdx] = {\n                // 2 is the sum of the front and back positions of the tag\n                offset: startOffset + rowOffset + cellOffset + 2,\n                nodeSize: nodeSize,\n            };\n            rowInfo.length += 1;\n        });\n        cellInfoMatrix.push(rowInfo);\n    });\n    return cellInfoMatrix;\n};\nfunction mixinTableOffsetMapPrototype(offsetMapMixin, createOffsetMapMixin) {\n    assign(TableOffsetMap.prototype, offsetMapMixin);\n    createOffsetMap = createOffsetMapMixin;\n    return TableOffsetMap;\n}\n\nfunction getSelectionRanges(doc, map, _a) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx;\n    var ranges = [];\n    for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {\n        for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n            var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n            ranges.push(new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange(doc.resolve(offset + 1), doc.resolve(offset + nodeSize - 1)));\n        }\n    }\n    return ranges;\n}\nfunction createTableFragment(tableHead, tableBody) {\n    var fragment = [];\n    if (tableHead.childCount) {\n        fragment.push(tableHead);\n    }\n    if (tableBody.childCount) {\n        fragment.push(tableBody);\n    }\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(fragment);\n}\nvar CellSelection = /** @class */ (function (_super) {\n    __extends$1(CellSelection, _super);\n    function CellSelection(startCellPos, endCellPos) {\n        if (endCellPos === void 0) { endCellPos = startCellPos; }\n        var _this = this;\n        var doc = startCellPos.node(0);\n        var map = TableOffsetMap.create(startCellPos);\n        var selectionInfo = map.getRectOffsets(startCellPos, endCellPos);\n        var ranges = getSelectionRanges(doc, map, selectionInfo);\n        _this = _super.call(this, ranges[0].$from, ranges[0].$to, ranges) || this;\n        _this.startCell = startCellPos;\n        _this.endCell = endCellPos;\n        _this.offsetMap = map;\n        _this.isCellSelection = true;\n        // This property is the api of the 'Selection' in prosemirror,\n        // and is used to disable the text selection.\n        _this.visible = false;\n        return _this;\n    }\n    CellSelection.prototype.map = function (doc, mapping) {\n        var startPos = this.startCell.pos;\n        var endPos = this.endCell.pos;\n        var startCell = doc.resolve(mapping.map(startPos));\n        var endCell = doc.resolve(mapping.map(endPos));\n        var map = TableOffsetMap.create(startCell);\n        // text selection when rows or columns are deleted\n        if (this.offsetMap.totalColumnCount > map.totalColumnCount ||\n            this.offsetMap.totalRowCount > map.totalRowCount) {\n            var depthMap = { tableBody: 1, tableRow: 2, tableCell: 3, paragraph: 4 };\n            var depthFromTable = depthMap[endCell.parent.type.name];\n            var tableEndPos = endCell.end(endCell.depth - depthFromTable);\n            // subtract 4(</td></tr></tbody></table> tag length)\n            var from = Math.min(tableEndPos - 4, endCell.pos);\n            return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, from);\n        }\n        return new CellSelection(startCell, endCell);\n    };\n    CellSelection.prototype.eq = function (cell) {\n        return (cell instanceof CellSelection &&\n            cell.startCell.pos === this.startCell.pos &&\n            cell.endCell.pos === this.endCell.pos);\n    };\n    CellSelection.prototype.content = function () {\n        var table = this.startCell.node(-2);\n        var tableOffset = this.startCell.start(-2);\n        var row = table.child(1).firstChild;\n        var tableHead = table.child(0).type.create();\n        var tableBody = table.child(1).type.create();\n        var map = TableOffsetMap.create(this.startCell);\n        var selectionInfo = map.getRectOffsets(this.startCell, this.endCell);\n        var startRowIdx = selectionInfo.startRowIdx, startColIdx = selectionInfo.startColIdx, endRowIdx = selectionInfo.endRowIdx, endColIdx = selectionInfo.endColIdx;\n        var isTableHeadCell = false;\n        for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {\n            var cells = [];\n            for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n                var offset = map.getCellInfo(rowIdx, colIdx).offset;\n                var cell = table.nodeAt(offset - tableOffset);\n                if (cell) {\n                    isTableHeadCell = cell.type.name === 'tableHeadCell';\n                    // mark the extended cell for pasting\n                    if (map.extendedRowspan(rowIdx, colIdx) || map.extendedColspan(rowIdx, colIdx)) {\n                        cells.push(cell.type.create({ extended: true }));\n                    }\n                    else {\n                        cells.push(cell.copy(cell.content));\n                    }\n                }\n            }\n            var copiedRow = row.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n            var targetNode = isTableHeadCell ? tableHead : tableBody;\n            // @ts-ignore\n            targetNode.content = targetNode.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(copiedRow));\n        }\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(createTableFragment(tableHead, tableBody), 1, 1);\n    };\n    CellSelection.prototype.toJSON = function () {\n        return JSON.stringify(this);\n    };\n    return CellSelection;\n}(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection));\n\nfunction createTableHeadRow(columnCount, schema, data) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableHeadCell = _a.tableHeadCell, paragraph = _a.paragraph;\n    var cells = [];\n    for (var index = 0; index < columnCount; index += 1) {\n        var text = data && data[index];\n        var para = paragraph.create(null, text ? schema.text(text) : []);\n        cells.push(tableHeadCell.create(null, para));\n    }\n    return [tableRow.create(null, cells)];\n}\nfunction createTableBodyRows(rowCount, columnCount, schema, data) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableBodyCell = _a.tableBodyCell, paragraph = _a.paragraph;\n    var tableRows = [];\n    for (var rowIdx = 0; rowIdx < rowCount; rowIdx += 1) {\n        var cells = [];\n        for (var colIdx = 0; colIdx < columnCount; colIdx += 1) {\n            var text = data && data[rowIdx * columnCount + colIdx];\n            var para = paragraph.create(null, text ? schema.text(text) : []);\n            cells.push(tableBodyCell.create(null, para));\n        }\n        tableRows.push(tableRow.create(null, cells));\n    }\n    return tableRows;\n}\nfunction createDummyCells(columnCount, rowIdx, schema, attrs) {\n    if (attrs === void 0) { attrs = null; }\n    var _a = schema.nodes, tableHeadCell = _a.tableHeadCell, tableBodyCell = _a.tableBodyCell, paragraph = _a.paragraph;\n    var cell = rowIdx === 0 ? tableHeadCell : tableBodyCell;\n    var cells = [];\n    for (var index = 0; index < columnCount; index += 1) {\n        cells.push(cell.create(attrs, paragraph.create()));\n    }\n    return cells;\n}\nfunction findCellElement(node, root) {\n    while (node && node !== root) {\n        if (node.nodeName === 'TD' || node.nodeName === 'TH') {\n            return node;\n        }\n        node = node.parentNode;\n    }\n    return null;\n}\nfunction findCell(pos) {\n    return findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';\n    });\n}\nfunction getResolvedSelection(selection) {\n    if (selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n        var $anchor = selection.$anchor;\n        var foundCell = findCell($anchor);\n        if (foundCell) {\n            var anchor = $anchor.node(0).resolve($anchor.before(foundCell.depth));\n            return { anchor: anchor, head: anchor };\n        }\n    }\n    var _a = selection, startCell = _a.startCell, endCell = _a.endCell;\n    return { anchor: startCell, head: endCell };\n}\nfunction getTableContentFromSlice(slice) {\n    var _a;\n    if (slice.size) {\n        var content = slice.content, openStart = slice.openStart, openEnd = slice.openEnd;\n        if (content.childCount !== 1) {\n            return null;\n        }\n        while (content.childCount === 1 &&\n            ((openStart > 0 && openEnd > 0) || ((_a = content.firstChild) === null || _a === void 0 ? void 0 : _a.type.name) === 'table')) {\n            openStart -= 1;\n            openEnd -= 1;\n            content = content.firstChild.content;\n        }\n        if (content.firstChild.type.name === 'tableHead' ||\n            content.firstChild.type.name === 'tableBody') {\n            return content;\n        }\n    }\n    return null;\n}\nfunction getRowAndColumnCount(_a) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx;\n    var rowCount = endRowIdx - startRowIdx + 1;\n    var columnCount = endColIdx - startColIdx + 1;\n    return { rowCount: rowCount, columnCount: columnCount };\n}\nfunction setAttrs(cell, attrs) {\n    return __assign$1(__assign$1({}, cell.attrs), attrs);\n}\n\nvar pluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('cellSelection');\nvar MOUSE_RIGHT_BUTTON = 2;\nvar TableSelection = /** @class */ (function () {\n    function TableSelection(view) {\n        this.view = view;\n        this.handlers = {\n            mousedown: this.handleMousedown.bind(this),\n            mousemove: this.handleMousemove.bind(this),\n            mouseup: this.handleMouseup.bind(this),\n        };\n        this.startCellPos = null;\n        this.init();\n    }\n    TableSelection.prototype.init = function () {\n        this.view.dom.addEventListener('mousedown', this.handlers.mousedown);\n    };\n    TableSelection.prototype.handleMousedown = function (ev) {\n        var foundCell = findCellElement(ev.target, this.view.dom);\n        if (ev.button === MOUSE_RIGHT_BUTTON) {\n            ev.preventDefault();\n            return;\n        }\n        if (foundCell) {\n            var startCellPos = this.getCellPos(ev);\n            if (startCellPos) {\n                this.startCellPos = startCellPos;\n            }\n            this.bindEvent();\n        }\n    };\n    TableSelection.prototype.handleMousemove = function (ev) {\n        var prevEndCellOffset = pluginKey.getState(this.view.state);\n        var endCellPos = this.getCellPos(ev);\n        var startCellPos = this.startCellPos;\n        var prevEndCellPos;\n        if (prevEndCellOffset) {\n            prevEndCellPos = this.view.state.doc.resolve(prevEndCellOffset);\n        }\n        else if (startCellPos !== endCellPos) {\n            prevEndCellPos = startCellPos;\n        }\n        if (prevEndCellPos && startCellPos && endCellPos) {\n            this.setCellSelection(startCellPos, endCellPos);\n        }\n    };\n    TableSelection.prototype.handleMouseup = function () {\n        this.startCellPos = null;\n        this.unbindEvent();\n        if (pluginKey.getState(this.view.state) !== null) {\n            this.view.dispatch(this.view.state.tr.setMeta(pluginKey, -1));\n        }\n    };\n    TableSelection.prototype.bindEvent = function () {\n        var dom = this.view.dom;\n        dom.addEventListener('mousemove', this.handlers.mousemove);\n        dom.addEventListener('mouseup', this.handlers.mouseup);\n    };\n    TableSelection.prototype.unbindEvent = function () {\n        var dom = this.view.dom;\n        dom.removeEventListener('mousemove', this.handlers.mousemove);\n        dom.removeEventListener('mouseup', this.handlers.mouseup);\n    };\n    TableSelection.prototype.getCellPos = function (_a) {\n        var clientX = _a.clientX, clientY = _a.clientY;\n        var mousePos = this.view.posAtCoords({ left: clientX, top: clientY });\n        if (mousePos) {\n            var doc = this.view.state.doc;\n            var currentPos = doc.resolve(mousePos.pos);\n            var foundCell = findCell(currentPos);\n            if (foundCell) {\n                var cellOffset = currentPos.before(foundCell.depth);\n                return doc.resolve(cellOffset);\n            }\n        }\n        return null;\n    };\n    TableSelection.prototype.setCellSelection = function (startCellPos, endCellPos) {\n        var _a = this.view.state, selection = _a.selection, tr = _a.tr;\n        var starting = pluginKey.getState(this.view.state) === null;\n        var cellSelection = new CellSelection(startCellPos, endCellPos);\n        if (starting || !selection.eq(cellSelection)) {\n            var newTr = tr.setSelection(cellSelection);\n            if (starting) {\n                newTr.setMeta(pluginKey, endCellPos.pos);\n            }\n            this.view.dispatch(newTr);\n        }\n    };\n    TableSelection.prototype.destroy = function () {\n        this.view.dom.removeEventListener('mousedown', this.handlers.mousedown);\n    };\n    return TableSelection;\n}());\n\nvar SELECTED_CELL_CLASS_NAME = cls('cell-selected');\nfunction drawCellSelection(_a) {\n    var selection = _a.selection, doc = _a.doc;\n    if (selection instanceof CellSelection) {\n        var cells_1 = [];\n        var ranges = selection.ranges;\n        ranges.forEach(function (_a) {\n            var $from = _a.$from, $to = _a.$to;\n            cells_1.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.node($from.pos - 1, $to.pos + 1, { class: SELECTED_CELL_CLASS_NAME }));\n        });\n        return prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.DecorationSet.create(doc, cells_1);\n    }\n    return null;\n}\nfunction tableSelection() {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: pluginKey,\n        state: {\n            init: function () {\n                return null;\n            },\n            apply: function (tr, value) {\n                var cellOffset = tr.getMeta(pluginKey);\n                if (cellOffset) {\n                    return cellOffset === -1 ? null : cellOffset;\n                }\n                if (isNull_1(value) || !tr.docChanged) {\n                    return value;\n                }\n                var _a = tr.mapping.mapResult(value), deleted = _a.deleted, pos = _a.pos;\n                return deleted ? null : pos;\n            },\n        },\n        props: {\n            decorations: drawCellSelection,\n            createSelectionBetween: function (_a) {\n                var state = _a.state;\n                if (!isNull_1(pluginKey.getState(state))) {\n                    return state.selection;\n                }\n                return null;\n            },\n        },\n        view: function (editorView) {\n            return new TableSelection(editorView);\n        },\n    });\n}\n\n/**\n * @class\n * @ignore\n * @classdesc ES6 Map\n */\nvar Map$1 = /** @class */ (function () {\n    function Map() {\n        this.keys = [];\n        this.values = [];\n    }\n    Map.prototype.getKeyIndex = function (key) {\n        return inArray_1(key, this.keys);\n    };\n    Map.prototype.get = function (key) {\n        return this.values[this.getKeyIndex(key)];\n    };\n    Map.prototype.set = function (key, value) {\n        var keyIndex = this.getKeyIndex(key);\n        if (keyIndex > -1) {\n            this.values[keyIndex] = value;\n        }\n        else {\n            this.keys.push(key);\n            this.values.push(value);\n        }\n        return this;\n    };\n    Map.prototype.has = function (key) {\n        return this.getKeyIndex(key) > -1;\n    };\n    Map.prototype.delete = function (key) {\n        var keyIndex = this.getKeyIndex(key);\n        if (keyIndex > -1) {\n            this.keys.splice(keyIndex, 1);\n            this.values.splice(keyIndex, 1);\n            return true;\n        }\n        return false;\n    };\n    Map.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        if (thisArg === void 0) { thisArg = this; }\n        this.values.forEach(function (value, index) {\n            if (value && _this.keys[index]) {\n                callback.call(thisArg, value, _this.keys[index], _this);\n            }\n        });\n    };\n    Map.prototype.clear = function () {\n        this.keys = [];\n        this.values = [];\n    };\n    return Map;\n}());\n\n/**\n * @fileoverview Implements i18n\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n */\nvar DEFAULT_CODE = 'en-US';\n/**\n * Class I18n\n * @ignore\n */\nvar I18n = /** @class */ (function () {\n    function I18n() {\n        this.code = DEFAULT_CODE;\n        this.langs = new Map$1();\n    }\n    I18n.prototype.setCode = function (code) {\n        this.code = code || DEFAULT_CODE;\n    };\n    /**\n     * Set language set\n     * @param {string|string[]} codes locale code\n     * @param {object} data language set\n     */\n    I18n.prototype.setLanguage = function (codes, data) {\n        var _this = this;\n        codes = [].concat(codes);\n        codes.forEach(function (code) {\n            if (!_this.langs.has(code)) {\n                _this.langs.set(code, data);\n            }\n            else {\n                var langData = _this.langs.get(code);\n                _this.langs.set(code, extend_1(langData, data));\n            }\n        });\n    };\n    I18n.prototype.get = function (key, code) {\n        if (!code) {\n            code = this.code;\n        }\n        var langSet = this.langs.get(code);\n        if (!langSet) {\n            langSet = this.langs.get(DEFAULT_CODE);\n        }\n        var text = langSet[key];\n        if (!text) {\n            throw new Error(\"There is no text key \\\"\" + key + \"\\\" in \" + code);\n        }\n        return text;\n    };\n    return I18n;\n}());\nvar i18n = new I18n();\n\nvar contextMenuGroups = [\n    [\n        {\n            action: 'Add row to up',\n            command: 'addRowToUp',\n            disableInThead: true,\n            className: 'add-row-up',\n        },\n        {\n            action: 'Add row to down',\n            command: 'addRowToDown',\n            disableInThead: true,\n            className: 'add-row-down',\n        },\n        { action: 'Remove row', command: 'removeRow', disableInThead: true, className: 'remove-row' },\n    ],\n    [\n        { action: 'Add column to left', command: 'addColumnToLeft', className: 'add-column-left' },\n        { action: 'Add column to right', command: 'addColumnToRight', className: 'add-column-right' },\n        { action: 'Remove column', command: 'removeColumn', className: 'remove-column' },\n    ],\n    [\n        {\n            action: 'Align column to left',\n            command: 'alignColumn',\n            payload: { align: 'left' },\n            className: 'align-column-left',\n        },\n        {\n            action: 'Align column to center',\n            command: 'alignColumn',\n            payload: { align: 'center' },\n            className: 'align-column-center',\n        },\n        {\n            action: 'Align column to right',\n            command: 'alignColumn',\n            payload: { align: 'right' },\n            className: 'align-column-right',\n        },\n    ],\n    [{ action: 'Remove table', command: 'removeTable', className: 'remove-table' }],\n];\nfunction getContextMenuGroups(eventEmitter, inTableHead) {\n    return contextMenuGroups\n        .map(function (contextMenuGroup) {\n        return contextMenuGroup.map(function (_a) {\n            var action = _a.action, command = _a.command, payload = _a.payload, disableInThead = _a.disableInThead, className = _a.className;\n            return {\n                label: i18n.get(action),\n                onClick: function () {\n                    eventEmitter.emit('command', command, payload);\n                },\n                disabled: inTableHead && !!disableInThead,\n                className: className,\n            };\n        });\n    })\n        .concat();\n}\nfunction tableContextMenu(eventEmitter) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                contextmenu: function (view, ev) {\n                    var tableCell = findCellElement(ev.target, view.dom);\n                    if (tableCell) {\n                        ev.preventDefault();\n                        var _a = ev, clientX = _a.clientX, clientY = _a.clientY;\n                        var _b = view.dom.parentNode.getBoundingClientRect(), left = _b.left, top_1 = _b.top;\n                        var inTableHead = tableCell.nodeName === 'TH';\n                        eventEmitter.emit('contextmenu', {\n                            pos: { left: clientX - left + 10 + \"px\", top: clientY - top_1 + 30 + \"px\" },\n                            menuGroups: getContextMenuGroups(eventEmitter, inTableHead),\n                            tableCell: tableCell,\n                        });\n                        return true;\n                    }\n                    return false;\n                },\n            },\n        },\n    });\n}\n\nfunction task() {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                mousedown: function (view, ev) {\n                    var _a = ev, clientX = _a.clientX, clientY = _a.clientY;\n                    var mousePos = view.posAtCoords({ left: clientX, top: clientY });\n                    if (mousePos) {\n                        var _b = view.state, doc = _b.doc, tr = _b.tr;\n                        var currentPos = doc.resolve(mousePos.pos);\n                        var listItem = findListItem(currentPos);\n                        var target = ev.target;\n                        var style = getComputedStyle(target, ':before');\n                        var _c = ev, offsetX = _c.offsetX, offsetY = _c.offsetY;\n                        if (!listItem || !isPositionInBox(style, offsetX, offsetY)) {\n                            return false;\n                        }\n                        ev.preventDefault();\n                        var offset = currentPos.before(listItem.depth);\n                        var attrs = listItem.node.attrs;\n                        tr.setNodeMarkup(offset, null, __assign$1(__assign$1({}, attrs), { checked: !attrs.checked }));\n                        view.dispatch(tr);\n                        return true;\n                    }\n                    return false;\n                },\n            },\n        },\n    });\n}\n\nvar EXCEPT_TYPES = ['image', 'link', 'customBlock', 'frontMatter'];\nvar MARK_TYPES = ['strong', 'strike', 'emph', 'code'];\nvar LIST_TYPES = ['bulletList', 'orderedList', 'taskList'];\nfunction getToolbarStateType(node, parentNode) {\n    var type = node.type.name;\n    if (type === 'listItem') {\n        return node.attrs.task ? 'taskList' : parentNode.type.name;\n    }\n    if (type.indexOf('table') !== -1) {\n        return 'table';\n    }\n    return type;\n}\nfunction setListNodeToolbarState(type, nodeTypeState) {\n    nodeTypeState[type] = { active: true };\n    LIST_TYPES.filter(function (listName) { return listName !== type; }).forEach(function (listType) {\n        if (nodeTypeState[listType]) {\n            delete nodeTypeState[listType];\n        }\n    });\n}\nfunction setMarkTypeStates(from, to, schema, toolbarState) {\n    MARK_TYPES.forEach(function (type) {\n        var mark = schema.marks[type];\n        var marksAtPos = from.marksAcross(to) || [];\n        var foundMark = !!mark.isInSet(marksAtPos);\n        if (foundMark) {\n            toolbarState[type] = { active: true };\n        }\n    });\n}\nfunction getToolbarState(selection, doc, schema) {\n    var $from = selection.$from, $to = selection.$to, from = selection.from, to = selection.to;\n    var toolbarState = {\n        indent: { active: false, disabled: true },\n        outdent: { active: false, disabled: true },\n    };\n    doc.nodesBetween(from, to, function (node, _, parentNode) {\n        var type = getToolbarStateType(node, parentNode);\n        if (includes(EXCEPT_TYPES, type)) {\n            return;\n        }\n        if (includes(LIST_TYPES, type)) {\n            setListNodeToolbarState(type, toolbarState);\n            toolbarState.indent.disabled = false;\n            toolbarState.outdent.disabled = false;\n        }\n        else if (type === 'paragraph' || type === 'text') {\n            setMarkTypeStates($from, $to, schema, toolbarState);\n        }\n        else {\n            toolbarState[type] = { active: true };\n        }\n    });\n    return toolbarState;\n}\nfunction toolbarStateHighlight(eventEmitter) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        view: function () {\n            return {\n                update: function (view) {\n                    var _a = view.state, selection = _a.selection, doc = _a.doc, schema = _a.schema;\n                    eventEmitter.emit('changeToolbarState', {\n                        toolbarState: getToolbarState(selection, doc, schema),\n                    });\n                },\n            };\n        },\n    });\n}\n\nvar CustomBlockView = /** @class */ (function () {\n    function CustomBlockView(node, view, getPos, toDOMAdaptor) {\n        var _this = this;\n        this.openEditor = function () {\n            if (_this.innerEditorView) {\n                throw new Error('The editor is already opened.');\n            }\n            _this.dom.draggable = false;\n            _this.wrapper.style.display = 'none';\n            _this.innerViewContainer.style.display = 'block';\n            _this.innerEditorView = new prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView(_this.innerViewContainer, {\n                state: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({\n                    doc: _this.node,\n                    plugins: [\n                        (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)({\n                            'Mod-z': function () { return (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo)(_this.innerEditorView.state, _this.innerEditorView.dispatch); },\n                            'Shift-Mod-z': function () { return (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.redo)(_this.innerEditorView.state, _this.innerEditorView.dispatch); },\n                            Tab: function (state, dispatch) {\n                                dispatch(state.tr.insertText('\\t'));\n                                return true;\n                            },\n                            Enter: prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.newlineInCode,\n                            Escape: function () {\n                                _this.cancelEditing();\n                                return true;\n                            },\n                            'Ctrl-Enter': function () {\n                                _this.saveAndFinishEditing();\n                                return true;\n                            },\n                        }),\n                        (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.history)(),\n                    ],\n                }),\n                dispatchTransaction: function (tr) { return _this.dispatchInner(tr); },\n                handleDOMEvents: {\n                    mousedown: function () {\n                        if (_this.editorView.hasFocus()) {\n                            _this.innerEditorView.focus();\n                        }\n                        return true;\n                    },\n                    blur: function () {\n                        _this.saveAndFinishEditing();\n                        return true;\n                    },\n                },\n            });\n            _this.innerEditorView.focus();\n        };\n        this.node = node;\n        this.editorView = view;\n        this.getPos = getPos;\n        this.toDOMAdaptor = toDOMAdaptor;\n        this.innerEditorView = null;\n        this.canceled = false;\n        this.dom = document.createElement('div');\n        this.dom.className = cls('custom-block');\n        this.wrapper = document.createElement('div');\n        this.wrapper.className = cls('custom-block-view');\n        this.createInnerViewContainer();\n        this.renderCustomBlock();\n        this.dom.appendChild(this.innerViewContainer);\n        this.dom.appendChild(this.wrapper);\n    }\n    CustomBlockView.prototype.renderToolArea = function () {\n        var _this = this;\n        var tool = document.createElement('div');\n        var span = document.createElement('span');\n        var button = document.createElement('button');\n        tool.className = 'tool';\n        span.textContent = this.node.attrs.info;\n        span.className = 'info';\n        button.type = 'button';\n        button.addEventListener('click', function () { return _this.openEditor(); });\n        tool.appendChild(span);\n        tool.appendChild(button);\n        this.wrapper.appendChild(tool);\n    };\n    CustomBlockView.prototype.renderCustomBlock = function () {\n        var toDOMNode = this.toDOMAdaptor.getToDOMNode(this.node.attrs.info);\n        if (toDOMNode) {\n            var node = toDOMNode(this.node);\n            while (this.wrapper.hasChildNodes()) {\n                this.wrapper.removeChild(this.wrapper.lastChild);\n            }\n            if (node) {\n                this.wrapper.appendChild(node);\n            }\n            this.renderToolArea();\n        }\n    };\n    CustomBlockView.prototype.createInnerViewContainer = function () {\n        this.innerViewContainer = document.createElement('div');\n        this.innerViewContainer.className = cls('custom-block-editor');\n        this.innerViewContainer.style.display = 'none';\n    };\n    CustomBlockView.prototype.closeEditor = function () {\n        if (this.innerEditorView) {\n            this.innerEditorView.destroy();\n            this.innerEditorView = null;\n            this.innerViewContainer.style.display = 'none';\n        }\n        this.wrapper.style.display = 'block';\n    };\n    CustomBlockView.prototype.saveAndFinishEditing = function () {\n        var to = this.editorView.state.selection.to;\n        var outerState = this.editorView.state;\n        this.editorView.dispatch(outerState.tr.setSelection(createTextSelection(outerState.tr, to)));\n        this.editorView.focus();\n        this.renderCustomBlock();\n        this.closeEditor();\n    };\n    CustomBlockView.prototype.cancelEditing = function () {\n        var undoableCount = (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undoDepth)(this.innerEditorView.state);\n        this.canceled = true;\n        // should undo editing result\n        // eslint-disable-next-line no-plusplus\n        while (undoableCount--) {\n            (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo)(this.innerEditorView.state, this.innerEditorView.dispatch);\n            (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo)(this.editorView.state, this.editorView.dispatch);\n        }\n        this.canceled = false;\n        var to = this.editorView.state.selection.to;\n        var outerState = this.editorView.state;\n        this.editorView.dispatch(outerState.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(outerState.doc, to)));\n        this.editorView.focus();\n        this.closeEditor();\n    };\n    CustomBlockView.prototype.dispatchInner = function (tr) {\n        var _a = this.innerEditorView.state.applyTransaction(tr), state = _a.state, transactions = _a.transactions;\n        this.innerEditorView.updateState(state);\n        if (!this.canceled && isFunction_1(this.getPos)) {\n            var outerTr = this.editorView.state.tr;\n            var offsetMap = prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.StepMap.offset(this.getPos() + 1);\n            for (var i = 0; i < transactions.length; i += 1) {\n                var steps = transactions[i].steps;\n                for (var j = 0; j < steps.length; j += 1) {\n                    outerTr.step(steps[j].map(offsetMap));\n                }\n            }\n            if (outerTr.docChanged) {\n                this.editorView.dispatch(outerTr);\n            }\n        }\n    };\n    CustomBlockView.prototype.update = function (node) {\n        if (!node.sameMarkup(this.node)) {\n            return false;\n        }\n        this.node = node;\n        if (!this.innerEditorView) {\n            this.renderCustomBlock();\n        }\n        return true;\n    };\n    CustomBlockView.prototype.stopEvent = function (event) {\n        return (!!this.innerEditorView &&\n            !!event.target &&\n            this.innerEditorView.dom.contains(event.target));\n    };\n    CustomBlockView.prototype.ignoreMutation = function () {\n        return true;\n    };\n    CustomBlockView.prototype.destroy = function () {\n        this.dom.removeEventListener('dblclick', this.openEditor);\n        this.closeEditor();\n    };\n    return CustomBlockView;\n}());\n\nvar IMAGE_LINK_CLASS_NAME = 'image-link';\nvar ImageView = /** @class */ (function () {\n    function ImageView(node, view, getPos, eventEmitter) {\n        var _this = this;\n        var _a;\n        this.handleMousedown = function (ev) {\n            ev.preventDefault();\n            var target = ev.target, offsetX = ev.offsetX, offsetY = ev.offsetY;\n            if (_this.imageLink &&\n                isFunction_1(_this.getPos) &&\n                hasClass_1(target, IMAGE_LINK_CLASS_NAME)) {\n                var style = getComputedStyle(target, ':before');\n                ev.stopPropagation();\n                if (isPositionInBox(style, offsetX, offsetY)) {\n                    var tr = _this.view.state.tr;\n                    var pos = _this.getPos();\n                    tr.setSelection(createTextSelection(tr, pos, pos + 1));\n                    _this.view.dispatch(tr);\n                    _this.eventEmitter.emit('openPopup', 'link', _this.imageLink.attrs);\n                }\n            }\n        };\n        this.node = node;\n        this.view = view;\n        this.getPos = getPos;\n        this.eventEmitter = eventEmitter;\n        this.imageLink = (_a = node.marks.filter(function (_a) {\n            var type = _a.type;\n            return type.name === 'link';\n        })[0]) !== null && _a !== void 0 ? _a : null;\n        this.dom = this.createElement();\n        this.bindEvent();\n    }\n    ImageView.prototype.createElement = function () {\n        var image = this.createImageElement(this.node);\n        if (this.imageLink) {\n            var wrapper = document.createElement('span');\n            wrapper.className = IMAGE_LINK_CLASS_NAME;\n            wrapper.appendChild(image);\n            return wrapper;\n        }\n        return image;\n    };\n    ImageView.prototype.createImageElement = function (node) {\n        var image = document.createElement('img');\n        var _a = node.attrs, imageUrl = _a.imageUrl, altText = _a.altText;\n        var attrs = getCustomAttrs(node.attrs);\n        image.src = imageUrl;\n        if (altText) {\n            image.alt = altText;\n        }\n        setAttributes(attrs, image);\n        return image;\n    };\n    ImageView.prototype.bindEvent = function () {\n        if (this.imageLink) {\n            this.dom.addEventListener('mousedown', this.handleMousedown);\n        }\n    };\n    ImageView.prototype.stopEvent = function () {\n        return true;\n    };\n    ImageView.prototype.destroy = function () {\n        if (this.imageLink) {\n            this.dom.removeEventListener('mousedown', this.handleMousedown);\n        }\n    };\n    return ImageView;\n}());\n\nvar WRAPPER_CLASS_NAME = 'toastui-editor-ww-code-block';\nvar CODE_BLOCK_LANG_CLASS_NAME = 'toastui-editor-ww-code-block-language';\nvar CodeBlockView = /** @class */ (function () {\n    function CodeBlockView(node, view, getPos, eventEmitter) {\n        var _this = this;\n        this.contentDOM = null;\n        this.input = null;\n        this.timer = null;\n        this.handleMousedown = function (ev) {\n            var target = ev.target;\n            var style = getComputedStyle(target, ':after');\n            // judge to click pseudo element with background image for IE11\n            if (style.backgroundImage !== 'none' && isFunction_1(_this.getPos)) {\n                var _a = _this.view.coordsAtPos(_this.getPos()), top_1 = _a.top, right = _a.right;\n                _this.createLanguageEditor({ top: top_1, right: right });\n            }\n        };\n        this.handleKeydown = function (ev) {\n            if (ev.key === 'Enter' && _this.input) {\n                ev.preventDefault();\n                _this.changeLanguage();\n            }\n        };\n        this.node = node;\n        this.view = view;\n        this.getPos = getPos;\n        this.eventEmitter = eventEmitter;\n        this.createElement();\n        this.bindDOMEvent();\n        this.bindEvent();\n    }\n    CodeBlockView.prototype.createElement = function () {\n        var language = this.node.attrs.language;\n        var wrapper = document.createElement('div');\n        wrapper.setAttribute('data-language', language || 'text');\n        wrapper.className = WRAPPER_CLASS_NAME;\n        var pre = this.createCodeBlockElement();\n        var code = pre.firstChild;\n        wrapper.appendChild(pre);\n        this.dom = wrapper;\n        this.contentDOM = code;\n    };\n    CodeBlockView.prototype.createCodeBlockElement = function () {\n        var pre = document.createElement('pre');\n        var code = document.createElement('code');\n        var language = this.node.attrs.language;\n        var attrs = getCustomAttrs(this.node.attrs);\n        if (language) {\n            code.setAttribute('data-language', language);\n        }\n        setAttributes(attrs, pre);\n        pre.appendChild(code);\n        return pre;\n    };\n    CodeBlockView.prototype.createLanguageEditor = function (_a) {\n        var _this = this;\n        var top = _a.top, right = _a.right;\n        var wrapper = document.createElement('span');\n        wrapper.className = CODE_BLOCK_LANG_CLASS_NAME;\n        var input = document.createElement('input');\n        input.type = 'text';\n        input.value = this.node.attrs.language;\n        wrapper.appendChild(input);\n        this.view.dom.parentElement.appendChild(wrapper);\n        var wrpperWidth = wrapper.clientWidth;\n        css_1(wrapper, {\n            top: top + 10 + \"px\",\n            left: right - wrpperWidth - 10 + \"px\",\n            width: wrpperWidth + \"px\",\n        });\n        this.input = input;\n        this.input.addEventListener('blur', function () { return _this.changeLanguage(); });\n        this.input.addEventListener('keydown', this.handleKeydown);\n        this.clearTimer();\n        this.timer = setTimeout(function () {\n            _this.input.focus();\n        });\n    };\n    CodeBlockView.prototype.bindDOMEvent = function () {\n        if (this.dom) {\n            this.dom.addEventListener('click', this.handleMousedown);\n        }\n    };\n    CodeBlockView.prototype.bindEvent = function () {\n        var _this = this;\n        this.eventEmitter.listen('scroll', function () {\n            if (_this.input) {\n                _this.reset();\n            }\n        });\n    };\n    CodeBlockView.prototype.changeLanguage = function () {\n        if (this.input && isFunction_1(this.getPos)) {\n            var value = this.input.value;\n            this.reset();\n            var pos = this.getPos();\n            var tr = this.view.state.tr;\n            tr.setNodeMarkup(pos, null, { language: value });\n            this.view.dispatch(tr);\n        }\n    };\n    CodeBlockView.prototype.reset = function () {\n        var _a;\n        if ((_a = this.input) === null || _a === void 0 ? void 0 : _a.parentElement) {\n            var parent_1 = this.input.parentElement;\n            this.input = null;\n            removeNode$1(parent_1);\n        }\n    };\n    CodeBlockView.prototype.clearTimer = function () {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n    CodeBlockView.prototype.stopEvent = function () {\n        return true;\n    };\n    CodeBlockView.prototype.update = function (node) {\n        if (!node.sameMarkup(this.node)) {\n            return false;\n        }\n        this.node = node;\n        return true;\n    };\n    CodeBlockView.prototype.destroy = function () {\n        this.reset();\n        this.clearTimer();\n        if (this.dom) {\n            this.dom.removeEventListener('click', this.handleMousedown);\n        }\n    };\n    return CodeBlockView;\n}());\n\nvar reMSOListClassName = /MsoListParagraph/;\nvar reMSOStylePrefix = /style=(.|\\n)*mso-/;\nvar reMSOListStyle = /mso-list:(.*)/;\nvar reMSOTagName = /O:P/;\nvar reMSOListBullet = /^(n|u|l)/;\nvar MSO_CLASS_NAME_LIST_PARA = 'p.MsoListParagraph';\nfunction isFromMso(html) {\n    return reMSOStylePrefix.test(html);\n}\nfunction getListItemContents(para) {\n    var removedNodes = [];\n    var walker = document.createTreeWalker(para, 1, null, false);\n    while (walker.nextNode()) {\n        var node = walker.currentNode;\n        if (isElemNode(node)) {\n            var _a = node, outerHTML = _a.outerHTML, textContent = _a.textContent;\n            var msoSpan = reMSOStylePrefix.test(outerHTML);\n            var bulletSpan = reMSOListStyle.test(outerHTML);\n            if (msoSpan && !bulletSpan && textContent) {\n                removedNodes.push([node, true]);\n            }\n            else if (reMSOTagName.test(node.nodeName) || (msoSpan && !textContent) || bulletSpan) {\n                removedNodes.push([node, false]);\n            }\n        }\n    }\n    removedNodes.forEach(function (_a) {\n        var node = _a[0], isUnwrap = _a[1];\n        if (isUnwrap) {\n            unwrapNode(node);\n        }\n        else {\n            removeNode$1(node);\n        }\n    });\n    return para.innerHTML.trim();\n}\nfunction createListItemDataFromParagraph(para, index) {\n    var styleAttr = para.getAttribute('style');\n    if (styleAttr) {\n        var _a = styleAttr.match(reMSOListStyle), listItemInfo = _a[1];\n        var _b = listItemInfo.trim().split(' '), levelStr = _b[1];\n        var level = parseInt(levelStr.replace('level', ''), 10);\n        var unordered = reMSOListBullet.test(para.textContent || '');\n        return {\n            id: index,\n            level: level,\n            prev: null,\n            parent: null,\n            children: [],\n            unordered: unordered,\n            contents: getListItemContents(para),\n        };\n    }\n    return null;\n}\nfunction addListItemDetailData(data, prevData) {\n    if (prevData.level < data.level) {\n        prevData.children.push(data);\n        data.parent = prevData;\n    }\n    else {\n        while (prevData) {\n            if (prevData.level === data.level) {\n                break;\n            }\n            prevData = prevData.parent;\n        }\n        if (prevData) {\n            data.prev = prevData;\n            data.parent = prevData.parent;\n            if (data.parent) {\n                data.parent.children.push(data);\n            }\n        }\n    }\n}\nfunction createListData(paras) {\n    var listData = [];\n    paras.forEach(function (para, index) {\n        var prevListItemData = listData[index - 1];\n        var listItemData = createListItemDataFromParagraph(para, index);\n        if (listItemData) {\n            if (prevListItemData) {\n                addListItemDetailData(listItemData, prevListItemData);\n            }\n            listData.push(listItemData);\n        }\n    });\n    return listData;\n}\nfunction makeList(listData) {\n    var listTagName = listData[0].unordered ? 'ul' : 'ol';\n    var list = document.createElement(listTagName);\n    listData.forEach(function (data) {\n        var children = data.children, contents = data.contents;\n        var listItem = document.createElement('li');\n        listItem.innerHTML = contents;\n        list.appendChild(listItem);\n        if (children.length) {\n            list.appendChild(makeList(children));\n        }\n    });\n    return list;\n}\nfunction makeListFromParagraphs(paras) {\n    var listData = createListData(paras);\n    var rootChildren = listData.filter(function (_a) {\n        var parent = _a.parent;\n        return !parent;\n    });\n    return makeList(rootChildren);\n}\nfunction isMsoListParagraphEnd(node) {\n    while (node) {\n        if (isElemNode(node)) {\n            break;\n        }\n        node = node.nextSibling;\n    }\n    return node ? !reMSOListClassName.test(node.className) : true;\n}\nfunction convertMsoParagraphsToList(html) {\n    var container = document.createElement('div');\n    container.innerHTML = html;\n    var paras = [];\n    var foundParas = findNodes(container, MSO_CLASS_NAME_LIST_PARA);\n    foundParas.forEach(function (para) {\n        var msoListParaEnd = isMsoListParagraphEnd(para.nextSibling);\n        paras.push(para);\n        if (msoListParaEnd) {\n            var list = makeListFromParagraphs(paras);\n            var nextSibling = para.nextSibling;\n            if (nextSibling) {\n                insertBeforeNode(list, nextSibling);\n            }\n            else {\n                appendNodes(container, list);\n            }\n            paras = [];\n        }\n        removeNode$1(para);\n    });\n    // without `<p></p>`, the list string was parsed as a paragraph node and added\n    var extraHTML = foundParas.length ? '<p></p>' : '';\n    return \"\" + extraHTML + container.innerHTML;\n}\n\nvar START_FRAGMENT_COMMENT = '<!--StartFragment-->';\nvar END_FRAGMENT_COMMENT = '<!--EndFragment-->';\nfunction getContentBetweenFragmentComments(html) {\n    var startFragmentIndex = html.indexOf(START_FRAGMENT_COMMENT);\n    var endFragmentIndex = html.lastIndexOf(END_FRAGMENT_COMMENT);\n    if (startFragmentIndex > -1 && endFragmentIndex > -1) {\n        html = html.slice(startFragmentIndex + START_FRAGMENT_COMMENT.length, endFragmentIndex);\n    }\n    return html.replace(/<br[^>]*>/g, ALTERNATIVE_TAG_FOR_BR);\n}\nfunction convertMsoTableToCompletedTable(html) {\n    // wrap with <tr> if html contains dangling <td> tags\n    // dangling <td> tag is that tag does not have <tr> as parent node\n    if (/<\\/td>((?!<\\/tr>)[\\s\\S])*$/i.test(html)) {\n        html = \"<tr>\" + html + \"</tr>\";\n    }\n    // wrap with <table> if html contains dangling <tr> tags\n    // dangling <tr> tag is that tag does not have <table> as parent node\n    if (/<\\/tr>((?!<\\/table>)[\\s\\S])*$/i.test(html)) {\n        html = \"<table>\" + html + \"</table>\";\n    }\n    return html;\n}\nfunction changePastedHTML(html) {\n    html = getContentBetweenFragmentComments(html);\n    html = convertMsoTableToCompletedTable(html);\n    if (isFromMso(html)) {\n        html = convertMsoParagraphsToList(html);\n    }\n    return html;\n}\nfunction getMaxColumnCount(rows) {\n    var row = rows.reduce(function (prevRow, currentRow) {\n        return prevRow.childCount > currentRow.childCount ? prevRow : currentRow;\n    });\n    return row.childCount;\n}\nfunction createCells(orgRow, maxColumnCount, cell) {\n    var cells = [];\n    var cellCount = orgRow.childCount;\n    for (var colIdx = 0; colIdx < cellCount; colIdx += 1) {\n        if (!orgRow.child(colIdx).attrs.extended) {\n            var copiedCell = colIdx < cellCount\n                ? cell.create(orgRow.child(colIdx).attrs, orgRow.child(colIdx).content)\n                : cell.createAndFill();\n            cells.push(copiedCell);\n        }\n    }\n    return cells;\n}\nfunction copyTableHeadRow(orgRow, maxColumnCount, schema) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableHeadCell = _a.tableHeadCell;\n    var cells = createCells(orgRow, maxColumnCount, tableHeadCell);\n    return tableRow.create(null, cells);\n}\nfunction copyTableBodyRow(orgRow, maxColumnCount, schema) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableBodyCell = _a.tableBodyCell;\n    var cells = createCells(orgRow, maxColumnCount, tableBodyCell);\n    return tableRow.create(null, cells);\n}\nfunction creatTableBodyDummyRow(columnCount, schema) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableBodyCell = _a.tableBodyCell;\n    var cells = [];\n    for (var columnIndex = 0; columnIndex < columnCount; columnIndex += 1) {\n        var dummyCell = tableBodyCell.createAndFill();\n        cells.push(dummyCell);\n    }\n    return tableRow.create({ dummyRowForPasting: true }, cells);\n}\nfunction createRowsFromPastingTable(tableContent) {\n    var tableHeadRows = [];\n    var tableBodyRows = [];\n    if (tableContent.firstChild.type.name === 'tableHead') {\n        var tableHead = tableContent.firstChild;\n        tableHead.forEach(function (row) { return tableHeadRows.push(row); });\n    }\n    if (tableContent.lastChild.type.name === 'tableBody') {\n        var tableBody = tableContent.lastChild;\n        tableBody.forEach(function (row) { return tableBodyRows.push(row); });\n    }\n    return __spreadArray$1(__spreadArray$1([], tableHeadRows), tableBodyRows);\n}\nfunction createTableHead(tableHeadRow, maxColumnCount, schema) {\n    var copiedRow = copyTableHeadRow(tableHeadRow, maxColumnCount, schema);\n    return schema.nodes.tableHead.create(null, copiedRow);\n}\nfunction createTableBody(tableBodyRows, maxColumnCount, schema) {\n    var copiedRows = tableBodyRows.map(function (tableBodyRow) {\n        return copyTableBodyRow(tableBodyRow, maxColumnCount, schema);\n    });\n    if (!tableBodyRows.length) {\n        var dummyTableRow = creatTableBodyDummyRow(maxColumnCount, schema);\n        copiedRows.push(dummyTableRow);\n    }\n    return schema.nodes.tableBody.create(null, copiedRows);\n}\nfunction createTableFromPastingTable(rows, schema, startFromBody, isInTable) {\n    var columnCount = getMaxColumnCount(rows);\n    if (startFromBody && isInTable) {\n        return schema.nodes.table.create(null, [createTableBody(rows, columnCount, schema)]);\n    }\n    var tableHeadRow = rows[0];\n    var tableBodyRows = rows.slice(1);\n    var nodes = [createTableHead(tableHeadRow, columnCount, schema)];\n    if (tableBodyRows.length) {\n        nodes.push(createTableBody(tableBodyRows, columnCount, schema));\n    }\n    return schema.nodes.table.create(null, nodes);\n}\nfunction changePastedSlice(slice, schema, isInTable) {\n    var nodes = [];\n    var content = slice.content, openStart = slice.openStart, openEnd = slice.openEnd;\n    content.forEach(function (node) {\n        if (node.type.name === 'table') {\n            var tableContent = getTableContentFromSlice(new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(node), 0, 0));\n            if (tableContent) {\n                var rows = createRowsFromPastingTable(tableContent);\n                var startFromBody = tableContent.firstChild.type.name === 'tableBody';\n                var table = createTableFromPastingTable(rows, schema, startFromBody, isInTable);\n                nodes.push(table);\n            }\n        }\n        else {\n            nodes.push(node);\n        }\n    });\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(nodes), openStart, openEnd);\n}\n\nvar DUMMY_CELL_SIZE = 4;\nvar TR_NODES_SIZE = 2;\nfunction getDummyCellSize(dummyCellCount) {\n    return dummyCellCount * DUMMY_CELL_SIZE;\n}\nfunction createPastingCells(tableContent, curSelectionInfo, schema) {\n    var pastingRows = [];\n    var pastingTableRows = createRowsFromPastingTable(tableContent);\n    var columnCount = pastingTableRows[0].childCount;\n    var rowCount = pastingTableRows.length;\n    var startToTableHead = curSelectionInfo.startRowIdx === 0;\n    var slicedRows = pastingTableRows.slice(0, rowCount);\n    if (startToTableHead) {\n        var tableHeadRow = slicedRows.shift();\n        if (tableHeadRow) {\n            var content = copyTableHeadRow(tableHeadRow, columnCount, schema).content;\n            pastingRows.push(content);\n        }\n    }\n    slicedRows.forEach(function (tableBodyRow) {\n        if (!tableBodyRow.attrs.dummyRowForPasting) {\n            var content = copyTableBodyRow(tableBodyRow, columnCount, schema).content;\n            pastingRows.push(content);\n        }\n    });\n    return pastingRows;\n}\nfunction getPastingRangeInfo(map, _a, pastingCells) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx;\n    var pastingRowCount = pastingCells.length;\n    var pastingColumnCount = 0;\n    var _loop_1 = function (i) {\n        var columnCount = pastingCells[i].childCount;\n        pastingCells[i].forEach(function (_a) {\n            var attrs = _a.attrs;\n            var colspan = attrs.colspan;\n            if (colspan > 1) {\n                columnCount += colspan - 1;\n            }\n        });\n        pastingColumnCount = Math.max(pastingColumnCount, columnCount);\n    };\n    for (var i = 0; i < pastingRowCount; i += 1) {\n        _loop_1(i);\n    }\n    var endRowIdx = startRowIdx + pastingRowCount - 1;\n    var endColIdx = startColIdx + pastingColumnCount - 1;\n    var addedRowCount = Math.max(endRowIdx + 1 - map.totalRowCount, 0);\n    var addedColumnCount = Math.max(endColIdx + 1 - map.totalColumnCount, 0);\n    return {\n        startRowIdx: startRowIdx,\n        startColIdx: startColIdx,\n        endRowIdx: endRowIdx,\n        endColIdx: endColIdx,\n        addedRowCount: addedRowCount,\n        addedColumnCount: addedColumnCount,\n    };\n}\nfunction addReplacedOffsets(_a, cellsOffsets) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx, addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount;\n    for (var rowIdx = startRowIdx; rowIdx <= endRowIdx - addedRowCount; rowIdx += 1) {\n        cellsOffsets.push({\n            rowIdx: rowIdx,\n            startColIdx: startColIdx,\n            endColIdx: endColIdx - addedColumnCount,\n        });\n    }\n}\nfunction expandColumns(tr, schema, map, _a, cellsOffsets) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx, addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount;\n    var totalRowCount = map.totalRowCount;\n    var index = 0;\n    for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n        var _b = map.getCellInfo(rowIdx, endColIdx - addedColumnCount), offset = _b.offset, nodeSize = _b.nodeSize;\n        var insertOffset = tr.mapping.map(offset + nodeSize);\n        var cells = createDummyCells(addedColumnCount, rowIdx, schema);\n        tr.insert(insertOffset, cells);\n        if (rowIdx >= startRowIdx && rowIdx <= endRowIdx - addedRowCount) {\n            var cellInfo = map.getCellInfo(rowIdx, endColIdx - addedColumnCount);\n            var startCellOffset = tr.mapping.map(cellInfo.offset);\n            var endCellOffset = insertOffset + getDummyCellSize(addedColumnCount);\n            cellsOffsets[index] = {\n                rowIdx: rowIdx,\n                startColIdx: startColIdx,\n                endColIdx: endColIdx,\n                dummyOffsets: [startCellOffset, endCellOffset],\n            };\n            index += 1;\n        }\n    }\n}\nfunction expandRows(tr, schema, map, _a, cellsOffsets) {\n    var addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount, startColIdx = _a.startColIdx, endColIdx = _a.endColIdx;\n    var mapStart = tr.mapping.maps.length;\n    var tableEndPos = map.tableEndOffset - 2;\n    var rows = createTableBodyRows(addedRowCount, map.totalColumnCount + addedColumnCount, schema);\n    var startOffset = tableEndPos;\n    tr.insert(tr.mapping.slice(mapStart).map(startOffset), rows);\n    for (var rowIndex = 0; rowIndex < addedRowCount; rowIndex += 1) {\n        var startCellOffset = startOffset + getDummyCellSize(startColIdx) + 1;\n        var endCellOffset = startOffset + getDummyCellSize(endColIdx + 1) + 1;\n        var nextCellOffset = startOffset + getDummyCellSize(map.totalColumnCount + addedColumnCount) + TR_NODES_SIZE;\n        cellsOffsets.push({\n            rowIdx: rowIndex + map.totalRowCount,\n            startColIdx: startColIdx,\n            endColIdx: endColIdx,\n            dummyOffsets: [startCellOffset, endCellOffset],\n        });\n        startOffset = nextCellOffset;\n    }\n}\nfunction replaceCells(tr, pastingRows, cellsOffsets, map) {\n    var mapStart = tr.mapping.maps.length;\n    cellsOffsets.forEach(function (offsets, index) {\n        var rowIdx = offsets.rowIdx, startColIdx = offsets.startColIdx, endColIdx = offsets.endColIdx, dummyOffsets = offsets.dummyOffsets;\n        var mapping = tr.mapping.slice(mapStart);\n        var cells = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(pastingRows[index], 0, 0);\n        var from = dummyOffsets ? dummyOffsets[0] : map.getCellStartOffset(rowIdx, startColIdx);\n        var to = dummyOffsets ? dummyOffsets[1] : map.getCellEndOffset(rowIdx, endColIdx);\n        tr.replace(mapping.map(from), mapping.map(to), cells);\n    });\n}\nfunction pasteToTable(view, slice) {\n    var _a = view.state, selection = _a.selection, schema = _a.schema, tr = _a.tr;\n    var _b = getResolvedSelection(selection), anchor = _b.anchor, head = _b.head;\n    if (anchor && head) {\n        var tableContent = getTableContentFromSlice(slice);\n        if (!tableContent) {\n            return false;\n        }\n        var map = TableOffsetMap.create(anchor);\n        var curSelectionInfo = map.getRectOffsets(anchor, head);\n        var pastingCells = createPastingCells(tableContent, curSelectionInfo, schema);\n        var pastingInfo = getPastingRangeInfo(map, curSelectionInfo, pastingCells);\n        var cellsOffsets = [];\n        // @TODO: unmerge the span and paste the cell\n        if (canMerge(map, pastingInfo)) {\n            addReplacedOffsets(pastingInfo, cellsOffsets);\n            if (pastingInfo.addedColumnCount) {\n                expandColumns(tr, schema, map, pastingInfo, cellsOffsets);\n            }\n            if (pastingInfo.addedRowCount) {\n                expandRows(tr, schema, map, pastingInfo, cellsOffsets);\n            }\n            replaceCells(tr, pastingCells, cellsOffsets, map);\n            view.dispatch(tr);\n            setSelection(view, cellsOffsets, map.getCellInfo(0, 0).offset);\n        }\n        return true;\n    }\n    return false;\n}\nfunction setSelection(view, cellsOffsets, pos) {\n    var _a = view.state, tr = _a.tr, doc = _a.doc;\n    // get changed cell offsets\n    var map = TableOffsetMap.create(doc.resolve(pos));\n    // eslint-disable-next-line prefer-destructuring\n    var _b = cellsOffsets[0], startRowIdx = _b.rowIdx, startColIdx = _b.startColIdx;\n    var _c = last$1(cellsOffsets), endRowIdx = _c.rowIdx, endColIdx = _c.endColIdx;\n    var startOffset = map.getCellInfo(startRowIdx, startColIdx).offset;\n    var endOffset = map.getCellInfo(endRowIdx, endColIdx).offset;\n    view.dispatch(tr.setSelection(new CellSelection(doc.resolve(startOffset), doc.resolve(endOffset))));\n}\nfunction canMerge(map, pastingInfo) {\n    var ranges = map.getSpannedOffsets(pastingInfo);\n    var _a = getRowAndColumnCount(ranges), rowCount = _a.rowCount, columnCount = _a.columnCount;\n    var _b = getRowAndColumnCount(pastingInfo), pastingRowCount = _b.rowCount, pastingColumnCount = _b.columnCount;\n    return rowCount === pastingRowCount && columnCount === pastingColumnCount;\n}\n\nvar Doc = /** @class */ (function (_super) {\n    __extends$1(Doc, _super);\n    function Doc() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Doc.prototype, \"name\", {\n        get: function () {\n            return 'doc';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Doc.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'block+',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Doc;\n}(Node$2));\n\nvar Paragraph = /** @class */ (function (_super) {\n    __extends$1(Paragraph, _super);\n    function Paragraph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Paragraph.prototype, \"name\", {\n        get: function () {\n            return 'paragraph';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Paragraph.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'inline*',\n                group: 'block',\n                attrs: __assign$1({}, getDefaultCustomAttrs()),\n                parseDOM: [{ tag: 'p' }],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['p', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Paragraph;\n}(Node$2));\n\nvar reSoftTabLen = /\\s{1,4}$/;\nvar Text = /** @class */ (function (_super) {\n    __extends$1(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Text.prototype, \"name\", {\n        get: function () {\n            return 'text';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"schema\", {\n        get: function () {\n            return {\n                group: 'inline',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Text.prototype.addSpaces = function () {\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr;\n            var $from = selection.$from, $to = selection.$to;\n            var range = $from.blockRange($to);\n            if (range && !isInListNode($from) && !isInTableNode($from)) {\n                dispatch(tr.insertText('    ', $from.pos, $to.pos));\n                return true;\n            }\n            return false;\n        };\n    };\n    Text.prototype.removeSpaces = function () {\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr;\n            var $from = selection.$from, $to = selection.$to, from = selection.from;\n            var range = $from.blockRange($to);\n            if (range && !isInListNode($from) && !isInTableNode($from)) {\n                var nodeBefore = $from.nodeBefore;\n                if (nodeBefore && nodeBefore.isText) {\n                    var text = nodeBefore.text;\n                    var removedSpaceText = text.replace(reSoftTabLen, '');\n                    var spaces = text.length - removedSpaceText.length;\n                    dispatch(tr.delete(from - spaces, from));\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    Text.prototype.keymaps = function () {\n        return {\n            Tab: this.addSpaces(),\n            'Shift-Tab': this.removeSpaces(),\n        };\n    };\n    return Text;\n}(Node$2));\n\nvar Heading = /** @class */ (function (_super) {\n    __extends$1(Heading, _super);\n    function Heading() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Heading.prototype, \"name\", {\n        get: function () {\n            return 'heading';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heading.prototype, \"levels\", {\n        get: function () {\n            return [1, 2, 3, 4, 5, 6];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heading.prototype, \"schema\", {\n        get: function () {\n            var parseDOM = this.levels.map(function (level) {\n                return {\n                    tag: \"h\" + level,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute('data-raw-html');\n                        return __assign$1({ level: level }, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ level: { default: 1 }, headingType: { default: 'atx' }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                content: 'inline*',\n                group: 'block',\n                defining: true,\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\"h\" + attrs.level, getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Heading.prototype.commands = function () {\n        return function (payload) { return function (state, dispatch) {\n            var nodeType = state.schema.nodes[payload.level ? 'heading' : 'paragraph'];\n            return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(nodeType, payload)(state, dispatch);\n        }; };\n    };\n    return Heading;\n}(Node$2));\n\nvar CodeBlock = /** @class */ (function (_super) {\n    __extends$1(CodeBlock, _super);\n    function CodeBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CodeBlock.prototype, \"name\", {\n        get: function () {\n            return 'codeBlock';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CodeBlock.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'text*',\n                group: 'block',\n                attrs: __assign$1({ language: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                code: true,\n                defining: true,\n                marks: '',\n                parseDOM: [\n                    {\n                        tag: 'pre',\n                        preserveWhitespace: 'full',\n                        getAttrs: function (dom) {\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            var child = dom.firstElementChild;\n                            return __assign$1({ language: (child === null || child === void 0 ? void 0 : child.getAttribute('data-language')) || null }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || 'pre',\n                        ['code', __assign$1({ 'data-language': attrs.language }, getCustomAttrs(attrs)), 0],\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CodeBlock.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(state.schema.nodes.codeBlock)(state, dispatch); }; };\n    };\n    CodeBlock.prototype.moveCursor = function (direction) {\n        var _this = this;\n        return function (state, dispatch) {\n            var tr = state.tr, doc = state.doc, schema = state.schema;\n            var $from = state.selection.$from;\n            var view = _this.context.view;\n            if (view.endOfTextblock(direction) && $from.node().type.name === 'codeBlock') {\n                var lines = $from.parent.textContent.split('\\n');\n                var offset = direction === 'up' ? $from.start() : $from.end();\n                var range = direction === 'up'\n                    ? [offset, lines[0].length + offset]\n                    : [offset - last$1(lines).length, offset];\n                var pos = doc.resolve(direction === 'up' ? $from.before() : $from.after());\n                var node = direction === 'up' ? pos.nodeBefore : pos.nodeAfter;\n                if (between$1($from.pos, range[0], range[1]) && !node) {\n                    var newTr = addParagraph(tr, pos, schema);\n                    if (newTr) {\n                        dispatch(newTr);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n    };\n    CodeBlock.prototype.keymaps = function () {\n        var codeCommand = this.commands()();\n        return {\n            'Shift-Mod-p': codeCommand,\n            'Shift-Mod-P': codeCommand,\n            ArrowUp: this.moveCursor('up'),\n            ArrowDown: this.moveCursor('down'),\n        };\n    };\n    return CodeBlock;\n}(Node$2));\n\nvar BulletList = /** @class */ (function (_super) {\n    __extends$1(BulletList, _super);\n    function BulletList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(BulletList.prototype, \"name\", {\n        get: function () {\n            return 'bulletList';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BulletList.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'listItem+',\n                group: 'block',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [createDOMInfoParsedRawHTML('ul')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['ul', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BulletList.prototype.changeList = function () {\n        return function (state, dispatch) { return changeList(state.schema.nodes.bulletList)(state, dispatch); };\n    };\n    BulletList.prototype.commands = function () {\n        return {\n            bulletList: this.changeList,\n            taskList: toggleTask,\n        };\n    };\n    BulletList.prototype.keymaps = function () {\n        var bulletListCommand = this.changeList();\n        var _a = getWwCommands(), indent = _a.indent, outdent = _a.outdent;\n        return {\n            'Mod-u': bulletListCommand,\n            'Mod-U': bulletListCommand,\n            Tab: indent(),\n            'Shift-Tab': outdent(),\n        };\n    };\n    return BulletList;\n}(Node$2));\n\nvar OrderedList = /** @class */ (function (_super) {\n    __extends$1(OrderedList, _super);\n    function OrderedList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(OrderedList.prototype, \"name\", {\n        get: function () {\n            return 'orderedList';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OrderedList.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'listItem+',\n                group: 'block',\n                attrs: __assign$1({ order: { default: 1 }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: 'ol',\n                        getAttrs: function (dom) {\n                            var start = dom.getAttribute('start');\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            return __assign$1({ order: dom.hasAttribute('start') ? Number(start) : 1 }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || 'ol',\n                        __assign$1({ start: attrs.order === 1 ? null : attrs.order }, getCustomAttrs(attrs)),\n                        0,\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    OrderedList.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return changeList(state.schema.nodes.orderedList)(state, dispatch); }; };\n    };\n    OrderedList.prototype.keymaps = function () {\n        var orderedListCommand = this.commands()();\n        var _a = getWwCommands(), indent = _a.indent, outdent = _a.outdent;\n        return {\n            'Mod-o': orderedListCommand,\n            'Mod-O': orderedListCommand,\n            Tab: indent(),\n            'Shift-Tab': outdent(),\n        };\n    };\n    return OrderedList;\n}(Node$2));\n\nvar ListItem = /** @class */ (function (_super) {\n    __extends$1(ListItem, _super);\n    function ListItem() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ListItem.prototype, \"name\", {\n        get: function () {\n            return 'listItem';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ListItem.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'paragraph block*',\n                selectable: false,\n                attrs: {\n                    task: { default: false },\n                    checked: { default: false },\n                    rawHTML: { default: null },\n                },\n                defining: true,\n                parseDOM: [\n                    {\n                        tag: 'li',\n                        getAttrs: function (dom) {\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            return __assign$1({ task: dom.hasAttribute('data-task'), checked: dom.hasAttribute('data-task-checked') }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var task = attrs.task, checked = attrs.checked;\n                    if (!task) {\n                        return [attrs.rawHTML || 'li', 0];\n                    }\n                    var classNames = ['task-list-item'];\n                    if (checked) {\n                        classNames.push('checked');\n                    }\n                    return [\n                        attrs.rawHTML || 'li',\n                        __assign$1({ class: classNames.join(' '), 'data-task': task }, (checked && { 'data-task-checked': checked })),\n                        0,\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ListItem.prototype.liftToPrevListItem = function () {\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var $from = selection.$from, empty = selection.empty;\n            var listItem = schema.nodes.listItem;\n            var parent = $from.parent;\n            var listItemParent = $from.node(-1);\n            if (empty && !parent.childCount && listItemParent.type === listItem) {\n                // move to previous sibling list item when the current list item is not top list item\n                if ($from.index(-2) >= 1) {\n                    // should subtract '1' for considering tag length(<li>)\n                    tr.delete($from.start(-1) - 1, $from.end(-1));\n                    dispatch(tr);\n                    return true;\n                }\n                var grandParentListItem = $from.node(-3);\n                // move to parent list item when the current list item is top list item\n                if (grandParentListItem.type === listItem) {\n                    // should subtract '1' for considering tag length(<ul>)\n                    tr.delete($from.start(-2) - 1, $from.end(-1));\n                    dispatch(tr);\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    ListItem.prototype.keymaps = function () {\n        var split = function (state, dispatch) {\n            return splitListItem(state.schema.nodes.listItem)(state, dispatch);\n        };\n        return {\n            Backspace: this.liftToPrevListItem(),\n            Enter: split,\n        };\n    };\n    return ListItem;\n}(Node$2));\n\nvar BlockQuote = /** @class */ (function (_super) {\n    __extends$1(BlockQuote, _super);\n    function BlockQuote() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(BlockQuote.prototype, \"name\", {\n        get: function () {\n            return 'blockQuote';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BlockQuote.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                content: 'block+',\n                group: 'block',\n                parseDOM: [createDOMInfoParsedRawHTML('blockquote')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['blockquote', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BlockQuote.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.wrapIn)(state.schema.nodes.blockQuote)(state, dispatch); }; };\n    };\n    BlockQuote.prototype.keymaps = function () {\n        var blockQutoeCommand = this.commands()();\n        return {\n            'Alt-q': blockQutoeCommand,\n            'Alt-Q': blockQutoeCommand,\n        };\n    };\n    return BlockQuote;\n}(Node$2));\n\nvar cellOffsetFnMap = {\n    left: getLeftCellOffset,\n    right: getRightCellOffset,\n    up: getUpCellOffset,\n    down: getDownCellOffset,\n};\nfunction isInFirstListItem(pos, doc, _a) {\n    var paraDepth = _a[0], listDepth = _a[1];\n    var listItemNode = doc.resolve(pos.before(paraDepth - 1));\n    return listDepth === paraDepth && !listItemNode.nodeBefore;\n}\nfunction isInLastListItem(pos) {\n    var _a;\n    var depth = pos.depth;\n    var parentNode;\n    while (depth) {\n        parentNode = pos.node(depth);\n        if (parentNode.type.name === 'tableBodyCell') {\n            break;\n        }\n        if (parentNode.type.name === 'listItem') {\n            var grandParent = pos.node(depth - 1);\n            var lastListItem = grandParent.lastChild === parentNode;\n            var hasChildren = ((_a = parentNode.lastChild) === null || _a === void 0 ? void 0 : _a.type.name) !== 'paragraph';\n            if (!lastListItem) {\n                return false;\n            }\n            return !hasChildren;\n        }\n        depth -= 1;\n    }\n    return false;\n}\nfunction canMoveToBeforeCell(direction, _a, from, doc, inList) {\n    var paraDepth = _a[0], listDepth = _a[1], curDepth = _a[2];\n    if (direction === \"left\" /* LEFT */ || direction === \"up\" /* UP */) {\n        if (inList && !isInFirstListItem(from, doc, [paraDepth, listDepth])) {\n            return false;\n        }\n        var endOffset = from.before(curDepth);\n        var nodeBefore = doc.resolve(endOffset).nodeBefore;\n        if (nodeBefore) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction canMoveToAfterCell(direction, curDepth, from, doc, inList) {\n    if (direction === \"right\" /* RIGHT */ || direction === \"down\" /* DOWN */) {\n        if (inList && !isInLastListItem(from)) {\n            return false;\n        }\n        var endOffset = from.after(curDepth);\n        var nodeAfter = doc.resolve(endOffset).nodeAfter;\n        if (nodeAfter) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction canMoveBetweenCells(direction, _a, from, doc) {\n    var cellDepth = _a[0], paraDepth = _a[1];\n    var listDepth = cellDepth + 3; // 3 is position of <ul><li><p>\n    var inList = paraDepth >= listDepth;\n    var curDepth = inList ? cellDepth + 1 : paraDepth;\n    var moveBeforeCell = canMoveToBeforeCell(direction, [paraDepth, listDepth, curDepth], from, doc, inList);\n    var moveAfterCell = canMoveToAfterCell(direction, curDepth, from, doc, inList);\n    return moveBeforeCell && moveAfterCell;\n}\nfunction canBeOutOfTable(direction, map, _a) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var rowspanInfo = map.getRowspanStartInfo(rowIdx, colIdx);\n    var inFirstRow = direction === \"up\" /* UP */ && rowIdx === 0;\n    var inLastRow = direction === \"down\" /* DOWN */ &&\n        ((rowspanInfo === null || rowspanInfo === void 0 ? void 0 : rowspanInfo.count) > 1 ? rowIdx + rowspanInfo.count - 1 : rowIdx) === map.totalRowCount - 1;\n    return inFirstRow || inLastRow;\n}\nfunction addParagraphBeforeTable(tr, map, schema) {\n    var tableStartPos = tr.doc.resolve(map.tableStartOffset - 1);\n    if (!tableStartPos.nodeBefore) {\n        return addParagraph(tr, tableStartPos, schema);\n    }\n    return tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tableStartPos, -1));\n}\nfunction addParagraphAfterTable(tr, map, schema, forcedAddtion) {\n    if (forcedAddtion === void 0) { forcedAddtion = false; }\n    var tableEndPos = tr.doc.resolve(map.tableEndOffset);\n    if (forcedAddtion || !tableEndPos.nodeAfter) {\n        return addParagraph(tr, tableEndPos, schema);\n    }\n    return tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tableEndPos, 1));\n}\nfunction getRightCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var totalRowCount = map.totalRowCount, totalColumnCount = map.totalColumnCount;\n    var lastCellInRow = colIdx === totalColumnCount - 1;\n    var lastCellInTable = rowIdx === totalRowCount - 1 && lastCellInRow;\n    if (!lastCellInTable) {\n        var nextColIdx = colIdx + 1;\n        var colspanInfo = map.getColspanStartInfo(rowIdx, colIdx);\n        if ((colspanInfo === null || colspanInfo === void 0 ? void 0 : colspanInfo.count) > 1) {\n            nextColIdx += colspanInfo.count - 1;\n        }\n        if (lastCellInRow || nextColIdx === totalColumnCount) {\n            rowIdx += 1;\n            nextColIdx = 0;\n        }\n        var offset = map.getCellInfo(rowIdx, nextColIdx).offset;\n        return offset + 2;\n    }\n    return null;\n}\nfunction getLeftCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var totalColumnCount = map.totalColumnCount;\n    var firstCellInRow = colIdx === 0;\n    var firstCellInTable = rowIdx === 0 && firstCellInRow;\n    if (!firstCellInTable) {\n        colIdx -= 1;\n        if (firstCellInRow) {\n            rowIdx -= 1;\n            colIdx = totalColumnCount - 1;\n        }\n        var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n        return offset + nodeSize - 2;\n    }\n    return null;\n}\nfunction getUpCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    if (rowIdx > 0) {\n        var _b = map.getCellInfo(rowIdx - 1, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n        return offset + nodeSize - 2;\n    }\n    return null;\n}\nfunction getDownCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var totalRowCount = map.totalRowCount;\n    if (rowIdx < totalRowCount - 1) {\n        var nextRowIdx = rowIdx + 1;\n        var rowspanInfo = map.getRowspanStartInfo(rowIdx, colIdx);\n        if ((rowspanInfo === null || rowspanInfo === void 0 ? void 0 : rowspanInfo.count) > 1) {\n            nextRowIdx += rowspanInfo.count - 1;\n        }\n        var offset = map.getCellInfo(nextRowIdx, colIdx).offset;\n        return offset + 2;\n    }\n    return null;\n}\nfunction moveToCell(direction, tr, cellIndex, map) {\n    var cellOffsetFn = cellOffsetFnMap[direction];\n    var offset = cellOffsetFn(cellIndex, map);\n    if (offset) {\n        var dir = direction === \"right\" /* RIGHT */ || direction === \"down\" /* DOWN */ ? 1 : -1;\n        return tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve(offset), dir));\n    }\n    return null;\n}\nfunction canSelectTableNode(direction, map, _a) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    if (direction === \"up\" /* UP */ || direction === \"down\" /* DOWN */) {\n        return false;\n    }\n    var tableStartOffset = map.tableStartOffset, tableEndOffset = map.tableEndOffset;\n    var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n    var pos = direction === \"left\" /* LEFT */ ? tableStartOffset : tableEndOffset;\n    var curPos = direction === \"left\" /* LEFT */ ? offset - 2 : offset + nodeSize + 3;\n    return pos === curPos;\n}\nfunction selectNode(tr, pos, depth) {\n    var tablePos = tr.doc.resolve(pos.before(depth - 3));\n    return tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection(tablePos));\n}\n\nfunction getTargetRowInfo(direction, map, selectionInfo) {\n    var targetRowIdx;\n    var insertColIdx;\n    var nodeSize;\n    if (direction === \"up\" /* UP */) {\n        targetRowIdx = selectionInfo.startRowIdx;\n        insertColIdx = 0;\n        nodeSize = -1;\n    }\n    else {\n        targetRowIdx = selectionInfo.endRowIdx;\n        insertColIdx = map.totalColumnCount - 1;\n        nodeSize = map.getCellInfo(targetRowIdx, insertColIdx).nodeSize + 1;\n    }\n    return { targetRowIdx: targetRowIdx, insertColIdx: insertColIdx, nodeSize: nodeSize };\n}\nfunction getRowRanges(map, rowIdx, totalColumnCount) {\n    var startOffset = map.getCellInfo(rowIdx, 0).offset;\n    var _a = map.getCellInfo(rowIdx, totalColumnCount - 1), offset = _a.offset, nodeSize = _a.nodeSize;\n    return { from: startOffset, to: offset + nodeSize };\n}\nvar Table = /** @class */ (function (_super) {\n    __extends$1(Table, _super);\n    function Table() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Table.prototype, \"name\", {\n        get: function () {\n            return 'table';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Table.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'tableHead{1} tableBody{1}',\n                group: 'block',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [createDOMInfoParsedRawHTML('table')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['table', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Table.prototype.addTable = function () {\n        return function (payload) {\n            if (payload === void 0) { payload = { rowCount: 2, columnCount: 1, data: [] }; }\n            return function (state, dispatch) {\n                var rowCount = payload.rowCount, columnCount = payload.columnCount, data = payload.data;\n                var schema = state.schema, selection = state.selection, tr = state.tr;\n                var from = selection.from, to = selection.to, $from = selection.$from;\n                var collapsed = from === to;\n                if (collapsed && !isInTableNode($from)) {\n                    var _a = schema.nodes, tableHead = _a.tableHead, tableBody = _a.tableBody;\n                    var theadData = data === null || data === void 0 ? void 0 : data.slice(0, columnCount);\n                    var tbodyData = data === null || data === void 0 ? void 0 : data.slice(columnCount, data.length);\n                    var tableHeadRow = createTableHeadRow(columnCount, schema, theadData);\n                    var tableBodyRows = createTableBodyRows(rowCount - 1, columnCount, schema, tbodyData);\n                    var table = schema.nodes.table.create(null, [\n                        tableHead.create(null, tableHeadRow),\n                        tableBody.create(null, tableBodyRows),\n                    ]);\n                    dispatch(tr.replaceSelectionWith(table));\n                    return true;\n                }\n                return false;\n            };\n        };\n    };\n    Table.prototype.removeTable = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr;\n            var map = TableOffsetMap.create(selection.$anchor);\n            if (map) {\n                var tableStartOffset = map.tableStartOffset, tableEndOffset = map.tableEndOffset;\n                var startOffset = tableStartOffset - 1;\n                var cursorPos = createTextSelection(tr.delete(startOffset, tableEndOffset), startOffset);\n                dispatch(tr.setSelection(cursorPos));\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.addColumn = function (direction) {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var targetColIdx = direction === \"left\" /* LEFT */ ? selectionInfo.startColIdx : selectionInfo.endColIdx + 1;\n                var columnCount = getRowAndColumnCount(selectionInfo).columnCount;\n                var totalRowCount = map.totalRowCount;\n                for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n                    var cells = createDummyCells(columnCount, rowIdx, schema);\n                    tr.insert(tr.mapping.map(map.posAt(rowIdx, targetColIdx)), cells);\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.removeColumn = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var totalColumnCount = map.totalColumnCount, totalRowCount = map.totalRowCount;\n                var columnCount = getRowAndColumnCount(selectionInfo).columnCount;\n                var selectedAllColumn = columnCount === totalColumnCount;\n                if (selectedAllColumn) {\n                    return false;\n                }\n                var startColIdx = selectionInfo.startColIdx, endColIdx = selectionInfo.endColIdx;\n                var mapStart = tr.mapping.maps.length;\n                for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n                    for (var colIdx = endColIdx; colIdx >= startColIdx; colIdx -= 1) {\n                        var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n                        var from = tr.mapping.slice(mapStart).map(offset);\n                        var to = from + nodeSize;\n                        tr.delete(from, to);\n                    }\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.addRow = function (direction) {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var totalColumnCount = map.totalColumnCount;\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var rowCount = getRowAndColumnCount(selectionInfo).rowCount;\n                var _b = getTargetRowInfo(direction, map, selectionInfo), targetRowIdx = _b.targetRowIdx, insertColIdx = _b.insertColIdx, nodeSize = _b.nodeSize;\n                var selectedThead = targetRowIdx === 0;\n                if (!selectedThead) {\n                    var rows = [];\n                    var from = tr.mapping.map(map.posAt(targetRowIdx, insertColIdx)) + nodeSize;\n                    var cells = [];\n                    for (var colIdx = 0; colIdx < totalColumnCount; colIdx += 1) {\n                        cells = cells.concat(createDummyCells(1, targetRowIdx, schema));\n                    }\n                    for (var i = 0; i < rowCount; i += 1) {\n                        rows.push(schema.nodes.tableRow.create(null, cells));\n                    }\n                    dispatch(tr.insert(from, rows));\n                    return true;\n                }\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.removeRow = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var totalRowCount = map.totalRowCount, totalColumnCount = map.totalColumnCount;\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var rowCount = getRowAndColumnCount(selectionInfo).rowCount;\n                var startRowIdx = selectionInfo.startRowIdx, endRowIdx = selectionInfo.endRowIdx;\n                var selectedThead = startRowIdx === 0;\n                var selectedAllTbodyRow = rowCount === totalRowCount - 1;\n                if (selectedAllTbodyRow || selectedThead) {\n                    return false;\n                }\n                for (var rowIdx = endRowIdx; rowIdx >= startRowIdx; rowIdx -= 1) {\n                    var _b = getRowRanges(map, rowIdx, totalColumnCount), from = _b.from, to = _b.to;\n                    // delete table row\n                    tr.delete(from - 1, to + 1);\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.alignColumn = function () {\n        return function (payload) {\n            if (payload === void 0) { payload = { align: 'center' }; }\n            return function (state, dispatch) {\n                var align = payload.align;\n                var selection = state.selection, tr = state.tr;\n                var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n                if (anchor && head) {\n                    var map = TableOffsetMap.create(anchor);\n                    var totalRowCount = map.totalRowCount;\n                    var selectionInfo = map.getRectOffsets(anchor, head);\n                    var startColIdx = selectionInfo.startColIdx, endColIdx = selectionInfo.endColIdx;\n                    for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n                        for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n                            if (!map.extendedRowspan(rowIdx, colIdx) && !map.extendedColspan(rowIdx, colIdx)) {\n                                var _b = map.getNodeAndPos(rowIdx, colIdx), node = _b.node, pos = _b.pos;\n                                var attrs = setAttrs(node, { align: align });\n                                tr.setNodeMarkup(pos, null, attrs);\n                            }\n                        }\n                    }\n                    dispatch(tr);\n                    return true;\n                }\n                return false;\n            };\n        };\n    };\n    Table.prototype.moveToCell = function (direction) {\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var cellIndex = map.getCellIndex(anchor);\n                var newTr = void 0;\n                if (canBeOutOfTable(direction, map, cellIndex)) {\n                    // When there is no content before or after the table,\n                    // an empty line('paragraph') is created by pressing the arrow keys.\n                    newTr = addParagraphAfterTable(tr, map, schema);\n                }\n                else {\n                    newTr = moveToCell(direction, tr, cellIndex, map);\n                }\n                if (newTr) {\n                    dispatch(newTr);\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    Table.prototype.moveInCell = function (direction) {\n        var _this = this;\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, doc = state.doc, schema = state.schema;\n            var $from = selection.$from;\n            var view = _this.context.view;\n            if (!view.endOfTextblock(direction)) {\n                return false;\n            }\n            var cell = findNodeBy($from, function (_a) {\n                var type = _a.type;\n                return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';\n            });\n            if (cell) {\n                var para = findNodeBy($from, function (_a) {\n                    var type = _a.type;\n                    return type.name === 'paragraph';\n                });\n                var cellDepth = cell.depth;\n                if (para && canMoveBetweenCells(direction, [cellDepth, para.depth], $from, doc)) {\n                    var anchor = getResolvedSelection(selection).anchor;\n                    var map = TableOffsetMap.create(anchor);\n                    var cellIndex = map.getCellIndex(anchor);\n                    var newTr = void 0;\n                    if (canSelectTableNode(direction, map, cellIndex)) {\n                        // When the cursor position is at the end of the cell,\n                        // the table is selected when the left / right arrow keys are pressed.\n                        newTr = selectNode(tr, $from, cellDepth);\n                    }\n                    else if (canBeOutOfTable(direction, map, cellIndex)) {\n                        // When there is no content before or after the table,\n                        // an empty line('paragraph') is created by pressing the arrow keys.\n                        if (direction === \"up\" /* UP */) {\n                            newTr = addParagraphBeforeTable(tr, map, schema);\n                        }\n                        else if (direction === \"down\" /* DOWN */) {\n                            newTr = addParagraphAfterTable(tr, map, schema);\n                        }\n                    }\n                    else {\n                        newTr = moveToCell(direction, tr, cellIndex, map);\n                    }\n                    if (newTr) {\n                        dispatch(newTr);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n    };\n    Table.prototype.deleteCells = function () {\n        return function (state, dispatch) {\n            var schema = state.schema, selection = state.selection, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            var textSelection = selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection;\n            if (anchor && head && !textSelection) {\n                var map = TableOffsetMap.create(anchor);\n                var _b = map.getRectOffsets(anchor, head), startRowIdx = _b.startRowIdx, startColIdx = _b.startColIdx, endRowIdx = _b.endRowIdx, endColIdx = _b.endColIdx;\n                for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {\n                    for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n                        if (!map.extendedRowspan(rowIdx, colIdx) && !map.extendedColspan(rowIdx, colIdx)) {\n                            var _c = map.getNodeAndPos(rowIdx, colIdx), node = _c.node, pos = _c.pos;\n                            var cells = createDummyCells(1, rowIdx, schema, node.attrs);\n                            tr.replaceWith(tr.mapping.map(pos), tr.mapping.map(pos + node.nodeSize), cells);\n                        }\n                    }\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Table.prototype.exitTable = function () {\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var $from = selection.$from;\n            var cell = findNodeBy($from, function (_a) {\n                var type = _a.type;\n                return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';\n            });\n            if (cell) {\n                var para = findNodeBy($from, function (_a) {\n                    var type = _a.type;\n                    return type.name === 'paragraph';\n                });\n                if (para) {\n                    var anchor = getResolvedSelection(selection).anchor;\n                    var map = TableOffsetMap.create(anchor);\n                    dispatch(addParagraphAfterTable(tr, map, schema, true));\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    Table.prototype.commands = function () {\n        return {\n            addTable: this.addTable(),\n            removeTable: this.removeTable(),\n            addColumnToLeft: this.addColumn(\"left\" /* LEFT */),\n            addColumnToRight: this.addColumn(\"right\" /* RIGHT */),\n            removeColumn: this.removeColumn(),\n            addRowToUp: this.addRow(\"up\" /* UP */),\n            addRowToDown: this.addRow(\"down\" /* DOWN */),\n            removeRow: this.removeRow(),\n            alignColumn: this.alignColumn(),\n        };\n    };\n    Table.prototype.keymaps = function () {\n        var deleteCellContent = this.deleteCells();\n        return {\n            Tab: this.moveToCell(\"right\" /* RIGHT */),\n            'Shift-Tab': this.moveToCell(\"left\" /* LEFT */),\n            ArrowUp: this.moveInCell(\"up\" /* UP */),\n            ArrowDown: this.moveInCell(\"down\" /* DOWN */),\n            ArrowLeft: this.moveInCell(\"left\" /* LEFT */),\n            ArrowRight: this.moveInCell(\"right\" /* RIGHT */),\n            Backspace: deleteCellContent,\n            'Mod-Backspace': deleteCellContent,\n            Delete: deleteCellContent,\n            'Mod-Delete': deleteCellContent,\n            'Mod-Enter': this.exitTable(),\n        };\n    };\n    return Table;\n}(Node$2));\n\nvar TableHead = /** @class */ (function (_super) {\n    __extends$1(TableHead, _super);\n    function TableHead() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableHead.prototype, \"name\", {\n        get: function () {\n            return 'tableHead';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableHead.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'tableRow{1}',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [createDOMInfoParsedRawHTML('thead')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['thead', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableHead;\n}(Node$2));\n\nvar TableBody = /** @class */ (function (_super) {\n    __extends$1(TableBody, _super);\n    function TableBody() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableBody.prototype, \"name\", {\n        get: function () {\n            return 'tableBody';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableBody.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'tableRow+',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: 'tbody',\n                        getAttrs: function (dom) {\n                            var rows = dom.querySelectorAll('tr');\n                            var columns = rows[0].children.length;\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            if (!columns) {\n                                return false;\n                            }\n                            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['tbody', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableBody;\n}(Node$2));\n\nvar TableRow = /** @class */ (function (_super) {\n    __extends$1(TableRow, _super);\n    function TableRow() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableRow.prototype, \"name\", {\n        get: function () {\n            return 'tableRow';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableRow.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: '(tableHeadCell | tableBodyCell)*',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: 'tr',\n                        getAttrs: function (dom) {\n                            var columns = dom.children.length;\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            if (!columns) {\n                                return false;\n                            }\n                            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['tr', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableRow;\n}(Node$2));\n\nvar TableHeadCell = /** @class */ (function (_super) {\n    __extends$1(TableHeadCell, _super);\n    function TableHeadCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableHeadCell.prototype, \"name\", {\n        get: function () {\n            return 'tableHeadCell';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableHeadCell.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'paragraph+',\n                attrs: __assign$1({ align: { default: null }, className: { default: null }, rawHTML: { default: null }, colspan: { default: null }, extended: { default: null } }, getDefaultCustomAttrs()),\n                isolating: true,\n                parseDOM: [createParsedCellDOM('th')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var cellAttrs = createCellAttrs(attrs);\n                    return ['th', __assign$1(__assign$1({}, cellAttrs), getCustomAttrs(attrs)), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableHeadCell;\n}(Node$2));\n\nvar TableBodyCell = /** @class */ (function (_super) {\n    __extends$1(TableBodyCell, _super);\n    function TableBodyCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableBodyCell.prototype, \"name\", {\n        get: function () {\n            return 'tableBodyCell';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableBodyCell.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: '(paragraph | bulletList | orderedList)+',\n                attrs: {\n                    align: { default: null },\n                    className: { default: null },\n                    rawHTML: { default: null },\n                    colspan: { default: null },\n                    rowspan: { default: null },\n                    extended: { default: null },\n                },\n                isolating: true,\n                parseDOM: [createParsedCellDOM('td')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var cellAttrs = createCellAttrs(attrs);\n                    return ['td', cellAttrs, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableBodyCell;\n}(Node$2));\n\nvar Image = /** @class */ (function (_super) {\n    __extends$1(Image, _super);\n    function Image() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Image.prototype, \"name\", {\n        get: function () {\n            return 'image';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Image.prototype, \"schema\", {\n        get: function () {\n            return {\n                inline: true,\n                attrs: __assign$1({ imageUrl: { default: '' }, altText: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                group: 'inline',\n                selectable: false,\n                parseDOM: [\n                    {\n                        tag: 'img[src]',\n                        getAttrs: function (dom) {\n                            var sanitizedDOM = sanitizeHTML(dom, { RETURN_DOM_FRAGMENT: true })\n                                .firstChild;\n                            var imageUrl = sanitizedDOM.getAttribute('src') || '';\n                            var rawHTML = sanitizedDOM.getAttribute('data-raw-html');\n                            var altText = sanitizedDOM.getAttribute('alt');\n                            return __assign$1({ imageUrl: imageUrl,\n                                altText: altText }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || 'img',\n                        __assign$1(__assign$1({ src: escapeXml$1(attrs.imageUrl) }, (attrs.altText && { alt: attrs.altText })), getCustomAttrs(attrs)),\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Image.prototype.addImage = function () {\n        return function (payload) { return function (_a, dispatch) {\n            var schema = _a.schema, tr = _a.tr;\n            var _b = payload, imageUrl = _b.imageUrl, altText = _b.altText;\n            if (!imageUrl) {\n                return false;\n            }\n            var node = schema.nodes.image.createAndFill(__assign$1({ imageUrl: imageUrl }, (altText && { altText: altText })));\n            dispatch(tr.replaceSelectionWith(node).scrollIntoView());\n            return true;\n        }; };\n    };\n    Image.prototype.commands = function () {\n        return {\n            addImage: this.addImage(),\n        };\n    };\n    return Image;\n}(Node$2));\n\nvar ROOT_BLOCK_DEPTH = 1;\nvar ThematicBreak = /** @class */ (function (_super) {\n    __extends$1(ThematicBreak, _super);\n    function ThematicBreak() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ThematicBreak.prototype, \"name\", {\n        get: function () {\n            return 'thematicBreak';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ThematicBreak.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                group: 'block',\n                parseDOM: [{ tag: 'hr' }],\n                selectable: false,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['div', getCustomAttrs(attrs), [attrs.rawHTML || 'hr']];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ThematicBreak.prototype.hr = function () {\n        var _this = this;\n        return function () { return function (state, dispatch) {\n            var _a;\n            var _b = state.selection, $from = _b.$from, $to = _b.$to;\n            if ($from === $to) {\n                var doc = state.doc;\n                var _c = state.schema.nodes, thematicBreak = _c.thematicBreak, paragraph = _c.paragraph;\n                var nodes = [thematicBreak.create()];\n                var rootBlock = $from.node(ROOT_BLOCK_DEPTH);\n                var lastBlock = doc.child(doc.childCount - 1) === rootBlock;\n                var blockEnd = doc.resolve($from.after(ROOT_BLOCK_DEPTH));\n                var nextHr = ((_a = $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.type.name) === _this.name;\n                if (lastBlock || nextHr) {\n                    nodes.push(paragraph.create());\n                }\n                dispatch(state.tr.insert(blockEnd.pos, nodes).scrollIntoView());\n                return true;\n            }\n            return false;\n        }; };\n    };\n    ThematicBreak.prototype.commands = function () {\n        return { hr: this.hr() };\n    };\n    ThematicBreak.prototype.keymaps = function () {\n        var hrCommand = this.hr()();\n        return {\n            'Mod-l': hrCommand,\n            'Mod-L': hrCommand,\n        };\n    };\n    return ThematicBreak;\n}(Node$2));\n\nvar Strong = /** @class */ (function (_super) {\n    __extends$1(Strong, _super);\n    function Strong() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strong.prototype, \"name\", {\n        get: function () {\n            return 'strong';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strong.prototype, \"schema\", {\n        get: function () {\n            var parseDOM = ['b', 'strong'].map(function (tag) {\n                return {\n                    tag: tag,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute('data-raw-html');\n                        return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || 'strong', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strong.prototype.bold = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.strong)(state, dispatch); }; };\n    };\n    Strong.prototype.commands = function () {\n        return { bold: this.bold() };\n    };\n    Strong.prototype.keymaps = function () {\n        var boldCommand = this.bold()();\n        return {\n            'Mod-b': boldCommand,\n            'Mod-B': boldCommand,\n        };\n    };\n    return Strong;\n}(Mark));\n\nvar Emph = /** @class */ (function (_super) {\n    __extends$1(Emph, _super);\n    function Emph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Emph.prototype, \"name\", {\n        get: function () {\n            return 'emph';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Emph.prototype, \"schema\", {\n        get: function () {\n            var parseDOM = ['i', 'em'].map(function (tag) {\n                return {\n                    tag: tag,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute('data-raw-html');\n                        return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || 'em', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Emph.prototype.italic = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.emph)(state, dispatch); }; };\n    };\n    Emph.prototype.commands = function () {\n        return { italic: this.italic() };\n    };\n    Emph.prototype.keymaps = function () {\n        var italicCommand = this.italic()();\n        return {\n            'Mod-i': italicCommand,\n            'Mod-I': italicCommand,\n        };\n    };\n    return Emph;\n}(Mark));\n\nvar Strike = /** @class */ (function (_super) {\n    __extends$1(Strike, _super);\n    function Strike() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strike.prototype, \"name\", {\n        get: function () {\n            return 'strike';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strike.prototype, \"schema\", {\n        get: function () {\n            var parseDOM = ['s', 'del'].map(function (tag) {\n                return {\n                    tag: tag,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute('data-raw-html');\n                        return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || 'del', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strike.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.strike)(state, dispatch); }; };\n    };\n    Strike.prototype.keymaps = function () {\n        var strikeCommand = this.commands()();\n        return {\n            'Mod-s': strikeCommand,\n            'Mod-S': strikeCommand,\n        };\n    };\n    return Strike;\n}(Mark));\n\nvar Link = /** @class */ (function (_super) {\n    __extends$1(Link, _super);\n    function Link(linkAttributes) {\n        var _this = _super.call(this) || this;\n        _this.linkAttributes = linkAttributes;\n        return _this;\n    }\n    Object.defineProperty(Link.prototype, \"name\", {\n        get: function () {\n            return 'link';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Link.prototype, \"schema\", {\n        get: function () {\n            var _this = this;\n            return {\n                attrs: __assign$1({ linkUrl: { default: '' }, title: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                inclusive: false,\n                parseDOM: [\n                    {\n                        tag: 'a[href]',\n                        getAttrs: function (dom) {\n                            var sanitizedDOM = sanitizeHTML(dom, { RETURN_DOM_FRAGMENT: true })\n                                .firstChild;\n                            var href = sanitizedDOM.getAttribute('href') || '';\n                            var title = sanitizedDOM.getAttribute('title') || '';\n                            var rawHTML = sanitizedDOM.getAttribute('data-raw-html');\n                            return __assign$1({ linkUrl: href, title: title }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || 'a',\n                        __assign$1(__assign$1({ href: escapeXml$1(attrs.linkUrl) }, _this.linkAttributes), getCustomAttrs(attrs)),\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Link.prototype.addLink = function () {\n        return function (payload) { return function (state, dispatch) {\n            var _a = payload, linkUrl = _a.linkUrl, _b = _a.linkText, linkText = _b === void 0 ? '' : _b;\n            var schema = state.schema, tr = state.tr, selection = state.selection;\n            var empty = selection.empty, from = selection.from, to = selection.to;\n            if (from && to && linkUrl) {\n                var attrs = { linkUrl: linkUrl };\n                var mark = schema.mark('link', attrs);\n                if (empty && linkText) {\n                    var node = createTextNode$1(schema, linkText, mark);\n                    tr.replaceRangeWith(from, to, node);\n                }\n                else {\n                    tr.addMark(from, to, mark);\n                }\n                dispatch(tr.scrollIntoView());\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Link.prototype.toggleLink = function () {\n        return function (payload) { return function (state, dispatch) {\n            return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.link, payload)(state, dispatch);\n        }; };\n    };\n    Link.prototype.commands = function () {\n        return {\n            addLink: this.addLink(),\n            toggleLink: this.toggleLink(),\n        };\n    };\n    return Link;\n}(Mark));\n\nvar Code = /** @class */ (function (_super) {\n    __extends$1(Code, _super);\n    function Code() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Code.prototype, \"name\", {\n        get: function () {\n            return 'code';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Code.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: 'code',\n                        getAttrs: function (dom) {\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || 'code', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Code.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.code)(state, dispatch); }; };\n    };\n    Code.prototype.keymaps = function () {\n        var codeCommand = this.commands()();\n        return {\n            'Shift-Mod-c': codeCommand,\n            'Shift-Mod-C': codeCommand,\n        };\n    };\n    return Code;\n}(Mark));\n\nvar CustomBlock = /** @class */ (function (_super) {\n    __extends$1(CustomBlock, _super);\n    function CustomBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CustomBlock.prototype, \"name\", {\n        get: function () {\n            return 'customBlock';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CustomBlock.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'text*',\n                group: 'block',\n                attrs: {\n                    info: { default: null },\n                },\n                atom: true,\n                code: true,\n                defining: true,\n                parseDOM: [\n                    {\n                        tag: 'div[data-custom-info]',\n                        getAttrs: function (dom) {\n                            var info = dom.getAttribute('data-custom-info');\n                            return { info: info };\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['div', { 'data-custom-info': attrs.info || null }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CustomBlock.prototype.commands = function () {\n        return function (payload) { return function (state, dispatch) {\n            return (payload === null || payload === void 0 ? void 0 : payload.info)\n                ? (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(state.schema.nodes.customBlock, payload)(state, dispatch)\n                : false;\n        }; };\n    };\n    return CustomBlock;\n}(Node$2));\n\nvar FrontMatter = /** @class */ (function (_super) {\n    __extends$1(FrontMatter, _super);\n    function FrontMatter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(FrontMatter.prototype, \"name\", {\n        get: function () {\n            return 'frontMatter';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FrontMatter.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'text*',\n                group: 'block',\n                code: true,\n                defining: true,\n                parseDOM: [\n                    {\n                        preserveWhitespace: 'full',\n                        tag: 'div[data-front-matter]',\n                    },\n                ],\n                toDOM: function () {\n                    return ['div', { 'data-front-matter': 'true' }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FrontMatter.prototype.commands = function () {\n        return function () { return function (state, dispatch, view) {\n            var $from = state.selection.$from;\n            if (view.endOfTextblock('down') && $from.node().type.name === 'frontMatter') {\n                return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.exitCode)(state, dispatch);\n            }\n            return false;\n        }; };\n    };\n    FrontMatter.prototype.keymaps = function () {\n        return {\n            Enter: this.commands()(),\n        };\n    };\n    return FrontMatter;\n}(Node$2));\n\nvar HTMLComment = /** @class */ (function (_super) {\n    __extends$1(HTMLComment, _super);\n    function HTMLComment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(HTMLComment.prototype, \"name\", {\n        get: function () {\n            return 'htmlComment';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(HTMLComment.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'text*',\n                group: 'block',\n                code: true,\n                defining: true,\n                parseDOM: [{ preserveWhitespace: 'full', tag: 'div[data-html-comment]' }],\n                toDOM: function () {\n                    return ['div', { 'data-html-comment': 'true' }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    HTMLComment.prototype.commands = function () {\n        return function () { return function (state, dispatch, view) {\n            var $from = state.selection.$from;\n            if (view.endOfTextblock('down') && $from.node().type.name === 'htmlComment') {\n                return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.exitCode)(state, dispatch);\n            }\n            return false;\n        }; };\n    };\n    HTMLComment.prototype.keymaps = function () {\n        return {\n            Enter: this.commands()(),\n        };\n    };\n    return HTMLComment;\n}(Node$2));\n\nfunction createSpecs(linkAttributes) {\n    return new SpecManager([\n        new Doc(),\n        new Paragraph(),\n        new Text(),\n        new Heading(),\n        new CodeBlock(),\n        new BulletList(),\n        new OrderedList(),\n        new ListItem(),\n        new BlockQuote(),\n        new Table(),\n        new TableHead(),\n        new TableBody(),\n        new TableRow(),\n        new TableHeadCell(),\n        new TableBodyCell(),\n        new Image(),\n        new ThematicBreak(),\n        new Strong(),\n        new Emph(),\n        new Strike(),\n        new Link(linkAttributes),\n        new Code(),\n        new CustomBlock(),\n        new FrontMatter(),\n        new Widget(),\n        new HTMLComment(),\n    ]);\n}\n\nvar CONTENTS_CLASS_NAME = cls('contents');\nvar WysiwygEditor = /** @class */ (function (_super) {\n    __extends$1(WysiwygEditor, _super);\n    function WysiwygEditor(eventEmitter, options) {\n        var _this = _super.call(this, eventEmitter) || this;\n        var toDOMAdaptor = options.toDOMAdaptor, _a = options.htmlSchemaMap, htmlSchemaMap = _a === void 0 ? {} : _a, _b = options.linkAttributes, linkAttributes = _b === void 0 ? {} : _b, _c = options.useCommandShortcut, useCommandShortcut = _c === void 0 ? true : _c, _d = options.wwPlugins, wwPlugins = _d === void 0 ? [] : _d, _e = options.wwNodeViews, wwNodeViews = _e === void 0 ? {} : _e;\n        _this.editorType = 'wysiwyg';\n        _this.el.classList.add('ww-mode');\n        _this.toDOMAdaptor = toDOMAdaptor;\n        _this.linkAttributes = linkAttributes;\n        _this.extraPlugins = wwPlugins;\n        _this.pluginNodeViews = wwNodeViews;\n        _this.specs = _this.createSpecs();\n        _this.schema = _this.createSchema(htmlSchemaMap);\n        _this.context = _this.createContext();\n        _this.keymaps = _this.createKeymaps(useCommandShortcut);\n        _this.view = _this.createView();\n        _this.commands = _this.createCommands();\n        _this.specs.setContext(__assign$1(__assign$1({}, _this.context), { view: _this.view }));\n        _this.initEvent();\n        return _this;\n    }\n    WysiwygEditor.prototype.createSpecs = function () {\n        return createSpecs(this.linkAttributes);\n    };\n    WysiwygEditor.prototype.createContext = function () {\n        return {\n            schema: this.schema,\n            eventEmitter: this.eventEmitter,\n        };\n    };\n    WysiwygEditor.prototype.createSchema = function (htmlSchemaMap) {\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Schema({\n            nodes: __assign$1(__assign$1({}, this.specs.nodes), htmlSchemaMap.nodes),\n            marks: __assign$1(__assign$1({}, this.specs.marks), htmlSchemaMap.marks),\n        });\n    };\n    WysiwygEditor.prototype.createPlugins = function () {\n        return __spreadArray$1([\n            tableSelection(),\n            tableContextMenu(this.eventEmitter),\n            task(),\n            toolbarStateHighlight(this.eventEmitter)\n        ], this.createPluginProps()).concat(this.defaultPlugins);\n    };\n    WysiwygEditor.prototype.createPluginNodeViews = function () {\n        var _a = this, eventEmitter = _a.eventEmitter, pluginNodeViews = _a.pluginNodeViews;\n        var pluginNodeViewMap = {};\n        if (pluginNodeViews) {\n            Object.keys(pluginNodeViews).forEach(function (key) {\n                pluginNodeViewMap[key] = function (node, view, getPos) {\n                    return pluginNodeViews[key](node, view, getPos, eventEmitter);\n                };\n            });\n        }\n        return pluginNodeViewMap;\n    };\n    WysiwygEditor.prototype.createView = function () {\n        var _this = this;\n        var _a = this, toDOMAdaptor = _a.toDOMAdaptor, eventEmitter = _a.eventEmitter;\n        return new prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView(this.el, {\n            state: this.createState(),\n            attributes: {\n                class: CONTENTS_CLASS_NAME,\n            },\n            nodeViews: __assign$1({ customBlock: function (node, view, getPos) {\n                    return new CustomBlockView(node, view, getPos, toDOMAdaptor);\n                },\n                image: function (node, view, getPos) {\n                    return new ImageView(node, view, getPos, eventEmitter);\n                },\n                codeBlock: function (node, view, getPos) {\n                    return new CodeBlockView(node, view, getPos, eventEmitter);\n                }, widget: widgetNodeView }, this.createPluginNodeViews()),\n            dispatchTransaction: function (tr) {\n                var state = _this.view.state.applyTransaction(tr).state;\n                _this.view.updateState(state);\n                _this.emitChangeEvent(tr.scrollIntoView());\n                _this.eventEmitter.emit('setFocusedNode', state.selection.$from.node(1));\n            },\n            transformPastedHTML: changePastedHTML,\n            transformPasted: function (slice) {\n                return changePastedSlice(slice, _this.schema, isInTableNode(_this.view.state.selection.$from));\n            },\n            handlePaste: function (view, _, slice) { return pasteToTable(view, slice); },\n            handleKeyDown: function (_, ev) {\n                _this.eventEmitter.emit('keydown', _this.editorType, ev);\n                return false;\n            },\n            handleDOMEvents: {\n                paste: function (_, ev) {\n                    var clipboardData = ev.clipboardData || window.clipboardData;\n                    var items = clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.items;\n                    if (items) {\n                        var containRtfItem = toArray_1(items).some(function (item) { return item.kind === 'string' && item.type === 'text/rtf'; });\n                        // if it contains rtf, it's most likely copy paste from office -> no image\n                        if (!containRtfItem) {\n                            var imageBlob = pasteImageOnly(items);\n                            if (imageBlob) {\n                                ev.preventDefault();\n                                emitImageBlobHook(_this.eventEmitter, imageBlob, ev.type);\n                            }\n                        }\n                    }\n                    return false;\n                },\n                keyup: function (_, ev) {\n                    _this.eventEmitter.emit('keyup', _this.editorType, ev);\n                    return false;\n                },\n                scroll: function () {\n                    _this.eventEmitter.emit('scroll', 'editor');\n                    return true;\n                },\n            },\n        });\n    };\n    WysiwygEditor.prototype.createCommands = function () {\n        return this.specs.commands(this.view, getWwCommands());\n    };\n    WysiwygEditor.prototype.getHTML = function () {\n        return removeProseMirrorHackNodes(this.view.dom.innerHTML);\n    };\n    WysiwygEditor.prototype.getModel = function () {\n        return this.view.state.doc;\n    };\n    WysiwygEditor.prototype.getSelection = function () {\n        var _a = this.view.state.selection, from = _a.from, to = _a.to;\n        return [from, to];\n    };\n    WysiwygEditor.prototype.getSchema = function () {\n        return this.view.state.schema;\n    };\n    WysiwygEditor.prototype.replaceSelection = function (text, start, end) {\n        var _a = this.view.state, schema = _a.schema, tr = _a.tr;\n        var lineTexts = text.split('\\n');\n        var paras = lineTexts.map(function (lineText) {\n            return createParagraph(schema, createNodesWithWidget(lineText, schema));\n        });\n        var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(paras), 1, 1);\n        var newTr = isNumber_1(start) && isNumber_1(end)\n            ? tr.replaceRange(start, end, slice)\n            : tr.replaceSelection(slice);\n        this.view.dispatch(newTr);\n        this.focus();\n    };\n    WysiwygEditor.prototype.deleteSelection = function (start, end) {\n        var tr = this.view.state.tr;\n        var newTr = isNumber_1(start) && isNumber_1(end) ? tr.deleteRange(start, end) : tr.deleteSelection();\n        this.view.dispatch(newTr.scrollIntoView());\n    };\n    WysiwygEditor.prototype.getSelectedText = function (start, end) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var from = selection.from, to = selection.to;\n        if (isNumber_1(start) && isNumber_1(end)) {\n            from = start;\n            to = end;\n        }\n        return doc.textBetween(from, to, '\\n');\n    };\n    WysiwygEditor.prototype.setModel = function (newDoc, cursorToEnd) {\n        if (cursorToEnd === void 0) { cursorToEnd = false; }\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc;\n        this.view.dispatch(tr.replaceWith(0, doc.content.size, newDoc));\n        if (cursorToEnd) {\n            this.moveCursorToEnd(true);\n        }\n    };\n    WysiwygEditor.prototype.setSelection = function (start, end) {\n        if (end === void 0) { end = start; }\n        var tr = this.view.state.tr;\n        var selection = createTextSelection(tr, start, end);\n        this.view.dispatch(tr.setSelection(selection).scrollIntoView());\n    };\n    WysiwygEditor.prototype.addWidget = function (node, style, pos) {\n        var _a = this.view, dispatch = _a.dispatch, state = _a.state;\n        dispatch(state.tr.setMeta('widget', { pos: pos !== null && pos !== void 0 ? pos : state.selection.to, node: node, style: style }));\n    };\n    WysiwygEditor.prototype.replaceWithWidget = function (start, end, text) {\n        var _a = this.view.state, tr = _a.tr, schema = _a.schema;\n        var nodes = createNodesWithWidget(text, schema);\n        this.view.dispatch(tr.replaceWith(start, end, nodes));\n    };\n    WysiwygEditor.prototype.getRangeInfoOfNode = function (pos) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var $pos = pos ? doc.resolve(pos) : selection.$from;\n        var marks = $pos.marks();\n        var node = $pos.node();\n        var start = $pos.start();\n        var end = $pos.end();\n        var type = node.type.name;\n        if (marks.length || type === 'paragraph') {\n            var mark_1 = marks[marks.length - 1];\n            var maybeHasMark_1 = function (nodeMarks) {\n                return nodeMarks.length ? includes(nodeMarks, mark_1) : true;\n            };\n            type = mark_1 ? mark_1.type.name : 'text';\n            node.forEach(function (child, offset) {\n                var isText = child.isText, nodeSize = child.nodeSize, nodeMarks = child.marks;\n                var startOffset = $pos.pos - start;\n                if (isText &&\n                    offset <= startOffset &&\n                    offset + nodeSize >= startOffset &&\n                    maybeHasMark_1(nodeMarks)) {\n                    start = start + offset;\n                    end = start + nodeSize;\n                }\n            });\n        }\n        return { range: [start, end], type: type };\n    };\n    return WysiwygEditor;\n}(EditorBase));\n\n/**\n * @fileoverview Check whether the given variable is existing or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isUndefined = isUndefined_1;\nvar isNull = isNull_1;\n\n/**\n * Check whether the given variable is existing or not.\n * If the given variable is not null and not undefined, returns true.\n * @param {*} param - Target for checking\n * @returns {boolean} Is existy?\n * @memberof module:type\n * @example\n * // ES6\n * import isExisty from 'tui-code-snippet/type/isExisty');\n * \n * // CommonJS\n * const isExisty = require('tui-code-snippet/type/isExisty');\n *\n * isExisty(''); //true\n * isExisty(0); //true\n * isExisty([]); //true\n * isExisty({}); //true\n * isExisty(null); //false\n * isExisty(undefined); //false\n*/\nfunction isExisty$1(param) {\n  return !isUndefined(param) && !isNull(param);\n}\n\nvar isExisty_1 = isExisty$1;\n\n/**\n * @fileoverview Check whether the given variable is truthy or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isExisty = isExisty_1;\n\n/**\n * Check whether the given variable is truthy or not.\n * If the given variable is not null or not undefined or not false, returns true.\n * (It regards 0 as true)\n * @param {*} obj - Target for checking\n * @returns {boolean} Is truthy?\n * @memberof module:type\n */\nfunction isTruthy$1(obj) {\n  return isExisty(obj) && obj !== false;\n}\n\nvar isTruthy_1 = isTruthy$1;\n\n/**\n * @fileoverview Check whether the given variable is falsy or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isTruthy = isTruthy_1;\n\n/**\n * Check whether the given variable is falsy or not.\n * If the given variable is null or undefined or false, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is falsy?\n * @memberof module:type\n */\nfunction isFalsy(obj) {\n  return !isTruthy(obj);\n}\n\nvar isFalsy_1 = isFalsy;\n\nvar eventTypeList = [\n    'afterPreviewRender',\n    'updatePreview',\n    'changeMode',\n    'needChangeMode',\n    'command',\n    'changePreviewStyle',\n    'changePreviewTabPreview',\n    'changePreviewTabWrite',\n    'scroll',\n    'contextmenu',\n    'show',\n    'hide',\n    'changeLanguage',\n    'changeToolbarState',\n    'toggleScrollSync',\n    'mixinTableOffsetMapPrototype',\n    'setFocusedNode',\n    'removePopupWidget',\n    'query',\n    // provide event for user\n    'openPopup',\n    'closePopup',\n    'addImageBlobHook',\n    'beforePreviewRender',\n    'beforeConvertWysiwygToMarkdown',\n    'load',\n    'loadUI',\n    'change',\n    'caretChange',\n    'destroy',\n    'focus',\n    'blur',\n    'keydown',\n    'keyup',\n];\n/**\n * Class EventEmitter\n * @ignore\n */\nvar EventEmitter = /** @class */ (function () {\n    function EventEmitter() {\n        var _this = this;\n        this.events = new Map$1();\n        this.eventTypes = eventTypeList.reduce(function (types, type) {\n            return __assign$1(__assign$1({}, types), { type: type });\n        }, {});\n        this.hold = false;\n        eventTypeList.forEach(function (eventType) {\n            _this.addEventType(eventType);\n        });\n    }\n    /**\n     * Listen event and bind event handler\n     * @param {string} type Event type string\n     * @param {function} handler Event handler\n     */\n    EventEmitter.prototype.listen = function (type, handler) {\n        var typeInfo = this.getTypeInfo(type);\n        var eventHandlers = this.events.get(typeInfo.type) || [];\n        if (!this.hasEventType(typeInfo.type)) {\n            throw new Error(\"There is no event type \" + typeInfo.type);\n        }\n        if (typeInfo.namespace) {\n            handler.namespace = typeInfo.namespace;\n        }\n        eventHandlers.push(handler);\n        this.events.set(typeInfo.type, eventHandlers);\n    };\n    /**\n     * Emit event\n     * @param {string} eventName Event name to emit\n     * @returns {Array}\n     */\n    EventEmitter.prototype.emit = function (type) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var typeInfo = this.getTypeInfo(type);\n        var eventHandlers = this.events.get(typeInfo.type);\n        var results = [];\n        if (!this.hold && eventHandlers) {\n            eventHandlers.forEach(function (handler) {\n                var result = handler.apply(void 0, args);\n                if (!isUndefined_1(result)) {\n                    results.push(result);\n                }\n            });\n        }\n        return results;\n    };\n    /**\n     * Emit given event and return result\n     * @param {string} eventName Event name to emit\n     * @param {any} source Source to change\n     * @returns {string}\n     */\n    EventEmitter.prototype.emitReduce = function (type, source) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var eventHandlers = this.events.get(type);\n        if (!this.hold && eventHandlers) {\n            eventHandlers.forEach(function (handler) {\n                var result = handler.apply(void 0, __spreadArray$1([source], args));\n                if (!isFalsy_1(result)) {\n                    source = result;\n                }\n            });\n        }\n        return source;\n    };\n    /**\n     * Get event type and namespace\n     * @param {string} type Event type name\n     * @returns {{type: string, namespace: string}}\n     * @private\n     */\n    EventEmitter.prototype.getTypeInfo = function (type) {\n        var splited = type.split('.');\n        return {\n            type: splited[0],\n            namespace: splited[1],\n        };\n    };\n    /**\n     * Check whether event type exists or not\n     * @param {string} type Event type name\n     * @returns {boolean}\n     * @private\n     */\n    EventEmitter.prototype.hasEventType = function (type) {\n        return !isUndefined_1(this.eventTypes[this.getTypeInfo(type).type]);\n    };\n    /**\n     * Add event type when given event not exists\n     * @param {string} type Event type name\n     */\n    EventEmitter.prototype.addEventType = function (type) {\n        if (this.hasEventType(type)) {\n            throw new Error(\"There is already have event type \" + type);\n        }\n        this.eventTypes[type] = type;\n    };\n    /**\n     * Remove event handler from given event type\n     * @param {string} eventType Event type name\n     * @param {function} [handler] - registered event handler\n     */\n    EventEmitter.prototype.removeEventHandler = function (eventType, handler) {\n        var _this = this;\n        var _a = this.getTypeInfo(eventType), type = _a.type, namespace = _a.namespace;\n        if (type && handler) {\n            this.removeEventHandlerWithHandler(type, handler);\n        }\n        else if (type && !namespace) {\n            this.events.delete(type);\n        }\n        else if (!type && namespace) {\n            this.events.forEach(function (_, evtType) {\n                _this.removeEventHandlerWithTypeInfo(evtType, namespace);\n            });\n        }\n        else if (type && namespace) {\n            this.removeEventHandlerWithTypeInfo(type, namespace);\n        }\n    };\n    /**\n     * Remove event handler with event handler\n     * @param {string} type - event type name\n     * @param {function} handler - event handler\n     * @private\n     */\n    EventEmitter.prototype.removeEventHandlerWithHandler = function (type, handler) {\n        var eventHandlers = this.events.get(type);\n        if (eventHandlers) {\n            var handlerIndex = eventHandlers.indexOf(handler);\n            if (eventHandlers.indexOf(handler) >= 0) {\n                eventHandlers.splice(handlerIndex, 1);\n            }\n        }\n    };\n    /**\n     * Remove event handler with event type information\n     * @param {string} type Event type name\n     * @param {string} namespace Event namespace\n     * @private\n     */\n    EventEmitter.prototype.removeEventHandlerWithTypeInfo = function (type, namespace) {\n        var handlersToSurvive = [];\n        var eventHandlers = this.events.get(type);\n        if (!eventHandlers) {\n            return;\n        }\n        eventHandlers.map(function (handler) {\n            if (handler.namespace !== namespace) {\n                handlersToSurvive.push(handler);\n            }\n            return null;\n        });\n        this.events.set(type, handlersToSurvive);\n    };\n    EventEmitter.prototype.getEvents = function () {\n        return this.events;\n    };\n    EventEmitter.prototype.holdEventInvoke = function (fn) {\n        this.hold = true;\n        fn();\n        this.hold = false;\n    };\n    return EventEmitter;\n}());\n\nvar CommandManager = /** @class */ (function () {\n    function CommandManager(eventEmitter, mdCommands, wwCommands, getEditorType) {\n        this.eventEmitter = eventEmitter;\n        this.mdCommands = mdCommands;\n        this.wwCommands = wwCommands;\n        this.getEditorType = getEditorType;\n        this.initEvent();\n    }\n    CommandManager.prototype.initEvent = function () {\n        var _this = this;\n        this.eventEmitter.listen('command', function (command, payload) {\n            _this.exec(command, payload);\n        });\n    };\n    CommandManager.prototype.addCommand = function (type, name, command) {\n        if (type === 'markdown') {\n            this.mdCommands[name] = command;\n        }\n        else {\n            this.wwCommands[name] = command;\n        }\n    };\n    CommandManager.prototype.deleteCommand = function (type, name) {\n        if (type === 'markdown') {\n            delete this.mdCommands[name];\n        }\n        else {\n            delete this.wwCommands[name];\n        }\n    };\n    CommandManager.prototype.exec = function (name, payload) {\n        var type = this.getEditorType();\n        if (type === 'markdown') {\n            this.mdCommands[name](payload);\n        }\n        else {\n            this.wwCommands[name](payload);\n        }\n    };\n    return CommandManager;\n}());\n\nfunction getTextWithoutTrailingNewline(text) {\n    return text[text.length - 1] === '\\n' ? text.slice(0, text.length - 1) : text;\n}\nfunction isCustomHTMLInlineNode(_a, node) {\n    var schema = _a.schema;\n    var html = node.literal;\n    var matched = html.match(reHTMLTag);\n    if (matched) {\n        var openTagName = matched[1], closeTagName = matched[3];\n        var typeName = (openTagName || closeTagName).toLowerCase();\n        return node.type === 'htmlInline' && !!(schema.marks[typeName] || schema.nodes[typeName]);\n    }\n    return false;\n}\nfunction isInlineNode(_a) {\n    var type = _a.type;\n    return includes(['text', 'strong', 'emph', 'strike', 'image', 'link', 'code'], type);\n}\nfunction isSoftbreak(mdNode) {\n    return (mdNode === null || mdNode === void 0 ? void 0 : mdNode.type) === 'softbreak';\n}\nfunction isListNode(_a) {\n    var type = _a.type, literal = _a.literal;\n    var matched = type === 'htmlInline' && literal.match(reHTMLTag);\n    if (matched) {\n        var openTagName = matched[1], closeTagName = matched[3];\n        var tagName = openTagName || closeTagName;\n        if (tagName) {\n            return includes(['ul', 'ol', 'li'], tagName.toLowerCase());\n        }\n    }\n    return false;\n}\nfunction getListItemAttrs(_a) {\n    var literal = _a.literal;\n    var task = /data-task/.test(literal);\n    var checked = /data-task-checked/.test(literal);\n    return { task: task, checked: checked };\n}\nfunction getMatchedAttributeValue(rawHTML) {\n    var attrNames = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        attrNames[_i - 1] = arguments[_i];\n    }\n    var wrapper = document.createElement('div');\n    wrapper.innerHTML = sanitizeHTML(rawHTML);\n    var el = wrapper.firstChild;\n    return attrNames.map(function (attrName) { return el.getAttribute(attrName) || ''; });\n}\nfunction createConvertors(convertors) {\n    var convertorMap = {};\n    Object.keys(convertors).forEach(function (key) {\n        var tagNames = key.split(', ');\n        tagNames.forEach(function (tagName) {\n            var name = tagName.toLowerCase();\n            convertorMap[name] = convertors[key];\n        });\n    });\n    return convertorMap;\n}\nvar convertors = {\n    'b, strong': function (state, _, openTagName) {\n        var strong = state.schema.marks.strong;\n        if (openTagName) {\n            state.openMark(strong.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(strong);\n        }\n    },\n    'i, em': function (state, _, openTagName) {\n        var emph = state.schema.marks.emph;\n        if (openTagName) {\n            state.openMark(emph.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(emph);\n        }\n    },\n    's, del': function (state, _, openTagName) {\n        var strike = state.schema.marks.strike;\n        if (openTagName) {\n            state.openMark(strike.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(strike);\n        }\n    },\n    code: function (state, _, openTagName) {\n        var code = state.schema.marks.code;\n        if (openTagName) {\n            state.openMark(code.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(code);\n        }\n    },\n    a: function (state, node, openTagName) {\n        var tag = node.literal;\n        var link = state.schema.marks.link;\n        if (openTagName) {\n            var linkUrl = getMatchedAttributeValue(tag, 'href')[0];\n            state.openMark(link.create({\n                linkUrl: linkUrl,\n                rawHTML: openTagName,\n            }));\n        }\n        else {\n            state.closeMark(link);\n        }\n    },\n    img: function (state, node, openTagName) {\n        var tag = node.literal;\n        if (openTagName) {\n            var _a = getMatchedAttributeValue(tag, 'src', 'alt'), imageUrl = _a[0], altText = _a[1];\n            var image = state.schema.nodes.image;\n            state.addNode(image, __assign$1({ rawHTML: openTagName, imageUrl: imageUrl }, (altText && { altText: altText })));\n        }\n    },\n    hr: function (state, _, openTagName) {\n        state.addNode(state.schema.nodes.thematicBreak, { rawHTML: openTagName });\n    },\n    br: function (state, node) {\n        var paragraph = state.schema.nodes.paragraph;\n        var parent = node.parent, prev = node.prev, next = node.next;\n        if ((parent === null || parent === void 0 ? void 0 : parent.type) === 'paragraph') {\n            // should open a paragraph node when line text has only <br> tag\n            // ex) first line\\n\\n<br>\\nfourth line\n            if (isSoftbreak(prev)) {\n                state.openNode(paragraph);\n            }\n            // should close a paragraph node when line text has only <br> tag\n            // ex) first line\\n\\n<br>\\nfourth line\n            if (isSoftbreak(next)) {\n                state.closeNode();\n                // should close a paragraph node and open a paragraph node to separate between blocks\n                // when <br> tag is in the middle of the paragraph\n                // ex) first <br>line\\nthird line\n            }\n            else if (next) {\n                state.closeNode();\n                state.openNode(paragraph);\n            }\n        }\n        else if ((parent === null || parent === void 0 ? void 0 : parent.type) === 'tableCell') {\n            if (prev && (isInlineNode(prev) || isCustomHTMLInlineNode(state, prev))) {\n                state.closeNode();\n            }\n            if (next && (isInlineNode(next) || isCustomHTMLInlineNode(state, next))) {\n                state.openNode(paragraph);\n            }\n        }\n    },\n    pre: function (state, node, openTagName) {\n        var _a, _b;\n        var container = document.createElement('div');\n        container.innerHTML = node.literal;\n        var literal = (_b = (_a = container.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild) === null || _b === void 0 ? void 0 : _b.textContent;\n        state.openNode(state.schema.nodes.codeBlock, { rawHTML: openTagName });\n        state.addText(getTextWithoutTrailingNewline(literal));\n        state.closeNode();\n    },\n    'ul, ol': function (state, node, openTagName) {\n        // in the table cell, '<ul>', '<ol>' is parsed as 'htmlInline' node\n        if (node.parent.type === 'tableCell') {\n            var _a = state.schema.nodes, bulletList = _a.bulletList, orderedList = _a.orderedList, paragraph = _a.paragraph;\n            var list = openTagName === 'ul' ? bulletList : orderedList;\n            if (openTagName) {\n                if (node.prev && !isListNode(node.prev)) {\n                    state.closeNode();\n                }\n                state.openNode(list, { rawHTML: openTagName });\n            }\n            else {\n                state.closeNode();\n                if (node.next && !isListNode(node.next)) {\n                    state.openNode(paragraph);\n                }\n            }\n        }\n    },\n    li: function (state, node, openTagName) {\n        var _a;\n        // in the table cell, '<li>' is parsed as 'htmlInline' node\n        if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'tableCell') {\n            var _b = state.schema.nodes, listItem = _b.listItem, paragraph = _b.paragraph;\n            if (openTagName) {\n                var attrs = getListItemAttrs(node);\n                if (node.prev && !isListNode(node.prev)) {\n                    state.closeNode();\n                }\n                state.openNode(listItem, __assign$1({ rawHTML: openTagName }, attrs));\n                if (node.next && !isListNode(node.next)) {\n                    state.openNode(paragraph);\n                }\n            }\n            else {\n                if (node.prev && !isListNode(node.prev)) {\n                    state.closeNode();\n                }\n                state.closeNode();\n            }\n        }\n    },\n};\nvar htmlToWwConvertors = createConvertors(convertors);\n\nfunction isBRTag(node) {\n    return node.type === 'htmlInline' && reBR.test(node.literal);\n}\nfunction addRawHTMLAttributeToDOM(parent) {\n    toArray_1(parent.childNodes).forEach(function (child) {\n        if (isElemNode(child)) {\n            var openTagName = child.nodeName.toLowerCase();\n            child.setAttribute('data-raw-html', openTagName);\n            if (child.childNodes) {\n                addRawHTMLAttributeToDOM(child);\n            }\n        }\n    });\n}\nvar toWwConvertors = {\n    text: function (state, node) {\n        state.addText(node.literal || '');\n    },\n    paragraph: function (state, node, _a, customAttrs) {\n        var _b;\n        var entering = _a.entering;\n        if (entering) {\n            var paragraph = state.schema.nodes.paragraph;\n            // The `\\n\\n` entered in markdown separates the paragraph.\n            // When changing to wysiwyg, a newline is added between the two paragraphs.\n            if (((_b = node.prev) === null || _b === void 0 ? void 0 : _b.type) === 'paragraph') {\n                state.openNode(paragraph, customAttrs);\n                state.closeNode();\n            }\n            state.openNode(paragraph, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    heading: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            var _b = node, level = _b.level, headingType = _b.headingType;\n            state.openNode(state.schema.nodes.heading, __assign$1({ level: level, headingType: headingType }, customAttrs));\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    codeBlock: function (state, node, customAttrs) {\n        var codeBlock = state.schema.nodes.codeBlock;\n        var _a = node, info = _a.info, literal = _a.literal;\n        state.openNode(codeBlock, __assign$1({ language: info }, customAttrs));\n        state.addText(getTextWithoutTrailingNewline(literal || ''));\n        state.closeNode();\n    },\n    list: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            var _b = state.schema.nodes, bulletList = _b.bulletList, orderedList = _b.orderedList;\n            var _c = node.listData, type = _c.type, start = _c.start;\n            if (type === 'bullet') {\n                state.openNode(bulletList, customAttrs);\n            }\n            else {\n                state.openNode(orderedList, __assign$1({ order: start }, customAttrs));\n            }\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    item: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        var listItem = state.schema.nodes.listItem;\n        var _b = node.listData, task = _b.task, checked = _b.checked;\n        if (entering) {\n            var attrs = __assign$1(__assign$1(__assign$1({}, (task && { task: task })), (checked && { checked: checked })), customAttrs);\n            state.openNode(listItem, attrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    blockQuote: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.blockQuote, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    image: function (state, node, _a, customAttrs) {\n        var entering = _a.entering, skipChildren = _a.skipChildren;\n        var image = state.schema.nodes.image;\n        var _b = node, destination = _b.destination, firstChild = _b.firstChild;\n        if (entering && skipChildren) {\n            skipChildren();\n        }\n        state.addNode(image, __assign$1(__assign$1({ imageUrl: destination }, (firstChild && { altText: firstChild.literal })), customAttrs));\n    },\n    thematicBreak: function (state, node, _, customAttrs) {\n        state.addNode(state.schema.nodes.thematicBreak, customAttrs);\n    },\n    strong: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        var strong = state.schema.marks.strong;\n        if (entering) {\n            state.openMark(strong.create(customAttrs));\n        }\n        else {\n            state.closeMark(strong);\n        }\n    },\n    emph: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        var emph = state.schema.marks.emph;\n        if (entering) {\n            state.openMark(emph.create(customAttrs));\n        }\n        else {\n            state.closeMark(emph);\n        }\n    },\n    link: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        var link = state.schema.marks.link;\n        var _b = node, destination = _b.destination, title = _b.title;\n        if (entering) {\n            var attrs = __assign$1({ linkUrl: destination, title: title }, customAttrs);\n            state.openMark(link.create(attrs));\n        }\n        else {\n            state.closeMark(link);\n        }\n    },\n    softbreak: function (state, node) {\n        if (node.parent.type === 'paragraph') {\n            var prev = node.prev, next = node.next;\n            if (prev && !isBRTag(prev)) {\n                state.closeNode();\n            }\n            if (next && !isBRTag(next)) {\n                state.openNode(state.schema.nodes.paragraph);\n            }\n        }\n    },\n    // GFM specifications node\n    table: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.table, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableHead: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.tableHead, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableBody: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.tableBody, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableRow: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.tableRow, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableCell: function (state, node, _a) {\n        var entering = _a.entering;\n        if (!node.ignored) {\n            var hasParaNode = function (childNode) {\n                return childNode && (isInlineNode(childNode) || isCustomHTMLInlineNode(state, childNode));\n            };\n            if (entering) {\n                var _b = state.schema.nodes, tableHeadCell = _b.tableHeadCell, tableBodyCell = _b.tableBodyCell, paragraph = _b.paragraph;\n                var tablePart = node.parent.parent;\n                var cell = tablePart.type === 'tableHead' ? tableHeadCell : tableBodyCell;\n                var table = tablePart.parent;\n                var align = (table.columns[node.startIdx] || {}).align;\n                var attrs = __assign$1({}, node.attrs);\n                if (align) {\n                    attrs.align = align;\n                }\n                state.openNode(cell, attrs);\n                if (hasParaNode(node.firstChild)) {\n                    state.openNode(paragraph);\n                }\n            }\n            else {\n                if (hasParaNode(node.lastChild)) {\n                    state.closeNode();\n                }\n                state.closeNode();\n            }\n        }\n    },\n    strike: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        var strike = state.schema.marks.strike;\n        if (entering) {\n            state.openMark(strike.create(customAttrs));\n        }\n        else {\n            state.closeMark(strike);\n        }\n    },\n    code: function (state, node, _, customAttrs) {\n        var code = state.schema.marks.code;\n        state.openMark(code.create(customAttrs));\n        state.addText(getTextWithoutTrailingNewline(node.literal || ''));\n        state.closeMark(code);\n    },\n    customBlock: function (state, node) {\n        var _a = state.schema.nodes, customBlock = _a.customBlock, paragraph = _a.paragraph;\n        var _b = node, info = _b.info, literal = _b.literal;\n        state.openNode(customBlock, { info: info });\n        state.addText(getTextWithoutTrailingNewline(literal || ''));\n        state.closeNode();\n        // add empty line to edit the content in next line\n        if (!node.next) {\n            state.openNode(paragraph);\n            state.closeNode();\n        }\n    },\n    frontMatter: function (state, node) {\n        state.openNode(state.schema.nodes.frontMatter);\n        state.addText(node.literal);\n        state.closeNode();\n    },\n    htmlInline: function (state, node) {\n        var html = node.literal;\n        var matched = html.match(reHTMLTag);\n        var openTagName = matched[1], closeTagName = matched[3];\n        var typeName = (openTagName || closeTagName).toLowerCase();\n        var markType = state.schema.marks[typeName];\n        var sanitizedHTML = sanitizeHTML(html);\n        // for user defined html schema\n        if (markType === null || markType === void 0 ? void 0 : markType.spec.attrs.htmlInline) {\n            if (openTagName) {\n                var htmlAttrs = getHTMLAttrsByHTMLString(sanitizedHTML);\n                state.openMark(markType.create({ htmlAttrs: htmlAttrs }));\n            }\n            else {\n                state.closeMark(markType);\n            }\n        }\n        else {\n            var htmlToWwConvertor = htmlToWwConvertors[typeName];\n            if (htmlToWwConvertor) {\n                htmlToWwConvertor(state, node, openTagName);\n            }\n        }\n    },\n    htmlBlock: function (state, node) {\n        var html = node.literal;\n        var container = document.createElement('div');\n        var isHTMLComment = reHTMLComment.test(html);\n        if (isHTMLComment) {\n            state.openNode(state.schema.nodes.htmlComment);\n            state.addText(node.literal);\n            state.closeNode();\n        }\n        else {\n            var matched = html.match(reHTMLTag);\n            var openTagName = matched[1], closeTagName = matched[3];\n            var typeName = (openTagName || closeTagName).toLowerCase();\n            var nodeType = state.schema.nodes[typeName];\n            var sanitizedHTML = sanitizeHTML(html);\n            // for user defined html schema\n            if (nodeType === null || nodeType === void 0 ? void 0 : nodeType.spec.attrs.htmlBlock) {\n                var htmlAttrs = getHTMLAttrsByHTMLString(sanitizedHTML);\n                var childrenHTML = getChildrenHTML(node, typeName);\n                state.addNode(nodeType, { htmlAttrs: htmlAttrs, childrenHTML: childrenHTML });\n            }\n            else {\n                container.innerHTML = sanitizedHTML;\n                addRawHTMLAttributeToDOM(container);\n                state.convertByDOMParser(container);\n            }\n        }\n    },\n    customInline: function (state, node, _a) {\n        var entering = _a.entering, skipChildren = _a.skipChildren;\n        var _b = node, info = _b.info, firstChild = _b.firstChild;\n        var schema = state.schema;\n        if (info.indexOf('widget') !== -1 && entering) {\n            var content = getWidgetContent(node);\n            skipChildren();\n            state.addNode(schema.nodes.widget, { info: info }, [\n                schema.text(createWidgetContent(info, content)),\n            ]);\n        }\n        else {\n            var text = '$$';\n            if (entering) {\n                text += firstChild ? info + \" \" : info;\n            }\n            state.addText(text);\n        }\n    },\n};\nfunction createWwConvertors(customConvertors) {\n    var customConvertorTypes = Object.keys(customConvertors);\n    var convertors = __assign$1({}, toWwConvertors);\n    var renderer = new Renderer({\n        gfm: true,\n        nodeId: true,\n        convertors: customConvertors,\n    });\n    var orgConvertors = renderer.getConvertors();\n    customConvertorTypes.forEach(function (type) {\n        var wwConvertor = toWwConvertors[type];\n        if (wwConvertor && !includes(['htmlBlock', 'htmlInline'], type)) {\n            convertors[type] = function (state, node, context) {\n                context.origin = function () { return orgConvertors[type](node, context, orgConvertors); };\n                var tokens = customConvertors[type](node, context);\n                var attrs;\n                if (tokens) {\n                    var _a = Array.isArray(tokens) ? tokens[0] : tokens, htmlAttrs = _a.attributes, classNames = _a.classNames;\n                    attrs = { htmlAttrs: htmlAttrs, classNames: classNames };\n                }\n                wwConvertor(state, node, context, attrs);\n            };\n        }\n    });\n    return convertors;\n}\n\nfunction mergeMarkText(a, b) {\n    if (a.isText && b.isText && prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Mark.sameSet(a.marks, b.marks)) {\n        // @ts-ignore\n        // type is not defined for \"withText\" in prosemirror-model\n        return a.withText(a.text + b.text);\n    }\n    return false;\n}\nvar ToWwConvertorState = /** @class */ (function () {\n    function ToWwConvertorState(schema, convertors) {\n        this.schema = schema;\n        this.convertors = convertors;\n        this.stack = [{ type: this.schema.topNodeType, attrs: null, content: [] }];\n        this.marks = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Mark.none;\n    }\n    ToWwConvertorState.prototype.top = function () {\n        return last$1(this.stack);\n    };\n    ToWwConvertorState.prototype.push = function (node) {\n        if (this.stack.length) {\n            this.top().content.push(node);\n        }\n    };\n    ToWwConvertorState.prototype.addText = function (text) {\n        if (text) {\n            var nodes = this.top().content;\n            var lastNode = last$1(nodes);\n            var node = this.schema.text(text, this.marks);\n            var merged = lastNode && mergeMarkText(lastNode, node);\n            if (merged) {\n                nodes[nodes.length - 1] = merged;\n            }\n            else {\n                nodes.push(node);\n            }\n        }\n    };\n    ToWwConvertorState.prototype.openMark = function (mark) {\n        this.marks = mark.addToSet(this.marks);\n    };\n    ToWwConvertorState.prototype.closeMark = function (mark) {\n        this.marks = mark.removeFromSet(this.marks);\n    };\n    ToWwConvertorState.prototype.addNode = function (type, attrs, content) {\n        var node = type.createAndFill(attrs, content, this.marks);\n        if (node) {\n            this.push(node);\n            return node;\n        }\n        return null;\n    };\n    ToWwConvertorState.prototype.openNode = function (type, attrs) {\n        this.stack.push({ type: type, attrs: attrs, content: [] });\n    };\n    ToWwConvertorState.prototype.closeNode = function () {\n        if (this.marks.length) {\n            this.marks = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Mark.none;\n        }\n        var _a = this.stack.pop(), type = _a.type, attrs = _a.attrs, content = _a.content;\n        return this.addNode(type, attrs, content);\n    };\n    ToWwConvertorState.prototype.convertByDOMParser = function (root) {\n        var _this = this;\n        var doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMParser.fromSchema(this.schema).parse(root);\n        doc.content.forEach(function (node) { return _this.push(node); });\n    };\n    ToWwConvertorState.prototype.closeUnmatchedHTMLInline = function (node, entering) {\n        var _a;\n        if (!entering && node.type !== 'htmlInline') {\n            var length_1 = this.stack.length - 1;\n            for (var i = length_1; i >= 0; i -= 1) {\n                var nodeInfo = this.stack[i];\n                if ((_a = nodeInfo.attrs) === null || _a === void 0 ? void 0 : _a.rawHTML) {\n                    if (nodeInfo.content.length) {\n                        this.closeNode();\n                    }\n                    else {\n                        // just pop useless unmatched html inline node\n                        this.stack.pop();\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n    };\n    ToWwConvertorState.prototype.convert = function (mdNode, infoForPosSync) {\n        var walker = mdNode.walker();\n        var event = walker.next();\n        var _loop_1 = function () {\n            var node = event.node, entering = event.entering;\n            var convertor = this_1.convertors[node.type];\n            var skipped = false;\n            if (convertor) {\n                var context = {\n                    entering: entering,\n                    leaf: !isContainer$2(node),\n                    getChildrenText: getChildrenText$1,\n                    options: { gfm: true, nodeId: false, tagFilter: false, softbreak: '\\n' },\n                    skipChildren: function () {\n                        skipped = true;\n                    },\n                };\n                this_1.closeUnmatchedHTMLInline(node, entering);\n                convertor(this_1, node, context);\n                if ((infoForPosSync === null || infoForPosSync === void 0 ? void 0 : infoForPosSync.node) === node) {\n                    var pos = this_1.stack.reduce(function (nodeSize, stackItem) {\n                        return nodeSize +\n                            stackItem.content.reduce(function (contentSize, pmNode) { return contentSize + pmNode.nodeSize; }, 0);\n                    }, 0) + 1;\n                    infoForPosSync.setMappedPos(pos);\n                }\n            }\n            if (skipped) {\n                walker.resumeAt(node, false);\n                walker.next();\n            }\n            event = walker.next();\n        };\n        var this_1 = this;\n        while (event) {\n            _loop_1();\n        }\n    };\n    ToWwConvertorState.prototype.convertNode = function (mdNode, infoForPosSync) {\n        this.convert(mdNode, infoForPosSync);\n        if (this.stack.length) {\n            return this.closeNode();\n        }\n        return null;\n    };\n    return ToWwConvertorState;\n}());\n\nfunction convertToRawHTMLHavingInlines(state, node, _a) {\n    var openTag = _a[0], closeTag = _a[1];\n    state.write(openTag);\n    state.convertInline(node);\n    state.write(closeTag);\n}\nfunction convertToRawHTMLHavingBlocks(state, _a, _b) {\n    var node = _a.node, parent = _a.parent;\n    var openTag = _b[0], closeTag = _b[1];\n    state.stopNewline = true;\n    state.write(openTag);\n    state.convertNode(node);\n    state.write(closeTag);\n    if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === 'doc') {\n        state.closeBlock(node);\n        state.stopNewline = false;\n    }\n}\nfunction createTableHeadDelim(textContent, columnAlign) {\n    var textLen = textContent.length;\n    var leftDelim = '';\n    var rightDelim = '';\n    if (columnAlign === 'left') {\n        leftDelim = ':';\n        textLen -= 1;\n    }\n    else if (columnAlign === 'right') {\n        rightDelim = ':';\n        textLen -= 1;\n    }\n    else if (columnAlign === 'center') {\n        leftDelim = ':';\n        rightDelim = ':';\n        textLen -= 2;\n    }\n    return \"\" + leftDelim + repeat$1('-', Math.max(textLen, 3)) + rightDelim;\n}\nvar nodeTypeWriters = {\n    text: function (state, _a) {\n        var _b;\n        var node = _a.node;\n        var text = (_b = node.text) !== null && _b !== void 0 ? _b : '';\n        if ((node.marks || []).some(function (mark) { return mark.type.name === 'link'; })) {\n            state.text(escapeTextForLink(text), false);\n        }\n        else {\n            state.text(text);\n        }\n    },\n    paragraph: function (state, _a) {\n        var node = _a.node, parent = _a.parent, _b = _a.index, index = _b === void 0 ? 0 : _b;\n        if (state.stopNewline) {\n            state.convertInline(node);\n        }\n        else {\n            var firstChildNode = index === 0;\n            var prevNode = !firstChildNode && parent.child(index - 1);\n            var prevEmptyNode = prevNode && prevNode.childCount === 0;\n            var nextNode = index < parent.childCount - 1 && parent.child(index + 1);\n            var nextParaNode = nextNode && nextNode.type.name === 'paragraph';\n            var emptyNode = node.childCount === 0;\n            if (emptyNode && prevEmptyNode) {\n                state.write('<br>\\n');\n            }\n            else if (emptyNode && !prevEmptyNode && !firstChildNode) {\n                if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === 'listItem') {\n                    var prevDelim = state.getDelim();\n                    state.setDelim('');\n                    state.write('<br>');\n                    state.setDelim(prevDelim);\n                }\n                state.write('\\n');\n            }\n            else {\n                state.convertInline(node);\n                if (nextParaNode) {\n                    state.write('\\n');\n                }\n                else {\n                    state.closeBlock(node);\n                }\n            }\n        }\n    },\n    heading: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        var headingType = node.attrs.headingType;\n        if (headingType === 'atx') {\n            state.write(delim + \" \");\n            state.convertInline(node);\n            state.closeBlock(node);\n        }\n        else {\n            state.convertInline(node);\n            state.ensureNewLine();\n            state.write(delim);\n            state.closeBlock(node);\n        }\n    },\n    codeBlock: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim, text = _b.text;\n        var _c = delim, openDelim = _c[0], closeDelim = _c[1];\n        state.write(openDelim);\n        state.ensureNewLine();\n        state.text(text, false);\n        state.ensureNewLine();\n        state.write(closeDelim);\n        state.closeBlock(node);\n    },\n    blockQuote: function (state, _a, _b) {\n        var node = _a.node, parent = _a.parent;\n        var delim = _b.delim;\n        if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === node.type.name) {\n            state.flushClose(1);\n        }\n        state.wrapBlock(delim, null, node, function () { return state.convertNode(node); });\n    },\n    bulletList: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        // soft-tab(4)\n        state.convertList(node, repeat$1(' ', 4), function () { return delim + \" \"; });\n    },\n    orderedList: function (state, _a) {\n        var node = _a.node;\n        var start = node.attrs.order || 1;\n        // soft-tab(4)\n        state.convertList(node, repeat$1(' ', 4), function (index) {\n            var orderedNum = String(start + index);\n            return orderedNum + \". \";\n        });\n    },\n    listItem: function (state, _a) {\n        var node = _a.node;\n        var _b = node.attrs, task = _b.task, checked = _b.checked;\n        if (task) {\n            state.write(\"[\" + (checked ? 'x' : ' ') + \"] \");\n        }\n        state.convertNode(node);\n    },\n    image: function (state, _, _a) {\n        var attrs = _a.attrs;\n        state.write(\"![\" + (attrs === null || attrs === void 0 ? void 0 : attrs.altText) + \"](\" + (attrs === null || attrs === void 0 ? void 0 : attrs.imageUrl) + \")\");\n    },\n    thematicBreak: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        state.write(delim);\n        state.closeBlock(node);\n    },\n    table: function (state, _a) {\n        var node = _a.node;\n        state.convertNode(node);\n        state.closeBlock(node);\n    },\n    tableHead: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        var row = node.firstChild;\n        state.convertNode(node);\n        var result = delim !== null && delim !== void 0 ? delim : '';\n        if (!delim && row) {\n            row.forEach(function (_a) {\n                var textContent = _a.textContent, attrs = _a.attrs;\n                var headDelim = createTableHeadDelim(textContent, attrs.align);\n                result += \"| \" + headDelim + \" \";\n            });\n        }\n        state.write(result + \"|\");\n        state.ensureNewLine();\n    },\n    tableBody: function (state, _a) {\n        var node = _a.node;\n        state.convertNode(node);\n    },\n    tableRow: function (state, _a) {\n        var node = _a.node;\n        state.convertNode(node);\n        state.write('|');\n        state.ensureNewLine();\n    },\n    tableHeadCell: function (state, _a, _b) {\n        var node = _a.node;\n        var _c = _b.delim, delim = _c === void 0 ? '| ' : _c;\n        state.write(delim);\n        state.convertTableCell(node);\n        state.write(' ');\n    },\n    tableBodyCell: function (state, _a, _b) {\n        var node = _a.node;\n        var _c = _b.delim, delim = _c === void 0 ? '| ' : _c;\n        state.write(delim);\n        state.convertTableCell(node);\n        state.write(' ');\n    },\n    customBlock: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim, text = _b.text;\n        var _c = delim, openDelim = _c[0], closeDelim = _c[1];\n        state.write(openDelim);\n        state.ensureNewLine();\n        state.text(text, false);\n        state.ensureNewLine();\n        state.write(closeDelim);\n        state.closeBlock(node);\n    },\n    frontMatter: function (state, _a, _b) {\n        var node = _a.node;\n        var text = _b.text;\n        state.text(text, false);\n        state.closeBlock(node);\n    },\n    widget: function (state, _, _a) {\n        var text = _a.text;\n        state.write(text);\n    },\n    html: function (state, _a, _b) {\n        var node = _a.node;\n        var text = _b.text;\n        state.write(text);\n        if (node.attrs.htmlBlock) {\n            state.closeBlock(node);\n        }\n    },\n    htmlComment: function (state, _a, _b) {\n        var node = _a.node;\n        var text = _b.text;\n        state.write(text);\n        state.closeBlock(node);\n    },\n};\nfunction write(type, _a) {\n    var state = _a.state, nodeInfo = _a.nodeInfo, params = _a.params;\n    var rawHTML = params.rawHTML;\n    if (rawHTML) {\n        if (inArray_1(type, ['heading', 'codeBlock']) > -1) {\n            convertToRawHTMLHavingInlines(state, nodeInfo.node, rawHTML);\n        }\n        else if (inArray_1(type, ['image', 'thematicBreak']) > -1) {\n            state.write(rawHTML);\n        }\n        else {\n            convertToRawHTMLHavingBlocks(state, nodeInfo, rawHTML);\n        }\n    }\n    else {\n        nodeTypeWriters[type](state, nodeInfo, params);\n    }\n}\n\nfunction addBackticks(node, side) {\n    var text = node.text;\n    var ticks = /`+/g;\n    var len = 0;\n    if (node.isText && text) {\n        var matched = ticks.exec(text);\n        while (matched) {\n            len = Math.max(len, matched[0].length);\n            matched = ticks.exec(text);\n        }\n    }\n    var result = len > 0 && side > 0 ? ' `' : '`';\n    for (var i = 0; i < len; i += 1) {\n        result += '`';\n    }\n    if (len > 0 && side < 0) {\n        result += ' ';\n    }\n    return result;\n}\nfunction getPairRawHTML(rawHTML) {\n    return rawHTML ? [\"<\" + rawHTML + \">\", \"</\" + rawHTML + \">\"] : null;\n}\nfunction getOpenRawHTML(rawHTML) {\n    return rawHTML ? \"<\" + rawHTML + \">\" : null;\n}\nfunction getCloseRawHTML(rawHTML) {\n    return rawHTML ? \"</\" + rawHTML + \">\" : null;\n}\nvar toMdConvertors = {\n    heading: function (_a) {\n        var node = _a.node;\n        var attrs = node.attrs;\n        var level = attrs.level;\n        var delim = repeat$1('#', level);\n        if (attrs.headingType === 'setext') {\n            delim = level === 1 ? '===' : '---';\n        }\n        return {\n            delim: delim,\n            rawHTML: getPairRawHTML(attrs.rawHTML),\n        };\n    },\n    codeBlock: function (_a) {\n        var node = _a.node;\n        var _b = node, attrs = _b.attrs, textContent = _b.textContent;\n        return {\n            delim: [\"```\" + (attrs.language || ''), '```'],\n            rawHTML: getPairRawHTML(attrs.rawHTML),\n            text: textContent,\n        };\n    },\n    blockQuote: function (_a) {\n        var node = _a.node;\n        return {\n            delim: '> ',\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    bulletList: function (_a, _b) {\n        var node = _a.node;\n        var inTable = _b.inTable;\n        var rawHTML = node.attrs.rawHTML;\n        if (inTable) {\n            rawHTML = rawHTML || 'ul';\n        }\n        return {\n            delim: '*',\n            rawHTML: getPairRawHTML(rawHTML),\n        };\n    },\n    orderedList: function (_a, _b) {\n        var node = _a.node;\n        var inTable = _b.inTable;\n        var rawHTML = node.attrs.rawHTML;\n        if (inTable) {\n            rawHTML = rawHTML || 'ol';\n        }\n        return {\n            rawHTML: getPairRawHTML(rawHTML),\n        };\n    },\n    listItem: function (_a, _b) {\n        var node = _a.node;\n        var inTable = _b.inTable;\n        var _c = node.attrs, task = _c.task, checked = _c.checked;\n        var rawHTML = node.attrs.rawHTML;\n        if (inTable) {\n            rawHTML = rawHTML || 'li';\n        }\n        var className = task ? \" class=\\\"task-list-item\" + (checked ? ' checked' : '') + \"\\\"\" : '';\n        var dataset = task ? \" data-task\" + (checked ? \" data-task-checked\" : '') : '';\n        return {\n            rawHTML: rawHTML ? [\"<\" + rawHTML + className + dataset + \">\", \"</\" + rawHTML + \">\"] : null,\n        };\n    },\n    table: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableHead: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableBody: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableRow: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableHeadCell: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableBodyCell: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    image: function (_a) {\n        var node = _a.node;\n        var attrs = node.attrs;\n        var rawHTML = attrs.rawHTML, altText = attrs.altText;\n        var imageUrl = attrs.imageUrl.replace(/&amp;/g, '&');\n        var altAttr = altText ? \" alt=\\\"\" + escapeXml$1(altText) + \"\\\"\" : '';\n        return {\n            rawHTML: rawHTML ? \"<\" + rawHTML + \" src=\\\"\" + escapeXml$1(imageUrl) + \"\\\"\" + altAttr + \">\" : null,\n            attrs: {\n                altText: escapeTextForLink(altText || ''),\n                imageUrl: imageUrl,\n            },\n        };\n    },\n    thematicBreak: function (_a) {\n        var node = _a.node;\n        return {\n            delim: '***',\n            rawHTML: getOpenRawHTML(node.attrs.rawHTML),\n        };\n    },\n    customBlock: function (_a) {\n        var node = _a.node;\n        var _b = node, attrs = _b.attrs, textContent = _b.textContent;\n        return {\n            delim: [\"$$\" + attrs.info, '$$'],\n            text: textContent,\n        };\n    },\n    frontMatter: function (_a) {\n        var node = _a.node;\n        return {\n            text: node.textContent,\n        };\n    },\n    widget: function (_a) {\n        var node = _a.node;\n        return {\n            text: node.textContent,\n        };\n    },\n    strong: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var rawHTML = node.attrs.rawHTML;\n        return {\n            delim: '**',\n            rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML),\n        };\n    },\n    emph: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var rawHTML = node.attrs.rawHTML;\n        return {\n            delim: '*',\n            rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML),\n        };\n    },\n    strike: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var rawHTML = node.attrs.rawHTML;\n        return {\n            delim: '~~',\n            rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML),\n        };\n    },\n    link: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var attrs = node.attrs;\n        var title = attrs.title, rawHTML = attrs.rawHTML;\n        var linkUrl = attrs.linkUrl.replace(/&amp;/g, '&');\n        var titleAttr = title ? \" title=\\\"\" + escapeXml$1(title) + \"\\\"\" : '';\n        if (entering) {\n            return {\n                delim: '[',\n                rawHTML: rawHTML ? \"<\" + rawHTML + \" href=\\\"\" + escapeXml$1(linkUrl) + \"\\\"\" + titleAttr + \">\" : null,\n            };\n        }\n        return {\n            delim: \"](\" + linkUrl + (title ? \" \" + quote(escapeTextForLink(title)) : '') + \")\",\n            rawHTML: getCloseRawHTML(rawHTML),\n        };\n    },\n    code: function (_a, _b) {\n        var node = _a.node, parent = _a.parent, _c = _a.index, index = _c === void 0 ? 0 : _c;\n        var entering = _b.entering;\n        var delim = entering\n            ? addBackticks(parent.child(index), -1)\n            : addBackticks(parent.child(index - 1), 1);\n        var rawHTML = entering\n            ? getOpenRawHTML(node.attrs.rawHTML)\n            : getCloseRawHTML(node.attrs.rawHTML);\n        return {\n            delim: delim,\n            rawHTML: rawHTML,\n        };\n    },\n    htmlComment: function (_a) {\n        var node = _a.node;\n        return {\n            text: node.textContent,\n        };\n    },\n    // html inline node, html block node\n    html: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var tagName = node.type.name;\n        var attrs = node.attrs.htmlAttrs;\n        var openTag = \"<\" + tagName;\n        var closeTag = \"</\" + tagName + \">\";\n        Object.keys(attrs).forEach(function (attrName) {\n            // To prevent broken converting when attributes has double quote string\n            openTag += \" \" + attrName + \"=\\\"\" + attrs[attrName].replace(/\"/g, \"'\") + \"\\\"\";\n        });\n        openTag += '>';\n        if (node.attrs.htmlInline) {\n            return {\n                rawHTML: entering ? openTag : closeTag,\n            };\n        }\n        return {\n            text: \"\" + openTag + node.attrs.childrenHTML + closeTag,\n        };\n    },\n};\nvar markTypeOptions = {\n    strong: {\n        mixable: true,\n        removedEnclosingWhitespace: true,\n    },\n    emph: {\n        mixable: true,\n        removedEnclosingWhitespace: true,\n    },\n    strike: {\n        mixable: true,\n        removedEnclosingWhitespace: true,\n    },\n    code: {\n        escape: false,\n    },\n    link: null,\n    html: null,\n};\nfunction createNodeTypeConvertors(convertors) {\n    var nodeTypeConvertors = {};\n    var nodeTypes = Object.keys(nodeTypeWriters);\n    nodeTypes.forEach(function (type) {\n        nodeTypeConvertors[type] = function (state, nodeInfo) {\n            var writer = nodeTypeWriters[type];\n            if (writer) {\n                var convertor = convertors[type];\n                var params = convertor\n                    ? convertor(nodeInfo, {\n                        inTable: state.inTable,\n                    })\n                    : {};\n                write(type, { state: state, nodeInfo: nodeInfo, params: params });\n            }\n        };\n    });\n    return nodeTypeConvertors;\n}\nfunction createMarkTypeConvertors(convertors) {\n    var markTypeConvertors = {};\n    var markTypes = Object.keys(markTypeOptions);\n    markTypes.forEach(function (type) {\n        markTypeConvertors[type] = function (nodeInfo, entering) {\n            var markOption = markTypeOptions[type];\n            var convertor = convertors[type];\n            // There are two ways to call the mark type converter\n            // in the `toMdConvertorState` module.\n            // When calling the converter without using `delim` and `rawHTML` values,\n            // the converter is called without parameters.\n            var runConvertor = convertor && nodeInfo && !isUndefined_1(entering);\n            var params = runConvertor ? convertor(nodeInfo, { entering: entering }) : {};\n            return __assign$1(__assign$1({}, params), markOption);\n        };\n    });\n    return markTypeConvertors;\n}\n// Step 1: Create the converter by overriding the custom converter\n//         to the original converter defined in the `toMdConvertors` module.\n//         If the node type is defined in the original converter,\n//         the `origin()` function is exported to the paramter of the converter.\n// Step 2: Create a converter for the node type of ProseMirror by combining the converter\n//         created in Step 1 with the writers defined in the`toMdNodeTypeWriters` module.\n//         Each writer converts the ProseMirror's node to a string with the value returned\n//         by the converter, and then stores the state in the`toMdConverterState` class.\n// Step 3: Create a converter for the mark type of ProseMirror by combining the converter\n//         created in Step 1 with `markTypeOptions`.\n// Step 4: The created node type converter and mark type converter are injected\n//         when creating an instance of the`toMdConverterState` class.\nfunction createMdConvertors(customConvertors) {\n    var customConvertorTypes = Object.keys(customConvertors);\n    customConvertorTypes.forEach(function (type) {\n        var baseConvertor = toMdConvertors[type];\n        var customConvertor = customConvertors[type];\n        if (baseConvertor) {\n            toMdConvertors[type] = function (nodeInfo, context) {\n                context.origin = function () { return baseConvertor(nodeInfo, context); };\n                return customConvertor(nodeInfo, context);\n            };\n        }\n        else {\n            toMdConvertors[type] = customConvertor;\n        }\n        delete customConvertors[type];\n    });\n    var nodeTypeConvertors = createNodeTypeConvertors(toMdConvertors);\n    var markTypeConvertors = createMarkTypeConvertors(toMdConvertors);\n    return {\n        nodeTypeConvertors: nodeTypeConvertors,\n        markTypeConvertors: markTypeConvertors,\n    };\n}\n\nvar ToMdConvertorState = /** @class */ (function () {\n    function ToMdConvertorState(_a) {\n        var nodeTypeConvertors = _a.nodeTypeConvertors, markTypeConvertors = _a.markTypeConvertors;\n        this.nodeTypeConvertors = nodeTypeConvertors;\n        this.markTypeConvertors = markTypeConvertors;\n        this.delim = '';\n        this.result = '';\n        this.closed = false;\n        this.tightList = false;\n        this.stopNewline = false;\n        this.inTable = false;\n    }\n    ToMdConvertorState.prototype.getMarkConvertor = function (mark) {\n        var type = mark.attrs.htmlInline ? 'html' : mark.type.name;\n        return this.markTypeConvertors[type];\n    };\n    ToMdConvertorState.prototype.isInBlank = function () {\n        return /(^|\\n)$/.test(this.result);\n    };\n    ToMdConvertorState.prototype.markText = function (mark, entering, parent, index) {\n        var convertor = this.getMarkConvertor(mark);\n        if (convertor) {\n            var _a = convertor({ node: mark, parent: parent, index: index }, entering), delim = _a.delim, rawHTML = _a.rawHTML;\n            return rawHTML || delim;\n        }\n        return '';\n    };\n    ToMdConvertorState.prototype.setDelim = function (delim) {\n        this.delim = delim;\n    };\n    ToMdConvertorState.prototype.getDelim = function () {\n        return this.delim;\n    };\n    ToMdConvertorState.prototype.flushClose = function (size) {\n        if (!this.stopNewline && this.closed) {\n            if (!this.isInBlank()) {\n                this.result += '\\n';\n            }\n            if (!size) {\n                size = 2;\n            }\n            if (size > 1) {\n                var delimMin = this.delim;\n                var trim = /\\s+$/.exec(delimMin);\n                if (trim) {\n                    delimMin = delimMin.slice(0, delimMin.length - trim[0].length);\n                }\n                for (var i = 1; i < size; i += 1) {\n                    this.result += delimMin + \"\\n\";\n                }\n            }\n            this.closed = false;\n        }\n    };\n    ToMdConvertorState.prototype.wrapBlock = function (delim, firstDelim, node, fn) {\n        var old = this.getDelim();\n        this.write(firstDelim || delim);\n        this.setDelim(this.getDelim() + delim);\n        fn();\n        this.setDelim(old);\n        this.closeBlock(node);\n    };\n    ToMdConvertorState.prototype.ensureNewLine = function () {\n        if (!this.isInBlank()) {\n            this.result += '\\n';\n        }\n    };\n    ToMdConvertorState.prototype.write = function (content) {\n        if (content === void 0) { content = ''; }\n        this.flushClose();\n        if (this.delim && this.isInBlank()) {\n            this.result += this.delim;\n        }\n        if (content) {\n            this.result += content;\n        }\n    };\n    ToMdConvertorState.prototype.closeBlock = function (node) {\n        this.closed = node;\n    };\n    ToMdConvertorState.prototype.text = function (text, escaped) {\n        if (escaped === void 0) { escaped = true; }\n        var lines = text.split('\\n');\n        for (var i = 0; i < lines.length; i += 1) {\n            this.write();\n            this.result += escaped ? escape$1(lines[i]) : lines[i];\n            if (i !== lines.length - 1) {\n                this.result += '\\n';\n            }\n        }\n    };\n    ToMdConvertorState.prototype.convertBlock = function (node, parent, index) {\n        var type = node.type.name;\n        var convertor = this.nodeTypeConvertors[type];\n        var nodeInfo = { node: node, parent: parent, index: index };\n        if (node.attrs.htmlBlock) {\n            this.nodeTypeConvertors.html(this, nodeInfo);\n        }\n        else if (convertor) {\n            convertor(this, nodeInfo);\n        }\n    };\n    ToMdConvertorState.prototype.convertInline = function (parent) {\n        var _this = this;\n        var active = [];\n        var trailing = '';\n        var progress = function (node, _, index) {\n            var marks = node ? node.marks : [];\n            var leading = trailing;\n            trailing = '';\n            // If whitespace has to be expelled from the node, adjust\n            // leading and trailing accordingly.\n            var removedWhitespace = node &&\n                node.isText &&\n                marks.some(function (mark) {\n                    var markConvertor = _this.getMarkConvertor(mark);\n                    var info = markConvertor && markConvertor();\n                    return info && info.removedEnclosingWhitespace;\n                });\n            if (removedWhitespace && node && node.text) {\n                var _a = /^(\\s*)(.*?)(\\s*)$/m.exec(node.text), lead = _a[1], mark = _a[2], trail = _a[3];\n                leading += lead;\n                trailing = trail;\n                if (lead || trail) {\n                    // @ts-ignore\n                    // type is not defined for \"withText\" in prosemirror-model\n                    node = mark ? node.withText(mark) : null;\n                    if (!node) {\n                        marks = active;\n                    }\n                }\n            }\n            var lastMark = marks.length && last$1(marks);\n            var markConvertor = lastMark && _this.getMarkConvertor(lastMark);\n            var markType = markConvertor && markConvertor();\n            var noEscape = markType && markType.escape === false;\n            var len = marks.length - (noEscape ? 1 : 0);\n            // Try to reorder 'mixable' marks, such as em and strong, which\n            // in Markdown may be opened and closed in different order, so\n            // that order of the marks for the token matches the order in\n            // active.\n            for (var i = 0; i < len; i += 1) {\n                var mark = marks[i];\n                if (markType && !markType.mixable) {\n                    break;\n                }\n                for (var j = 0; j < active.length; j += 1) {\n                    var other = active[j];\n                    if (markType && !markType.mixable) {\n                        break;\n                    }\n                    if (mark.eq(other)) {\n                        // eslint-disable-next-line max-depth\n                        if (i > j) {\n                            marks = marks\n                                .slice(0, j)\n                                .concat(mark)\n                                .concat(marks.slice(j, i))\n                                .concat(marks.slice(i + 1, len));\n                        }\n                        else if (j > i) {\n                            marks = marks\n                                .slice(0, i)\n                                .concat(marks.slice(i + 1, j))\n                                .concat(mark)\n                                .concat(marks.slice(j, len));\n                        }\n                        break;\n                    }\n                }\n            }\n            // Find the prefix of the mark set that didn't change\n            var keep = 0;\n            while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep])) {\n                keep += 1;\n            }\n            // Close the marks that need to be closed\n            while (keep < active.length) {\n                var activedMark = active.pop();\n                if (activedMark) {\n                    _this.text(_this.markText(activedMark, false, parent, index), false);\n                }\n            }\n            // Output any previously expelled trailing whitespace outside the marks\n            if (leading) {\n                _this.text(leading);\n            }\n            // Open the marks that need to be opened\n            if (node) {\n                while (active.length < len) {\n                    var mark = marks[active.length];\n                    active.push(mark);\n                    _this.text(_this.markText(mark, true, parent, index), false);\n                }\n                // Render the node. Special case code marks, since their content\n                // may not be escaped.\n                if (noEscape && node.isText) {\n                    _this.text(_this.markText(lastMark, true, parent, index) +\n                        node.text +\n                        _this.markText(lastMark, false, parent, index + 1), false);\n                }\n                else {\n                    _this.convertBlock(node, parent, index);\n                }\n            }\n        };\n        parent.forEach(progress);\n        progress(null, null, parent.childCount);\n    };\n    // Render a node's content as a list. `delim` should be the extra\n    // indentation added to all lines except the first in an item,\n    // `firstDelimFn` is a function going from an item index to a\n    // delimiter for the first line of the item.\n    ToMdConvertorState.prototype.convertList = function (node, delim, firstDelimFn) {\n        var _this = this;\n        var _a;\n        if (this.closed && this.closed.type === node.type) {\n            this.flushClose(3);\n        }\n        else if (this.tightList) {\n            this.flushClose(1);\n        }\n        var tight = (_a = node.attrs.tight) !== null && _a !== void 0 ? _a : true;\n        var prevTight = this.tightList;\n        this.tightList = tight;\n        node.forEach(function (child, _, index) {\n            if (index && tight) {\n                _this.flushClose(1);\n            }\n            _this.wrapBlock(delim, firstDelimFn(index), node, function () { return _this.convertBlock(child, node, index); });\n        });\n        this.tightList = prevTight;\n    };\n    ToMdConvertorState.prototype.convertTableCell = function (node) {\n        var _this = this;\n        this.stopNewline = true;\n        this.inTable = true;\n        node.forEach(function (child, _, index) {\n            if (includes(['bulletList', 'orderedList'], child.type.name)) {\n                _this.convertBlock(child, node, index);\n                _this.closed = false;\n            }\n            else {\n                _this.convertInline(child);\n                if (index < node.childCount - 1) {\n                    var nextChild = node.child(index + 1);\n                    if (nextChild.type.name === 'paragraph') {\n                        _this.write('<br>');\n                    }\n                }\n            }\n        });\n        this.stopNewline = false;\n        this.inTable = false;\n    };\n    ToMdConvertorState.prototype.convertNode = function (parent, infoForPosSync) {\n        var _this = this;\n        parent.forEach(function (node, _, index) {\n            _this.convertBlock(node, parent, index);\n            if ((infoForPosSync === null || infoForPosSync === void 0 ? void 0 : infoForPosSync.node) === node) {\n                var lineTexts = _this.result.split('\\n');\n                infoForPosSync.setMappedPos([lineTexts.length, last$1(lineTexts).length + 1]);\n            }\n        });\n        return this.result;\n    };\n    return ToMdConvertorState;\n}());\n\nvar Convertor = /** @class */ (function () {\n    function Convertor(schema, toMdConvertors, toHTMLConvertors, eventEmitter) {\n        var _this = this;\n        this.setMappedPos = function (pos) {\n            _this.mappedPosWhenConverting = pos;\n        };\n        this.schema = schema;\n        this.eventEmitter = eventEmitter;\n        this.focusedNode = null;\n        this.mappedPosWhenConverting = null;\n        this.toWwConvertors = createWwConvertors(toHTMLConvertors);\n        this.toMdConvertors = createMdConvertors(toMdConvertors || {});\n        this.eventEmitter.listen('setFocusedNode', function (node) { return (_this.focusedNode = node); });\n    }\n    Convertor.prototype.getMappedPos = function () {\n        return this.mappedPosWhenConverting;\n    };\n    Convertor.prototype.getInfoForPosSync = function () {\n        return { node: this.focusedNode, setMappedPos: this.setMappedPos };\n    };\n    Convertor.prototype.toWysiwygModel = function (mdNode) {\n        var state = new ToWwConvertorState(this.schema, this.toWwConvertors);\n        return state.convertNode(mdNode, this.getInfoForPosSync());\n    };\n    Convertor.prototype.toMarkdownText = function (wwNode) {\n        var state = new ToMdConvertorState(this.toMdConvertors);\n        var markdownText = state.convertNode(wwNode, this.getInfoForPosSync());\n        markdownText = this.eventEmitter.emitReduce('beforeConvertWysiwygToMarkdown', markdownText);\n        return markdownText;\n    };\n    return Convertor;\n}());\n\nfunction execPlugin(pluginInfo) {\n    var plugin = pluginInfo.plugin, eventEmitter = pluginInfo.eventEmitter, usageStatistics = pluginInfo.usageStatistics, instance = pluginInfo.instance;\n    var pmState = { Plugin: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin, PluginKey: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey, Selection: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection, TextSelection: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection };\n    var pmView = { Decoration: prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration, DecorationSet: prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.DecorationSet };\n    var pmModel = { Fragment: prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment };\n    var pmRules = { InputRule: prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.InputRule, inputRules: prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.inputRules, undoInputRule: prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.undoInputRule };\n    var pmKeymap = { keymap: prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap };\n    var context = {\n        eventEmitter: eventEmitter,\n        usageStatistics: usageStatistics,\n        instance: instance,\n        pmState: pmState,\n        pmView: pmView,\n        pmModel: pmModel,\n        pmRules: pmRules,\n        pmKeymap: pmKeymap,\n        i18n: i18n,\n    };\n    if (isArray_1(plugin)) {\n        var pluginFn = plugin[0], _a = plugin[1], options = _a === void 0 ? {} : _a;\n        return pluginFn(context, options);\n    }\n    return plugin(context);\n}\nfunction getPluginInfo(pluginsInfo) {\n    var plugins = pluginsInfo.plugins, eventEmitter = pluginsInfo.eventEmitter, usageStatistics = pluginsInfo.usageStatistics, instance = pluginsInfo.instance;\n    eventEmitter.listen('mixinTableOffsetMapPrototype', mixinTableOffsetMapPrototype);\n    return (plugins !== null && plugins !== void 0 ? plugins : []).reduce(function (acc, plugin) {\n        var pluginInfoResult = execPlugin({\n            plugin: plugin,\n            eventEmitter: eventEmitter,\n            usageStatistics: usageStatistics,\n            instance: instance,\n        });\n        if (!pluginInfoResult) {\n            throw new Error('The return value of the executed plugin is empty.');\n        }\n        var markdownParsers = pluginInfoResult.markdownParsers, toHTMLRenderers = pluginInfoResult.toHTMLRenderers, toMarkdownRenderers = pluginInfoResult.toMarkdownRenderers, markdownPlugins = pluginInfoResult.markdownPlugins, wysiwygPlugins = pluginInfoResult.wysiwygPlugins, wysiwygNodeViews = pluginInfoResult.wysiwygNodeViews, markdownCommands = pluginInfoResult.markdownCommands, wysiwygCommands = pluginInfoResult.wysiwygCommands, toolbarItems = pluginInfoResult.toolbarItems;\n        if (toHTMLRenderers) {\n            acc.toHTMLRenderers = deepMergedCopy(acc.toHTMLRenderers, toHTMLRenderers);\n        }\n        if (toMarkdownRenderers) {\n            acc.toMarkdownRenderers = deepMergedCopy(acc.toMarkdownRenderers, toMarkdownRenderers);\n        }\n        if (markdownPlugins) {\n            acc.mdPlugins = acc.mdPlugins.concat(markdownPlugins);\n        }\n        if (wysiwygPlugins) {\n            acc.wwPlugins = acc.wwPlugins.concat(wysiwygPlugins);\n        }\n        if (wysiwygNodeViews) {\n            acc.wwNodeViews = __assign$1(__assign$1({}, acc.wwNodeViews), wysiwygNodeViews);\n        }\n        if (markdownCommands) {\n            acc.mdCommands = __assign$1(__assign$1({}, acc.mdCommands), markdownCommands);\n        }\n        if (wysiwygCommands) {\n            acc.wwCommands = __assign$1(__assign$1({}, acc.wwCommands), wysiwygCommands);\n        }\n        if (toolbarItems) {\n            acc.toolbarItems = acc.toolbarItems.concat(toolbarItems);\n        }\n        if (markdownParsers) {\n            acc.markdownParsers = __assign$1(__assign$1({}, acc.markdownParsers), markdownParsers);\n        }\n        return acc;\n    }, {\n        toHTMLRenderers: {},\n        toMarkdownRenderers: {},\n        mdPlugins: [],\n        wwPlugins: [],\n        wwNodeViews: {},\n        mdCommands: {},\n        wwCommands: {},\n        toolbarItems: [],\n        markdownParsers: {},\n    });\n}\n\nvar TASK_ATTR_NAME = 'data-task';\nvar DISABLED_TASK_ATTR_NAME = 'data-task-disabled';\nvar TASK_CHECKED_CLASS_NAME = 'checked';\nfunction registerHTMLTagToWhitelist(convertorMap) {\n    ['htmlBlock', 'htmlInline'].forEach(function (htmlType) {\n        if (convertorMap[htmlType]) {\n            // register tag white list for preventing to remove the html in sanitizer\n            Object.keys(convertorMap[htmlType]).forEach(function (type) { return registerTagWhitelistIfPossible(type); });\n        }\n    });\n}\n/**\n * Class ToastUIEditorViewer\n * @param {object} options Option object\n *     @param {HTMLElement} options.el - container element\n *     @param {string} [options.initialValue] Editor's initial value\n *     @param {Object} [options.events] - Events\n *         @param {function} [options.events.load] - It would be emitted when editor fully load\n *         @param {function} [options.events.change] - It would be emitted when content changed\n *         @param {function} [options.events.caretChange] - It would be emitted when format change by cursor position\n *         @param {function} [options.events.focus] - It would be emitted when editor get focus\n *         @param {function} [options.events.blur] - It would be emitted when editor loose focus\n *     @param {Array.<function|Array>} [options.plugins] - Array of plugins. A plugin can be either a function or an array in the form of [function, options].\n *     @param {Object} [options.extendedAutolinks] - Using extended Autolinks specified in GFM spec\n *     @param {Object} [options.linkAttributes] - Attributes of anchor element that should be rel, target, hreflang, type\n *     @param {Object} [options.customHTMLRenderer=null] - Object containing custom renderer functions correspond to change markdown node to preview HTML or wysiwyg node\n *     @param {boolean} [options.referenceDefinition=false] - whether use the specification of link reference definition\n *     @param {function} [options.customHTMLSanitizer=null] - custom HTML sanitizer\n *     @param {boolean} [options.frontMatter=false] - whether use the front matter\n *     @param {string} [options.theme] - The theme to style the viewer with. The default is included in toastui-editor.css.\n */\nvar ToastUIEditorViewer = /** @class */ (function () {\n    function ToastUIEditorViewer(options) {\n        var _this = this;\n        this.options = extend_1({\n            linkAttributes: null,\n            extendedAutolinks: false,\n            customHTMLRenderer: null,\n            referenceDefinition: false,\n            customHTMLSanitizer: null,\n            frontMatter: false,\n            usageStatistics: true,\n            theme: 'light',\n        }, options);\n        this.eventEmitter = new EventEmitter();\n        var linkAttributes = sanitizeLinkAttribute(this.options.linkAttributes);\n        var _a = getPluginInfo({\n            plugins: this.options.plugins,\n            eventEmitter: this.eventEmitter,\n            usageStatistics: this.options.usageStatistics,\n            instance: this,\n        }) || {}, toHTMLRenderers = _a.toHTMLRenderers, markdownParsers = _a.markdownParsers;\n        var _b = this.options, customHTMLRenderer = _b.customHTMLRenderer, extendedAutolinks = _b.extendedAutolinks, referenceDefinition = _b.referenceDefinition, frontMatter = _b.frontMatter, customHTMLSanitizer = _b.customHTMLSanitizer;\n        var rendererOptions = {\n            linkAttributes: linkAttributes,\n            customHTMLRenderer: __assign$1(__assign$1({}, toHTMLRenderers), customHTMLRenderer),\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            frontMatter: frontMatter,\n            sanitizer: customHTMLSanitizer || sanitizeHTML,\n        };\n        registerHTMLTagToWhitelist(rendererOptions.customHTMLRenderer);\n        if (this.options.events) {\n            forEachOwnProperties_1(this.options.events, function (fn, key) {\n                _this.on(key, fn);\n            });\n        }\n        var _c = this.options, el = _c.el, initialValue = _c.initialValue, theme = _c.theme;\n        var existingHTML = el.innerHTML;\n        if (theme !== 'light') {\n            el.classList.add(cls(theme));\n        }\n        el.innerHTML = '';\n        this.toastMark = new ToastMark('', {\n            disallowedHtmlBlockTags: ['br', 'img'],\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            disallowDeepHeading: true,\n            frontMatter: frontMatter,\n            customParser: markdownParsers,\n        });\n        this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, rendererOptions), { isViewer: true }));\n        on_1(this.preview.previewContent, 'mousedown', this.toggleTask.bind(this));\n        if (initialValue) {\n            this.setMarkdown(initialValue);\n        }\n        else if (existingHTML) {\n            this.preview.setHTML(existingHTML);\n        }\n        el.appendChild(this.preview.previewContent);\n        this.eventEmitter.emit('load', this);\n    }\n    /**\n     * Toggle task by detecting mousedown event.\n     * @param {MouseEvent} ev - event\n     * @private\n     */\n    ToastUIEditorViewer.prototype.toggleTask = function (ev) {\n        var element = ev.target;\n        var style = getComputedStyle(element, ':before');\n        if (!element.hasAttribute(DISABLED_TASK_ATTR_NAME) &&\n            element.hasAttribute(TASK_ATTR_NAME) &&\n            isPositionInBox(style, ev.offsetX, ev.offsetY)) {\n            toggleClass(element, TASK_CHECKED_CLASS_NAME);\n            this.eventEmitter.emit('change', {\n                source: 'viewer',\n                date: ev,\n            });\n        }\n    };\n    /**\n     * Set content for preview\n     * @param {string} markdown Markdown text\n     */\n    ToastUIEditorViewer.prototype.setMarkdown = function (markdown) {\n        var lineTexts = this.toastMark.getLineTexts();\n        var length = lineTexts.length;\n        var lastLine = last$1(lineTexts);\n        var endSourcepos = [length, lastLine.length + 1];\n        var editResult = this.toastMark.editMarkdown([1, 1], endSourcepos, markdown || '');\n        this.eventEmitter.emit('updatePreview', editResult);\n    };\n    /**\n     * Bind eventHandler to event type\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorViewer.prototype.on = function (type, handler) {\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Unbind eventHandler from event type\n     * @param {string} type Event type\n     */\n    ToastUIEditorViewer.prototype.off = function (type) {\n        this.eventEmitter.removeEventHandler(type);\n    };\n    /**\n     * Add hook to TUIEditor event\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorViewer.prototype.addHook = function (type, handler) {\n        this.eventEmitter.removeEventHandler(type);\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Remove Viewer preview from document\n     */\n    ToastUIEditorViewer.prototype.destroy = function () {\n        off_1(this.preview.el, 'mousedown', this.toggleTask.bind(this));\n        this.preview.destroy();\n        this.eventEmitter.emit('destroy');\n    };\n    /**\n     * Return true\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isViewer = function () {\n        return true;\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isMarkdownMode = function () {\n        return false;\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isWysiwygMode = function () {\n        return false;\n    };\n    return ToastUIEditorViewer;\n}());\n\nfunction isPmNode(node) {\n    return node instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Node;\n}\nfunction isContainer(type) {\n    var containerTypes = [\n        'document',\n        'blockQuote',\n        'bulletList',\n        'orderedList',\n        'listItem',\n        'paragraph',\n        'heading',\n        'emph',\n        'strong',\n        'strike',\n        'link',\n        'image',\n        'table',\n        'tableHead',\n        'tableBody',\n        'tableRow',\n        'tableHeadCell',\n        'tableBodyCell',\n    ];\n    return includes(containerTypes, type);\n}\nfunction createMdLikeNode(node) {\n    var attrs = node.attrs, type = node.type;\n    var nodeType = type.name;\n    var mdLikeNode = {\n        type: nodeType,\n        wysiwygNode: true,\n        literal: !isContainer(nodeType) && isPmNode(node) ? node.textContent : null,\n    };\n    var nodeTypeMap = {\n        heading: { level: attrs.level },\n        link: { destination: attrs.linkUrl, title: attrs.title },\n        image: { destination: attrs.imageUrl },\n        codeBlock: { info: attrs.language },\n        bulletList: { type: 'list', listData: { type: 'bullet' } },\n        orderedList: { type: 'list', listData: { type: 'ordered', start: attrs.order } },\n        listItem: { type: 'item', listData: { task: attrs.task, checked: attrs.checked } },\n        tableHeadCell: { type: 'tableCell', cellType: 'head', align: attrs.align },\n        tableBodyCell: { type: 'tableCell', cellType: 'body', align: attrs.align },\n        customBlock: { info: attrs.info },\n    };\n    var nodeInfo = nodeTypeMap[nodeType];\n    var attributes = __assign$1(__assign$1({}, mdLikeNode), nodeInfo);\n    // html block, inline node\n    var _a = node.attrs, htmlAttrs = _a.htmlAttrs, childrenHTML = _a.childrenHTML;\n    if (htmlAttrs) {\n        return __assign$1(__assign$1({}, attributes), { attrs: htmlAttrs, childrenHTML: childrenHTML });\n    }\n    return attributes;\n}\n\nvar tokenToDOMNode = {\n    openTag: function (token, stack) {\n        var _a = token, tagName = _a.tagName, classNames = _a.classNames, attributes = _a.attributes;\n        var el = document.createElement(tagName);\n        var attrs = {};\n        if (classNames) {\n            el.className = classNames.join(' ');\n        }\n        if (attributes) {\n            attrs = __assign$1(__assign$1({}, attrs), attributes);\n        }\n        setAttributes(attrs, el);\n        stack.push(el);\n    },\n    closeTag: function (_, stack) {\n        if (stack.length > 1) {\n            var el = stack.pop();\n            last$1(stack).appendChild(el);\n        }\n    },\n    html: function (token, stack) {\n        last$1(stack).insertAdjacentHTML('beforeend', token.content);\n    },\n    text: function (token, stack) {\n        var textNode = document.createTextNode(token.content);\n        last$1(stack).appendChild(textNode);\n    },\n};\nvar WwToDOMAdaptor = /** @class */ (function () {\n    function WwToDOMAdaptor(linkAttributes, customRenderer) {\n        var convertors = getHTMLRenderConvertors(linkAttributes, customRenderer);\n        var customHTMLConvertor = __assign$1(__assign$1({}, customRenderer.htmlBlock), customRenderer.htmlInline);\n        // flatten the html block, inline convertor to other custom convertors\n        this.customConvertorKeys = Object.keys(customRenderer).concat(Object.keys(customHTMLConvertor));\n        this.renderer = new Renderer({\n            gfm: true,\n            convertors: __assign$1(__assign$1({}, convertors), customHTMLConvertor),\n        });\n        this.convertors = this.renderer.getConvertors();\n    }\n    WwToDOMAdaptor.prototype.generateTokens = function (node) {\n        var mdLikeNode = createMdLikeNode(node);\n        var context = {\n            entering: true,\n            leaf: isPmNode(node) ? node.isLeaf : false,\n            options: this.renderer.getOptions(),\n            getChildrenText: function () { return (isPmNode(node) ? node.textContent : ''); },\n            skipChildren: function () { return false; },\n        };\n        var convertor = this.convertors[node.type.name];\n        var converted = convertor(mdLikeNode, context, this.convertors);\n        var tokens = isArray_1(converted) ? converted : [converted];\n        if (isContainer(node.type.name) || node.attrs.htmlInline) {\n            context.entering = false;\n            tokens.push({ type: 'text', content: isPmNode(node) ? node.textContent : '' });\n            tokens = tokens.concat(convertor(mdLikeNode, context, this.convertors));\n        }\n        return tokens;\n    };\n    WwToDOMAdaptor.prototype.toDOMNode = function (node) {\n        var tokens = this.generateTokens(node);\n        var stack = [];\n        tokens.forEach(function (token) { return tokenToDOMNode[token.type](token, stack); });\n        return stack[0];\n    };\n    WwToDOMAdaptor.prototype.getToDOMNode = function (name) {\n        if (includes(this.customConvertorKeys, name)) {\n            return this.toDOMNode.bind(this);\n        }\n        return null;\n    };\n    return WwToDOMAdaptor;\n}());\n\nvar ANIMATION_TIME = 100;\nvar SCROLL_BLOCKING_RESET_DELAY = 15;\nvar currentTimeoutId = null;\nvar releaseTimer = null;\nfunction run(deltaScrollTop, _a) {\n    var syncScrollTop = _a.syncScrollTop, releaseEventBlock = _a.releaseEventBlock;\n    if (releaseTimer) {\n        clearTimeout(releaseTimer);\n    }\n    syncScrollTop(deltaScrollTop);\n    releaseTimer = setTimeout(function () {\n        releaseEventBlock();\n    }, SCROLL_BLOCKING_RESET_DELAY);\n}\nfunction animate(curScrollTop, targetScrollTop, syncCallbacks) {\n    var diff = targetScrollTop - curScrollTop;\n    var startTime = Date.now();\n    var step = function () {\n        var stepTime = Date.now();\n        var progress = (stepTime - startTime) / ANIMATION_TIME;\n        var deltaValue;\n        if (currentTimeoutId) {\n            clearTimeout(currentTimeoutId);\n        }\n        if (progress < 1) {\n            deltaValue = curScrollTop + diff * Math.cos(((1 - progress) * Math.PI) / 2);\n            run(Math.ceil(deltaValue), syncCallbacks);\n            currentTimeoutId = setTimeout(step, 1);\n        }\n        else {\n            run(targetScrollTop, syncCallbacks);\n            currentTimeoutId = null;\n        }\n    };\n    step();\n}\n\nvar EDITOR_BOTTOM_PADDING = 18;\nvar ScrollSync = /** @class */ (function () {\n    function ScrollSync(mdEditor, preview, eventEmitter) {\n        this.latestEditorScrollTop = null;\n        this.latestPreviewScrollTop = null;\n        this.blockedScroll = null;\n        this.active = true;\n        this.timer = null;\n        var previewRoot = preview.previewContent, previewEl = preview.el;\n        this.previewRoot = previewRoot;\n        this.previewEl = previewEl;\n        this.mdEditor = mdEditor;\n        this.editorView = mdEditor.view;\n        this.toastMark = mdEditor.getToastMark();\n        this.eventEmitter = eventEmitter;\n        this.addScrollSyncEvent();\n    }\n    ScrollSync.prototype.addScrollSyncEvent = function () {\n        var _this = this;\n        this.eventEmitter.listen('afterPreviewRender', function () {\n            _this.clearTimer();\n            // Immediately after the 'afterPreviewRender' event has occurred,\n            // browser rendering is not yet complete.\n            // So the size of elements can not be accurately measured.\n            _this.timer = setTimeout(function () {\n                _this.syncPreviewScrollTop(true);\n            }, 200);\n        });\n        this.eventEmitter.listen('scroll', function (type, data) {\n            if (_this.active) {\n                if (type === 'editor' && _this.blockedScroll !== 'editor') {\n                    _this.syncPreviewScrollTop();\n                }\n                else if (type === 'preview' && _this.blockedScroll !== 'preview') {\n                    _this.syncEditorScrollTop(data);\n                }\n            }\n        });\n        this.eventEmitter.listen('toggleScrollSync', function (active) {\n            _this.active = active;\n        });\n    };\n    ScrollSync.prototype.getMdNodeAtPos = function (doc, posInfo) {\n        var indexInfo = doc.content.findIndex(posInfo.pos);\n        var line = indexInfo.index;\n        return this.toastMark.findFirstNodeAtLine(line + 1);\n    };\n    ScrollSync.prototype.getScrollTopByCaretPos = function () {\n        var pos = this.mdEditor.getSelection();\n        var firstMdNode = this.toastMark.findFirstNodeAtLine(pos[0][0]);\n        var previewHeight = this.previewEl.clientHeight;\n        var el = getParentNodeObj(this.previewRoot, firstMdNode).el;\n        var totalOffsetTop = getTotalOffsetTop(el, this.previewRoot) || el.offsetTop;\n        var nodeHeight = el.clientHeight;\n        // multiply 0.5 for calculating the position in the middle of preview area\n        var targetScrollTop = totalOffsetTop + nodeHeight - previewHeight * 0.5;\n        this.latestEditorScrollTop = null;\n        var diff = el.getBoundingClientRect().top - this.previewEl.getBoundingClientRect().top;\n        return diff < previewHeight ? null : targetScrollTop;\n    };\n    ScrollSync.prototype.syncPreviewScrollTop = function (editing) {\n        if (editing === void 0) { editing = false; }\n        var _a = this, editorView = _a.editorView, previewEl = _a.previewEl, previewRoot = _a.previewRoot;\n        var _b = editorView.dom.getBoundingClientRect(), left = _b.left, top = _b.top;\n        var posInfo = editorView.posAtCoords({ left: left, top: top });\n        var doc = editorView.state.doc;\n        var firstMdNode = this.getMdNodeAtPos(doc, posInfo);\n        if (!firstMdNode || isHTMLNode(firstMdNode)) {\n            return;\n        }\n        var curScrollTop = previewEl.scrollTop;\n        var _c = editorView.dom, scrollTop = _c.scrollTop, scrollHeight = _c.scrollHeight, clientHeight = _c.clientHeight, children = _c.children;\n        var isBottomPos = scrollHeight - scrollTop <= clientHeight + EDITOR_BOTTOM_PADDING;\n        var targetScrollTop = isBottomPos ? previewEl.scrollHeight : 0;\n        if (scrollTop && !isBottomPos) {\n            if (editing) {\n                var scrollTopByEditing = this.getScrollTopByCaretPos();\n                if (!scrollTopByEditing) {\n                    return;\n                }\n                targetScrollTop = scrollTopByEditing;\n            }\n            else {\n                var _d = getParentNodeObj(this.previewRoot, firstMdNode), el = _d.el, mdNode = _d.mdNode;\n                var _e = getEditorRangeHeightInfo(doc, mdNode, children), height = _e.height, rect = _e.rect;\n                var totalOffsetTop = getTotalOffsetTop(el, previewRoot) || el.offsetTop;\n                var nodeHeight = el.clientHeight;\n                var ratio = top > rect.top ? Math.min((top - rect.top) / height, 1) : 0;\n                targetScrollTop = totalOffsetTop + nodeHeight * ratio;\n            }\n            targetScrollTop = this.getResolvedScrollTop('editor', scrollTop, targetScrollTop, curScrollTop);\n            this.latestEditorScrollTop = scrollTop;\n        }\n        if (targetScrollTop !== curScrollTop) {\n            this.run('editor', targetScrollTop, curScrollTop);\n        }\n    };\n    ScrollSync.prototype.syncEditorScrollTop = function (targetNode) {\n        var _a = this, toastMark = _a.toastMark, editorView = _a.editorView, previewRoot = _a.previewRoot, previewEl = _a.previewEl;\n        var dom = editorView.dom, state = editorView.state;\n        var scrollTop = previewEl.scrollTop, clientHeight = previewEl.clientHeight, scrollHeight = previewEl.scrollHeight;\n        var isBottomPos = scrollHeight - scrollTop <= clientHeight;\n        var curScrollTop = dom.scrollTop;\n        var targetScrollTop = isBottomPos ? dom.scrollHeight : 0;\n        if (scrollTop && targetNode && !isBottomPos) {\n            targetNode = findAncestorHavingId(targetNode, previewRoot);\n            if (!targetNode.getAttribute('data-nodeid')) {\n                return;\n            }\n            var children = dom.children;\n            var mdNodeId = Number(targetNode.getAttribute('data-nodeid'));\n            var _b = getParentNodeObj(this.previewRoot, toastMark.findNodeById(mdNodeId)), mdNode = _b.mdNode, el = _b.el;\n            var mdNodeStartLine = getMdStartLine(mdNode);\n            targetScrollTop = children[mdNodeStartLine - 1].offsetTop;\n            var height = getEditorRangeHeightInfo(state.doc, mdNode, children).height;\n            var _c = getAndSaveOffsetInfo(el, previewRoot, mdNodeId), nodeHeight = _c.nodeHeight, offsetTop = _c.offsetTop;\n            targetScrollTop += getAdditionalPos(scrollTop, offsetTop, nodeHeight, height);\n            targetScrollTop = this.getResolvedScrollTop('preview', scrollTop, targetScrollTop, curScrollTop);\n            this.latestPreviewScrollTop = scrollTop;\n        }\n        if (targetScrollTop !== curScrollTop) {\n            this.run('preview', targetScrollTop, curScrollTop);\n        }\n    };\n    ScrollSync.prototype.getResolvedScrollTop = function (from, scrollTop, targetScrollTop, curScrollTop) {\n        var latestScrollTop = from === 'editor' ? this.latestEditorScrollTop : this.latestPreviewScrollTop;\n        if (latestScrollTop === null) {\n            return targetScrollTop;\n        }\n        return latestScrollTop < scrollTop\n            ? Math.max(targetScrollTop, curScrollTop)\n            : Math.min(targetScrollTop, curScrollTop);\n    };\n    ScrollSync.prototype.run = function (from, targetScrollTop, curScrollTop) {\n        var _this = this;\n        var scrollTarget;\n        if (from === 'editor') {\n            scrollTarget = this.previewEl;\n            this.blockedScroll = 'preview';\n        }\n        else {\n            scrollTarget = this.editorView.dom;\n            this.blockedScroll = 'editor';\n        }\n        var syncCallbacks = {\n            syncScrollTop: function (scrollTop) { return (scrollTarget.scrollTop = scrollTop); },\n            releaseEventBlock: function () { return (_this.blockedScroll = null); },\n        };\n        animate(curScrollTop, targetScrollTop, syncCallbacks);\n    };\n    ScrollSync.prototype.clearTimer = function () {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n    ScrollSync.prototype.destroy = function () {\n        this.clearTimer();\n        this.eventEmitter.removeEventHandler('scroll');\n        this.eventEmitter.removeEventHandler('afterPreviewRender');\n    };\n    return ScrollSync;\n}());\n\nvar queryMap = {\n    getPopupInitialValues: function (editor, payload) {\n        var popupName = payload.popupName;\n        return popupName === 'link' ? { linkText: editor.getSelectedText() } : {};\n    },\n};\nfunction buildQuery(editor) {\n    editor.eventEmitter.listen('query', function (query, payload) {\n        return queryMap[query](editor, payload);\n    });\n}\n\n/**\n * ToastUIEditorCore\n * @param {Object} options Option object\n *     @param {HTMLElement} options.el - container element\n *     @param {string} [options.height='300px'] - Editor's height style value. Height is applied as border-box ex) '300px', '100%', 'auto'\n *     @param {string} [options.minHeight='200px'] - Editor's min-height style value in pixel ex) '300px'\n *     @param {string} [options.initialValue] - Editor's initial value\n *     @param {string} [options.previewStyle] - Markdown editor's preview style (tab, vertical)\n *     @param {boolean} [options.previewHighlight = true] - Highlight a preview element corresponds to the cursor position in the markdown editor\n *     @param {string} [options.initialEditType] - Initial editor type (markdown, wysiwyg)\n *     @param {Object} [options.events] - Events\n *         @param {function} [options.events.load] - It would be emitted when editor fully load\n *         @param {function} [options.events.change] - It would be emitted when content changed\n *         @param {function} [options.events.caretChange] - It would be emitted when format change by cursor position\n *         @param {function} [options.events.focus] - It would be emitted when editor get focus\n *         @param {function} [options.events.blur] - It would be emitted when editor loose focus\n *         @param {function} [options.events.keydown] - It would be emitted when the key is pressed in editor\n *         @param {function} [options.events.keyup] - It would be emitted when the key is released in editor\n *         @param {function} [options.events.beforePreviewRender] - It would be emitted before rendering the markdown preview with html string\n *         @param {function} [options.events.beforeConvertWysiwygToMarkdown] - It would be emitted before converting wysiwyg to markdown with markdown text\n *     @param {Object} [options.hooks] - Hooks\n *         @param {addImageBlobHook} [options.hooks.addImageBlobHook] - hook for image upload\n *     @param {string} [options.language='en-US'] - language\n *     @param {boolean} [options.useCommandShortcut=true] - whether use keyboard shortcuts to perform commands\n *     @param {boolean} [options.usageStatistics=true] - send hostname to google analytics\n *     @param {Array.<string|toolbarItemsValue>} [options.toolbarItems] - toolbar items.\n *     @param {boolean} [options.hideModeSwitch=false] - hide mode switch tab bar\n *     @param {Array.<function|Array>} [options.plugins] - Array of plugins. A plugin can be either a function or an array in the form of [function, options].\n *     @param {Object} [options.extendedAutolinks] - Using extended Autolinks specified in GFM spec\n *     @param {string} [options.placeholder] - The placeholder text of the editable element.\n *     @param {Object} [options.linkAttributes] - Attributes of anchor element that should be rel, target, hreflang, type\n *     @param {Object} [options.customHTMLRenderer=null] - Object containing custom renderer functions correspond to change markdown node to preview HTML or wysiwyg node\n *     @param {Object} [options.customMarkdownRenderer=null] - Object containing custom renderer functions correspond to change wysiwyg node to markdown text\n *     @param {boolean} [options.referenceDefinition=false] - whether use the specification of link reference definition\n *     @param {function} [options.customHTMLSanitizer=null] - custom HTML sanitizer\n *     @param {boolean} [options.previewHighlight=false] - whether highlight preview area\n *     @param {boolean} [options.frontMatter=false] - whether use the front matter\n *     @param {Array.<object>} [options.widgetRules=[]] - The rules for replacing the text with widget node\n *     @param {string} [options.theme] - The theme to style the editor with. The default is included in toastui-editor.css.\n *     @param {autofocus} [options.autofocus=true] - automatically focus the editor on creation.\n */\nvar ToastUIEditorCore = /** @class */ (function () {\n    function ToastUIEditorCore(options) {\n        var _this = this;\n        this.initialHTML = options.el.innerHTML;\n        options.el.innerHTML = '';\n        this.options = extend_1({\n            previewStyle: 'tab',\n            previewHighlight: true,\n            initialEditType: 'markdown',\n            height: '300px',\n            minHeight: '200px',\n            language: 'en-US',\n            useCommandShortcut: true,\n            usageStatistics: true,\n            toolbarItems: [\n                ['heading', 'bold', 'italic', 'strike'],\n                ['hr', 'quote'],\n                ['ul', 'ol', 'task', 'indent', 'outdent'],\n                ['table', 'image', 'link'],\n                ['code', 'codeblock'],\n                ['scrollSync'],\n            ],\n            hideModeSwitch: false,\n            linkAttributes: null,\n            extendedAutolinks: false,\n            customHTMLRenderer: null,\n            customMarkdownRenderer: null,\n            referenceDefinition: false,\n            customHTMLSanitizer: null,\n            frontMatter: false,\n            widgetRules: [],\n            theme: 'light',\n            autofocus: true,\n        }, options);\n        var _a = this.options, customHTMLRenderer = _a.customHTMLRenderer, extendedAutolinks = _a.extendedAutolinks, referenceDefinition = _a.referenceDefinition, frontMatter = _a.frontMatter, customMarkdownRenderer = _a.customMarkdownRenderer, useCommandShortcut = _a.useCommandShortcut, initialEditType = _a.initialEditType, widgetRules = _a.widgetRules, customHTMLSanitizer = _a.customHTMLSanitizer;\n        this.mode = initialEditType || 'markdown';\n        this.mdPreviewStyle = this.options.previewStyle;\n        this.i18n = i18n;\n        this.i18n.setCode(this.options.language);\n        this.eventEmitter = new EventEmitter();\n        setWidgetRules(widgetRules);\n        var linkAttributes = sanitizeLinkAttribute(this.options.linkAttributes);\n        this.pluginInfo = getPluginInfo({\n            plugins: this.options.plugins,\n            eventEmitter: this.eventEmitter,\n            usageStatistics: this.options.usageStatistics,\n            instance: this,\n        });\n        var _b = this.pluginInfo, toHTMLRenderers = _b.toHTMLRenderers, toMarkdownRenderers = _b.toMarkdownRenderers, mdPlugins = _b.mdPlugins, wwPlugins = _b.wwPlugins, wwNodeViews = _b.wwNodeViews, mdCommands = _b.mdCommands, wwCommands = _b.wwCommands, markdownParsers = _b.markdownParsers;\n        var rendererOptions = {\n            linkAttributes: linkAttributes,\n            customHTMLRenderer: deepMergedCopy(toHTMLRenderers, customHTMLRenderer),\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            frontMatter: frontMatter,\n            sanitizer: customHTMLSanitizer || sanitizeHTML,\n        };\n        var wwToDOMAdaptor = new WwToDOMAdaptor(linkAttributes, rendererOptions.customHTMLRenderer);\n        var htmlSchemaMap = createHTMLSchemaMap(rendererOptions.customHTMLRenderer, rendererOptions.sanitizer, wwToDOMAdaptor);\n        this.toastMark = new ToastMark('', {\n            disallowedHtmlBlockTags: ['br', 'img'],\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            disallowDeepHeading: true,\n            frontMatter: frontMatter,\n            customParser: markdownParsers,\n        });\n        this.mdEditor = new MdEditor(this.eventEmitter, {\n            toastMark: this.toastMark,\n            useCommandShortcut: useCommandShortcut,\n            mdPlugins: mdPlugins,\n        });\n        this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, rendererOptions), { isViewer: false, highlight: this.options.previewHighlight }));\n        this.wwEditor = new WysiwygEditor(this.eventEmitter, {\n            toDOMAdaptor: wwToDOMAdaptor,\n            useCommandShortcut: useCommandShortcut,\n            htmlSchemaMap: htmlSchemaMap,\n            linkAttributes: linkAttributes,\n            wwPlugins: wwPlugins,\n            wwNodeViews: wwNodeViews,\n        });\n        this.convertor = new Convertor(this.wwEditor.getSchema(), __assign$1(__assign$1({}, toMarkdownRenderers), customMarkdownRenderer), getHTMLRenderConvertors(linkAttributes, rendererOptions.customHTMLRenderer), this.eventEmitter);\n        this.setMinHeight(this.options.minHeight);\n        this.setHeight(this.options.height);\n        this.setMarkdown(this.options.initialValue, false);\n        if (this.options.placeholder) {\n            this.setPlaceholder(this.options.placeholder);\n        }\n        if (!this.options.initialValue) {\n            this.setHTML(this.initialHTML, false);\n        }\n        this.commandManager = new CommandManager(this.eventEmitter, this.mdEditor.commands, this.wwEditor.commands, function () { return _this.mode; });\n        if (this.options.usageStatistics) {\n            sendHostName();\n        }\n        this.scrollSync = new ScrollSync(this.mdEditor, this.preview, this.eventEmitter);\n        this.addInitEvent();\n        this.addInitCommand(mdCommands, wwCommands);\n        buildQuery(this);\n        if (this.options.hooks) {\n            forEachOwnProperties_1(this.options.hooks, function (fn, key) { return _this.addHook(key, fn); });\n        }\n        if (this.options.events) {\n            forEachOwnProperties_1(this.options.events, function (fn, key) { return _this.on(key, fn); });\n        }\n        this.eventEmitter.emit('load', this);\n        this.moveCursorToStart(this.options.autofocus);\n    }\n    ToastUIEditorCore.prototype.addInitEvent = function () {\n        var _this = this;\n        this.on('needChangeMode', this.changeMode.bind(this));\n        this.on('loadUI', function () {\n            if (_this.height !== 'auto') {\n                // 75px equals default editor ui height - the editing area height\n                var minHeight = Math.min(parseInt(_this.minHeight, 10), parseInt(_this.height, 10) - 75) + \"px\";\n                _this.setMinHeight(minHeight);\n            }\n        });\n        addDefaultImageBlobHook(this.eventEmitter);\n    };\n    ToastUIEditorCore.prototype.addInitCommand = function (mdCommands, wwCommands) {\n        var _this = this;\n        var addPluginCommands = function (type, commandMap) {\n            Object.keys(commandMap).forEach(function (name) {\n                _this.addCommand(type, name, commandMap[name]);\n            });\n        };\n        this.addCommand('markdown', 'toggleScrollSync', function (payload) {\n            _this.eventEmitter.emit('toggleScrollSync', payload.active);\n            return true;\n        });\n        addPluginCommands('markdown', mdCommands);\n        addPluginCommands('wysiwyg', wwCommands);\n    };\n    ToastUIEditorCore.prototype.getCurrentModeEditor = function () {\n        return (this.isMarkdownMode() ? this.mdEditor : this.wwEditor);\n    };\n    /**\n     * Factory method for Editor\n     * @param {object} options Option for initialize TUIEditor\n     * @returns {object} ToastUIEditorCore or ToastUIEditorViewer\n     */\n    ToastUIEditorCore.factory = function (options) {\n        return options.viewer ? new ToastUIEditorViewer(options) : new ToastUIEditorCore(options);\n    };\n    /**\n     * Set language\n     * @param {string|string[]} code - code for I18N language\n     * @param {object} data - language set\n     */\n    ToastUIEditorCore.setLanguage = function (code, data) {\n        i18n.setLanguage(code, data);\n    };\n    /**\n     * change preview style\n     * @param {string} style - 'tab'|'vertical'\n     */\n    ToastUIEditorCore.prototype.changePreviewStyle = function (style) {\n        if (this.mdPreviewStyle !== style) {\n            this.mdPreviewStyle = style;\n            this.eventEmitter.emit('changePreviewStyle', style);\n        }\n    };\n    /**\n     * execute editor command\n     * @param {string} name - command name\n     * @param {object} [payload] - payload for command\n     */\n    ToastUIEditorCore.prototype.exec = function (name, payload) {\n        this.commandManager.exec(name, payload);\n    };\n    /**\n     * @param {string} type - editor type\n     * @param {string} name - command name\n     * @param {function} command - command handler\n     */\n    ToastUIEditorCore.prototype.addCommand = function (type, name, command) {\n        var _this = this;\n        var commandHoc = function (paylaod) {\n            if (paylaod === void 0) { paylaod = {}; }\n            var view = (type === 'markdown' ? _this.mdEditor : _this.wwEditor).view;\n            command(paylaod, view.state, view.dispatch, view);\n        };\n        this.commandManager.addCommand(type, name, commandHoc);\n    };\n    /**\n     * Bind eventHandler to event type\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorCore.prototype.on = function (type, handler) {\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Unbind eventHandler from event type\n     * @param {string} type Event type\n     */\n    ToastUIEditorCore.prototype.off = function (type) {\n        this.eventEmitter.removeEventHandler(type);\n    };\n    /**\n     * Add hook to TUIEditor event\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorCore.prototype.addHook = function (type, handler) {\n        this.eventEmitter.removeEventHandler(type);\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Remove hook from TUIEditor event\n     * @param {string} type Event type\n     */\n    ToastUIEditorCore.prototype.removeHook = function (type) {\n        this.eventEmitter.removeEventHandler(type);\n    };\n    /**\n     * Set focus to current Editor\n     */\n    ToastUIEditorCore.prototype.focus = function () {\n        this.getCurrentModeEditor().focus();\n    };\n    /**\n     * Remove focus of current Editor\n     */\n    ToastUIEditorCore.prototype.blur = function () {\n        this.getCurrentModeEditor().blur();\n    };\n    /**\n     * Set cursor position to end\n     * @param {boolean} [focus] - automatically focus the editor\n     */\n    ToastUIEditorCore.prototype.moveCursorToEnd = function (focus) {\n        if (focus === void 0) { focus = true; }\n        this.getCurrentModeEditor().moveCursorToEnd(focus);\n    };\n    /**\n     * Set cursor position to start\n     * @param {boolean} [focus] - automatically focus the editor\n     */\n    ToastUIEditorCore.prototype.moveCursorToStart = function (focus) {\n        if (focus === void 0) { focus = true; }\n        this.getCurrentModeEditor().moveCursorToStart(focus);\n    };\n    /**\n     * Set markdown syntax text.\n     * @param {string} markdown - markdown syntax text.\n     * @param {boolean} [cursorToEnd=true] - move cursor to contents end\n     */\n    ToastUIEditorCore.prototype.setMarkdown = function (markdown, cursorToEnd) {\n        if (markdown === void 0) { markdown = ''; }\n        if (cursorToEnd === void 0) { cursorToEnd = true; }\n        this.mdEditor.setMarkdown(markdown, cursorToEnd);\n        if (this.isWysiwygMode()) {\n            var mdNode = this.toastMark.getRootNode();\n            var wwNode = this.convertor.toWysiwygModel(mdNode);\n            this.wwEditor.setModel(wwNode, cursorToEnd);\n        }\n    };\n    /**\n     * Set html value.\n     * @param {string} html - html syntax text\n     * @param {boolean} [cursorToEnd=true] - move cursor to contents end\n     */\n    ToastUIEditorCore.prototype.setHTML = function (html, cursorToEnd) {\n        if (html === void 0) { html = ''; }\n        if (cursorToEnd === void 0) { cursorToEnd = true; }\n        var container = document.createElement('div');\n        // the `br` tag should be replaced with empty block to separate between blocks\n        container.innerHTML = replaceBRWithEmptyBlock(html);\n        var wwNode = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMParser.fromSchema(this.wwEditor.schema).parse(container);\n        if (this.isMarkdownMode()) {\n            this.mdEditor.setMarkdown(this.convertor.toMarkdownText(wwNode), cursorToEnd);\n        }\n        else {\n            this.wwEditor.setModel(wwNode, cursorToEnd);\n        }\n    };\n    /**\n     * Get content to markdown\n     * @returns {string} markdown text\n     */\n    ToastUIEditorCore.prototype.getMarkdown = function () {\n        if (this.isMarkdownMode()) {\n            return this.mdEditor.getMarkdown();\n        }\n        return this.convertor.toMarkdownText(this.wwEditor.getModel());\n    };\n    /**\n     * Get content to html\n     * @returns {string} html string\n     */\n    ToastUIEditorCore.prototype.getHTML = function () {\n        var _this = this;\n        this.eventEmitter.holdEventInvoke(function () {\n            if (_this.isMarkdownMode()) {\n                var mdNode = _this.toastMark.getRootNode();\n                var wwNode = _this.convertor.toWysiwygModel(mdNode);\n                _this.wwEditor.setModel(wwNode);\n            }\n        });\n        var html = removeProseMirrorHackNodes(this.wwEditor.view.dom.innerHTML);\n        if (this.placeholder) {\n            var rePlaceholder = new RegExp(\"<span class=\\\"placeholder[^>]+>\" + this.placeholder + \"</span>\", 'i');\n            return html.replace(rePlaceholder, '');\n        }\n        return html;\n    };\n    /**\n     * Insert text\n     * @param {string} text - text content\n     */\n    ToastUIEditorCore.prototype.insertText = function (text) {\n        this.getCurrentModeEditor().replaceSelection(text);\n    };\n    /**\n     * Set selection range\n     * @param {number|Array.<number>} start - start position\n     * @param {number|Array.<number>} end - end position\n     */\n    ToastUIEditorCore.prototype.setSelection = function (start, end) {\n        this.getCurrentModeEditor().setSelection(start, end);\n    };\n    /**\n     * Replace selection range with given text content\n     * @param {string} text - text content\n     * @param {number|Array.<number>} [start] - start position\n     * @param {number|Array.<number>} [end] - end position\n     */\n    ToastUIEditorCore.prototype.replaceSelection = function (text, start, end) {\n        this.getCurrentModeEditor().replaceSelection(text, start, end);\n    };\n    /**\n     * Delete the content of selection range\n     * @param {number|Array.<number>} [start] - start position\n     * @param {number|Array.<number>} [end] - end position\n     */\n    ToastUIEditorCore.prototype.deleteSelection = function (start, end) {\n        this.getCurrentModeEditor().deleteSelection(start, end);\n    };\n    /**\n     * Get selected text content\n     * @param {number|Array.<number>} [start] - start position\n     * @param {number|Array.<number>} [end] - end position\n     * @returns {string} - selected text content\n     */\n    ToastUIEditorCore.prototype.getSelectedText = function (start, end) {\n        return this.getCurrentModeEditor().getSelectedText(start, end);\n    };\n    /**\n     * Get range of the node\n     * @param {number|Array.<number>} [pos] - position\n     * @returns {Array.<number[]>|Array.<number>} - node [start, end] range\n     * @example\n     * // Markdown mode\n     * const rangeInfo = editor.getRangeInfoOfNode();\n     *\n     * console.log(rangeInfo); // { range: [[startLineOffset, startCurorOffset], [endLineOffset, endCurorOffset]], type: 'emph' }\n     *\n     * // WYSIWYG mode\n     * const rangeInfo = editor.getRangeInfoOfNode();\n     *\n     * console.log(rangeInfo); // { range: [startCursorOffset, endCursorOffset], type: 'emph' }\n     */\n    ToastUIEditorCore.prototype.getRangeInfoOfNode = function (pos) {\n        return this.getCurrentModeEditor().getRangeInfoOfNode(pos);\n    };\n    /**\n     * Add widget to selection\n     * @param {Node} node - widget node\n     * @param {string} style - Adding style \"top\" or \"bottom\"\n     * @param {number|Array.<number>} [pos] - position\n     */\n    ToastUIEditorCore.prototype.addWidget = function (node, style, pos) {\n        this.getCurrentModeEditor().addWidget(node, style, pos);\n    };\n    /**\n     * Replace node with widget to range\n     * @param {number|Array.<number>} start - start position\n     * @param {number|Array.<number>} end - end position\n     * @param {string} text - widget text content\n     */\n    ToastUIEditorCore.prototype.replaceWithWidget = function (start, end, text) {\n        this.getCurrentModeEditor().replaceWithWidget(start, end, text);\n    };\n    /**\n     * Set editor height\n     * @param {string} height - editor height in pixel\n     */\n    ToastUIEditorCore.prototype.setHeight = function (height) {\n        var el = this.options.el;\n        if (isString_1(height)) {\n            if (height === 'auto') {\n                addClass_1(el, 'auto-height');\n            }\n            else {\n                removeClass_1(el, 'auto-height');\n            }\n            this.setMinHeight(this.getMinHeight());\n        }\n        css_1(el, { height: height });\n        this.height = height;\n    };\n    /**\n     * Get editor height\n     * @returns {string} editor height in pixel\n     */\n    ToastUIEditorCore.prototype.getHeight = function () {\n        return this.height;\n    };\n    /**\n     * Set minimum height to editor content\n     * @param {string} minHeight - min content height in pixel\n     */\n    ToastUIEditorCore.prototype.setMinHeight = function (minHeight) {\n        if (minHeight !== this.minHeight) {\n            var height = this.height || this.options.height;\n            if (height !== 'auto' && this.options.el.querySelector(\".\" + cls('main'))) {\n                // 75px equals default editor ui height - the editing area height\n                minHeight = Math.min(parseInt(minHeight, 10), parseInt(height, 10) - 75) + \"px\";\n            }\n            var minHeightNum = parseInt(minHeight, 10);\n            this.minHeight = minHeight;\n            this.wwEditor.setMinHeight(minHeightNum);\n            this.mdEditor.setMinHeight(minHeightNum);\n            this.preview.setMinHeight(minHeightNum);\n        }\n    };\n    /**\n     * Get minimum height of editor content\n     * @returns {string} min height in pixel\n     */\n    ToastUIEditorCore.prototype.getMinHeight = function () {\n        return this.minHeight;\n    };\n    /**\n     * Return true if current editor mode is Markdown\n     * @returns {boolean}\n     */\n    ToastUIEditorCore.prototype.isMarkdownMode = function () {\n        return this.mode === 'markdown';\n    };\n    /**\n     * Return true if current editor mode is WYSIWYG\n     * @returns {boolean}\n     */\n    ToastUIEditorCore.prototype.isWysiwygMode = function () {\n        return this.mode === 'wysiwyg';\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorCore.prototype.isViewer = function () {\n        return false;\n    };\n    /**\n     * Get current Markdown editor's preview style\n     * @returns {string}\n     */\n    ToastUIEditorCore.prototype.getCurrentPreviewStyle = function () {\n        return this.mdPreviewStyle;\n    };\n    /**\n     * Change editor's mode to given mode string\n     * @param {string} mode - Editor mode name of want to change\n     * @param {boolean} [withoutFocus] - Change mode without focus\n     */\n    ToastUIEditorCore.prototype.changeMode = function (mode, withoutFocus) {\n        if (this.mode === mode) {\n            return;\n        }\n        this.mode = mode;\n        if (this.isWysiwygMode()) {\n            var mdNode = this.toastMark.getRootNode();\n            var wwNode = this.convertor.toWysiwygModel(mdNode);\n            this.wwEditor.setModel(wwNode);\n        }\n        else {\n            var wwNode = this.wwEditor.getModel();\n            this.mdEditor.setMarkdown(this.convertor.toMarkdownText(wwNode), !withoutFocus);\n        }\n        this.eventEmitter.emit('removePopupWidget');\n        this.eventEmitter.emit('changeMode', mode);\n        if (!withoutFocus) {\n            var pos = this.convertor.getMappedPos();\n            this.focus();\n            if (this.isWysiwygMode() && isNumber_1(pos)) {\n                this.wwEditor.setSelection(pos);\n            }\n            else if (Array.isArray(pos)) {\n                this.mdEditor.setSelection(pos);\n            }\n        }\n    };\n    /**\n     * Destroy TUIEditor from document\n     */\n    ToastUIEditorCore.prototype.destroy = function () {\n        var _this = this;\n        this.wwEditor.destroy();\n        this.mdEditor.destroy();\n        this.preview.destroy();\n        this.scrollSync.destroy();\n        this.eventEmitter.emit('destroy');\n        this.eventEmitter.getEvents().forEach(function (_, type) { return _this.off(type); });\n    };\n    /**\n     * Hide TUIEditor\n     */\n    ToastUIEditorCore.prototype.hide = function () {\n        this.eventEmitter.emit('hide');\n    };\n    /**\n     * Show TUIEditor\n     */\n    ToastUIEditorCore.prototype.show = function () {\n        this.eventEmitter.emit('show');\n    };\n    /**\n     * Move on scroll position of the editor container\n     * @param {number} value scrollTop value of editor container\n     */\n    ToastUIEditorCore.prototype.setScrollTop = function (value) {\n        this.getCurrentModeEditor().setScrollTop(value);\n    };\n    /**\n     * Get scroll position value of editor container\n     * @returns {number} scrollTop value of editor container\n     */\n    ToastUIEditorCore.prototype.getScrollTop = function () {\n        return this.getCurrentModeEditor().getScrollTop();\n    };\n    /**\n     * Reset TUIEditor\n     */\n    ToastUIEditorCore.prototype.reset = function () {\n        this.wwEditor.setModel([]);\n        this.mdEditor.setMarkdown('');\n    };\n    /**\n     * Get current selection range\n     * @returns {Array.<number[]>|Array.<number>} Returns the range of the selection depending on the editor mode\n     * @example\n     * // Markdown mode\n     * const mdSelection = editor.getSelection();\n     *\n     * console.log(mdSelection); // [[startLineOffset, startCurorOffset], [endLineOffset, endCurorOffset]]\n     *\n     * // WYSIWYG mode\n     * const wwSelection = editor.getSelection();\n     *\n     * console.log(wwSelection); // [startCursorOffset, endCursorOffset]\n     */\n    ToastUIEditorCore.prototype.getSelection = function () {\n        return this.getCurrentModeEditor().getSelection();\n    };\n    /**\n     * Set the placeholder on all editors\n     * @param {string} placeholder - placeholder to set\n     */\n    ToastUIEditorCore.prototype.setPlaceholder = function (placeholder) {\n        this.placeholder = placeholder;\n        this.mdEditor.setPlaceholder(placeholder);\n        this.wwEditor.setPlaceholder(placeholder);\n    };\n    /**\n     * Get markdown editor, preview, wysiwyg editor DOM elements\n     */\n    ToastUIEditorCore.prototype.getEditorElements = function () {\n        return {\n            mdEditor: this.mdEditor.getElement(),\n            mdPreview: this.preview.getElement(),\n            wwEditor: this.wwEditor.getElement(),\n        };\n    };\n    /**\n     * Convert position to match editor mode\n     * @param {number|Array.<number>} start - start position\n     * @param {number|Array.<number>} end - end position\n     * @param {string} mode - Editor mode name of want to match converted position to\n     */\n    ToastUIEditorCore.prototype.convertPosToMatchEditorMode = function (start, end, mode) {\n        var _a, _b;\n        if (end === void 0) { end = start; }\n        if (mode === void 0) { mode = this.mode; }\n        var doc = this.mdEditor.view.state.doc;\n        var isFromArray = Array.isArray(start);\n        var isToArray = Array.isArray(end);\n        var convertedFrom = start;\n        var convertedTo = end;\n        if (isFromArray !== isToArray) {\n            throw new Error('Types of arguments must be same');\n        }\n        if (mode === 'markdown' && !isFromArray && !isToArray) {\n            _a = getEditorToMdPos(doc, start, end), convertedFrom = _a[0], convertedTo = _a[1];\n        }\n        else if (mode === 'wysiwyg' && isFromArray && isToArray) {\n            _b = getMdToEditorPos(doc, start, end), convertedFrom = _b[0], convertedTo = _b[1];\n        }\n        return [convertedFrom, convertedTo];\n    };\n    return ToastUIEditorCore;\n}());\n\n// @TODO: change syntax with our convention\n/* eslint-disable */\nfunction html$1 (n) {\n  for (\n    var l,\n      e,\n      s = arguments,\n      t = 1,\n      r = '',\n      u = '',\n      a = [0],\n      c = function (n) {\n        t === 1 && (n || (r = r.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g, '')))\n          ? a.push(n ? s[n] : r)\n          : t === 3 && (n || r)\n          ? ((a[1] = n ? s[n] : r), (t = 2))\n          : t === 2 && r === '...' && n\n          ? (a[2] = assign(a[2] || {}, s[n]))\n          : t === 2 && r && !n\n          ? ((a[2] = a[2] || {})[r] = !0)\n          : t >= 5 &&\n            (t === 5\n              ? (((a[2] = a[2] || {})[e] = n ? (r ? r + s[n] : s[n]) : r), (t = 6))\n              : (n || r) && (a[2][e] += n ? r + s[n] : r)),\n          (r = '');\n      },\n      h = 0;\n    h < n.length;\n    h++\n  ) {\n    h && (t === 1 && c(), c(h));\n    for (let i = 0; i < n[h].length; i++)\n      (l = n[h][i]),\n        t === 1\n          ? l === '<'\n            ? (c(), (a = [a, '', null]), (t = 3))\n            : (r += l)\n          : t === 4\n          ? r === '--' && l === '>'\n            ? ((t = 1), (r = ''))\n            : (r = l + r[0])\n          : u\n          ? l === u\n            ? (u = '')\n            : (r += l)\n          : l === '\"' || l === \"'\"\n          ? (u = l)\n          : l === '>'\n          ? (c(), (t = 1))\n          : t &&\n            (l === '='\n              ? ((t = 5), (e = r), (r = ''))\n              : l === '/' && (t < 5 || n[h][i + 1] === '>')\n              ? (c(),\n                t === 3 && (a = a[0]),\n                (t = a),\n                (a = a[0]).push(this.apply(null, t.slice(1))),\n                (t = 0))\n              : l === ' ' || l === '\\t' || l === '\\n' || l === '\\r'\n              ? (c(), (t = 2))\n              : (r += l)),\n        t === 3 && r === '!--' && ((t = 4), (a = a[0]));\n  }\n  return c(), a.length > 2 ? a.slice(1) : a[1];\n}\n\n/**\n * @fileoverview Check whether the given variable is a string or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a boolean or not.\n *  If the given variable is a boolean, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is boolean?\n * @memberof module:type\n */\nfunction isBoolean(obj) {\n  return typeof obj === 'boolean' || obj instanceof Boolean;\n}\n\nvar isBoolean_1 = isBoolean;\n\nvar VNodeWalker = /** @class */ (function () {\n    function VNodeWalker(current) {\n        this.current = current;\n        this.root = current;\n        this.entering = true;\n    }\n    VNodeWalker.prototype.walk = function () {\n        var _a = this, entering = _a.entering, cur = _a.current;\n        if (!cur) {\n            return null;\n        }\n        if (entering) {\n            if (cur.firstChild) {\n                this.current = cur.firstChild;\n                this.entering = true;\n            }\n            else {\n                this.entering = false;\n            }\n        }\n        else if (cur === this.root) {\n            this.current = null;\n        }\n        else if (cur.next) {\n            this.current = cur.next;\n            this.entering = true;\n        }\n        else {\n            this.current = cur.parent;\n            this.entering = false;\n        }\n        return { vnode: cur, entering: entering };\n    };\n    return VNodeWalker;\n}());\nvar VNode = /** @class */ (function () {\n    function VNode(type, props, children) {\n        this.parent = null;\n        this.old = null;\n        this.firstChild = null;\n        this.next = null;\n        this.skip = false;\n        this.type = type;\n        this.props = props;\n        this.children = children;\n        this.props.children = children;\n        if (props.ref) {\n            this.ref = props.ref;\n            delete props.ref;\n        }\n        if (props.key) {\n            this.key = props.key;\n            delete props.key;\n        }\n    }\n    VNode.prototype.walker = function () {\n        return new VNodeWalker(this);\n    };\n    VNode.removalNodes = [];\n    return VNode;\n}());\n\nfunction createTextNode(text) {\n    return new VNode('TEXT_NODE', { nodeValue: text }, []);\n}\nfunction excludeUnnecessaryChild(child, flatted) {\n    var vnode = child;\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    if (isBoolean_1(child) || child == null) {\n        vnode = null;\n    }\n    else if (isString_1(child) || isNumber_1(child)) {\n        vnode = createTextNode(String(child));\n    }\n    if (vnode) {\n        flatted.push(vnode);\n    }\n}\nfunction h(type, props) {\n    var children = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        children[_i - 2] = arguments[_i];\n    }\n    var flatted = [];\n    children.forEach(function (child) {\n        if (Array.isArray(child)) {\n            child.forEach(function (vnode) {\n                excludeUnnecessaryChild(vnode, flatted);\n            });\n        }\n        else {\n            excludeUnnecessaryChild(child, flatted);\n        }\n    });\n    return new VNode(type, props || {}, flatted);\n}\n// @ts-ignore\nvar html = html$1.bind(h);\n\n/**\n * @fileoverview Check whether the given variable is an object or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is an object or not.\n * If the given variable is an object, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is object?\n * @memberof module:type\n */\nfunction isObject(obj) {\n  return obj === Object(obj);\n}\n\nvar isObject_1 = isObject;\n\n// @TODO: clearfy the type definition for CSSDeclaration\nfunction createNode(vnode) {\n    var node;\n    if (vnode.type === 'TEXT_NODE') {\n        node = document.createTextNode(vnode.props.nodeValue);\n    }\n    else {\n        node = document.createElement(vnode.type);\n        setProps(node, {}, vnode.props);\n    }\n    return node;\n}\nfunction removeNode(vnode, parentNode) {\n    if (vnode.node) {\n        parentNode.removeChild(vnode.node);\n    }\n    else {\n        removeNode(vnode.firstChild, parentNode);\n    }\n}\nfunction innerDiff(node, prevProps, nextProps) {\n    Object.keys(prevProps).forEach(function (propName) {\n        if (/^on/.test(propName)) {\n            if (!nextProps[propName] || prevProps[propName] !== nextProps[propName]) {\n                var eventName = propName.slice(2).toLowerCase();\n                node.removeEventListener(eventName, prevProps[propName]);\n            }\n        }\n        else if (propName !== 'children' && !nextProps[propName] && !isTextNode(node)) {\n            node.removeAttribute(propName);\n        }\n    });\n    setProps(node, prevProps, nextProps, function (propName) { return !shallowEqual(prevProps[propName], nextProps[propName]); });\n}\nvar reNonDimension = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\nfunction setProps(node, prevProps, props, condition) {\n    Object.keys(props).forEach(function (propName) {\n        if (!condition || condition(propName)) {\n            if (/^on/.test(propName)) {\n                var eventName = propName.slice(2).toLowerCase();\n                node.addEventListener(eventName, props[propName]);\n            }\n            else if (propName === 'nodeValue') {\n                node[propName] = props[propName];\n            }\n            else if (propName === 'style' && isObject_1(props[propName])) {\n                setStyleProps(node, prevProps[propName], props[propName]);\n            }\n            else if (propName !== 'children') {\n                if (props[propName] === false) {\n                    node.removeAttribute(propName);\n                }\n                else {\n                    node.setAttribute(propName, props[propName]);\n                }\n            }\n        }\n    });\n}\nfunction setStyleProps(node, prevStyleProps, styleProps) {\n    if (prevStyleProps) {\n        Object.keys(prevStyleProps).forEach(function (styleProp) {\n            // @ts-ignore\n            node.style[styleProp] = '';\n        });\n    }\n    Object.keys(styleProps).forEach(function (styleProp) {\n        var value = styleProps[styleProp];\n        // @ts-ignore\n        node.style[styleProp] =\n            isNumber_1(value) && !reNonDimension.test(styleProp) ? value + \"px\" : value;\n    });\n}\n\nfunction commit(vnode) {\n    VNode.removalNodes.forEach(function (removalNode) { return diff(removalNode); });\n    if (vnode) {\n        var next = void 0;\n        var walker = vnode.walker();\n        while ((next = walker.walk())) {\n            vnode = next.vnode;\n            if (next.entering) {\n                diff(vnode);\n            }\n            else if (isFunction_1(vnode.type)) {\n                var comp = vnode.component;\n                // lifecycle method\n                if (!vnode.old && comp.mounted) {\n                    comp.mounted();\n                }\n                if (vnode.old && comp.updated) {\n                    var prevProps = comp.prevProps || {};\n                    comp.updated(prevProps);\n                }\n            }\n        }\n    }\n}\nfunction getParentNode(vnode) {\n    var parent = vnode.parent;\n    while (!parent.node) {\n        parent = parent.parent;\n    }\n    return parent.node;\n}\nfunction diff(vnode) {\n    if (!vnode || !vnode.parent) {\n        return;\n    }\n    if (vnode.node) {\n        var parentNode = getParentNode(vnode);\n        if (vnode.effect === 'A') {\n            parentNode.appendChild(vnode.node);\n        }\n        else if (vnode.effect === 'U') {\n            innerDiff(vnode.node, vnode.old.props, vnode.props);\n        }\n    }\n    if (vnode.effect === 'D') {\n        var next = void 0;\n        var walker = vnode.walker();\n        while ((next = walker.walk())) {\n            vnode = next.vnode;\n            if (!next.entering) {\n                if (isFunction_1(vnode.type)) {\n                    var comp = vnode.component;\n                    // lifecycle method\n                    if (comp.beforeDestroy) {\n                        comp.beforeDestroy();\n                    }\n                }\n                else {\n                    var parentNode = getParentNode(vnode);\n                    removeNode(vnode, parentNode);\n                }\n            }\n        }\n    }\n    // apply ref\n    if (vnode.ref) {\n        if (vnode.component) {\n            vnode.ref(vnode.component);\n        }\n        else if (vnode.node) {\n            vnode.ref(vnode.node);\n        }\n    }\n}\n\nfunction createComponent(Comp, vnode) {\n    var props = vnode.props, component = vnode.component;\n    if (component) {\n        component.prevProps = component.props;\n        component.props = vnode.props;\n        return component;\n    }\n    return new Comp(props);\n}\nfunction buildVNode(vnode) {\n    var root = vnode;\n    while (vnode && !vnode.skip) {\n        if (isFunction_1(vnode.type)) {\n            var instance = createComponent(vnode.type, vnode);\n            instance.vnode = vnode;\n            vnode.component = instance;\n            vnode.props.children = vnode.children = [instance.render()];\n            buildChildrenVNode(vnode);\n        }\n        else {\n            if (!vnode.node) {\n                vnode.node = createNode(vnode);\n            }\n            buildChildrenVNode(vnode);\n        }\n        if (vnode.firstChild) {\n            vnode = vnode.firstChild;\n        }\n        else {\n            while (vnode && vnode.parent && !vnode.next) {\n                vnode = vnode.parent;\n                if (vnode === root) {\n                    break;\n                }\n            }\n            vnode = vnode.next;\n        }\n    }\n}\nfunction isSameType(old, vnode) {\n    return old && vnode && vnode.type === old.type && (!vnode.key || vnode.key === old.key);\n}\n// @TODO: add key diff algorithm\nfunction buildChildrenVNode(parent) {\n    var children = parent.children;\n    var old = parent.old ? parent.old.firstChild : null;\n    var prev = null;\n    children.forEach(function (vnode, index) {\n        var sameType = isSameType(old, vnode);\n        if (sameType) {\n            vnode.old = old;\n            vnode.parent = parent;\n            vnode.node = old.node;\n            vnode.component = old.component;\n            vnode.effect = 'U';\n        }\n        if (vnode && !sameType) {\n            vnode.old = null;\n            vnode.parent = parent;\n            vnode.node = null;\n            vnode.effect = 'A';\n        }\n        if (old && !sameType) {\n            VNode.removalNodes.push(old);\n            old.effect = 'D';\n        }\n        if (old) {\n            old = old.next;\n        }\n        if (index === 0) {\n            parent.firstChild = vnode;\n        }\n        else if (vnode) {\n            prev.next = vnode;\n        }\n        prev = vnode;\n    });\n    var lastChild = last$1(children);\n    if (!children.length) {\n        while (old) {\n            VNode.removalNodes.push(old);\n            old.effect = 'D';\n            old = old.next;\n        }\n    }\n    while (old && lastChild) {\n        if (old && lastChild.old !== old) {\n            VNode.removalNodes.push(old);\n            old.effect = 'D';\n            old = old.next;\n        }\n    }\n}\n\nfunction destroy(vnode) {\n    vnode.effect = 'D';\n    VNode.removalNodes = [vnode];\n    commit();\n    VNode.removalNodes = [];\n}\nfunction rerender(comp) {\n    var root = comp.vnode;\n    root.effect = 'U';\n    root.old = root;\n    // skip for unnecessary reconciliation\n    if (root.next) {\n        root.next.skip = true;\n    }\n    VNode.removalNodes = [];\n    buildVNode(root);\n    commit(root);\n    if (root.next) {\n        root.next.skip = false;\n    }\n}\nfunction render(container, vnode) {\n    var root = new VNode(container.tagName.toLowerCase(), {}, [vnode]);\n    root.node = container;\n    VNode.removalNodes = [];\n    buildVNode(root);\n    commit(root);\n    return function () { return destroy(root.firstChild); };\n}\n\nvar Component = /** @class */ (function () {\n    function Component(props) {\n        this.props = props;\n        this.state = {};\n        this.refs = {};\n    }\n    Component.prototype.setState = function (state) {\n        var newState = __assign$1(__assign$1({}, this.state), state);\n        if (!shallowEqual(this.state, newState)) {\n            this.state = newState;\n            rerender(this);\n        }\n    };\n    return Component;\n}());\n\nvar Switch = /** @class */ (function (_super) {\n    __extends$1(Switch, _super);\n    function Switch(props) {\n        var _this = _super.call(this, props) || this;\n        _this.state = {\n            hide: false,\n        };\n        return _this;\n    }\n    Switch.prototype.show = function () {\n        this.setState({ hide: false });\n    };\n    Switch.prototype.hide = function () {\n        this.setState({ hide: true });\n    };\n    Switch.prototype.render = function () {\n        var _a = this.props, editorType = _a.editorType, eventEmitter = _a.eventEmitter;\n        return html(templateObject_1$h || (templateObject_1$h = __makeTemplateObject([\"\\n      <div class=\\\"\", \"\\\" style=\\\"display: \", \"\\\">\\n        <div\\n          class=\\\"tab-item\", \"\\\"\\n          onClick=\", \"\\n        >\\n          \", \"\\n        </div>\\n        <div\\n          class=\\\"tab-item\", \"\\\"\\n          onClick=\", \"\\n        >\\n          \", \"\\n        </div>\\n      </div>\\n    \"], [\"\\n      <div class=\\\"\", \"\\\" style=\\\"display: \", \"\\\">\\n        <div\\n          class=\\\"tab-item\", \"\\\"\\n          onClick=\",\n            \"\\n        >\\n          \", \"\\n        </div>\\n        <div\\n          class=\\\"tab-item\", \"\\\"\\n          onClick=\",\n            \"\\n        >\\n          \", \"\\n        </div>\\n      </div>\\n    \"])), cls('mode-switch'), this.state.hide ? 'none' : 'block', editorType === 'markdown' ? ' active' : '', function () {\n            eventEmitter.emit('needChangeMode', 'markdown');\n        }, i18n.get('Markdown'), editorType === 'wysiwyg' ? ' active' : '', function () {\n            eventEmitter.emit('needChangeMode', 'wysiwyg');\n        }, i18n.get('WYSIWYG'));\n    };\n    return Switch;\n}(Component));\nvar templateObject_1$h;\n\n/**\n * @fileoverview Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed since the last time the debouced function was invoked.\n * @author NHN FE Development Lab <dl_javascript.nhn.com>\n */\n\n/**\n * @module tricks\n */\n\n/**\n * Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed\n * since the last time the debouced function was invoked.\n * @param {function} fn The function to debounce.\n * @param {number} [delay=0] The number of milliseconds to delay\n * @returns {function} debounced function.\n * @memberof module:tricks\n * @example\n * // ES6\n * import debounce from 'tui-code-snippet/tricks/debounce';\n * \n * // CommonJS\n * const debounce = require('tui-code-snippet/tricks/debounce');\n *\n * function someMethodToInvokeDebounced() {}\n *\n * const debounced = debounce(someMethodToInvokeDebounced, 300);\n *\n * // invoke repeatedly\n * debounced();\n * debounced();\n * debounced();\n * debounced();\n * debounced();\n * debounced();    // last invoke of debounced()\n *\n * // invoke someMethodToInvokeDebounced() after 300 milliseconds.\n */\nfunction debounce$1(fn, delay) {\n  var timer, args;\n\n  /* istanbul ignore next */\n  delay = delay || 0;\n\n  function debounced() { // eslint-disable-line require-jsdoc\n    args = Array.prototype.slice.call(arguments);\n\n    window.clearTimeout(timer);\n    timer = window.setTimeout(function() {\n      fn.apply(null, args);\n    }, delay);\n  }\n\n  return debounced;\n}\n\nvar debounce_1 = debounce$1;\n\n/**\n * @fileoverview Creates a throttled function that only invokes fn at most once per every interval milliseconds.\n * @author NHN FE Development Lab <dl_javascript.nhn.com>\n */\n\nvar debounce = debounce_1;\n\n/**\n * Creates a throttled function that only invokes fn at most once per every interval milliseconds.\n * You can use this throttle short time repeatedly invoking functions. (e.g MouseMove, Resize ...)\n * if you need reuse throttled method. you must remove slugs (e.g. flag variable) related with throttling.\n * @param {function} fn function to throttle\n * @param {number} [interval=0] the number of milliseconds to throttle invocations to.\n * @returns {function} throttled function\n * @memberof module:tricks\n * @example\n * // ES6\n * import throttle from 'tui-code-snippet/tricks/throttle';\n * \n * // CommonJS\n * const throttle = require('tui-code-snippet/tricks/throttle');\n *\n * function someMethodToInvokeThrottled() {}\n *\n * const throttled = throttle(someMethodToInvokeThrottled, 300);\n *\n * // invoke repeatedly\n * throttled();    // invoke (leading)\n * throttled();\n * throttled();    // invoke (near 300 milliseconds)\n * throttled();\n * throttled();\n * throttled();    // invoke (near 600 milliseconds)\n * // ...\n * // invoke (trailing)\n *\n * // if you need reuse throttled method. then invoke reset()\n * throttled.reset();\n */\nfunction throttle$1(fn, interval) {\n  var base;\n  var isLeading = true;\n  var tick = function(_args) {\n    fn.apply(null, _args);\n    base = null;\n  };\n  var debounced, stamp, args;\n\n  /* istanbul ignore next */\n  interval = interval || 0;\n\n  debounced = debounce(tick, interval);\n\n  function throttled() { // eslint-disable-line require-jsdoc\n    args = Array.prototype.slice.call(arguments);\n\n    if (isLeading) {\n      tick(args);\n      isLeading = false;\n\n      return;\n    }\n\n    stamp = Number(new Date());\n\n    base = base || stamp;\n\n    // pass array directly because `debounce()`, `tick()` are already use\n    // `apply()` method to invoke developer's `fn` handler.\n    //\n    // also, this `debounced` line invoked every time for implements\n    // `trailing` features.\n    debounced(args);\n\n    if ((stamp - base) >= interval) {\n      tick(args);\n    }\n  }\n\n  function reset() { // eslint-disable-line require-jsdoc\n    isLeading = true;\n    base = null;\n  }\n\n  throttled.reset = reset;\n\n  return throttled;\n}\n\nvar throttle_1 = throttle$1;\n\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\nvar HeadingPopupBody = /** @class */ (function (_super) {\n    __extends$1(HeadingPopupBody, _super);\n    function HeadingPopupBody() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    HeadingPopupBody.prototype.execCommand = function (ev) {\n        var el = closest(ev.target, 'li');\n        this.props.execCommand('heading', {\n            level: Number(el.getAttribute('data-level')),\n        });\n    };\n    HeadingPopupBody.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_2$8 || (templateObject_2$8 = __makeTemplateObject([\"\\n      <ul\\n        onClick=\", \"\\n        aria-role=\\\"menu\\\"\\n        aria-label=\\\"\", \"\\\"\\n      >\\n        \", \"\\n        <li data-type=\\\"Paragraph\\\" aria-role=\\\"menuitem\\\">\\n          <div>\", \"</div>\\n        </li>\\n      </ul>\\n    \"], [\"\\n      <ul\\n        onClick=\", \"\\n        aria-role=\\\"menu\\\"\\n        aria-label=\\\"\", \"\\\"\\n      >\\n        \",\n            \"\\n        <li data-type=\\\"Paragraph\\\" aria-role=\\\"menuitem\\\">\\n          <div>\", \"</div>\\n        </li>\\n      </ul>\\n    \"])), function (ev) { return _this.execCommand(ev); }, i18n.get('Headings'), [1, 2, 3, 4, 5, 6].map(function (level) {\n            return html(templateObject_1$g || (templateObject_1$g = __makeTemplateObject([\"\\n              <li data-level=\\\"\", \"\\\" data-type=\\\"Heading\\\" aria-role=\\\"menuitem\\\">\\n                <\", \">\", \" \", \"</$>\\n              </li>\\n            \"], [\"\\n              <li data-level=\\\"\", \"\\\" data-type=\\\"Heading\\\" aria-role=\\\"menuitem\\\">\\n                <\", \">\", \" \", \"</$>\\n              </li>\\n            \"])), level, \"h\" + level, i18n.get('Heading'), level);\n        }), i18n.get('Paragraph'));\n    };\n    return HeadingPopupBody;\n}(Component));\nvar templateObject_1$g, templateObject_2$8;\n\nvar Tabs = /** @class */ (function (_super) {\n    __extends$1(Tabs, _super);\n    function Tabs() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Tabs.prototype.toggleTab = function (ev, activeTab) {\n        this.props.onClick(ev, activeTab);\n    };\n    Tabs.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_2$7 || (templateObject_2$7 = __makeTemplateObject([\"\\n      <div class=\\\"\", \"\\\" aria-role=\\\"tabpanel\\\">\\n        \", \"\\n      </div>\\n    \"], [\"\\n      <div class=\\\"\", \"\\\" aria-role=\\\"tabpanel\\\">\\n        \",\n            \"\\n      </div>\\n    \"])), cls('tabs'), this.props.tabs.map(function (_a) {\n            var name = _a.name, text = _a.text;\n            var isActive = _this.props.activeTab === name;\n            return html(templateObject_1$f || (templateObject_1$f = __makeTemplateObject([\"\\n            <div\\n              class=\\\"tab-item\", \"\\\"\\n              onClick=\", \"\\n              aria-role=\\\"tab\\\"\\n              aria-label=\\\"\", \"\\\"\\n              aria-selected=\\\"\", \"\\\"\\n              tabindex=\\\"\", \"\\\"\\n            >\\n              \", \"\\n            </div>\\n          \"], [\"\\n            <div\\n              class=\\\"tab-item\", \"\\\"\\n              onClick=\", \"\\n              aria-role=\\\"tab\\\"\\n              aria-label=\\\"\", \"\\\"\\n              aria-selected=\\\"\", \"\\\"\\n              tabindex=\\\"\", \"\\\"\\n            >\\n              \", \"\\n            </div>\\n          \"])), isActive ? ' active' : '', function (ev) { return _this.toggleTab(ev, name); }, i18n.get(text), isActive ? 'true' : 'false', isActive ? '0' : '-1', i18n.get(text));\n        }));\n    };\n    return Tabs;\n}(Component));\nvar templateObject_1$f, templateObject_2$7;\n\nvar TYPE_UI = 'ui';\nvar ImagePopupBody = /** @class */ (function (_super) {\n    __extends$1(ImagePopupBody, _super);\n    function ImagePopupBody(props) {\n        var _this = _super.call(this, props) || this;\n        _this.initialize = function (activeTab) {\n            if (activeTab === void 0) { activeTab = 'file'; }\n            var urlEl = _this.refs.url;\n            urlEl.value = '';\n            _this.refs.altText.value = '';\n            _this.refs.file.value = '';\n            removeClass_1(urlEl, 'wrong');\n            _this.setState({ activeTab: activeTab, file: null, fileNameElClassName: '' });\n        };\n        _this.execCommand = function () {\n            if (_this.state.activeTab === 'file') {\n                _this.emitAddImageBlob();\n            }\n            else {\n                _this.emitAddImage();\n            }\n        };\n        _this.toggleTab = function (_, activeTab) {\n            if (activeTab !== _this.state.activeTab) {\n                _this.initialize(activeTab);\n            }\n        };\n        _this.showFileSelectBox = function () {\n            _this.refs.file.click();\n        };\n        _this.changeFile = function (ev) {\n            var files = ev.target.files;\n            if (files === null || files === void 0 ? void 0 : files.length) {\n                _this.setState({ file: files[0] });\n            }\n        };\n        _this.state = { activeTab: 'file', file: null, fileNameElClassName: '' };\n        _this.tabs = [\n            { name: 'file', text: 'File' },\n            { name: 'url', text: 'URL' },\n        ];\n        return _this;\n    }\n    ImagePopupBody.prototype.emitAddImageBlob = function () {\n        var _this = this;\n        var files = this.refs.file.files;\n        var altTextEl = this.refs.altText;\n        var fileNameElClassName = ' wrong';\n        if (files === null || files === void 0 ? void 0 : files.length) {\n            fileNameElClassName = '';\n            var imageFile = files.item(0);\n            var hookCallback = function (url, text) {\n                return _this.props.execCommand('addImage', { imageUrl: url, altText: text || altTextEl.value });\n            };\n            this.props.eventEmitter.emit('addImageBlobHook', imageFile, hookCallback, TYPE_UI);\n        }\n        this.setState({ fileNameElClassName: fileNameElClassName });\n    };\n    ImagePopupBody.prototype.emitAddImage = function () {\n        var imageUrlEl = this.refs.url;\n        var altTextEl = this.refs.altText;\n        var imageUrl = imageUrlEl.value;\n        var altText = altTextEl.value || 'image';\n        removeClass_1(imageUrlEl, 'wrong');\n        if (!imageUrl.length) {\n            addClass_1(imageUrlEl, 'wrong');\n            return;\n        }\n        if (imageUrl) {\n            this.props.execCommand('addImage', { imageUrl: imageUrl, altText: altText });\n        }\n    };\n    ImagePopupBody.prototype.preventSelectStart = function (ev) {\n        ev.preventDefault();\n    };\n    ImagePopupBody.prototype.updated = function () {\n        if (!this.props.show) {\n            this.initialize();\n        }\n    };\n    ImagePopupBody.prototype.render = function () {\n        var _this = this;\n        var _a = this.state, activeTab = _a.activeTab, file = _a.file, fileNameElClassName = _a.fileNameElClassName;\n        return html(templateObject_1$e || (templateObject_1$e = __makeTemplateObject([\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <\", \" tabs=\", \" activeTab=\", \" onClick=\", \" />\\n        <div style=\\\"display:\", \"\\\">\\n          <label for=\\\"toastuiImageUrlInput\\\">\", \"</label>\\n          <input\\n            id=\\\"toastuiImageUrlInput\\\"\\n            type=\\\"text\\\"\\n            ref=\", \"\\n          />\\n        </div>\\n        <div style=\\\"display:\", \";position: relative;\\\">\\n          <label for=\\\"toastuiImageFileInput\\\">\", \"</label>\\n          <span\\n            class=\\\"\", \"\", \"\\\"\\n            onClick=\", \"\\n            onSelectstart=\", \"\\n          >\\n            \", \"\\n          </span>\\n          <button\\n            type=\\\"button\\\"\\n            class=\\\"\", \"\\\"\\n            onClick=\", \"\\n          >\\n            \", \"\\n          </button>\\n          <input\\n            id=\\\"toastuiImageFileInput\\\"\\n            type=\\\"file\\\"\\n            accept=\\\"image/*\\\"\\n            onChange=\", \"\\n            ref=\", \"\\n          />\\n        </div>\\n        <label for=\\\"toastuiAltTextInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiAltTextInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <div class=\\\"\", \"\\\">\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n        </div>\\n      </div>\\n    \"], [\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <\", \" tabs=\", \" activeTab=\", \" onClick=\", \" />\\n        <div style=\\\"display:\", \"\\\">\\n          <label for=\\\"toastuiImageUrlInput\\\">\", \"</label>\\n          <input\\n            id=\\\"toastuiImageUrlInput\\\"\\n            type=\\\"text\\\"\\n            ref=\", \"\\n          />\\n        </div>\\n        <div style=\\\"display:\", \";position: relative;\\\">\\n          <label for=\\\"toastuiImageFileInput\\\">\", \"</label>\\n          <span\\n            class=\\\"\", \"\", \"\\\"\\n            onClick=\", \"\\n            onSelectstart=\", \"\\n          >\\n            \", \"\\n          </span>\\n          <button\\n            type=\\\"button\\\"\\n            class=\\\"\", \"\\\"\\n            onClick=\", \"\\n          >\\n            \", \"\\n          </button>\\n          <input\\n            id=\\\"toastuiImageFileInput\\\"\\n            type=\\\"file\\\"\\n            accept=\\\"image/*\\\"\\n            onChange=\", \"\\n            ref=\", \"\\n          />\\n        </div>\\n        <label for=\\\"toastuiAltTextInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiAltTextInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <div class=\\\"\", \"\\\">\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n        </div>\\n      </div>\\n    \"])), i18n.get('Insert image'), Tabs, this.tabs, activeTab, this.toggleTab, activeTab === 'url' ? 'block' : 'none', i18n.get('Image URL'), function (el) { return (_this.refs.url = el); }, activeTab === 'file' ? 'block' : 'none', i18n.get('Select image file'), cls('file-name'), file ? ' has-file' : fileNameElClassName, this.showFileSelectBox, this.preventSelectStart, file ? file.name : i18n.get('No file'), cls('file-select-button'), this.showFileSelectBox, i18n.get('Choose a file'), this.changeFile, function (el) { return (_this.refs.file = el); }, i18n.get('Description'), function (el) { return (_this.refs.altText = el); }, cls('button-container'), cls('close-button'), this.props.hidePopup, i18n.get('Cancel'), cls('ok-button'), this.execCommand, i18n.get('OK'));\n    };\n    return ImagePopupBody;\n}(Component));\nvar templateObject_1$e;\n\nvar LinkPopupBody = /** @class */ (function (_super) {\n    __extends$1(LinkPopupBody, _super);\n    function LinkPopupBody() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.execCommand = function () {\n            var linkUrlEl = _this.refs.url;\n            var linkTextEl = _this.refs.text;\n            removeClass_1(linkUrlEl, 'wrong');\n            removeClass_1(linkTextEl, 'wrong');\n            if (linkUrlEl.value.length < 1) {\n                addClass_1(linkUrlEl, 'wrong');\n                return;\n            }\n            var checkLinkText = isUndefined_1(_this.props.initialValues.linkUrl);\n            if (checkLinkText && linkTextEl.value.length < 1) {\n                addClass_1(linkTextEl, 'wrong');\n                return;\n            }\n            _this.props.execCommand('addLink', {\n                linkUrl: linkUrlEl.value,\n                linkText: linkTextEl.value,\n            });\n        };\n        return _this;\n    }\n    LinkPopupBody.prototype.initialize = function () {\n        var _a = this.props.initialValues, linkUrl = _a.linkUrl, linkText = _a.linkText;\n        var linkUrlEl = this.refs.url;\n        var linkTextEl = this.refs.text;\n        removeClass_1(linkUrlEl, 'wrong');\n        removeClass_1(linkTextEl, 'wrong', 'disabled');\n        linkTextEl.removeAttribute('disabled');\n        if (linkUrl) {\n            addClass_1(linkTextEl, 'disabled');\n            linkTextEl.setAttribute('disabled', 'disabled');\n        }\n        linkUrlEl.value = linkUrl || '';\n        linkTextEl.value = linkText || '';\n    };\n    LinkPopupBody.prototype.mounted = function () {\n        this.initialize();\n    };\n    LinkPopupBody.prototype.updated = function (prevProps) {\n        if (!prevProps.show && this.props.show) {\n            this.initialize();\n        }\n    };\n    LinkPopupBody.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_1$d || (templateObject_1$d = __makeTemplateObject([\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <label for=\\\"toastuiLinkUrlInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiLinkUrlInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <label for=\\\"toastuiLinkTextInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiLinkTextInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <div class=\\\"\", \"\\\">\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n        </div>\\n      </div>\\n    \"], [\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <label for=\\\"toastuiLinkUrlInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiLinkUrlInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <label for=\\\"toastuiLinkTextInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiLinkTextInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <div class=\\\"\", \"\\\">\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n        </div>\\n      </div>\\n    \"])), i18n.get('Insert link'), i18n.get('URL'), function (el) { return (_this.refs.url = el); }, i18n.get('Link text'), function (el) { return (_this.refs.text = el); }, cls('button-container'), cls('close-button'), this.props.hidePopup, i18n.get('Cancel'), cls('ok-button'), this.execCommand, i18n.get('OK'));\n    };\n    return LinkPopupBody;\n}(Component));\nvar templateObject_1$d;\n\nvar CELL_WIDTH = 20;\nvar CELL_HEIGHT = 20;\nvar MIN_ROW_INDEX = 5;\nvar MAX_ROW_INDEX = 14;\nvar MIN_COL_INDEX = 5;\nvar MAX_COL_INDEX = 9;\nvar MIN_ROW_SELECTION_INDEX = 1;\nvar MIN_COL_SELECTION_INDEX = 1;\nvar BORDER_WIDTH = 1;\nvar TablePopupBody = /** @class */ (function (_super) {\n    __extends$1(TablePopupBody, _super);\n    function TablePopupBody(props) {\n        var _this = _super.call(this, props) || this;\n        _this.extendSelectionRange = function (_a) {\n            var pageX = _a.pageX, pageY = _a.pageY;\n            var x = pageX - _this.offsetRect.left;\n            var y = pageY - _this.offsetRect.top;\n            var range = _this.getSelectionRangeByOffset(x, y);\n            _this.setState(__assign$1({}, range));\n        };\n        _this.execCommand = function () {\n            _this.props.execCommand('addTable', {\n                rowCount: _this.state.rowIdx + 1,\n                columnCount: _this.state.colIdx + 1,\n            });\n        };\n        _this.state = {\n            rowIdx: -1,\n            colIdx: -1,\n        };\n        return _this;\n    }\n    TablePopupBody.prototype.getDescription = function () {\n        return this.state.colIdx === -1 ? '' : this.state.colIdx + 1 + \" x \" + (this.state.rowIdx + 1);\n    };\n    TablePopupBody.prototype.getBoundByRange = function (colIdx, rowIdx) {\n        return {\n            width: (colIdx + 1) * CELL_WIDTH,\n            height: (rowIdx + 1) * CELL_HEIGHT,\n        };\n    };\n    TablePopupBody.prototype.getRangeByOffset = function (x, y) {\n        return {\n            colIdx: Math.floor(x / CELL_WIDTH),\n            rowIdx: Math.floor(y / CELL_HEIGHT),\n        };\n    };\n    TablePopupBody.prototype.getTableRange = function () {\n        var _a = this.state, orgColIdx = _a.colIdx, orgRowIdx = _a.rowIdx;\n        var colIdx = Math.max(orgColIdx, MIN_COL_INDEX);\n        var rowIdx = Math.max(orgRowIdx, MIN_ROW_INDEX);\n        if (orgColIdx >= MIN_COL_INDEX && colIdx < MAX_COL_INDEX) {\n            colIdx += 1;\n        }\n        if (orgRowIdx >= MIN_ROW_INDEX && rowIdx < MAX_ROW_INDEX) {\n            rowIdx += 1;\n        }\n        return { colIdx: colIdx + 1, rowIdx: rowIdx + 1 };\n    };\n    TablePopupBody.prototype.getSelectionAreaBound = function () {\n        var _a = this.getBoundByRange(this.state.colIdx, this.state.rowIdx), width = _a.width, height = _a.height;\n        if (!width && !height) {\n            return { display: 'none' };\n        }\n        return { width: width - BORDER_WIDTH, height: height - BORDER_WIDTH, display: 'block' };\n    };\n    TablePopupBody.prototype.getSelectionRangeByOffset = function (x, y) {\n        var range = this.getRangeByOffset(x, y);\n        range.rowIdx = Math.min(Math.max(range.rowIdx, MIN_ROW_SELECTION_INDEX), MAX_ROW_INDEX);\n        range.colIdx = Math.min(Math.max(range.colIdx, MIN_COL_SELECTION_INDEX), MAX_COL_INDEX);\n        return range;\n    };\n    TablePopupBody.prototype.updated = function () {\n        if (!this.props.show) {\n            this.setState({ colIdx: -1, rowIdx: -1 });\n        }\n        else if (this.state.colIdx === -1 && this.state.rowIdx === -1) {\n            var _a = this.refs.tableEl.getBoundingClientRect(), left = _a.left, top_1 = _a.top;\n            this.offsetRect = {\n                left: window.pageXOffset + left,\n                top: window.pageYOffset + top_1,\n            };\n        }\n    };\n    TablePopupBody.prototype.createTableArea = function (tableRange) {\n        var colIdx = tableRange.colIdx, rowIdx = tableRange.rowIdx;\n        var rows = [];\n        for (var i = 0; i < rowIdx; i += 1) {\n            var cells = [];\n            for (var j = 0; j < colIdx; j += 1) {\n                var cellClassNames = \"\" + cls('table-cell') + (i > 0 ? '' : ' header');\n                cells.push(html(templateObject_1$c || (templateObject_1$c = __makeTemplateObject([\"<div class=\\\"\", \"\\\"></div>\"], [\"<div class=\\\"\", \"\\\"></div>\"])), cellClassNames));\n            }\n            rows.push(html(templateObject_2$6 || (templateObject_2$6 = __makeTemplateObject([\"<div class=\\\"\", \"\\\">\", \"</div>\"], [\"<div class=\\\"\", \"\\\">\", \"</div>\"])), cls('table-row'), cells));\n        }\n        return html(templateObject_3$2 || (templateObject_3$2 = __makeTemplateObject([\"<div class=\\\"\", \"\\\">\", \"</div>\"], [\"<div class=\\\"\", \"\\\">\", \"</div>\"])), cls('table'), rows);\n    };\n    TablePopupBody.prototype.render = function () {\n        var _this = this;\n        var tableRange = this.getTableRange();\n        var selectionAreaBound = this.getSelectionAreaBound();\n        return html(templateObject_4$1 || (templateObject_4$1 = __makeTemplateObject([\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <div\\n          class=\\\"\", \"\\\"\\n          ref=\", \"\\n          onMousemove=\", \"\\n          onClick=\", \"\\n        >\\n          \", \"\\n          <div class=\\\"\", \"\\\" style=\", \"></div>\\n        </div>\\n        <p class=\\\"\", \"\\\">\", \"</p>\\n      </div>\\n    \"], [\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <div\\n          class=\\\"\", \"\\\"\\n          ref=\", \"\\n          onMousemove=\", \"\\n          onClick=\", \"\\n        >\\n          \", \"\\n          <div class=\\\"\", \"\\\" style=\", \"></div>\\n        </div>\\n        <p class=\\\"\", \"\\\">\", \"</p>\\n      </div>\\n    \"])), i18n.get('Insert table'), cls('table-selection'), function (el) { return (_this.refs.tableEl = el); }, this.extendSelectionRange, this.execCommand, this.createTableArea(tableRange), cls('table-selection-layer'), selectionAreaBound, cls('table-description'), this.getDescription());\n    };\n    return TablePopupBody;\n}(Component));\nvar templateObject_1$c, templateObject_2$6, templateObject_3$2, templateObject_4$1;\n\nvar CustomPopupBody = /** @class */ (function (_super) {\n    __extends$1(CustomPopupBody, _super);\n    function CustomPopupBody() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CustomPopupBody.prototype.mounted = function () {\n        // append the custom popup body element\n        this.refs.el.appendChild(this.props.body);\n    };\n    CustomPopupBody.prototype.updated = function (prevProps) {\n        // update custom popup element\n        this.refs.el.replaceChild(this.props.body, prevProps.body);\n    };\n    CustomPopupBody.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_1$b || (templateObject_1$b = __makeTemplateObject([\"<div ref=\", \"></div>\"], [\"<div ref=\", \"></div>\"])), function (el) { return (_this.refs.el = el); });\n    };\n    return CustomPopupBody;\n}(Component));\nvar templateObject_1$b;\n\nfunction createToolbarItemInfo(type) {\n    return isString_1(type) ? createDefaultToolbarItemInfo(type) : type;\n}\nfunction createScrollSyncToolbarItem() {\n    var label = document.createElement('label');\n    var checkbox = document.createElement('input');\n    var toggleSwitch = document.createElement('span');\n    label.className = 'scroll-sync active';\n    checkbox.type = 'checkbox';\n    checkbox.checked = true;\n    toggleSwitch.className = 'switch';\n    var onMounted = function (execCommand) {\n        return checkbox.addEventListener('change', function (ev) {\n            var checked = ev.target.checked;\n            if (checked) {\n                addClass_1(label, 'active');\n            }\n            else {\n                removeClass_1(label, 'active');\n            }\n            execCommand('toggleScrollSync', { active: checked });\n        });\n    };\n    label.appendChild(checkbox);\n    label.appendChild(toggleSwitch);\n    return {\n        name: 'scrollSync',\n        el: label,\n        onMounted: onMounted,\n    };\n}\nfunction createDefaultToolbarItemInfo(type) {\n    var info;\n    switch (type) {\n        case 'heading':\n            info = {\n                name: 'heading',\n                className: 'heading',\n                tooltip: i18n.get('Headings'),\n                state: 'heading',\n            };\n            break;\n        case 'bold':\n            info = {\n                name: 'bold',\n                className: 'bold',\n                command: 'bold',\n                tooltip: i18n.get('Bold'),\n                state: 'strong',\n            };\n            break;\n        case 'italic':\n            info = {\n                name: 'italic',\n                className: 'italic',\n                command: 'italic',\n                tooltip: i18n.get('Italic'),\n                state: 'emph',\n            };\n            break;\n        case 'strike':\n            info = {\n                name: 'strike',\n                className: 'strike',\n                command: 'strike',\n                tooltip: i18n.get('Strike'),\n                state: 'strike',\n            };\n            break;\n        case 'hr':\n            info = {\n                name: 'hr',\n                className: 'hrline',\n                command: 'hr',\n                tooltip: i18n.get('Line'),\n                state: 'thematicBreak',\n            };\n            break;\n        case 'quote':\n            info = {\n                name: 'quote',\n                className: 'quote',\n                command: 'blockQuote',\n                tooltip: i18n.get('Blockquote'),\n                state: 'blockQuote',\n            };\n            break;\n        case 'ul':\n            info = {\n                name: 'ul',\n                className: 'bullet-list',\n                command: 'bulletList',\n                tooltip: i18n.get('Unordered list'),\n                state: 'bulletList',\n            };\n            break;\n        case 'ol':\n            info = {\n                name: 'ol',\n                className: 'ordered-list',\n                command: 'orderedList',\n                tooltip: i18n.get('Ordered list'),\n                state: 'orderedList',\n            };\n            break;\n        case 'task':\n            info = {\n                name: 'task',\n                className: 'task-list',\n                command: 'taskList',\n                tooltip: i18n.get('Task'),\n                state: 'taskList',\n            };\n            break;\n        case 'table':\n            info = {\n                name: 'table',\n                className: 'table',\n                tooltip: i18n.get('Insert table'),\n                state: 'table',\n            };\n            break;\n        case 'image':\n            info = {\n                name: 'image',\n                className: 'image',\n                tooltip: i18n.get('Insert image'),\n            };\n            break;\n        case 'link':\n            info = {\n                name: 'link',\n                className: 'link',\n                tooltip: i18n.get('Insert link'),\n            };\n            break;\n        case 'code':\n            info = {\n                name: 'code',\n                className: 'code',\n                command: 'code',\n                tooltip: i18n.get('Code'),\n                state: 'code',\n            };\n            break;\n        case 'codeblock':\n            info = {\n                name: 'codeblock',\n                className: 'codeblock',\n                command: 'codeBlock',\n                tooltip: i18n.get('Insert CodeBlock'),\n                state: 'codeBlock',\n            };\n            break;\n        case 'indent':\n            info = {\n                name: 'indent',\n                className: 'indent',\n                command: 'indent',\n                tooltip: i18n.get('Indent'),\n                state: 'indent',\n            };\n            break;\n        case 'outdent':\n            info = {\n                name: 'outdent',\n                className: 'outdent',\n                command: 'outdent',\n                tooltip: i18n.get('Outdent'),\n                state: 'outdent',\n            };\n            break;\n        case 'scrollSync':\n            info = createScrollSyncToolbarItem();\n            break;\n        case 'more':\n            info = {\n                name: 'more',\n                className: 'more',\n                tooltip: i18n.get('More'),\n            };\n            break;\n        // do nothing\n    }\n    if (info.name !== 'scrollSync') {\n        info.className += \" \" + cls('toolbar-icons');\n    }\n    return info;\n}\nfunction createPopupInfo(type, payload) {\n    var el = payload.el, pos = payload.pos, popup = payload.popup, initialValues = payload.initialValues;\n    switch (type) {\n        case 'heading':\n            return {\n                render: function (props) { return html(templateObject_1$a || (templateObject_1$a = __makeTemplateObject([\"<\", \" ...\", \" />\"], [\"<\", \" ...\", \" />\"])), HeadingPopupBody, props); },\n                className: cls('popup-add-heading'),\n                fromEl: el,\n                pos: pos,\n            };\n        case 'link':\n            return {\n                render: function (props) { return html(templateObject_2$5 || (templateObject_2$5 = __makeTemplateObject([\"<\", \" ...\", \" />\"], [\"<\", \" ...\", \" />\"])), LinkPopupBody, props); },\n                className: cls('popup-add-link'),\n                fromEl: el,\n                pos: pos,\n                initialValues: initialValues,\n            };\n        case 'image':\n            return {\n                render: function (props) { return html(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject([\"<\", \" ...\", \" />\"], [\"<\", \" ...\", \" />\"])), ImagePopupBody, props); },\n                className: cls('popup-add-image'),\n                fromEl: el,\n                pos: pos,\n            };\n        case 'table':\n            return {\n                render: function (props) { return html(templateObject_4 || (templateObject_4 = __makeTemplateObject([\"<\", \" ...\", \" />\"], [\"<\", \" ...\", \" />\"])), TablePopupBody, props); },\n                className: cls('popup-add-table'),\n                fromEl: el,\n                pos: pos,\n            };\n        case 'customPopupBody':\n            if (!popup) {\n                return null;\n            }\n            return __assign$1({ render: function (props) { return html(templateObject_5 || (templateObject_5 = __makeTemplateObject([\"<\", \" ...\", \" body=\", \" />\"], [\"<\", \" ...\", \" body=\", \" />\"])), CustomPopupBody, props, popup.body); }, fromEl: el, pos: pos }, popup);\n        default:\n            return null;\n    }\n}\nfunction setGroupState(group) {\n    group.hidden = group.length === group.filter(function (info) { return info.hidden; }).length;\n}\nfunction groupToolbarItems(toolbarItems, hiddenScrollSync) {\n    var toggleScrollSyncState = function (item) {\n        item.hidden = item.name === 'scrollSync' && hiddenScrollSync;\n        return item;\n    };\n    return toolbarItems.reduce(function (acc, item) {\n        acc.push(item.map(function (type) { return toggleScrollSyncState(createToolbarItemInfo(type)); }));\n        var group = acc[(acc.length || 1) - 1];\n        if (group) {\n            setGroupState(group);\n        }\n        return acc;\n    }, []);\n}\nfunction toggleScrollSync(toolbarItems, hiddenScrollSync) {\n    toolbarItems.forEach(function (group) {\n        group.forEach(function (item) { return (item.hidden = item.name === 'scrollSync' && hiddenScrollSync); });\n        setGroupState(group);\n    });\n}\nvar templateObject_1$a, templateObject_2$5, templateObject_3$1, templateObject_4, templateObject_5;\n\nvar MARGIN_FROM_RIGHT_SIDE = 20;\nvar Popup = /** @class */ (function (_super) {\n    __extends$1(Popup, _super);\n    function Popup() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.handleMousedown = function (ev) {\n            if (!closest(ev.target, \".\" + cls('popup')) &&\n                !closest(ev.target, _this.props.info.fromEl)) {\n                _this.props.hidePopup();\n            }\n        };\n        return _this;\n    }\n    Popup.prototype.mounted = function () {\n        document.addEventListener('mousedown', this.handleMousedown);\n        this.props.eventEmitter.listen('closePopup', this.props.hidePopup);\n    };\n    Popup.prototype.beforeDestroy = function () {\n        document.removeEventListener('mousedown', this.handleMousedown);\n    };\n    Popup.prototype.updated = function (prevProps) {\n        var _a = this.props, show = _a.show, info = _a.info;\n        if (show && info.pos && prevProps.show !== show) {\n            var popupPos = __assign$1({}, info.pos);\n            var offsetWidth = this.refs.el.offsetWidth;\n            var toolbarEl = closest(this.refs.el, \".\" + cls('toolbar'));\n            var toolbarOffsetWidth = toolbarEl.offsetWidth;\n            if (popupPos.left + offsetWidth >= toolbarOffsetWidth) {\n                popupPos.left = toolbarOffsetWidth - offsetWidth - MARGIN_FROM_RIGHT_SIDE;\n            }\n            if (!shallowEqual(this.state.popupPos, popupPos)) {\n                this.setState({ popupPos: popupPos });\n            }\n        }\n    };\n    Popup.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, info = _a.info, show = _a.show, hidePopup = _a.hidePopup, eventEmitter = _a.eventEmitter, execCommand = _a.execCommand;\n        var _b = info || {}, _c = _b.className, className = _c === void 0 ? '' : _c, style = _b.style, render = _b.render, _d = _b.initialValues, initialValues = _d === void 0 ? {} : _d;\n        var popupStyle = __assign$1(__assign$1({ display: show ? 'block' : 'none' }, style), this.state.popupPos);\n        return html(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject([\"\\n      <div\\n        class=\\\"\", \" \", \"\\\"\\n        style=\", \"\\n        ref=\", \"\\n        aria-role=\\\"dialog\\\"\\n      >\\n        <div class=\\\"\", \"\\\">\\n          \", \"\\n        </div>\\n      </div>\\n    \"], [\"\\n      <div\\n        class=\\\"\", \" \", \"\\\"\\n        style=\", \"\\n        ref=\", \"\\n        aria-role=\\\"dialog\\\"\\n      >\\n        <div class=\\\"\", \"\\\">\\n          \", \"\\n        </div>\\n      </div>\\n    \"])), cls('popup'), className, popupStyle, function (el) { return (_this.refs.el = el); }, cls('popup-body'), render && render({ eventEmitter: eventEmitter, show: show, hidePopup: hidePopup, execCommand: execCommand, initialValues: initialValues }));\n    };\n    return Popup;\n}(Component));\nvar templateObject_1$9;\n\nvar TOOLTIP_INDENT = 6;\nfunction connectHOC(WrappedComponent) {\n    return /** @class */ (function (_super) {\n        __extends$1(ButtonHOC, _super);\n        function ButtonHOC(props) {\n            var _this = _super.call(this, props) || this;\n            _this.showTooltip = function (el) {\n                var tooltip = _this.props.item.tooltip;\n                if (!_this.props.disabled && tooltip) {\n                    var bound = _this.getBound(el);\n                    var left = bound.left + TOOLTIP_INDENT + \"px\";\n                    var top_1 = bound.top + TOOLTIP_INDENT + \"px\";\n                    css_1(_this.props.tooltipRef.current, { display: 'block', left: left, top: top_1 });\n                    _this.props.tooltipRef.current.querySelector('.text').textContent = tooltip;\n                }\n            };\n            _this.hideTooltip = function () {\n                css_1(_this.props.tooltipRef.current, 'display', 'none');\n            };\n            _this.state = { active: false, disabled: props.disabled };\n            _this.addEvent();\n            return _this;\n        }\n        ButtonHOC.prototype.addEvent = function () {\n            var _this = this;\n            var _a = this.props, item = _a.item, eventEmitter = _a.eventEmitter;\n            if (item.state) {\n                eventEmitter.listen('changeToolbarState', function (_a) {\n                    var _b;\n                    var toolbarState = _a.toolbarState;\n                    var _c = (_b = toolbarState[item.state]) !== null && _b !== void 0 ? _b : {}, active = _c.active, disabled = _c.disabled;\n                    _this.setState({ active: !!active, disabled: disabled !== null && disabled !== void 0 ? disabled : _this.props.disabled });\n                });\n            }\n        };\n        ButtonHOC.prototype.getBound = function (el) {\n            var _a = getTotalOffset(el, closest(el, \".\" + cls('toolbar'))), offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop;\n            return { left: offsetLeft, top: el.offsetHeight + offsetTop };\n        };\n        ButtonHOC.prototype.render = function () {\n            return html(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject([\"\\n        <\", \"\\n          ...\", \"\\n          active=\", \"\\n          showTooltip=\", \"\\n          hideTooltip=\", \"\\n          getBound=\", \"\\n          disabled=\", \"\\n        />\\n      \"], [\"\\n        <\", \"\\n          ...\", \"\\n          active=\", \"\\n          showTooltip=\", \"\\n          hideTooltip=\", \"\\n          getBound=\", \"\\n          disabled=\", \"\\n        />\\n      \"])), WrappedComponent, this.props, this.state.active, this.showTooltip, this.hideTooltip, this.getBound, this.state.disabled || this.props.disabled);\n        };\n        return ButtonHOC;\n    }(Component));\n}\nvar templateObject_1$8;\n\nvar DEFAULT_WIDTH = 80;\nvar ToolbarButtonComp = /** @class */ (function (_super) {\n    __extends$1(ToolbarButtonComp, _super);\n    function ToolbarButtonComp() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.showTooltip = function () {\n            _this.props.showTooltip(_this.refs.el);\n        };\n        _this.execCommand = function () {\n            var _a = _this.props, item = _a.item, execCommand = _a.execCommand, setPopupInfo = _a.setPopupInfo, getBound = _a.getBound, eventEmitter = _a.eventEmitter;\n            var command = item.command, name = item.name, popup = item.popup;\n            if (command) {\n                execCommand(command);\n            }\n            else {\n                var popupName = popup ? 'customPopupBody' : name;\n                var initialValues = eventEmitter.emit('query', 'getPopupInitialValues', { popupName: popupName })[0];\n                var info = createPopupInfo(popupName, {\n                    el: _this.refs.el,\n                    pos: getBound(_this.refs.el),\n                    popup: popup,\n                    initialValues: initialValues,\n                });\n                if (info) {\n                    setPopupInfo(info);\n                }\n            }\n        };\n        return _this;\n    }\n    ToolbarButtonComp.prototype.mounted = function () {\n        this.setItemWidth();\n    };\n    ToolbarButtonComp.prototype.updated = function (prevProps) {\n        if (prevProps.item.name !== this.props.item.name) {\n            this.setItemWidth();\n        }\n    };\n    ToolbarButtonComp.prototype.setItemWidth = function () {\n        var _a = this.props, setItemWidth = _a.setItemWidth, item = _a.item;\n        // set width only if it is not a dropdown toolbar\n        if (setItemWidth) {\n            setItemWidth(item.name, getOuterWidth(this.refs.el) + (item.hidden ? DEFAULT_WIDTH : 0));\n        }\n    };\n    ToolbarButtonComp.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, hideTooltip = _a.hideTooltip, disabled = _a.disabled, item = _a.item, active = _a.active;\n        var style = __assign$1({ display: item.hidden ? 'none' : null }, item.style);\n        var classNames = \"\" + (item.className || '') + (active ? ' active' : '');\n        return html(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject([\"\\n      <button\\n        ref=\", \"\\n        type=\\\"button\\\"\\n        style=\", \"\\n        class=\", \"\\n        onClick=\", \"\\n        onMouseover=\", \"\\n        onMouseout=\", \"\\n        disabled=\", \"\\n        aria-label=\", \"\\n      >\\n        \", \"\\n      </button>\\n    \"], [\"\\n      <button\\n        ref=\", \"\\n        type=\\\"button\\\"\\n        style=\", \"\\n        class=\", \"\\n        onClick=\", \"\\n        onMouseover=\", \"\\n        onMouseout=\", \"\\n        disabled=\", \"\\n        aria-label=\", \"\\n      >\\n        \", \"\\n      </button>\\n    \"])), function (el) { return (_this.refs.el = el); }, style, classNames, this.execCommand, this.showTooltip, hideTooltip, !!disabled, item.text || item.tooltip || '', item.text || '');\n    };\n    return ToolbarButtonComp;\n}(Component));\nvar ToolbarButton = connectHOC(ToolbarButtonComp);\nvar templateObject_1$7;\n\nvar CustomToolbarItemComp = /** @class */ (function (_super) {\n    __extends$1(CustomToolbarItemComp, _super);\n    function CustomToolbarItemComp() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.showTooltip = function () {\n            _this.props.showTooltip(_this.refs.el);\n        };\n        _this.showPopup = function () {\n            var info = createPopupInfo('customPopupBody', {\n                el: _this.refs.el,\n                pos: _this.props.getBound(_this.refs.el),\n                popup: _this.props.item.popup,\n            });\n            if (info) {\n                _this.props.setPopupInfo(info);\n            }\n        };\n        return _this;\n    }\n    CustomToolbarItemComp.prototype.mounted = function () {\n        var _a = this.props, setItemWidth = _a.setItemWidth, item = _a.item;\n        // append the custom html element\n        this.refs.el.appendChild(item.el);\n        // set width only if it is not a dropdown toolbar\n        if (setItemWidth) {\n            setItemWidth(item.name, getOuterWidth(this.refs.el));\n        }\n        if (item.onMounted) {\n            item.onMounted(this.props.execCommand);\n        }\n    };\n    CustomToolbarItemComp.prototype.updated = function (prevProps) {\n        var _a;\n        var _b = this.props, item = _b.item, active = _b.active, disabled = _b.disabled;\n        if (prevProps.active !== active || prevProps.disabled !== disabled) {\n            (_a = item.onUpdated) === null || _a === void 0 ? void 0 : _a.call(item, { active: active, disabled: disabled });\n        }\n    };\n    CustomToolbarItemComp.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, disabled = _a.disabled, item = _a.item;\n        var style = { display: item.hidden ? 'none' : 'inline-block' };\n        var getListener = function (listener) { return (disabled ? null : listener); };\n        return html(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject([\"\\n      <div\\n        ref=\", \"\\n        style=\", \"\\n        class=\", \"\\n        onClick=\", \"\\n        onMouseover=\", \"\\n        onMouseout=\", \"\\n      ></div>\\n    \"], [\"\\n      <div\\n        ref=\", \"\\n        style=\", \"\\n        class=\", \"\\n        onClick=\", \"\\n        onMouseover=\", \"\\n        onMouseout=\", \"\\n      ></div>\\n    \"])), function (el) { return (_this.refs.el = el); }, style, cls('toolbar-item-wrapper'), getListener(this.showPopup), getListener(this.showTooltip), getListener(this.props.hideTooltip));\n    };\n    return CustomToolbarItemComp;\n}(Component));\nvar CustomToolbarItem = connectHOC(CustomToolbarItemComp);\nvar templateObject_1$6;\n\nvar ToolbarGroup = /** @class */ (function (_super) {\n    __extends$1(ToolbarGroup, _super);\n    function ToolbarGroup() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ToolbarGroup.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, group = _a.group, hiddenDivider = _a.hiddenDivider;\n        var groupStyle = group.hidden ? { display: 'none' } : null;\n        var dividerStyle = hiddenDivider ? { display: 'none' } : null;\n        return html(templateObject_2$4 || (templateObject_2$4 = __makeTemplateObject([\"\\n      <div class=\\\"\", \"\\\" style=\", \">\\n        \", \"\\n        <div class=\\\"\", \"\\\" style=\", \"></div>\\n      </div>\\n    \"], [\"\\n      <div class=\\\"\", \"\\\" style=\", \">\\n        \",\n            \"\\n        <div class=\\\"\", \"\\\" style=\", \"></div>\\n      </div>\\n    \"])), cls('toolbar-group'), groupStyle, group.map(function (item) {\n            var Comp = item.el ? CustomToolbarItem : ToolbarButton;\n            return html(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject([\"<\", \" key=\", \" ...\", \" item=\", \" />\"], [\"<\", \" key=\", \" ...\", \" item=\", \" />\"])), Comp, item.name, _this.props, item);\n        }), cls('toolbar-divider'), dividerStyle);\n    };\n    return ToolbarGroup;\n}(Component));\nvar templateObject_1$5, templateObject_2$4;\n\nvar POPUP_INDENT = 4;\nvar DropdownToolbarButtonComp = /** @class */ (function (_super) {\n    __extends$1(DropdownToolbarButtonComp, _super);\n    function DropdownToolbarButtonComp(props) {\n        var _this = _super.call(this, props) || this;\n        _this.handleClickDocument = function (_a) {\n            var target = _a.target;\n            if (!closest(target, \".\" + cls('dropdown-toolbar')) &&\n                !closest(target, '.more')) {\n                _this.setState({ showDropdown: false, dropdownPos: null });\n            }\n        };\n        _this.showTooltip = function () {\n            _this.props.showTooltip(_this.refs.el);\n        };\n        _this.state = { showDropdown: false, dropdownPos: null };\n        return _this;\n    }\n    DropdownToolbarButtonComp.prototype.getBound = function () {\n        var rect = this.props.getBound(this.refs.el);\n        rect.top += POPUP_INDENT;\n        return __assign$1(__assign$1({}, rect), { left: null, right: 10 });\n    };\n    DropdownToolbarButtonComp.prototype.mounted = function () {\n        document.addEventListener('click', this.handleClickDocument);\n    };\n    DropdownToolbarButtonComp.prototype.updated = function () {\n        if (this.state.showDropdown && !this.state.dropdownPos) {\n            this.setState({ dropdownPos: this.getBound() });\n        }\n    };\n    DropdownToolbarButtonComp.prototype.beforeDestroy = function () {\n        document.removeEventListener('click', this.handleClickDocument);\n    };\n    DropdownToolbarButtonComp.prototype.render = function () {\n        var _this = this;\n        var _a = this.state, showDropdown = _a.showDropdown, dropdownPos = _a.dropdownPos;\n        var _b = this.props, disabled = _b.disabled, item = _b.item, items = _b.items, hideTooltip = _b.hideTooltip;\n        var visibleItems = items.filter(function (dropdownItem) { return !dropdownItem.hidden; });\n        var groupStyle = visibleItems.length ? null : { display: 'none' };\n        var dropdownStyle = showDropdown ? null : { display: 'none' };\n        return html(templateObject_2$3 || (templateObject_2$3 = __makeTemplateObject([\"\\n      <div class=\\\"\", \"\\\" style=\", \">\\n        <button\\n          ref=\", \"\\n          type=\\\"button\\\"\\n          class=\", \"\\n          onClick=\", \"\\n          onMouseover=\", \"\\n          onMouseout=\", \"\\n          disabled=\", \"\\n        ></button>\\n        <div\\n          class=\\\"\", \"\\\"\\n          style=\", \"\\n          ref=\", \"\\n        >\\n          \", \"\\n        </div>\\n      </div>\\n    \"], [\"\\n      <div class=\\\"\", \"\\\" style=\", \">\\n        <button\\n          ref=\", \"\\n          type=\\\"button\\\"\\n          class=\", \"\\n          onClick=\", \"\\n          onMouseover=\", \"\\n          onMouseout=\", \"\\n          disabled=\", \"\\n        ></button>\\n        <div\\n          class=\\\"\", \"\\\"\\n          style=\", \"\\n          ref=\", \"\\n        >\\n          \",\n            \"\\n        </div>\\n      </div>\\n    \"])), cls('toolbar-group'), groupStyle, function (el) { return (_this.refs.el = el); }, item.className, function () { return _this.setState({ showDropdown: true }); }, this.showTooltip, hideTooltip, disabled, cls('dropdown-toolbar'), __assign$1(__assign$1({}, dropdownStyle), dropdownPos), function (el) { return (_this.refs.dropdownEl = el); }, visibleItems.length\n            ? visibleItems.map(function (group, index) {\n                var _a;\n                return html(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject([\"\\n                  <\", \"\\n                    group=\", \"\\n                    hiddenDivider=\", \"\\n                    ...\", \"\\n                  />\\n                \"], [\"\\n                  <\", \"\\n                    group=\", \"\\n                    hiddenDivider=\",\n                    \"\\n                    ...\", \"\\n                  />\\n                \"])), ToolbarGroup, group, index === visibleItems.length - 1 ||\n                    ((_a = visibleItems[index + 1]) === null || _a === void 0 ? void 0 : _a.hidden), _this.props);\n            })\n            : null);\n    };\n    return DropdownToolbarButtonComp;\n}(Component));\nvar DropdownToolbarButton = connectHOC(DropdownToolbarButtonComp);\nvar templateObject_1$4, templateObject_2$3;\n\nvar INLINE_PADDING = 50;\nvar Toolbar = /** @class */ (function (_super) {\n    __extends$1(Toolbar, _super);\n    function Toolbar(props) {\n        var _this = _super.call(this, props) || this;\n        _this.toggleTab = function (_, activeTab) {\n            var eventEmitter = _this.props.eventEmitter;\n            if (_this.state.activeTab !== activeTab) {\n                var event_1 = activeTab === 'write' ? 'changePreviewTabWrite' : 'changePreviewTabPreview';\n                eventEmitter.emit(event_1);\n                _this.setState({ activeTab: activeTab });\n            }\n        };\n        _this.setItemWidth = function (name, width) {\n            _this.itemWidthMap[name] = width;\n        };\n        _this.setPopupInfo = function (popupInfo) {\n            _this.setState({ showPopup: true, popupInfo: popupInfo });\n        };\n        _this.openPopup = function (popupName, initialValues) {\n            if (initialValues === void 0) { initialValues = {}; }\n            var el = _this.refs.el.querySelector(\".\" + cls('toolbar-group') + \" .\" + popupName);\n            if (el) {\n                var _a = getTotalOffset(el, closest(el, \".\" + cls('toolbar'))), offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop;\n                var info = createPopupInfo(popupName, {\n                    el: el,\n                    pos: { left: offsetLeft, top: el.offsetHeight + offsetTop },\n                    initialValues: initialValues,\n                });\n                if (info) {\n                    _this.setPopupInfo(info);\n                }\n            }\n        };\n        _this.hidePopup = function () {\n            if (_this.state.showPopup) {\n                _this.setState({ showPopup: false });\n            }\n        };\n        _this.execCommand = function (command, payload) {\n            var eventEmitter = _this.props.eventEmitter;\n            eventEmitter.emit('command', command, payload);\n            _this.hidePopup();\n        };\n        _this.tabs = [\n            { name: 'write', text: 'Write' },\n            { name: 'preview', text: 'Preview' },\n        ];\n        _this.itemWidthMap = {};\n        _this.initialItems = groupToolbarItems(props.toolbarItems || [], _this.hiddenScrollSync());\n        _this.state = {\n            items: _this.initialItems,\n            dropdownItems: [],\n            showPopup: false,\n            popupInfo: {},\n            activeTab: 'write',\n        };\n        _this.tooltipRef = { current: null };\n        _this.resizeObserver = new index(function () { return _this.handleResize(); });\n        _this.addEvent();\n        return _this;\n    }\n    Toolbar.prototype.insertToolbarItem = function (indexList, item) {\n        var groupIndex = indexList.groupIndex, itemIndex = indexList.itemIndex;\n        var group = this.initialItems[groupIndex];\n        item = createToolbarItemInfo(item);\n        if (group) {\n            group.splice(itemIndex, 0, item);\n        }\n        else {\n            this.initialItems.push([item]);\n        }\n        this.setState(this.classifyToolbarItems());\n    };\n    Toolbar.prototype.removeToolbarItem = function (name) {\n        var _this = this;\n        forEachArray_1(this.initialItems, function (group) {\n            var found = false;\n            forEachArray_1(group, function (item, index) {\n                if (item.name === name) {\n                    found = true;\n                    group.splice(index, 1);\n                    _this.setState(_this.classifyToolbarItems());\n                    return false;\n                }\n                return true;\n            });\n            return !found;\n        });\n    };\n    Toolbar.prototype.addEvent = function () {\n        var _this = this;\n        var eventEmitter = this.props.eventEmitter;\n        this.handleResize = throttle_1(function () {\n            // reset toolbar items to re-layout toolbar items with each clientWidth\n            _this.setState({ items: _this.initialItems, dropdownItems: [] });\n            _this.setState(_this.classifyToolbarItems());\n        }, 200);\n        eventEmitter.listen('openPopup', this.openPopup);\n    };\n    Toolbar.prototype.appendTooltipToRoot = function () {\n        var tooltip = \"<div class=\\\"\" + cls('tooltip') + \"\\\" style=\\\"display:none\\\">\\n        <div class=\\\"arrow\\\"></div>\\n        <span class=\\\"text\\\"></span>\\n      </div>\";\n        this.tooltipRef.current = createElementWith(tooltip, this.refs.el);\n    };\n    Toolbar.prototype.hiddenScrollSync = function () {\n        return this.props.editorType === 'wysiwyg' || this.props.previewStyle === 'tab';\n    };\n    Toolbar.prototype.movePrevItemToDropdownToolbar = function (itemIndex, items, group, dropdownGroup) {\n        var moveItem = function (targetGroup) {\n            var item = targetGroup.pop();\n            if (item) {\n                dropdownGroup.push(item);\n            }\n        };\n        if (itemIndex > 1) {\n            moveItem(group);\n        }\n        else {\n            var prevGroup = last$1(items);\n            if (prevGroup) {\n                moveItem(prevGroup);\n            }\n        }\n    };\n    Toolbar.prototype.classifyToolbarItems = function () {\n        var _this = this;\n        var totalWidth = 0;\n        var clientWidth = this.refs.el.clientWidth;\n        var divider = this.refs.el.querySelector(\".\" + cls('toolbar-divider'));\n        var dividerWidth = divider ? getOuterWidth(divider) : 0;\n        var items = [];\n        var dropdownItems = [];\n        var moved = false;\n        this.initialItems.forEach(function (initialGroup, groupIndex) {\n            var group = [];\n            var dropdownGroup = [];\n            initialGroup.forEach(function (item, itemIndex) {\n                if (!item.hidden) {\n                    totalWidth += _this.itemWidthMap[item.name];\n                    if (totalWidth > clientWidth - INLINE_PADDING) {\n                        // should move the prev item to dropdown toolbar for placing the more button\n                        if (!moved) {\n                            _this.movePrevItemToDropdownToolbar(itemIndex, items, group, dropdownGroup);\n                            moved = true;\n                        }\n                        dropdownGroup.push(item);\n                    }\n                    else {\n                        group.push(item);\n                    }\n                }\n            });\n            if (group.length) {\n                setGroupState(group);\n                items.push(group);\n            }\n            if (dropdownGroup.length) {\n                setGroupState(dropdownGroup);\n                dropdownItems.push(dropdownGroup);\n            }\n            // add divider width\n            if (groupIndex < _this.state.items.length - 1) {\n                totalWidth += dividerWidth;\n            }\n        });\n        return { items: items, dropdownItems: dropdownItems };\n    };\n    Toolbar.prototype.mounted = function () {\n        if (this.props.previewStyle === 'tab') {\n            this.props.eventEmitter.emit('changePreviewTabWrite', true);\n        }\n        // classify toolbar and dropdown toolbar after DOM has been rendered\n        this.setState(this.classifyToolbarItems());\n        this.appendTooltipToRoot();\n        this.resizeObserver.observe(this.refs.el);\n    };\n    Toolbar.prototype.updated = function (prevProps) {\n        var _a = this.props, editorType = _a.editorType, previewStyle = _a.previewStyle, eventEmitter = _a.eventEmitter;\n        var changedStyle = previewStyle !== prevProps.previewStyle;\n        var changedType = editorType !== prevProps.editorType;\n        if (changedStyle || changedType) {\n            // show or hide scrollSync button\n            toggleScrollSync(this.initialItems, this.hiddenScrollSync());\n            var newState = this.classifyToolbarItems();\n            if (changedStyle || (previewStyle === 'tab' && editorType === 'markdown')) {\n                eventEmitter.emit('changePreviewTabWrite');\n                newState.activeTab = 'write';\n            }\n            this.setState(newState);\n        }\n    };\n    Toolbar.prototype.beforeDestroy = function () {\n        window.removeEventListener('resize', this.handleResize);\n        this.resizeObserver.disconnect();\n        removeNode$1(this.tooltipRef.current);\n    };\n    Toolbar.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, previewStyle = _a.previewStyle, eventEmitter = _a.eventEmitter, editorType = _a.editorType;\n        var _b = this.state, popupInfo = _b.popupInfo, showPopup = _b.showPopup, activeTab = _b.activeTab, items = _b.items, dropdownItems = _b.dropdownItems;\n        var props = {\n            eventEmitter: eventEmitter,\n            tooltipRef: this.tooltipRef,\n            disabled: editorType === 'markdown' && previewStyle === 'tab' && activeTab === 'preview',\n            execCommand: this.execCommand,\n            setPopupInfo: this.setPopupInfo,\n        };\n        var toolbarStyle = previewStyle === 'tab' ? { borderTopLeftRadius: 0 } : null;\n        return html(templateObject_2$2 || (templateObject_2$2 = __makeTemplateObject([\"\\n      <div class=\\\"\", \"\\\">\\n        <div\\n          class=\\\"\", \"\\\"\\n          style=\\\"display: \", \"\\\"\\n        >\\n          <\", \" tabs=\", \" activeTab=\", \" onClick=\", \" />\\n        </div>\\n        <div\\n          class=\\\"\", \"\\\"\\n          ref=\", \"\\n          style=\", \"\\n        >\\n          \", \"\\n          <\", \"\\n            item=\", \"\\n            items=\", \"\\n            ...\", \"\\n          />\\n        </div>\\n        <\", \"\\n          info=\", \"\\n          show=\", \"\\n          eventEmitter=\", \"\\n          hidePopup=\", \"\\n          execCommand=\", \"\\n        />\\n      </div>\\n    \"], [\"\\n      <div class=\\\"\", \"\\\">\\n        <div\\n          class=\\\"\", \"\\\"\\n          style=\\\"display: \",\n            \"\\\"\\n        >\\n          <\", \" tabs=\", \" activeTab=\", \" onClick=\", \" />\\n        </div>\\n        <div\\n          class=\\\"\", \"\\\"\\n          ref=\", \"\\n          style=\", \"\\n        >\\n          \",\n            \"\\n          <\", \"\\n            item=\", \"\\n            items=\", \"\\n            ...\", \"\\n          />\\n        </div>\\n        <\", \"\\n          info=\", \"\\n          show=\", \"\\n          eventEmitter=\", \"\\n          hidePopup=\", \"\\n          execCommand=\", \"\\n        />\\n      </div>\\n    \"])), cls('toolbar'), cls('md-tab-container'), editorType === 'wysiwyg' || previewStyle === 'vertical'\n            ? 'none'\n            : 'block', Tabs, this.tabs, activeTab, this.toggleTab, cls('defaultUI-toolbar'), function (el) { return (_this.refs.el = el); }, toolbarStyle, items.map(function (group, index) {\n            var _a;\n            return html(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject([\"\\n              <\", \"\\n                group=\", \"\\n                hiddenDivider=\", \"\\n                setItemWidth=\", \"\\n                ...\", \"\\n              />\\n            \"], [\"\\n              <\", \"\\n                group=\", \"\\n                hiddenDivider=\", \"\\n                setItemWidth=\", \"\\n                ...\", \"\\n              />\\n            \"])), ToolbarGroup, group, index === items.length - 1 || ((_a = items[index + 1]) === null || _a === void 0 ? void 0 : _a.hidden), _this.setItemWidth, props);\n        }), DropdownToolbarButton, createToolbarItemInfo('more'), dropdownItems, props, Popup, popupInfo, showPopup, eventEmitter, this.hidePopup, this.execCommand);\n    };\n    return Toolbar;\n}(Component));\nvar templateObject_1$3, templateObject_2$2;\n\nvar ContextMenu = /** @class */ (function (_super) {\n    __extends$1(ContextMenu, _super);\n    function ContextMenu(props) {\n        var _this = _super.call(this, props) || this;\n        _this.handleClickDocument = function (ev) {\n            if (!closest(ev.target, \".\" + cls('context-menu'))) {\n                _this.setState({ pos: null });\n            }\n        };\n        _this.state = {\n            pos: null,\n            menuGroups: [],\n        };\n        _this.addEvent();\n        return _this;\n    }\n    ContextMenu.prototype.addEvent = function () {\n        var _this = this;\n        this.props.eventEmitter.listen('contextmenu', function (_a) {\n            var pos = _a.pos, menuGroups = _a.menuGroups;\n            _this.setState({ pos: pos, menuGroups: menuGroups });\n        });\n    };\n    ContextMenu.prototype.mounted = function () {\n        document.addEventListener('click', this.handleClickDocument);\n    };\n    ContextMenu.prototype.beforeDestroy = function () {\n        document.removeEventListener('click', this.handleClickDocument);\n    };\n    ContextMenu.prototype.getMenuGroupElements = function () {\n        var _this = this;\n        var _a = this.state, pos = _a.pos, menuGroups = _a.menuGroups;\n        return pos\n            ? menuGroups.reduce(function (acc, group) {\n                var menuItem = [];\n                group.forEach(function (_a) {\n                    var label = _a.label, _b = _a.className, className = _b === void 0 ? false : _b, disabled = _a.disabled, onClick = _a.onClick;\n                    var handleClick = function () {\n                        if (!disabled) {\n                            onClick();\n                            _this.setState({ pos: null });\n                        }\n                    };\n                    menuItem.push(html(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject([\"\\n                <li\\n                  onClick=\", \"\\n                  class=\\\"menu-item\", \"\\\"\\n                  aria-role=\\\"menuitem\\\"\\n                >\\n                  <span class=\\\"\", \"\\\">\", \"</span>\\n                </li>\\n              \"], [\"\\n                <li\\n                  onClick=\", \"\\n                  class=\\\"menu-item\", \"\\\"\\n                  aria-role=\\\"menuitem\\\"\\n                >\\n                  <span class=\\\"\", \"\\\">\", \"</span>\\n                </li>\\n              \"])), handleClick, disabled ? ' disabled' : '', className, label));\n                });\n                acc.push(html(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject([\"<ul class=\\\"menu-group\\\">\\n              \", \"\\n            </ul>\"], [\"<ul class=\\\"menu-group\\\">\\n              \", \"\\n            </ul>\"])), menuItem));\n                return acc;\n            }, [])\n            : [];\n    };\n    ContextMenu.prototype.render = function () {\n        var style = __assign$1({ display: this.state.pos ? 'block' : 'none' }, this.state.pos);\n        return html(templateObject_3 || (templateObject_3 = __makeTemplateObject([\"<div class=\\\"\", \"\\\" style=\", \" aria-role=\\\"menu\\\">\\n      \", \"\\n    </div>\"], [\"<div class=\\\"\", \"\\\" style=\", \" aria-role=\\\"menu\\\">\\n      \", \"\\n    </div>\"])), cls('context-menu'), style, this.getMenuGroupElements());\n    };\n    return ContextMenu;\n}(Component));\nvar templateObject_1$2, templateObject_2$1, templateObject_3;\n\nvar Layout = /** @class */ (function (_super) {\n    __extends$1(Layout, _super);\n    function Layout(props) {\n        var _this = _super.call(this, props) || this;\n        _this.changeMode = function (editorType) {\n            if (editorType !== _this.state.editorType) {\n                _this.setState({ editorType: editorType });\n            }\n        };\n        _this.changePreviewStyle = function (previewStyle) {\n            if (previewStyle !== _this.state.previewStyle) {\n                _this.setState({ previewStyle: previewStyle });\n            }\n        };\n        _this.hide = function () {\n            _this.setState({ hide: true });\n        };\n        _this.show = function () {\n            _this.setState({ hide: false });\n        };\n        var editorType = props.editorType, previewStyle = props.previewStyle;\n        _this.state = {\n            editorType: editorType,\n            previewStyle: previewStyle,\n            hide: false,\n        };\n        _this.addEvent();\n        return _this;\n    }\n    Layout.prototype.mounted = function () {\n        var _a = this.props.slots, wwEditor = _a.wwEditor, mdEditor = _a.mdEditor, mdPreview = _a.mdPreview;\n        this.refs.wwContainer.appendChild(wwEditor);\n        this.refs.mdContainer.insertAdjacentElement('afterbegin', mdEditor);\n        this.refs.mdContainer.appendChild(mdPreview);\n    };\n    Layout.prototype.insertToolbarItem = function (indexList, item) {\n        this.toolbar.insertToolbarItem(indexList, item);\n    };\n    Layout.prototype.removeToolbarItem = function (name) {\n        this.toolbar.removeToolbarItem(name);\n    };\n    Layout.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, eventEmitter = _a.eventEmitter, hideModeSwitch = _a.hideModeSwitch, toolbarItems = _a.toolbarItems, theme = _a.theme;\n        var _b = this.state, hide = _b.hide, previewStyle = _b.previewStyle, editorType = _b.editorType;\n        var displayClassName = hide ? ' hidden' : '';\n        var editorTypeClassName = cls(editorType === 'markdown' ? 'md-mode' : 'ww-mode');\n        var previewClassName = cls('md') + \"-\" + previewStyle + \"-style\";\n        var themeClassName = cls([theme !== 'light', theme + \" \"]);\n        return html(templateObject_2 || (templateObject_2 = __makeTemplateObject([\"\\n      <div\\n        class=\\\"\", \"\", \"\", \"\\\"\\n        ref=\", \"\\n      >\\n        <\", \"\\n          ref=\", \"\\n          eventEmitter=\", \"\\n          previewStyle=\", \"\\n          toolbarItems=\", \"\\n          editorType=\", \"\\n        />\\n        <div\\n          class=\\\"\", \" \", \"\\\"\\n          ref=\", \"\\n        >\\n          <div class=\\\"\", \"\\\">\\n            <div\\n              class=\\\"\", \" \", \"\\\"\\n              ref=\", \"\\n            >\\n              <div class=\\\"\", \"\\\"></div>\\n            </div>\\n            <div\\n              class=\\\"\", \"\\\"\\n              ref=\", \"\\n            />\\n          </div>\\n        </div>\\n        \", \"\\n        <\", \" eventEmitter=\", \" />\\n      </div>\\n    \"], [\"\\n      <div\\n        class=\\\"\", \"\", \"\", \"\\\"\\n        ref=\", \"\\n      >\\n        <\", \"\\n          ref=\", \"\\n          eventEmitter=\", \"\\n          previewStyle=\", \"\\n          toolbarItems=\", \"\\n          editorType=\", \"\\n        />\\n        <div\\n          class=\\\"\", \" \", \"\\\"\\n          ref=\", \"\\n        >\\n          <div class=\\\"\", \"\\\">\\n            <div\\n              class=\\\"\", \" \", \"\\\"\\n              ref=\", \"\\n            >\\n              <div class=\\\"\", \"\\\"></div>\\n            </div>\\n            <div\\n              class=\\\"\", \"\\\"\\n              ref=\", \"\\n            />\\n          </div>\\n        </div>\\n        \",\n            \"\\n        <\", \" eventEmitter=\", \" />\\n      </div>\\n    \"])), themeClassName, cls('defaultUI'), displayClassName, function (el) { return (_this.refs.el = el); }, Toolbar, function (toolbar) { return (_this.toolbar = toolbar); }, eventEmitter, previewStyle, toolbarItems, editorType, cls('main'), editorTypeClassName, function (el) { return (_this.refs.editorSection = el); }, cls('main-container'), cls('md-container'), previewClassName, function (el) { return (_this.refs.mdContainer = el); }, cls('md-splitter'), cls('ww-container'), function (el) { return (_this.refs.wwContainer = el); }, !hideModeSwitch && html(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject([\"<\", \" eventEmitter=\", \" editorType=\", \" />\"], [\"<\", \" eventEmitter=\", \" editorType=\", \" />\"])), Switch, eventEmitter, editorType), ContextMenu, eventEmitter);\n    };\n    Layout.prototype.addEvent = function () {\n        var eventEmitter = this.props.eventEmitter;\n        eventEmitter.listen('hide', this.hide);\n        eventEmitter.listen('show', this.show);\n        eventEmitter.listen('changeMode', this.changeMode);\n        eventEmitter.listen('changePreviewStyle', this.changePreviewStyle);\n    };\n    return Layout;\n}(Component));\nvar templateObject_1$1, templateObject_2;\n\n/**\n * ToastUI Editor\n * @extends ToastUIEditorCore\n */\nvar ToastUIEditor = /** @class */ (function (_super) {\n    __extends$1(ToastUIEditor, _super);\n    function ToastUIEditor(options) {\n        var _a;\n        var _this = _super.call(this, options) || this;\n        var layoutComp;\n        var destroy = render(_this.options.el, html(templateObject_1 || (templateObject_1 = __makeTemplateObject([\"\\n        <\", \"\\n          ref=\", \"\\n          eventEmitter=\", \"\\n          slots=\", \"\\n          hideModeSwitch=\", \"\\n          toolbarItems=\", \"\\n          previewStyle=\", \"\\n          editorType=\", \"\\n          theme=\", \"\\n        />\\n      \"], [\"\\n        <\", \"\\n          ref=\", \"\\n          eventEmitter=\", \"\\n          slots=\", \"\\n          hideModeSwitch=\", \"\\n          toolbarItems=\", \"\\n          previewStyle=\", \"\\n          editorType=\", \"\\n          theme=\", \"\\n        />\\n      \"])), Layout, function (layout) { return (layoutComp = layout); }, _this.eventEmitter, _this.getEditorElements(), _this.options.hideModeSwitch, _this.options.toolbarItems, _this.options.previewStyle, _this.options.initialEditType, _this.options.theme));\n        _this.setMinHeight(_this.options.minHeight);\n        _this.setHeight(_this.options.height);\n        _this.defaultUI = {\n            insertToolbarItem: layoutComp.insertToolbarItem.bind(layoutComp),\n            removeToolbarItem: layoutComp.removeToolbarItem.bind(layoutComp),\n            destroy: destroy,\n        };\n        (_a = _this.pluginInfo.toolbarItems) === null || _a === void 0 ? void 0 : _a.forEach(function (toolbarItem) {\n            var groupIndex = toolbarItem.groupIndex, itemIndex = toolbarItem.itemIndex, item = toolbarItem.item;\n            _this.defaultUI.insertToolbarItem({ groupIndex: groupIndex, itemIndex: itemIndex }, item);\n        });\n        _this.eventEmitter.emit('loadUI', _this);\n        return _this;\n    }\n    /**\n     * Factory method for Editor\n     * @param {object} options Option for initialize TUIEditor\n     * @returns {object} ToastUIEditor or ToastUIEditorViewer\n     */\n    ToastUIEditor.factory = function (options) {\n        return options.viewer ? new ToastUIEditorViewer(options) : new ToastUIEditor(options);\n    };\n    /**\n     * add toolbar item\n     * @param {Object} indexInfo group index and item index of the toolbar item\n     * @param {string|Object} item toolbar item\n     */\n    ToastUIEditor.prototype.insertToolbarItem = function (indexInfo, item) {\n        this.defaultUI.insertToolbarItem(indexInfo, item);\n    };\n    /**\n     * Remove toolbar item\n     * @param {string} itemName toolbar item name\n     */\n    ToastUIEditor.prototype.removeToolbarItem = function (itemName) {\n        this.defaultUI.removeToolbarItem(itemName);\n    };\n    /**\n     * Destroy TUIEditor from document\n     */\n    ToastUIEditor.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        this.defaultUI.destroy();\n    };\n    return ToastUIEditor;\n}(ToastUIEditorCore));\nvar templateObject_1;\n\n/**\n * @fileoverview I18N for English\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n */\nToastUIEditorCore.setLanguage(['en', 'en-US'], {\n    Markdown: 'Markdown',\n    WYSIWYG: 'WYSIWYG',\n    Write: 'Write',\n    Preview: 'Preview',\n    Headings: 'Headings',\n    Paragraph: 'Paragraph',\n    Bold: 'Bold',\n    Italic: 'Italic',\n    Strike: 'Strike',\n    Code: 'Inline code',\n    Line: 'Line',\n    Blockquote: 'Blockquote',\n    'Unordered list': 'Unordered list',\n    'Ordered list': 'Ordered list',\n    Task: 'Task',\n    Indent: 'Indent',\n    Outdent: 'Outdent',\n    'Insert link': 'Insert link',\n    'Insert CodeBlock': 'Insert codeBlock',\n    'Insert table': 'Insert table',\n    'Insert image': 'Insert image',\n    Heading: 'Heading',\n    'Image URL': 'Image URL',\n    'Select image file': 'Select image file',\n    'Choose a file': 'Choose a file',\n    'No file': 'No file',\n    Description: 'Description',\n    OK: 'OK',\n    More: 'More',\n    Cancel: 'Cancel',\n    File: 'File',\n    URL: 'URL',\n    'Link text': 'Link text',\n    'Add row to up': 'Add row to up',\n    'Add row to down': 'Add row to down',\n    'Add column to left': 'Add column to left',\n    'Add column to right': 'Add column to right',\n    'Remove row': 'Remove row',\n    'Remove column': 'Remove column',\n    'Align column to left': 'Align column to left',\n    'Align column to center': 'Align column to center',\n    'Align column to right': 'Align column to right',\n    'Remove table': 'Remove table',\n    'Would you like to paste as table?': 'Would you like to paste as table?',\n    'Text color': 'Text color',\n    'Auto scroll enabled': 'Auto scroll enabled',\n    'Auto scroll disabled': 'Auto scroll disabled',\n    'Choose language': 'Choose language',\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2VkaXRvci9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0g7QUFDekM7QUFDZ0I7QUFDaUQ7QUFDOUY7QUFDeUk7QUFDdkc7QUFDVDs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1Q0FBdUMsWUFBWSxLQUFLLE9BQU87QUFDaEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQSxJQUFJO0FBQ0osZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdB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S0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVDQUF1QztBQUM3RSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELCtEQUErRDtBQUNwSCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQ0FBMEM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBDQUEwQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUhBQWlILGlDQUFpQztBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGVBQWUsRUFBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsRUFBRSxnQ0FBZ0MsS0FBSyw2Q0FBNkMsS0FBSztBQUM5SSwyQ0FBMkMsS0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLFVBQVU7QUFDViw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsMkNBQTJDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEdBQUcsR0FBRyxHQUFHO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHdDQUF3QztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsVUFBVSxhQUFhLElBQUk7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixHQUFHLFdBQVcsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUk7QUFDakMsd0NBQXdDLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRztBQUMzRTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2Qyx5QkFBeUIsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyQ0FBMkM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGdCQUFnQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw0QkFBNEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFD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VjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsTUFBTTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsdUZBQXVGLGdFQUFnRTtBQUN2Sjs7QUFFQTtBQUNBLE1BQU0sd0NBQXdDLHdGQUF3RixvS0FBb0ssdUhBQXVILG1CQUFtQjtBQUNwYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMEJBQTBCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBEQUEwRCxnQ0FBZ0M7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlCQUFpQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHNCQUFzQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtEQUFrRDtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLDhCQUE4QixrREFBa0Q7QUFDaEY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG9CQUFvQjtBQUNsRiwyQ0FBMkM7QUFDM0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLCtDQUErQyxzQkFBc0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw4Q0FBOEM7QUFDaEcsNkNBQTZDLHNDQUFzQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQ0FBcUM7QUFDN0UsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixtQkFBbUIsVUFBVTtBQUM3QixtQkFBbUIsVUFBVTtBQUM3QixtQkFBbUIsVUFBVTtBQUM3QixtQkFBbUIsVUFBVTtBQUM3QixtQkFBbUIsVUFBVTtBQUM3QixtQkFBbUIsVUFBVTtBQUM3QixtQkFBbUIsVUFBVTtBQUM3QixtQkFBbUIsVUFBVTtBQUM3QixtQkFBbUIsVUFBVTtBQUM3QixlQUFlLFFBQVE7QUFDdkIsbUJBQW1CLGtCQUFrQjtBQUNyQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLGtDQUFrQztBQUNqRCxlQUFlLFNBQVM7QUFDeEIsZUFBZSx3QkFBd0I7QUFDdkMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsc0ZBQXNGLHNCQUFzQiwyREFBMkQ7QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtJQUFrSSxvQkFBb0I7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxnQ0FBZ0M7QUFDNUc7QUFDQTtBQUNBLDZFQUE2RSwyQkFBMkI7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0Isc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLHVCQUF1QjtBQUN0QyxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxpQkFBaUIsaUNBQWlDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSx5QkFBeUI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlDQUFpQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsZUFBZSx1QkFBdUI7QUFDdEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtEQUErRCxpRUFBaUU7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3REFBd0QsMkJBQTJCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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ekw7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGlCQUFpQjtBQUMvRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1vQkFBbW9CLCtCQUErQjtBQUNscUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDhDQUE4QztBQUM5RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRTZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktY29udGVudC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2VkaXRvci9kaXN0L2VzbS9pbmRleC5qcz8zNTVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHRvYXN0LXVpL2VkaXRvclxuICogQHZlcnNpb24gMy4yLjIgfCBGcmkgRmViIDE3IDIwMjNcbiAqIEBhdXRob3IgTkhOIENsb3VkIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuaW1wb3J0IHsgRnJhZ21lbnQsIFNjaGVtYSwgU2xpY2UsIE5vZGVSYW5nZSwgTWFyayBhcyBNYXJrJDEsIERPTVBhcnNlciwgTm9kZSBhcyBOb2RlJDMgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBEZWNvcmF0aW9uU2V0LCBEZWNvcmF0aW9uLCBFZGl0b3JWaWV3IH0gZnJvbSAncHJvc2VtaXJyb3Itdmlldyc7XG5pbXBvcnQgeyBSZXBsYWNlQXJvdW5kU3RlcCwgbGlmdFRhcmdldCwgY2FuU3BsaXQsIFN0ZXBNYXAgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiwgUGx1Z2luLCBQbHVnaW5LZXksIEVkaXRvclN0YXRlLCBBbGxTZWxlY3Rpb24sIFNlbGVjdGlvbiwgU2VsZWN0aW9uUmFuZ2UsIE5vZGVTZWxlY3Rpb24gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBrZXltYXAgfSBmcm9tICdwcm9zZW1pcnJvci1rZXltYXAnO1xuaW1wb3J0IHsgZGVsZXRlU2VsZWN0aW9uLCBzZWxlY3RBbGwsIGJhc2VLZXltYXAsIGNoYWluQ29tbWFuZHMsIGpvaW5Gb3J3YXJkLCBuZXdsaW5lSW5Db2RlLCBzZXRCbG9ja1R5cGUsIHdyYXBJbiwgdG9nZ2xlTWFyayBhcyB0b2dnbGVNYXJrJDEsIGV4aXRDb2RlIH0gZnJvbSAncHJvc2VtaXJyb3ItY29tbWFuZHMnO1xuaW1wb3J0IHsgSW5wdXRSdWxlLCBpbnB1dFJ1bGVzLCB1bmRvSW5wdXRSdWxlIH0gZnJvbSAncHJvc2VtaXJyb3ItaW5wdXRydWxlcyc7XG5pbXBvcnQgeyB1bmRvLCByZWRvLCBoaXN0b3J5LCB1bmRvRGVwdGggfSBmcm9tICdwcm9zZW1pcnJvci1oaXN0b3J5JztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzJDEgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzJDEgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzJDEoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMkMShkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MkMShkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24kMSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24kMSA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24kMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSQxKHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEV4ZWN1dGUgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggcHJvcGVydHkgb2Ygb2JqZWN0IHdoaWNoIGFjdHVhbGx5IGV4aXN0LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIHByb3BlcnR5IG9mIG9iamVjdCB3aGljaCBhY3R1YWxseSBleGlzdC5cbiAqIElmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLCB0aGUgbG9vcCB3aWxsIGJlIHN0b3BwZWQuXG4gKiBDYWxsYmFjayBmdW5jdGlvbihpdGVyYXRlZSkgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICAxKSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gKiAgMikgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4gKiAgMykgVGhlIG9iamVjdCBiZWluZyB0cmF2ZXJzZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCh0aGlzKSBvZiBjYWxsYmFjayBmdW5jdGlvblxuICogQG1lbWJlcm9mIG1vZHVsZTpjb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgZm9yRWFjaE93blByb3BlcnRpZXMgZnJvbSAndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL2ZvckVhY2hPd25Qcm9wZXJ0aWVzJztcbiAqIFxuICogLy8gQ29tbW9uSlNcbiAqIGNvbnN0IGZvckVhY2hPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL2ZvckVhY2hPd25Qcm9wZXJ0aWVzJyk7IFxuICpcbiAqIGxldCBzdW0gPSAwO1xuICpcbiAqIGZvckVhY2hPd25Qcm9wZXJ0aWVzKHthOjEsYjoyLGM6M30sIGZ1bmN0aW9uKHZhbHVlKXtcbiAqICAgc3VtICs9IHZhbHVlO1xuICogfSk7XG4gKiBhbGVydChzdW0pOyAvLyA2XG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hPd25Qcm9wZXJ0aWVzJDIob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICB2YXIga2V5O1xuXG4gIGNvbnRleHQgPSBjb250ZXh0IHx8IG51bGw7XG5cbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZvckVhY2hPd25Qcm9wZXJ0aWVzXzEgPSBmb3JFYWNoT3duUHJvcGVydGllcyQyO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXh0ZW5kIHRoZSB0YXJnZXQgb2JqZWN0IGZyb20gb3RoZXIgb2JqZWN0cy5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbi8qKlxuICogQG1vZHVsZSBvYmplY3RcbiAqL1xuXG4vKipcbiAqIEV4dGVuZCB0aGUgdGFyZ2V0IG9iamVjdCBmcm9tIG90aGVyIG9iamVjdHMuXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gT2JqZWN0IHRoYXQgd2lsbCBiZSBleHRlbmRlZFxuICogQHBhcmFtIHsuLi5vYmplY3R9IG9iamVjdHMgLSBPYmplY3RzIGFzIHNvdXJjZXNcbiAqIEByZXR1cm5zIHtvYmplY3R9IEV4dGVuZGVkIG9iamVjdFxuICogQG1lbWJlcm9mIG1vZHVsZTpvYmplY3RcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgb2JqZWN0cykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBoYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHNvdXJjZSwgcHJvcCwgaSwgbGVuO1xuXG4gIGZvciAoaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBleHRlbmRfMSA9IGV4dGVuZDtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgc3RyaW5nIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBzdHJpbmcgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgc3RyaW5nLCByZXR1cm4gdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIHN0cmluZz9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyQzKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHwgb2JqIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuXG52YXIgaXNTdHJpbmdfMSA9IGlzU3RyaW5nJDM7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBpbnN0YW5jZSBvZiBBcnJheSBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIGluc3RhbmNlIG9mIEFycmF5IG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBpbnN0YW5jZSBvZiBBcnJheSwgcmV0dXJuIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBhcnJheSBpbnN0YW5jZT9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc0FycmF5JDMob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBBcnJheTtcbn1cblxudmFyIGlzQXJyYXlfMSA9IGlzQXJyYXkkMztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEV4ZWN1dGUgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgaW4gYXNjZW5kaW5nIG9yZGVyLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIGVsZW1lbnQgcHJlc2VudFxuICogaW4gdGhlIGFycmF5KG9yIEFycmF5LWxpa2Ugb2JqZWN0KSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKiBJZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSwgdGhlIGxvb3Agd2lsbCBiZSBzdG9wcGVkLlxuICogQ2FsbGJhY2sgZnVuY3Rpb24oaXRlcmF0ZWUpIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAgMSkgVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50XG4gKiAgMikgVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50XG4gKiAgMykgVGhlIGFycmF5KG9yIEFycmF5LWxpa2Ugb2JqZWN0KSBiZWluZyB0cmF2ZXJzZWRcbiAqIEBwYXJhbSB7QXJyYXl8QXJndW1lbnRzfE5vZGVMaXN0fSBhcnIgVGhlIGFycmF5KG9yIEFycmF5LWxpa2Ugb2JqZWN0KSB0aGF0IHdpbGwgYmUgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSBDYWxsYmFjayBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0KHRoaXMpIG9mIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBmb3JFYWNoQXJyYXkgZnJvbSAndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL2ZvckVhY2hBcnJheSc7XG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBmb3JFYWNoQXJyYXkgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vZm9yRWFjaEFycmF5Jyk7IFxuICpcbiAqIGxldCBzdW0gPSAwO1xuICpcbiAqIGZvckVhY2hBcnJheShbMSwyLDNdLCBmdW5jdGlvbih2YWx1ZSl7XG4gKiAgIHN1bSArPSB2YWx1ZTtcbiAqIH0pO1xuICogYWxlcnQoc3VtKTsgLy8gNlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkkMyhhcnIsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGNvbnRleHQgPSBjb250ZXh0IHx8IG51bGw7XG5cbiAgZm9yICg7IGluZGV4IDwgbGVuOyBpbmRleCArPSAxKSB7XG4gICAgaWYgKGl0ZXJhdGVlLmNhbGwoY29udGV4dCwgYXJyW2luZGV4XSwgaW5kZXgsIGFycikgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxudmFyIGZvckVhY2hBcnJheV8xID0gZm9yRWFjaEFycmF5JDM7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIHByb3BlcnR5IG9mIG9iamVjdChvciBlbGVtZW50IG9mIGFycmF5KSB3aGljaCBhY3R1YWxseSBleGlzdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBpc0FycmF5JDIgPSBpc0FycmF5XzE7XG52YXIgZm9yRWFjaEFycmF5JDIgPSBmb3JFYWNoQXJyYXlfMTtcbnZhciBmb3JFYWNoT3duUHJvcGVydGllcyQxID0gZm9yRWFjaE93blByb3BlcnRpZXNfMTtcblxuLyoqXG4gKiBAbW9kdWxlIGNvbGxlY3Rpb25cbiAqL1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggcHJvcGVydHkgb2Ygb2JqZWN0KG9yIGVsZW1lbnQgb2YgYXJyYXkpIHdoaWNoIGFjdHVhbGx5IGV4aXN0LlxuICogSWYgdGhlIG9iamVjdCBpcyBBcnJheS1saWtlIG9iamVjdChleC1hcmd1bWVudHMgb2JqZWN0KSwgSXQgbmVlZHMgdG8gdHJhbnNmb3JtIHRvIEFycmF5LihzZWUgJ2V4Micgb2YgZXhhbXBsZSkuXG4gKiBJZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSwgdGhlIGxvb3Agd2lsbCBiZSBzdG9wcGVkLlxuICogQ2FsbGJhY2sgZnVuY3Rpb24oaXRlcmF0ZWUpIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAgMSkgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eShvciBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQpXG4gKiAgMikgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5KG9yIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudClcbiAqICAzKSBUaGUgb2JqZWN0IGJlaW5nIHRyYXZlcnNlZFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSB0cmF2ZXJzZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQodGhpcykgb2YgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29sbGVjdGlvblxuICogQGV4YW1wbGVcbiAqIC8vIEVTNlxuICogaW1wb3J0IGZvckVhY2ggZnJvbSAndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL2ZvckVhY2gnOyBcbiAqIFxuICogLy8gQ29tbW9uSlNcbiAqIGNvbnN0IGZvckVhY2ggPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vZm9yRWFjaCcpOyBcbiAqXG4gKiBsZXQgc3VtID0gMDtcbiAqXG4gKiBmb3JFYWNoKFsxLDIsM10sIGZ1bmN0aW9uKHZhbHVlKXtcbiAqICAgc3VtICs9IHZhbHVlO1xuICogfSk7XG4gKiBhbGVydChzdW0pOyAvLyA2XG4gKlxuICogLy8gSW4gY2FzZSBvZiBBcnJheS1saWtlIG9iamVjdFxuICogY29uc3QgYXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheUxpa2UpOyAvLyBjaGFuZ2UgdG8gYXJyYXlcbiAqIGZvckVhY2goYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAqICAgc3VtICs9IHZhbHVlO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gkNChvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gIGlmIChpc0FycmF5JDIob2JqKSkge1xuICAgIGZvckVhY2hBcnJheSQyKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIGZvckVhY2hPd25Qcm9wZXJ0aWVzJDEob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH1cbn1cblxudmFyIGZvckVhY2hfMSA9IGZvckVhY2gkNDtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNldHRpbmcgZWxlbWVudCBzdHlsZVxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGlzU3RyaW5nJDIgPSBpc1N0cmluZ18xO1xudmFyIGZvckVhY2gkMyA9IGZvckVhY2hfMTtcblxuLyoqXG4gKiBTZXR0aW5nIGVsZW1lbnQgc3R5bGVcbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IC0gZWxlbWVudCB0byBzZXR0aW5nIHN0eWxlXG4gKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0ga2V5IC0gc3R5bGUgcHJvcCBuYW1lIG9yIHtwcm9wOiB2YWx1ZX0gcGFpciBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdmFsdWVdIC0gc3R5bGUgdmFsdWVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiBjc3MoZWxlbWVudCwga2V5LCB2YWx1ZSkge1xuICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXG4gIGlmIChpc1N0cmluZyQyKGtleSkpIHtcbiAgICBzdHlsZVtrZXldID0gdmFsdWU7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBmb3JFYWNoJDMoa2V5LCBmdW5jdGlvbih2LCBrKSB7XG4gICAgc3R5bGVba10gPSB2O1xuICB9KTtcbn1cblxudmFyIGNzc18xID0gY3NzO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG5cbnZhciBpc0FycmF5JDEgPSBpc0FycmF5XzE7XG5cbi8qKlxuICogQG1vZHVsZSBhcnJheVxuICovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgYXJyYXlcbiAqIGZyb20gc3RhcnQgaW5kZXgoZGVmYXVsdCAwKSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gKiBJdCBjb21wYXJlcyBzZWFyY2hFbGVtZW50IHRvIGVsZW1lbnRzIG9mIHRoZSBBcnJheSB1c2luZyBzdHJpY3QgZXF1YWxpdHlcbiAqICh0aGUgc2FtZSBtZXRob2QgdXNlZCBieSB0aGUgPT09LCBvciB0cmlwbGUtZXF1YWxzLCBvcGVyYXRvcikuXG4gKiBAcGFyYW0geyp9IHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBsb2NhdGUgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0aGF0IHdpbGwgYmUgdHJhdmVyc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggU3RhcnQgaW5kZXggaW4gYXJyYXkgZm9yIHNlYXJjaGluZyAoZGVmYXVsdCAwKVxuICogQHJldHVybnMge251bWJlcn0gdGhlIEZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6YXJyYXlcbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBpbkFycmF5IGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvYXJyYXkvaW5BcnJheSc7XG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBpbkFycmF5ID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC9hcnJheS9pbkFycmF5Jyk7XG4gKlxuICogY29uc3QgYXJyID0gWydvbmUnLCAndHdvJywgJ3RocmVlJywgJ2ZvdXInXTtcbiAqIGNvbnN0IGlkeDEgPSBpbkFycmF5KCdvbmUnLCBhcnIsIDMpOyAvLyAtMVxuICogY29uc3QgaWR4MiA9IGluQXJyYXkoJ29uZScsIGFycik7IC8vIDBcbiAqL1xuZnVuY3Rpb24gaW5BcnJheSQ0KHNlYXJjaEVsZW1lbnQsIGFycmF5LCBzdGFydEluZGV4KSB7XG4gIHZhciBpO1xuICB2YXIgbGVuZ3RoO1xuICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuXG4gIGlmICghaXNBcnJheSQxKGFycmF5KSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGFycmF5LCBzZWFyY2hFbGVtZW50LCBzdGFydEluZGV4KTtcbiAgfVxuXG4gIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZm9yIChpID0gc3RhcnRJbmRleDsgc3RhcnRJbmRleCA+PSAwICYmIGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChhcnJheVtpXSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG52YXIgaW5BcnJheV8xID0gaW5BcnJheSQ0O1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgdW5kZWZpbmVkIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgdW5kZWZpbmVkIG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIHVuZGVmaW5lZD9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCQ0KG9iaikge1xuICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZpbmVkXG59XG5cbnZhciBpc1VuZGVmaW5lZF8xID0gaXNVbmRlZmluZWQkNDtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEdldCBIVE1MIGVsZW1lbnQncyBkZXNpZ24gY2xhc3Nlcy5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBpc1VuZGVmaW5lZCQzID0gaXNVbmRlZmluZWRfMTtcblxuLyoqXG4gKiBHZXQgSFRNTCBlbGVtZW50J3MgZGVzaWduIGNsYXNzZXMuXG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCB0YXJnZXQgZWxlbWVudFxuICogQHJldHVybnMge3N0cmluZ30gZWxlbWVudCBjc3MgY2xhc3MgbmFtZVxuICogQG1lbWJlcm9mIG1vZHVsZTpkb21VdGlsXG4gKi9cbmZ1bmN0aW9uIGdldENsYXNzJDMoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKGlzVW5kZWZpbmVkJDMoZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCkpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWU7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbDtcbn1cblxudmFyIGdldENsYXNzXzEgPSBnZXRDbGFzcyQzO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2V0IGNsYXNzTmFtZSB2YWx1ZVxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGlzQXJyYXkgPSBpc0FycmF5XzE7XG52YXIgaXNVbmRlZmluZWQkMiA9IGlzVW5kZWZpbmVkXzE7XG5cbi8qKlxuICogU2V0IGNsYXNzTmFtZSB2YWx1ZVxuICogQHBhcmFtIHsoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudCl9IGVsZW1lbnQgLSB0YXJnZXQgZWxlbWVudFxuICogQHBhcmFtIHsoc3RyaW5nfHN0cmluZ1tdKX0gY3NzQ2xhc3MgLSBjbGFzcyBuYW1lc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0Q2xhc3NOYW1lJDIoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgY3NzQ2xhc3MgPSBpc0FycmF5KGNzc0NsYXNzKSA/IGNzc0NsYXNzLmpvaW4oJyAnKSA6IGNzc0NsYXNzO1xuXG4gIGNzc0NsYXNzID0gY3NzQ2xhc3MucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblxuICBpZiAoaXNVbmRlZmluZWQkMihlbGVtZW50LmNsYXNzTmFtZS5iYXNlVmFsKSkge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY3NzQ2xhc3M7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50LmNsYXNzTmFtZS5iYXNlVmFsID0gY3NzQ2xhc3M7XG59XG5cbnZhciBfc2V0Q2xhc3NOYW1lID0gc2V0Q2xhc3NOYW1lJDI7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBBZGQgY3NzIGNsYXNzIHRvIGVsZW1lbnRcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBmb3JFYWNoJDIgPSBmb3JFYWNoXzE7XG52YXIgaW5BcnJheSQzID0gaW5BcnJheV8xO1xudmFyIGdldENsYXNzJDIgPSBnZXRDbGFzc18xO1xudmFyIHNldENsYXNzTmFtZSQxID0gX3NldENsYXNzTmFtZTtcblxuLyoqXG4gKiBkb21VdGlsIG1vZHVsZVxuICogQG1vZHVsZSBkb21VdGlsXG4gKi9cblxuLyoqXG4gKiBBZGQgY3NzIGNsYXNzIHRvIGVsZW1lbnRcbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IC0gdGFyZ2V0IGVsZW1lbnRcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBjc3NDbGFzcyAtIGNzcyBjbGFzc2VzIHRvIGFkZFxuICogQG1lbWJlcm9mIG1vZHVsZTpkb21VdGlsXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQpIHtcbiAgdmFyIGNzc0NsYXNzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGNsYXNzTGlzdCA9IGVsZW1lbnQuY2xhc3NMaXN0O1xuICB2YXIgbmV3Q2xhc3MgPSBbXTtcbiAgdmFyIG9yaWdpbjtcblxuICBpZiAoY2xhc3NMaXN0KSB7XG4gICAgZm9yRWFjaCQyKGNzc0NsYXNzLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQobmFtZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBvcmlnaW4gPSBnZXRDbGFzcyQyKGVsZW1lbnQpO1xuXG4gIGlmIChvcmlnaW4pIHtcbiAgICBjc3NDbGFzcyA9IFtdLmNvbmNhdChvcmlnaW4uc3BsaXQoL1xccysvKSwgY3NzQ2xhc3MpO1xuICB9XG5cbiAgZm9yRWFjaCQyKGNzc0NsYXNzLCBmdW5jdGlvbihjbHMpIHtcbiAgICBpZiAoaW5BcnJheSQzKGNscywgbmV3Q2xhc3MpIDwgMCkge1xuICAgICAgbmV3Q2xhc3MucHVzaChjbHMpO1xuICAgIH1cbiAgfSk7XG5cbiAgc2V0Q2xhc3NOYW1lJDEoZWxlbWVudCwgbmV3Q2xhc3MpO1xufVxuXG52YXIgYWRkQ2xhc3NfMSA9IGFkZENsYXNzO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVtb3ZlIGNzcyBjbGFzcyBmcm9tIGVsZW1lbnRcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBmb3JFYWNoQXJyYXkkMSA9IGZvckVhY2hBcnJheV8xO1xudmFyIGluQXJyYXkkMiA9IGluQXJyYXlfMTtcbnZhciBnZXRDbGFzcyQxID0gZ2V0Q2xhc3NfMTtcbnZhciBzZXRDbGFzc05hbWUgPSBfc2V0Q2xhc3NOYW1lO1xuXG4vKipcbiAqIFJlbW92ZSBjc3MgY2xhc3MgZnJvbSBlbGVtZW50XG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCAtIHRhcmdldCBlbGVtZW50XG4gKiBAcGFyYW0gey4uLnN0cmluZ30gY3NzQ2xhc3MgLSBjc3MgY2xhc3NlcyB0byByZW1vdmVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50KSB7XG4gIHZhciBjc3NDbGFzcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcbiAgdmFyIG9yaWdpbiwgbmV3Q2xhc3M7XG5cbiAgaWYgKGNsYXNzTGlzdCkge1xuICAgIGZvckVhY2hBcnJheSQxKGNzc0NsYXNzLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBjbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3JpZ2luID0gZ2V0Q2xhc3MkMShlbGVtZW50KS5zcGxpdCgvXFxzKy8pO1xuICBuZXdDbGFzcyA9IFtdO1xuICBmb3JFYWNoQXJyYXkkMShvcmlnaW4sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoaW5BcnJheSQyKG5hbWUsIGNzc0NsYXNzKSA8IDApIHtcbiAgICAgIG5ld0NsYXNzLnB1c2gobmFtZSk7XG4gICAgfVxuICB9KTtcblxuICBzZXRDbGFzc05hbWUoZWxlbWVudCwgbmV3Q2xhc3MpO1xufVxuXG52YXIgcmVtb3ZlQ2xhc3NfMSA9IHJlbW92ZUNsYXNzO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBudW1iZXIgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIG51bWJlciBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBudW1iZXIsIHJldHVybiB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgbnVtYmVyP1xuICogQG1lbWJlcm9mIG1vZHVsZTp0eXBlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTnVtYmVyO1xufVxuXG52YXIgaXNOdW1iZXJfMSA9IGlzTnVtYmVyO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgbnVsbCBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIG51bGwgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlKGFyZ3VtZW50c1swXSkgaXMgbnVsbCwgcmV0dXJucyB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgbnVsbD9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc051bGwkMShvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbn1cblxudmFyIGlzTnVsbF8xID0gaXNOdWxsJDE7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBSZXF1ZXN0IGltYWdlIHBpbmcuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgZm9yRWFjaE93blByb3BlcnRpZXMgPSBmb3JFYWNoT3duUHJvcGVydGllc18xO1xuXG4vKipcbiAqIEBtb2R1bGUgcmVxdWVzdFxuICovXG5cbi8qKlxuICogUmVxdWVzdCBpbWFnZSBwaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHVybCB1cmwgZm9yIHBpbmcgcmVxdWVzdFxuICogQHBhcmFtIHtPYmplY3R9IHRyYWNraW5nSW5mbyBpbmZvcyBmb3IgbWFrZSBxdWVyeSBzdHJpbmdcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAqIEBtZW1iZXJvZiBtb2R1bGU6cmVxdWVzdFxuICogQGV4YW1wbGVcbiAqIC8vIEVTNlxuICogaW1wb3J0IGltYWdlUGluZyBmcm9tICd0dWktY29kZS1zbmlwcGV0L3JlcXVlc3QvaW1hZ2VQaW5nJztcbiAqIFxuICogLy8gQ29tbW9uSlNcbiAqIGNvbnN0IGltYWdlUGluZyA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvcmVxdWVzdC9pbWFnZVBpbmcnKTtcbiAqXG4gKiBpbWFnZVBpbmcoJ2h0dHBzOi8vd3d3Lmdvb2dsZS1hbmFseXRpY3MuY29tL2NvbGxlY3QnLCB7XG4gKiAgIHY6IDEsXG4gKiAgIHQ6ICdldmVudCcsXG4gKiAgIHRpZDogJ3RyYWNraW5naWQnLFxuICogICBjaWQ6ICdjaWQnLFxuICogICBkcDogJ2RwJyxcbiAqICAgZGg6ICdkaCdcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBpbWFnZVBpbmckMSh1cmwsIHRyYWNraW5nSW5mbykge1xuICB2YXIgdHJhY2tpbmdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gIHZhciBxdWVyeVN0cmluZyA9ICcnO1xuICBmb3JFYWNoT3duUHJvcGVydGllcyh0cmFja2luZ0luZm8sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICBxdWVyeVN0cmluZyArPSAnJicgKyBrZXkgKyAnPScgKyB2YWx1ZTtcbiAgfSk7XG4gIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcuc3Vic3RyaW5nKDEpO1xuXG4gIHRyYWNraW5nRWxlbWVudC5zcmMgPSB1cmwgKyAnPycgKyBxdWVyeVN0cmluZztcblxuICB0cmFja2luZ0VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0cmFja2luZ0VsZW1lbnQpO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRyYWNraW5nRWxlbWVudCk7XG5cbiAgcmV0dXJuIHRyYWNraW5nRWxlbWVudDtcbn1cblxudmFyIGltYWdlUGluZ18xID0gaW1hZ2VQaW5nJDE7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBTZW5kIGhvc3RuYW1lIG9uIERPTUNvbnRlbnRMb2FkZWQuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaXNVbmRlZmluZWQkMSA9IGlzVW5kZWZpbmVkXzE7XG52YXIgaW1hZ2VQaW5nID0gaW1hZ2VQaW5nXzE7XG5cbnZhciBtczdkYXlzID0gNyAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGRhdGUgaGFzIHBhc3NlZCA3IGRheXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkYXRlIC0gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzRXhwaXJlZChkYXRlKSB7XG4gIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICByZXR1cm4gbm93IC0gZGF0ZSA+IG1zN2RheXM7XG59XG5cbi8qKlxuICogU2VuZCBob3N0bmFtZSBvbiBET01Db250ZW50TG9hZGVkLlxuICogVG8gcHJldmVudCBob3N0bmFtZSBzZXQgdHVpLnVzYWdlU3RhdGlzdGljcyB0byBmYWxzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcHBOYW1lIC0gYXBwbGljYXRpb24gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHRyYWNraW5nSWQgLSBHQSB0cmFja2luZyBJRFxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBzZW5kSG9zdG5hbWUoYXBwTmFtZSwgdHJhY2tpbmdJZCkge1xuICB2YXIgdXJsID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZS1hbmFseXRpY3MuY29tL2NvbGxlY3QnO1xuICB2YXIgaG9zdG5hbWUgPSBsb2NhdGlvbi5ob3N0bmFtZTtcbiAgdmFyIGhpdFR5cGUgPSAnZXZlbnQnO1xuICB2YXIgZXZlbnRDYXRlZ29yeSA9ICd1c2UnO1xuICB2YXIgYXBwbGljYXRpb25LZXlGb3JTdG9yYWdlID0gJ1RPQVNUIFVJICcgKyBhcHBOYW1lICsgJyBmb3IgJyArIGhvc3RuYW1lICsgJzogU3RhdGlzdGljcyc7XG4gIHZhciBkYXRlID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGFwcGxpY2F0aW9uS2V5Rm9yU3RvcmFnZSk7XG5cbiAgLy8gc2tpcCBpZiB0aGUgZmxhZyBpcyBkZWZpbmVkIGFuZCBpcyBzZXQgdG8gZmFsc2UgZXhwbGljaXRseVxuICBpZiAoIWlzVW5kZWZpbmVkJDEod2luZG93LnR1aSkgJiYgd2luZG93LnR1aS51c2FnZVN0YXRpc3RpY3MgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2tpcCBpZiBub3QgcGFzcyBzZXZlbiBkYXlzIG9sZFxuICBpZiAoZGF0ZSAmJiAhaXNFeHBpcmVkKGRhdGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGFwcGxpY2F0aW9uS2V5Rm9yU3RvcmFnZSwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgaW1hZ2VQaW5nKHVybCwge1xuICAgICAgICB2OiAxLFxuICAgICAgICB0OiBoaXRUeXBlLFxuICAgICAgICB0aWQ6IHRyYWNraW5nSWQsXG4gICAgICAgIGNpZDogaG9zdG5hbWUsXG4gICAgICAgIGRwOiBob3N0bmFtZSxcbiAgICAgICAgZGg6IGFwcE5hbWUsXG4gICAgICAgIGVsOiBhcHBOYW1lLFxuICAgICAgICBlYzogZXZlbnRDYXRlZ29yeVxuICAgICAgfSk7XG4gICAgfVxuICB9LCAxMDAwKTtcbn1cblxudmFyIHNlbmRIb3N0bmFtZV8xID0gc2VuZEhvc3RuYW1lO1xuXG4vTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG52YXIgcmVTcGFjZU1vcmVUaGFuT25lID0gL1tcXHUwMDIwXSsvZztcbnZhciByZUVzY2FwZUNoYXJzJDEgPSAvWz4oKXt9W1xcXSstLiEjfF0vZztcbnZhciByZUVzY2FwZUhUTUwgPSAvPChbYS16QS1aX11bYS16QS1aMC05XFwtLl9dKikoXFxzfFteXFxcXD5dKSpcXC8/Pnw8KFxcLykoW2EtekEtWl9dW2EtekEtWjAtOVxcLS5fXSopXFxzKlxcLz8+fDwhLS1bXi1dKy0tPnw8KFthLXpBLVpfXVthLXpBLVowLTlcXC0uOi9dKik+L2c7XG52YXIgcmVFc2NhcGVCYWNrU2xhc2ggPSAvXFxcXFshXCIjJCUmJygpKissLS4vOjs8PT4/QFtcXF1eX2B7fH1+XFxcXF0vZztcbnZhciByZUVzY2FwZVBhaXJlZENoYXJzID0gL1sqX35gXS9nO1xudmFyIHJlTWRJbWFnZVN5bnRheCA9IC8hXFxbLipcXF1cXCguKlxcKS9nO1xudmFyIHJlRXNjYXBlZENoYXJJbkxpbmtTeW50YXggPSAvW1tcXF1dL2c7XG52YXIgcmVFc2NhcGVCYWNrU2xhc2hJblNlbnRlbmNlID0gLyg/Ol58W15cXFxcXSlcXFxcKD8hXFxcXCkvZztcbnZhciBYTUxTUEVDSUFMJDEgPSAnWyY8PlwiXSc7XG52YXIgcmVYbWxTcGVjaWFsJDEgPSBuZXcgUmVnRXhwKFhNTFNQRUNJQUwkMSwgJ2cnKTtcbmZ1bmN0aW9uIHJlcGxhY2VVbnNhZmVDaGFyJDEoY2hhcikge1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgIHJldHVybiAnJmFtcDsnO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgIHJldHVybiAnJmx0Oyc7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICcmZ3Q7JztcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgcmV0dXJuICcmcXVvdDsnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNoYXI7XG4gICAgfVxufVxuZnVuY3Rpb24gZXNjYXBlWG1sJDEodGV4dCkge1xuICAgIGlmIChyZVhtbFNwZWNpYWwkMS50ZXN0KHRleHQpKSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UocmVYbWxTcGVjaWFsJDEsIHJlcGxhY2VVbnNhZmVDaGFyJDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIHNlbmRIb3N0TmFtZSgpIHtcbiAgICBzZW5kSG9zdG5hbWVfMSgnZWRpdG9yJywgJ1VBLTEyOTk2NjkyOS0xJyk7XG59XG5mdW5jdGlvbiBpbmNsdWRlcyhhcnIsIHRhcmdldEl0ZW0pIHtcbiAgICByZXR1cm4gYXJyLmluZGV4T2YodGFyZ2V0SXRlbSkgIT09IC0xO1xufVxudmFyIGF2YWlsYWJsZUxpbmtBdHRyaWJ1dGVzID0gWydyZWwnLCAndGFyZ2V0JywgJ2hyZWZsYW5nJywgJ3R5cGUnXTtcbnZhciByZU1hcmtkb3duVGV4dFRvRXNjYXBlTWFwID0ge1xuICAgIGNvZGVibG9jazogLyheIHs0fVteXFxuXStcXG4qKSsvLFxuICAgIHRoZW1hdGljQnJlYWs6IC9eICooKFxcKiAqKXszLH18KC0gKil7Myx9ICp8KF8gKil7Myx9KSAqLyxcbiAgICBhdHhIZWFkaW5nOiAvXigjezEsNn0pICtbXFxzXFxTXSsvLFxuICAgIHNlVGV4dGhlYWRpbmc6IC9eKFteXFxuXSspXFxuICooPXwtKXsyLH0gKi8sXG4gICAgYmxvY2txdW90ZTogL14oICo+W15cXG5dKy4qKSsvLFxuICAgIGxpc3Q6IC9eICooXFwqK3wtK3xcXGQrXFwuKSBbXFxzXFxTXSsvLFxuICAgIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICtbXCIoXShbXlxcbl0rKVtcIildKT8gKi8sXG4gICAgbGluazogLyE/XFxbLipcXF1cXCguKlxcKS8sXG4gICAgcmVmbGluazogLyE/XFxbLipcXF1cXHMqXFxbKFteXFxdXSopXFxdLyxcbiAgICB2ZXJ0aWNhbEJhcjogL1xcdTAwN0MvLFxuICAgIGZlbmNlZENvZGVibG9jazogL14oKGB8fil7Myx9KS8sXG59O1xuZnVuY3Rpb24gc2FuaXRpemVMaW5rQXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICAgIGlmICghYXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbGlua0F0dHJpYnV0ZXMgPSB7fTtcbiAgICBhdmFpbGFibGVMaW5rQXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZF8xKGF0dHJpYnV0ZVtrZXldKSkge1xuICAgICAgICAgICAgbGlua0F0dHJpYnV0ZXNba2V5XSA9IGF0dHJpYnV0ZVtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGxpbmtBdHRyaWJ1dGVzO1xufVxuZnVuY3Rpb24gcmVwZWF0JDEodGV4dCwgY291bnQpIHtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHJlc3VsdCArPSB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNOZWVkRXNjYXBlVGV4dCh0ZXh0KSB7XG4gICAgdmFyIG5lZWRFc2NhcGUgPSBmYWxzZTtcbiAgICBmb3JFYWNoT3duUHJvcGVydGllc18xKHJlTWFya2Rvd25UZXh0VG9Fc2NhcGVNYXAsIGZ1bmN0aW9uIChyZU1hcmtkb3duVGV4dFRvRXNjYXBlKSB7XG4gICAgICAgIGlmIChyZU1hcmtkb3duVGV4dFRvRXNjYXBlLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgIG5lZWRFc2NhcGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhbmVlZEVzY2FwZTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmVlZEVzY2FwZTtcbn1cbmZ1bmN0aW9uIGVzY2FwZVRleHRGb3JMaW5rKHRleHQpIHtcbiAgICB2YXIgaW1hZ2VTeW50YXhSYW5nZXMgPSBbXTtcbiAgICB2YXIgcmVzdWx0ID0gcmVNZEltYWdlU3ludGF4LmV4ZWModGV4dCk7XG4gICAgd2hpbGUgKHJlc3VsdCkge1xuICAgICAgICBpbWFnZVN5bnRheFJhbmdlcy5wdXNoKFtyZXN1bHQuaW5kZXgsIHJlc3VsdC5pbmRleCArIHJlc3VsdFswXS5sZW5ndGhdKTtcbiAgICAgICAgcmVzdWx0ID0gcmVNZEltYWdlU3ludGF4LmV4ZWModGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UocmVFc2NhcGVkQ2hhckluTGlua1N5bnRheCwgZnVuY3Rpb24gKG1hdGNoZWQsIG9mZnNldCkge1xuICAgICAgICB2YXIgaXNEZWxpbWl0ZXIgPSBpbWFnZVN5bnRheFJhbmdlcy5zb21lKGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gb2Zmc2V0ID4gcmFuZ2VbMF0gJiYgb2Zmc2V0IDwgcmFuZ2VbMV07IH0pO1xuICAgICAgICByZXR1cm4gaXNEZWxpbWl0ZXIgPyBtYXRjaGVkIDogXCJcXFxcXCIgKyBtYXRjaGVkO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZXNjYXBlJDEodGV4dCkge1xuICAgIHZhciBhaGVhZFJlcGxhY2VyID0gZnVuY3Rpb24gKG1hdGNoZWQpIHsgcmV0dXJuIFwiXFxcXFwiICsgbWF0Y2hlZDsgfTtcbiAgICB2YXIgYmVoaW5kUmVwbGFjZXIgPSBmdW5jdGlvbiAobWF0Y2hlZCkgeyByZXR1cm4gbWF0Y2hlZCArIFwiXFxcXFwiOyB9O1xuICAgIHZhciBlc2NhcGVkVGV4dCA9IHRleHQucmVwbGFjZShyZVNwYWNlTW9yZVRoYW5PbmUsICcgJyk7XG4gICAgaWYgKHJlRXNjYXBlQmFja1NsYXNoLnRlc3QoZXNjYXBlZFRleHQpKSB7XG4gICAgICAgIGVzY2FwZWRUZXh0ID0gZXNjYXBlZFRleHQucmVwbGFjZShyZUVzY2FwZUJhY2tTbGFzaCwgYWhlYWRSZXBsYWNlcik7XG4gICAgfVxuICAgIGlmIChyZUVzY2FwZUJhY2tTbGFzaEluU2VudGVuY2UudGVzdChlc2NhcGVkVGV4dCkpIHtcbiAgICAgICAgZXNjYXBlZFRleHQgPSBlc2NhcGVkVGV4dC5yZXBsYWNlKHJlRXNjYXBlQmFja1NsYXNoSW5TZW50ZW5jZSwgYmVoaW5kUmVwbGFjZXIpO1xuICAgIH1cbiAgICBlc2NhcGVkVGV4dCA9IGVzY2FwZWRUZXh0LnJlcGxhY2UocmVFc2NhcGVQYWlyZWRDaGFycywgYWhlYWRSZXBsYWNlcik7XG4gICAgaWYgKHJlRXNjYXBlSFRNTC50ZXN0KGVzY2FwZWRUZXh0KSkge1xuICAgICAgICBlc2NhcGVkVGV4dCA9IGVzY2FwZWRUZXh0LnJlcGxhY2UocmVFc2NhcGVIVE1MLCBhaGVhZFJlcGxhY2VyKTtcbiAgICB9XG4gICAgaWYgKGlzTmVlZEVzY2FwZVRleHQoZXNjYXBlZFRleHQpKSB7XG4gICAgICAgIGVzY2FwZWRUZXh0ID0gZXNjYXBlZFRleHQucmVwbGFjZShyZUVzY2FwZUNoYXJzJDEsIGFoZWFkUmVwbGFjZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZXNjYXBlZFRleHQ7XG59XG5mdW5jdGlvbiBxdW90ZSh0ZXh0KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAodGV4dC5pbmRleE9mKCdcIicpID09PSAtMSkge1xuICAgICAgICByZXN1bHQgPSAnXCJcIic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0ZXh0LmluZGV4T2YoXCInXCIpID09PSAtMSA/IFwiJydcIiA6ICcoKSc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRbMF0gKyB0ZXh0ICsgcmVzdWx0WzFdO1xufVxuZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgICByZXR1cm4gaXNOdWxsXzEodmFsdWUpIHx8IGlzVW5kZWZpbmVkXzEodmFsdWUpO1xufVxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG8xLCBvMikge1xuICAgIGlmIChvMSA9PT0gbnVsbCAmJiBvMSA9PT0gbzIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbzEgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBvMiAhPT0gJ29iamVjdCcgfHwgaXNOaWwobzEpIHx8IGlzTmlsKG8yKSkge1xuICAgICAgICByZXR1cm4gbzEgPT09IG8yO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gbzEpIHtcbiAgICAgICAgaWYgKG8xW2tleV0gIT09IG8yW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gbzIpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIG8xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbGFzdCQxKGFycikge1xuICAgIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gYmV0d2VlbiQxKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIHJldHVybiB2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPD0gbWF4O1xufVxuZnVuY3Rpb24gaXNPYmplY3QkMShvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsO1xufVxuZnVuY3Rpb24gZGVlcE1lcmdlZENvcHkodGFyZ2V0T2JqLCBvYmopIHtcbiAgICB2YXIgcmVzdWx0T2JqID0gX19hc3NpZ24kMSh7fSwgdGFyZ2V0T2JqKTtcbiAgICBpZiAodGFyZ2V0T2JqICYmIG9iaikge1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdCQxKHJlc3VsdE9ialtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE9ialtwcm9wXSA9IGRlZXBDb3B5QXJyYXkob2JqW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0T2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE9ialtwcm9wXSA9IGRlZXBNZXJnZWRDb3B5KHJlc3VsdE9ialtwcm9wXSwgb2JqW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE9ialtwcm9wXSA9IGRlZXBDb3B5KG9ialtwcm9wXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0T2JqW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdE9iajtcbn1cbmZ1bmN0aW9uIGRlZXBDb3B5QXJyYXkoaXRlbXMpIHtcbiAgICByZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpc09iamVjdCQxKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShpdGVtKSA/IGRlZXBDb3B5QXJyYXkoaXRlbSkgOiBkZWVwQ29weShpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRlZXBDb3B5KG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwcm9wKSB7XG4gICAgICAgIGlmIChpc09iamVjdCQxKG9ialtwcm9wXSkpIHtcbiAgICAgICAgICAgIGFjY1twcm9wXSA9IEFycmF5LmlzQXJyYXkob2JqW3Byb3BdKSA/IGRlZXBDb3B5QXJyYXkob2JqW3Byb3BdKSA6IGRlZXBDb3B5KG9ialtwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY2NbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0T2JqLCBvYmopIHtcbiAgICBpZiAob2JqID09PSB2b2lkIDApIHsgb2JqID0ge307IH1cbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgaWYgKHRhcmdldE9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiB0eXBlb2YgdGFyZ2V0T2JqW3Byb3BdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldE9ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2lnbih0YXJnZXRPYmpbcHJvcF0sIG9ialtwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRPYmpbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0T2JqO1xufVxuZnVuY3Rpb24gZ2V0U29ydGVkTnVtUGFpcih2YWx1ZUEsIHZhbHVlQikge1xuICAgIHJldHVybiB2YWx1ZUEgPiB2YWx1ZUIgPyBbdmFsdWVCLCB2YWx1ZUFdIDogW3ZhbHVlQSwgdmFsdWVCXTtcbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRyYW5zZm9ybSB0aGUgQXJyYXktbGlrZSBvYmplY3QgdG8gQXJyYXkuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgZm9yRWFjaEFycmF5ID0gZm9yRWFjaEFycmF5XzE7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBBcnJheS1saWtlIG9iamVjdCB0byBBcnJheS5cbiAqIEluIGxvdyBJRSAoYmVsb3cgOCksIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsIGlzIG5vdCBwZXJmZWN0LiBTbywgdHJ5LWNhdGNoIHN0YXRlbWVudCBpcyB1c2VkLlxuICogQHBhcmFtIHsqfSBhcnJheUxpa2UgQXJyYXktbGlrZSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXlcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29sbGVjdGlvblxuICogQGV4YW1wbGVcbiAqIC8vIEVTNlxuICogaW1wb3J0IHRvQXJyYXkgZnJvbSAndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL3RvQXJyYXknOyBcbiAqIFxuICogLy8gQ29tbW9uSlNcbiAqIGNvbnN0IHRvQXJyYXkgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vdG9BcnJheScpOyBcbiAqXG4gKiBjb25zdCBhcnJheUxpa2UgPSB7XG4gKiAgIDA6ICdvbmUnLFxuICogICAxOiAndHdvJyxcbiAqICAgMjogJ3RocmVlJyxcbiAqICAgMzogJ2ZvdXInLFxuICogICBsZW5ndGg6IDRcbiAqIH07XG4gKiBjb25zdCByZXN1bHQgPSB0b0FycmF5KGFycmF5TGlrZSk7XG4gKlxuICogYWxlcnQocmVzdWx0IGluc3RhbmNlb2YgQXJyYXkpOyAvLyB0cnVlXG4gKiBhbGVydChyZXN1bHQpOyAvLyBvbmUsdHdvLHRocmVlLGZvdXJcbiAqL1xuZnVuY3Rpb24gdG9BcnJheSQxKGFycmF5TGlrZSkge1xuICB2YXIgYXJyO1xuICB0cnkge1xuICAgIGFyciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhcnIgPSBbXTtcbiAgICBmb3JFYWNoQXJyYXkoYXJyYXlMaWtlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgYXJyLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn1cblxudmFyIHRvQXJyYXlfMSA9IHRvQXJyYXkkMTtcblxuZnVuY3Rpb24gY3JlYXRlUGFyYWdyYXBoKHNjaGVtYSwgY29udGVudCkge1xuICAgIHZhciBwYXJhZ3JhcGggPSBzY2hlbWEubm9kZXMucGFyYWdyYXBoO1xuICAgIGlmICghY29udGVudCkge1xuICAgICAgICByZXR1cm4gcGFyYWdyYXBoLmNyZWF0ZUFuZEZpbGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFncmFwaC5jcmVhdGUobnVsbCwgaXNTdHJpbmdfMShjb250ZW50KSA/IHNjaGVtYS50ZXh0KGNvbnRlbnQpIDogY29udGVudCk7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgdGV4dCwgbWFya3MpIHtcbiAgICByZXR1cm4gc2NoZW1hLnRleHQodGV4dCwgbWFya3MpO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgZnJvbSwgdG8pIHtcbiAgICBpZiAodG8gPT09IHZvaWQgMCkgeyB0byA9IGZyb207IH1cbiAgICB2YXIgY29udGVudFNpemUgPSB0ci5kb2MuY29udGVudC5zaXplO1xuICAgIHZhciBzaXplID0gY29udGVudFNpemUgPiAwID8gY29udGVudFNpemUgLSAxIDogMTtcbiAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBNYXRoLm1pbihmcm9tLCBzaXplKSwgTWF0aC5taW4odG8sIHNpemUpKTtcbn1cbmZ1bmN0aW9uIGFkZFBhcmFncmFwaCh0ciwgX2EsIHNjaGVtYSkge1xuICAgIHZhciBwb3MgPSBfYS5wb3M7XG4gICAgdHIucmVwbGFjZVdpdGgocG9zLCBwb3MsIGNyZWF0ZVBhcmFncmFwaChzY2hlbWEpKTtcbiAgICByZXR1cm4gdHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHBvcyArIDEpKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VUZXh0Tm9kZShfYSkge1xuICAgIHZhciBzdGF0ZSA9IF9hLnN0YXRlLCBmcm9tID0gX2EuZnJvbSwgc3RhcnRJbmRleCA9IF9hLnN0YXJ0SW5kZXgsIGVuZEluZGV4ID0gX2EuZW5kSW5kZXgsIGNyZWF0ZVRleHQgPSBfYS5jcmVhdGVUZXh0O1xuICAgIHZhciB0ciA9IHN0YXRlLnRyLCBkb2MgPSBzdGF0ZS5kb2MsIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8PSBlbmRJbmRleDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBfYiA9IGRvYy5jaGlsZChpKSwgbm9kZVNpemUgPSBfYi5ub2RlU2l6ZSwgdGV4dENvbnRlbnQgPSBfYi50ZXh0Q29udGVudCwgY29udGVudCA9IF9iLmNvbnRlbnQ7XG4gICAgICAgIHZhciB0ZXh0ID0gY3JlYXRlVGV4dCh0ZXh0Q29udGVudCk7XG4gICAgICAgIHZhciBub2RlID0gdGV4dCA/IGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCB0ZXh0KSA6IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICB2YXIgbWFwcGVkRnJvbSA9IHRyLm1hcHBpbmcubWFwKGZyb20pO1xuICAgICAgICB2YXIgbWFwcGVkVG8gPSBtYXBwZWRGcm9tICsgY29udGVudC5zaXplO1xuICAgICAgICB0ci5yZXBsYWNlV2l0aChtYXBwZWRGcm9tLCBtYXBwZWRUbywgbm9kZSk7XG4gICAgICAgIGZyb20gKz0gbm9kZVNpemU7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIHNwbGl0QW5kRXh0ZW5kQmxvY2sodHIsIHBvcywgdGV4dCwgbm9kZSkge1xuICAgIHZhciB0ZXh0TGVuID0gdGV4dC5sZW5ndGg7XG4gICAgdHIuc3BsaXQocG9zKVxuICAgICAgICAuZGVsZXRlKHBvcyAtIHRleHRMZW4sIHBvcylcbiAgICAgICAgLmluc2VydCh0ci5tYXBwaW5nLm1hcChwb3MpLCBub2RlKVxuICAgICAgICAuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHRyLm1hcHBpbmcubWFwKHBvcykgLSB0ZXh0TGVuKSk7XG59XG5cbmZ1bmN0aW9uIGdldE1kU3RhcnRMaW5lKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUuc291cmNlcG9zWzBdWzBdO1xufVxuZnVuY3Rpb24gZ2V0TWRFbmRMaW5lKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUuc291cmNlcG9zWzFdWzBdO1xufVxuZnVuY3Rpb24gZ2V0TWRTdGFydENoKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUuc291cmNlcG9zWzBdWzFdO1xufVxuZnVuY3Rpb24gZ2V0TWRFbmRDaChtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlLnNvdXJjZXBvc1sxXVsxXTtcbn1cbmZ1bmN0aW9uIGlzSFRNTE5vZGUobWROb2RlKSB7XG4gICAgdmFyIHR5cGUgPSBtZE5vZGUudHlwZTtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2h0bWxCbG9jaycgfHwgdHlwZSA9PT0gJ2h0bWxJbmxpbmUnO1xufVxuZnVuY3Rpb24gaXNTdHlsZWRJbmxpbmVOb2RlKG1kTm9kZSkge1xuICAgIHZhciB0eXBlID0gbWROb2RlLnR5cGU7XG4gICAgcmV0dXJuICh0eXBlID09PSAnc3RyaWtlJyB8fFxuICAgICAgICB0eXBlID09PSAnc3Ryb25nJyB8fFxuICAgICAgICB0eXBlID09PSAnZW1waCcgfHxcbiAgICAgICAgdHlwZSA9PT0gJ2NvZGUnIHx8XG4gICAgICAgIHR5cGUgPT09ICdsaW5rJyB8fFxuICAgICAgICB0eXBlID09PSAnaW1hZ2UnKTtcbn1cbmZ1bmN0aW9uIGlzQ29kZUJsb2NrTm9kZShtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlICYmIG1kTm9kZS50eXBlID09PSAnY29kZUJsb2NrJztcbn1cbmZ1bmN0aW9uIGlzTGlzdE5vZGUkMShtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlICYmIChtZE5vZGUudHlwZSA9PT0gJ2l0ZW0nIHx8IG1kTm9kZS50eXBlID09PSAnbGlzdCcpO1xufVxuZnVuY3Rpb24gaXNPcmRlcmVkTGlzdE5vZGUobWROb2RlKSB7XG4gICAgcmV0dXJuIGlzTGlzdE5vZGUkMShtZE5vZGUpICYmIG1kTm9kZS5saXN0RGF0YS50eXBlID09PSAnb3JkZXJlZCc7XG59XG5mdW5jdGlvbiBpc0J1bGxldExpc3ROb2RlKG1kTm9kZSkge1xuICAgIHJldHVybiBpc0xpc3ROb2RlJDEobWROb2RlKSAmJiBtZE5vZGUubGlzdERhdGEudHlwZSAhPT0gJ29yZGVyZWQnO1xufVxuZnVuY3Rpb24gaXNUYWJsZUNlbGxOb2RlKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUgJiYgKG1kTm9kZS50eXBlID09PSAndGFibGVDZWxsJyB8fCBtZE5vZGUudHlwZSA9PT0gJ3RhYmxlRGVsaW1DZWxsJyk7XG59XG5mdW5jdGlvbiBpc0lubGluZU5vZGUkMShtZE5vZGUpIHtcbiAgICBzd2l0Y2ggKG1kTm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NvZGUnOlxuICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgY2FzZSAnZW1waCc6XG4gICAgICAgIGNhc2UgJ3N0cm9uZyc6XG4gICAgICAgIGNhc2UgJ3N0cmlrZSc6XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgIGNhc2UgJ2h0bWxJbmxpbmUnOlxuICAgICAgICBjYXNlICdsaW5lYnJlYWsnOlxuICAgICAgICBjYXNlICdzb2Z0YnJlYWsnOlxuICAgICAgICBjYXNlICdjdXN0b21JbmxpbmUnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZENsb3Nlc3ROb2RlKG1kTm9kZSwgY29uZGl0aW9uLCBpbmNsdWRlU2VsZikge1xuICAgIGlmIChpbmNsdWRlU2VsZiA9PT0gdm9pZCAwKSB7IGluY2x1ZGVTZWxmID0gdHJ1ZTsgfVxuICAgIG1kTm9kZSA9IGluY2x1ZGVTZWxmID8gbWROb2RlIDogbWROb2RlLnBhcmVudDtcbiAgICB3aGlsZSAobWROb2RlICYmIG1kTm9kZS50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24obWROb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1kTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBtZE5vZGUgPSBtZE5vZGUucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUGFyZW50Tm9kZXMobWROb2RlLCBpdGVyYXRlZSwgaW5jbHVkZVNlbGYpIHtcbiAgICBpZiAoaW5jbHVkZVNlbGYgPT09IHZvaWQgMCkgeyBpbmNsdWRlU2VsZiA9IHRydWU7IH1cbiAgICBtZE5vZGUgPSBpbmNsdWRlU2VsZiA/IG1kTm9kZSA6IG1kTm9kZS5wYXJlbnQ7XG4gICAgd2hpbGUgKG1kTm9kZSAmJiBtZE5vZGUudHlwZSAhPT0gJ2RvY3VtZW50Jykge1xuICAgICAgICBpdGVyYXRlZShtZE5vZGUpO1xuICAgICAgICBtZE5vZGUgPSBtZE5vZGUucGFyZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZE9mZnNldFBvcyhvcmlnaW5Qb3MsIG9mZnNldCkge1xuICAgIHJldHVybiBbb3JpZ2luUG9zWzBdLCBvcmlnaW5Qb3NbMV0gKyBvZmZzZXRdO1xufVxuZnVuY3Rpb24gc2V0T2Zmc2V0UG9zKG9yaWdpblBvcywgbmV3T2Zmc2V0KSB7XG4gICAgcmV0dXJuIFtvcmlnaW5Qb3NbMF0sIG5ld09mZnNldF07XG59XG5mdW5jdGlvbiBnZXRJbmxpbmVNYXJrZG93blRleHQobWROb2RlKSB7XG4gICAgdmFyIHRleHQgPSBtZE5vZGUuZmlyc3RDaGlsZC5saXRlcmFsO1xuICAgIHN3aXRjaCAobWROb2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZW1waCc6XG4gICAgICAgICAgICByZXR1cm4gXCIqXCIgKyB0ZXh0ICsgXCIqXCI7XG4gICAgICAgIGNhc2UgJ3N0cm9uZyc6XG4gICAgICAgICAgICByZXR1cm4gXCIqKlwiICsgdGV4dCArIFwiKipcIjtcbiAgICAgICAgY2FzZSAnc3RyaWtlJzpcbiAgICAgICAgICAgIHJldHVybiBcIn5+XCIgKyB0ZXh0ICsgXCJ+flwiO1xuICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICAgIHJldHVybiBcImBcIiArIHRleHQgKyBcImBcIjtcbiAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNhc2UtZGVjbGFyYXRpb25zICovXG4gICAgICAgICAgICB2YXIgX2EgPSBtZE5vZGUsIGRlc3RpbmF0aW9uID0gX2EuZGVzdGluYXRpb24sIHRpdGxlID0gX2EudGl0bGU7XG4gICAgICAgICAgICB2YXIgZGVsaW0gPSBtZE5vZGUudHlwZSA9PT0gJ2xpbmsnID8gJycgOiAnISc7XG4gICAgICAgICAgICByZXR1cm4gZGVsaW0gKyBcIltcIiArIHRleHQgKyBcIl0oXCIgKyBkZXN0aW5hdGlvbiArICh0aXRsZSA/IFwiIFxcXCJcIiArIHRpdGxlICsgXCJcXFwiXCIgOiAnJykgKyBcIilcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQ29udGFpbmVyJDIobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgY2FzZSAnYmxvY2tRdW90ZSc6XG4gICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICBjYXNlICdpdGVtJzpcbiAgICAgICAgY2FzZSAncGFyYWdyYXBoJzpcbiAgICAgICAgY2FzZSAnaGVhZGluZyc6XG4gICAgICAgIGNhc2UgJ2VtcGgnOlxuICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICBjYXNlICdzdHJpa2UnOlxuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlSGVhZCc6XG4gICAgICAgIGNhc2UgJ3RhYmxlQm9keSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlUm93JzpcbiAgICAgICAgY2FzZSAndGFibGVDZWxsJzpcbiAgICAgICAgY2FzZSAndGFibGVEZWxpbVJvdyc6XG4gICAgICAgIGNhc2UgJ2N1c3RvbUlubGluZSc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlblRleHQkMShub2RlKSB7XG4gICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgIHZhciB3YWxrZXIgPSBub2RlLndhbGtlcigpO1xuICAgIHZhciBldmVudCA9IG51bGw7XG4gICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSBldmVudC5ub2RlO1xuICAgICAgICBpZiAoY2hpbGROb2RlLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgYnVmZmVyLnB1c2goY2hpbGROb2RlLmxpdGVyYWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbignJyk7XG59XG5cbnZhciB3aWRnZXRSdWxlcyA9IFtdO1xudmFyIHdpZGdldFJ1bGVNYXAgPSB7fTtcbnZhciByZVdpZGdldFByZWZpeCA9IC9cXCRcXCR3aWRnZXRcXGQrXFxzLztcbmZ1bmN0aW9uIHVud3JhcFdpZGdldFN5bnRheCh0ZXh0KSB7XG4gICAgdmFyIGluZGV4ID0gdGV4dC5zZWFyY2gocmVXaWRnZXRQcmVmaXgpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0ZXh0LnN1YnN0cmluZyhpbmRleCk7XG4gICAgICAgIHZhciByZXBsYWNlZCA9IHJlc3QucmVwbGFjZShyZVdpZGdldFByZWZpeCwgJycpLnJlcGxhY2UoJyQkJywgJycpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICB0ZXh0ICs9IHVud3JhcFdpZGdldFN5bnRheChyZXBsYWNlZCk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gY3JlYXRlV2lkZ2V0Q29udGVudChpbmZvLCB0ZXh0KSB7XG4gICAgcmV0dXJuIFwiJCRcIiArIGluZm8gKyBcIiBcIiArIHRleHQgKyBcIiQkXCI7XG59XG5mdW5jdGlvbiB3aWRnZXRUb0RPTShpbmZvLCB0ZXh0KSB7XG4gICAgdmFyIF9hID0gd2lkZ2V0UnVsZU1hcFtpbmZvXSwgcnVsZSA9IF9hLnJ1bGUsIHRvRE9NID0gX2EudG9ET007XG4gICAgdmFyIG1hdGNoZXMgPSB1bndyYXBXaWRnZXRTeW50YXgodGV4dCkubWF0Y2gocnVsZSk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgdGV4dCA9IG1hdGNoZXNbMF07XG4gICAgfVxuICAgIHJldHVybiB0b0RPTSh0ZXh0KTtcbn1cbmZ1bmN0aW9uIGdldFdpZGdldFJ1bGVzKCkge1xuICAgIHJldHVybiB3aWRnZXRSdWxlcztcbn1cbmZ1bmN0aW9uIHNldFdpZGdldFJ1bGVzKHJ1bGVzKSB7XG4gICAgd2lkZ2V0UnVsZXMgPSBydWxlcztcbiAgICB3aWRnZXRSdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlLCBpbmRleCkge1xuICAgICAgICB3aWRnZXRSdWxlTWFwW1wid2lkZ2V0XCIgKyBpbmRleF0gPSBydWxlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbWVyZ2VOb2Rlcyhub2RlcywgdGV4dCwgc2NoZW1hLCBydWxlSW5kZXgpIHtcbiAgICByZXR1cm4gbm9kZXMuY29uY2F0KGNyZWF0ZU5vZGVzV2l0aFdpZGdldCh0ZXh0LCBzY2hlbWEsIHJ1bGVJbmRleCkpO1xufVxuLyoqXG4gKiBjcmVhdGUgbm9kZXMgd2l0aCBwbGFpbiB0ZXh0IGFuZCByZXBsYWNlIHRleHQgbWF0Y2hlZCB0byB0aGUgd2lkZ2V0IHJ1bGVzIHdpdGggdGhlIHdpZGdldCBub2RlXG4gKiBGb3IgZXhhbXBsZSwgaW4gY2FzZSB0aGUgdGV4dCBhbmQgd2lkZ2V0IHJ1bGVzIGFzIGJlbG93XG4gKlxuICogdGV4dDogJHRlc3QgcGxhaW4gdGV4dCAjdGVzdFxuICogd2lkZ2V0IHJ1bGVzOiBbeyBydWxlOiAvJC4rLyB9LCB7IHJ1bGU6IC8jLisvIH1dXG4gKlxuICogVGhlIGNyZWF0aW5nIG5vZGUgcHJvY2VzcyBpcyByZWN1cnNpdmUgYW5kIGlzIGFzIGZvbGxvd3MuXG4gKlxuICogaW4gZmlyc3Qgd2lkZ2V0IHJ1bGUoLyQuKy8pXG4gKiAgJHRlc3QgLT4gd2lkZ2V0IG5vZGVcbiAqICBwbGFpbiB0ZXh0IC0+IG1hdGNoIHdpdGggbmV4dCB3aWRnZXQgcnVsZVxuICogICN0ZXN0IC0+IG1hdGNoIHdpdGggbmV4dCB3aWRnZXQgcnVsZVxuICpcbiAqIGluIHNlY29uZCB3aWRnZXQgcnVsZSgvIy4rLylcbiAqICBwbGFpbiB0ZXh0IC0+IHRleHQgbm9kZShubyBydWxlIGZvciBtYXRjaGluZylcbiAqICAjdGVzdCAtPiB3aWRnZXQgbm9kZVxuICovXG5mdW5jdGlvbiBjcmVhdGVOb2Rlc1dpdGhXaWRnZXQodGV4dCwgc2NoZW1hLCBydWxlSW5kZXgpIHtcbiAgICBpZiAocnVsZUluZGV4ID09PSB2b2lkIDApIHsgcnVsZUluZGV4ID0gMDsgfVxuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBydWxlID0gKHdpZGdldFJ1bGVzW3J1bGVJbmRleF0gfHwge30pLnJ1bGU7XG4gICAgdmFyIG5leHRSdWxlSW5kZXggPSBydWxlSW5kZXggKyAxO1xuICAgIHRleHQgPSB1bndyYXBXaWRnZXRTeW50YXgodGV4dCk7XG4gICAgaWYgKHJ1bGUgJiYgcnVsZS50ZXN0KHRleHQpKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHZvaWQgMDtcbiAgICAgICAgd2hpbGUgKChpbmRleCA9IHRleHQuc2VhcmNoKHJ1bGUpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gdGV4dC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgLy8gZ2V0IHdpZGdldCBub2RlIG9uIGZpcnN0IHNwbGl0dGVkIHRleHQgdXNpbmcgbmV4dCB3aWRnZXQgcnVsZVxuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICBub2RlcyA9IG1lcmdlTm9kZXMobm9kZXMsIHByZXYsIHNjaGVtYSwgbmV4dFJ1bGVJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBidWlsZCB3aWRnZXQgbm9kZSB1c2luZyBjdXJyZW50IHdpZGdldCBydWxlXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoaW5kZXgpO1xuICAgICAgICAgICAgdmFyIGxpdGVyYWwgPSB0ZXh0Lm1hdGNoKHJ1bGUpWzBdO1xuICAgICAgICAgICAgdmFyIGluZm8gPSBcIndpZGdldFwiICsgcnVsZUluZGV4O1xuICAgICAgICAgICAgbm9kZXMucHVzaChzY2hlbWEubm9kZXMud2lkZ2V0LmNyZWF0ZSh7IGluZm86IGluZm8gfSwgc2NoZW1hLnRleHQoY3JlYXRlV2lkZ2V0Q29udGVudChpbmZvLCBsaXRlcmFsKSkpKTtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZyhsaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IHdpZGdldCBub2RlIG9uIGxhc3Qgc3BsaXR0ZWQgdGV4dCB1c2luZyBuZXh0IHdpZGdldCBydWxlXG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBub2RlcyA9IG1lcmdlTm9kZXMobm9kZXMsIHRleHQsIHNjaGVtYSwgbmV4dFJ1bGVJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGV4dCkge1xuICAgICAgICBub2RlcyA9XG4gICAgICAgICAgICBydWxlSW5kZXggPCB3aWRnZXRSdWxlcy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgPyBtZXJnZU5vZGVzKG5vZGVzLCB0ZXh0LCBzY2hlbWEsIG5leHRSdWxlSW5kZXgpXG4gICAgICAgICAgICAgICAgOiBbc2NoZW1hLnRleHQodGV4dCldO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiBnZXRXaWRnZXRDb250ZW50KHdpZGdldE5vZGUpIHtcbiAgICB2YXIgZXZlbnQ7XG4gICAgdmFyIHRleHQgPSAnJztcbiAgICB2YXIgd2Fsa2VyID0gd2lkZ2V0Tm9kZS53YWxrZXIoKTtcbiAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBldmVudC5ub2RlLCBlbnRlcmluZyA9IGV2ZW50LmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIGlmIChub2RlICE9PSB3aWRnZXROb2RlICYmIG5vZGUudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBnZXRJbmxpbmVNYXJrZG93blRleHQobm9kZSk7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICB3YWxrZXIucmVzdW1lQXQod2lkZ2V0Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHdhbGtlci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gbm9kZS5saXRlcmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0Q29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsZXRlU2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWxldGVTZWxlY3Rpb247IH0sXG4gICAgICAgIHNlbGVjdEFsbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZWN0QWxsOyB9LFxuICAgICAgICB1bmRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRvOyB9LFxuICAgICAgICByZWRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWRvOyB9LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBkZWNvcmF0aW9uczogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvYyA9IHN0YXRlLmRvYztcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50ZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgIGRvYy5jaGlsZENvdW50ID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIGRvYy5maXJzdENoaWxkLmlzVGV4dGJsb2NrICYmXG4gICAgICAgICAgICAgICAgICAgIGRvYy5maXJzdENoaWxkLmNvbnRlbnQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGxhY2VIb2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgIGFkZENsYXNzXzEocGxhY2VIb2xkZXIsICdwbGFjZWhvbGRlcicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzXzEocGxhY2VIb2xkZXIsIG9wdGlvbnMuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwbGFjZUhvbGRlci50ZXh0Q29udGVudCA9IG9wdGlvbnMudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKGRvYywgW0RlY29yYXRpb24ud2lkZ2V0KDEsIHBsYWNlSG9sZGVyKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayBlbGVtZW50IGhhcyBzcGVjaWZpYyBjc3MgY2xhc3NcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBpbkFycmF5JDEgPSBpbkFycmF5XzE7XG52YXIgZ2V0Q2xhc3MgPSBnZXRDbGFzc18xO1xuXG4vKipcbiAqIENoZWNrIGVsZW1lbnQgaGFzIHNwZWNpZmljIGNzcyBjbGFzc1xuICogQHBhcmFtIHsoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudCl9IGVsZW1lbnQgLSB0YXJnZXQgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGNzc0NsYXNzIC0gY3NzIGNsYXNzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBjc3NDbGFzcykge1xuICB2YXIgb3JpZ2luO1xuXG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjc3NDbGFzcyk7XG4gIH1cblxuICBvcmlnaW4gPSBnZXRDbGFzcyhlbGVtZW50KS5zcGxpdCgvXFxzKy8pO1xuXG4gIHJldHVybiBpbkFycmF5JDEoY3NzQ2xhc3MsIG9yaWdpbikgPiAtMTtcbn1cblxudmFyIGhhc0NsYXNzXzEgPSBoYXNDbGFzcztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIGVsZW1lbnQgbWF0Y2ggc2VsZWN0b3JcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBpbkFycmF5ID0gaW5BcnJheV8xO1xudmFyIHRvQXJyYXkgPSB0b0FycmF5XzE7XG5cbnZhciBlbFByb3RvID0gRWxlbWVudC5wcm90b3R5cGU7XG52YXIgbWF0Y2hTZWxlY3RvciA9IGVsUHJvdG8ubWF0Y2hlcyB8fFxuICAgIGVsUHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgZWxQcm90by5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBlbFByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHZhciBkb2MgPSB0aGlzLmRvY3VtZW50IHx8IHRoaXMub3duZXJEb2N1bWVudDtcblxuICAgICAgcmV0dXJuIGluQXJyYXkodGhpcywgdG9BcnJheShkb2MucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpKSA+IC0xO1xuICAgIH07XG5cbi8qKlxuICogQ2hlY2sgZWxlbWVudCBtYXRjaCBzZWxlY3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAtIHNlbGVjdG9yIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXMgc2VsZWN0b3IgbWF0Y2hlZCB0byBlbGVtZW50P1xuICogQG1lbWJlcm9mIG1vZHVsZTpkb21VdGlsXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIG1hdGNoU2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG59XG5cbnZhciBtYXRjaGVzXzEgPSBtYXRjaGVzO1xuXG52YXIgVEFHX05BTUUgPSAnW0EtWmEtel1bQS1aYS16MC05LV0qJztcbnZhciBBVFRSSUJVVEVfTkFNRSA9ICdbYS16QS1aXzpdW2EtekEtWjAtOTouXy1dKic7XG52YXIgVU5RVU9URURfVkFMVUUgPSAnW15cIlxcJz08PmBcXFxceDAwLVxcXFx4MjBdKyc7XG52YXIgU0lOR0xFX1FVT1RFRF9WQUxVRSA9IFwiJ1teJ10qJ1wiO1xudmFyIERPVUJMRV9RVU9URURfVkFMVUUgPSAnXCJbXlwiXSpcIic7XG52YXIgQVRUUklCVVRFX1ZBTFVFID0gXCIoPzpcIiArIFVOUVVPVEVEX1ZBTFVFICsgXCJ8XCIgKyBTSU5HTEVfUVVPVEVEX1ZBTFVFICsgXCJ8XCIgKyBET1VCTEVfUVVPVEVEX1ZBTFVFICsgXCIpXCI7XG52YXIgQVRUUklCVVRFX1ZBTFVFX1NQRUMgPSBcIlwiICsgJyg/OlxcXFxzKj1cXFxccyonICsgQVRUUklCVVRFX1ZBTFVFICsgXCIpXCI7XG52YXIgQVRUUklCVVRFJDEgPSBcIlwiICsgJyg/OlxcXFxzKycgKyBBVFRSSUJVVEVfTkFNRSArIEFUVFJJQlVURV9WQUxVRV9TUEVDICsgXCI/KVwiO1xudmFyIE9QRU5fVEFHID0gXCI8KFwiICsgVEFHX05BTUUgKyBcIikoXCIgKyBBVFRSSUJVVEUkMSArIFwiKSpcXFxccyovPz5cIjtcbnZhciBDTE9TRV9UQUcgPSBcIjwvKFwiICsgVEFHX05BTUUgKyBcIilcXFxccypbPl1cIjtcbnZhciBIVE1MX1RBRyA9IFwiKD86XCIgKyBPUEVOX1RBRyArIFwifFwiICsgQ0xPU0VfVEFHICsgXCIpXCI7XG52YXIgcmVIVE1MVGFnID0gbmV3IFJlZ0V4cChcIl5cIiArIEhUTUxfVEFHLCAnaScpO1xudmFyIHJlQlIgPSAvPGJyXFxzKlxcLyo+L2k7XG52YXIgcmVIVE1MQ29tbWVudCA9IC88ISAtLS0tPnw8IS0tKD86LT9bXj4tXSkoPzotP1teLV0pKi0tPi87XG52YXIgQUxURVJOQVRJVkVfVEFHX0ZPUl9CUiA9ICc8L3A+PHA+JztcblxuZnVuY3Rpb24gaXNQb3NpdGlvbkluQm94KHN0eWxlLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgdmFyIGxlZnQgPSBwYXJzZUludChzdHlsZS5sZWZ0LCAxMCk7XG4gICAgdmFyIHRvcCA9IHBhcnNlSW50KHN0eWxlLnRvcCwgMTApO1xuICAgIHZhciB3aWR0aCA9IHBhcnNlSW50KHN0eWxlLndpZHRoLCAxMCkgKyBwYXJzZUludChzdHlsZS5wYWRkaW5nTGVmdCwgMTApICsgcGFyc2VJbnQoc3R5bGUucGFkZGluZ1JpZ2h0LCAxMCk7XG4gICAgdmFyIGhlaWdodCA9IHBhcnNlSW50KHN0eWxlLmhlaWdodCwgMTApICsgcGFyc2VJbnQoc3R5bGUucGFkZGluZ1RvcCwgMTApICsgcGFyc2VJbnQoc3R5bGUucGFkZGluZ0JvdHRvbSwgMTApO1xuICAgIHJldHVybiBvZmZzZXRYID49IGxlZnQgJiYgb2Zmc2V0WCA8PSBsZWZ0ICsgd2lkdGggJiYgb2Zmc2V0WSA+PSB0b3AgJiYgb2Zmc2V0WSA8PSB0b3AgKyBoZWlnaHQ7XG59XG52YXIgQ0xTX1BSRUZJWCA9ICd0b2FzdHVpLWVkaXRvci0nO1xuZnVuY3Rpb24gY2xzKCkge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG5hbWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBfYSA9IDAsIG5hbWVzXzEgPSBuYW1lczsgX2EgPCBuYW1lc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICB2YXIgbmFtZV8xID0gbmFtZXNfMVtfYV07XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWVfMSkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IG5hbWVfMVswXSA/IG5hbWVfMVsxXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBuYW1lXzE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJcIiArIENMU19QUkVGSVggKyBjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignICcpO1xufVxuZnVuY3Rpb24gY2xzV2l0aE1kUHJlZml4KCkge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG5hbWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5tYXAoZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gQ0xTX1BSRUZJWCArIFwibWQtXCIgKyBjbGFzc05hbWU7IH0pLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIGlzVGV4dE5vZGUobm9kZSkge1xuICAgIHJldHVybiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLm5vZGVUeXBlKSA9PT0gTm9kZS5URVhUX05PREU7XG59XG5mdW5jdGlvbiBpc0VsZW1Ob2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcbn1cbmZ1bmN0aW9uIGZpbmROb2RlcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIHZhciBub2RlTGlzdCA9IHRvQXJyYXlfMShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICBpZiAobm9kZUxpc3QubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBub2RlTGlzdDtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gYXBwZW5kTm9kZXMobm9kZSwgbm9kZXNUb0FwcGVuZCkge1xuICAgIG5vZGVzVG9BcHBlbmQgPSBpc0FycmF5XzEobm9kZXNUb0FwcGVuZCkgPyB0b0FycmF5XzEobm9kZXNUb0FwcGVuZCkgOiBbbm9kZXNUb0FwcGVuZF07XG4gICAgbm9kZXNUb0FwcGVuZC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlVG9BcHBlbmQpIHtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChub2RlVG9BcHBlbmQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlTm9kZShpbnNlcnRlZE5vZGUsIG5vZGUpIHtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5zZXJ0ZWROb2RlLCBub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW1vdmVOb2RlJDEobm9kZSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVud3JhcE5vZGUobm9kZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZS5maXJzdENoaWxkLCBub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVOb2RlJDEobm9kZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSwgc3RhdGUpIHtcbiAgICBpZiAoaXNVbmRlZmluZWRfMShzdGF0ZSkpIHtcbiAgICAgICAgc3RhdGUgPSAhaGFzQ2xhc3NfMShlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgIH1cbiAgICB2YXIgdG9nZ2xlRm4gPSBzdGF0ZSA/IGFkZENsYXNzXzEgOiByZW1vdmVDbGFzc18xO1xuICAgIHRvZ2dsZUZuKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aChjb250ZW50cywgdGFyZ2V0KSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGlmIChpc1N0cmluZ18xKGNvbnRlbnRzKSkge1xuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gY29udGVudHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGVudHMpO1xuICAgIH1cbiAgICB2YXIgZmlyc3RDaGlsZCA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3RDaGlsZDtcbn1cbmZ1bmN0aW9uIGdldE91dGVyV2lkdGgoZWwpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgcmV0dXJuIChbJ21hcmdpbi1sZWZ0JywgJ21hcmdpbi1yaWdodCddLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB0eXBlKSB7IHJldHVybiBhY2MgKyBwYXJzZUludChjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKHR5cGUpLCAxMCk7IH0sIDApICsgZWwub2Zmc2V0V2lkdGgpO1xufVxuZnVuY3Rpb24gY2xvc2VzdChub2RlLCBmb3VuZCkge1xuICAgIHZhciBjb25kaXRpb247XG4gICAgaWYgKGlzU3RyaW5nXzEoZm91bmQpKSB7XG4gICAgICAgIGNvbmRpdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIG1hdGNoZXNfMSh0YXJnZXQsIGZvdW5kKTsgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbmRpdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIHRhcmdldCA9PT0gZm91bmQ7IH07XG4gICAgfVxuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IGRvY3VtZW50KSB7XG4gICAgICAgIGlmIChpc0VsZW1Ob2RlKG5vZGUpICYmIGNvbmRpdGlvbihub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRUb3RhbE9mZnNldChlbCwgcm9vdCkge1xuICAgIHZhciBvZmZzZXRUb3AgPSAwO1xuICAgIHZhciBvZmZzZXRMZWZ0ID0gMDtcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IHJvb3QpIHtcbiAgICAgICAgdmFyIHRvcF8xID0gZWwub2Zmc2V0VG9wLCBsZWZ0ID0gZWwub2Zmc2V0TGVmdCwgb2Zmc2V0UGFyZW50ID0gZWwub2Zmc2V0UGFyZW50O1xuICAgICAgICBvZmZzZXRUb3AgKz0gdG9wXzE7XG4gICAgICAgIG9mZnNldExlZnQgKz0gbGVmdDtcbiAgICAgICAgaWYgKG9mZnNldFBhcmVudCA9PT0gcm9vdC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gZWwub2Zmc2V0UGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4geyBvZmZzZXRUb3A6IG9mZnNldFRvcCwgb2Zmc2V0TGVmdDogb2Zmc2V0TGVmdCB9O1xufVxuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBlbGVtZW50KSB7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgaWYgKGlzTmlsKGF0dHJpYnV0ZXNbYXR0ck5hbWVdKSkge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJpYnV0ZXNbYXR0ck5hbWVdKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVwbGFjZUJSV2l0aEVtcHR5QmxvY2soaHRtbCkge1xuICAgIC8vIHJlbW92ZSBiciBpbiBwYXJhZ3JhcGggdG8gY29tcGF0aWJsZSB3aXRoIG1hcmtkb3duXG4gICAgdmFyIHJlcGxhY2VkSFRNTCA9IGh0bWwucmVwbGFjZSgvPHA+PGJyXFxzKlxcLyo+PFxcL3A+L2dpLCAnPHA+PC9wPicpO1xuICAgIHZhciByZUhUTUxUYWcgPSBuZXcgUmVnRXhwKEhUTUxfVEFHLCAnaWcnKTtcbiAgICB2YXIgaHRtbFRhZ01hdGNoZWQgPSByZXBsYWNlZEhUTUwubWF0Y2gocmVIVE1MVGFnKTtcbiAgICBodG1sVGFnTWF0Y2hlZCA9PT0gbnVsbCB8fCBodG1sVGFnTWF0Y2hlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHRtbFRhZ01hdGNoZWQuZm9yRWFjaChmdW5jdGlvbiAoaHRtbFRhZywgaW5kZXgpIHtcbiAgICAgICAgaWYgKHJlQlIudGVzdChodG1sVGFnKSkge1xuICAgICAgICAgICAgdmFyIGFsdGVybmF0aXZlVGFnID0gQUxURVJOQVRJVkVfVEFHX0ZPUl9CUjtcbiAgICAgICAgICAgIGlmIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2VGFnID0gaHRtbFRhZ01hdGNoZWRbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgb3BlblRhZ01hdGNoZWQgPSBwcmV2VGFnLm1hdGNoKE9QRU5fVEFHKTtcbiAgICAgICAgICAgICAgICBpZiAob3BlblRhZ01hdGNoZWQgJiYgIS9ici9pLnRlc3Qob3BlblRhZ01hdGNoZWRbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWdOYW1lID0gb3BlblRhZ01hdGNoZWRbMV07XG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlVGFnID0gXCI8L1wiICsgdGFnTmFtZSArIFwiPjxcIiArIHRhZ05hbWUgKyBcIj5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBsYWNlZEhUTUwgPSByZXBsYWNlZEhUTUwucmVwbGFjZShyZUJSLCBhbHRlcm5hdGl2ZVRhZyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVwbGFjZWRIVE1MO1xufVxuZnVuY3Rpb24gcmVtb3ZlUHJvc2VNaXJyb3JIYWNrTm9kZXMoaHRtbCkge1xuICAgIHZhciByZVByb3NlTWlycm9ySW1hZ2UgPSAvPGltZyBjbGFzcz1cIlByb3NlTWlycm9yLXNlcGFyYXRvclwiIGFsdD1cIlwiPi9nO1xuICAgIHZhciByZVByb3NlTWlycm9yVHJhaWxpbmdCcmVhayA9IC8gY2xhc3M9XCJQcm9zZU1pcnJvci10cmFpbGluZ0JyZWFrXCIvZztcbiAgICB2YXIgcmVzdWx0SFRNTCA9IGh0bWw7XG4gICAgcmVzdWx0SFRNTCA9IHJlc3VsdEhUTUwucmVwbGFjZShyZVByb3NlTWlycm9ySW1hZ2UsICcnKTtcbiAgICByZXN1bHRIVE1MID0gcmVzdWx0SFRNTC5yZXBsYWNlKHJlUHJvc2VNaXJyb3JUcmFpbGluZ0JyZWFrLCAnJyk7XG4gICAgcmV0dXJuIHJlc3VsdEhUTUw7XG59XG5cbnZhciBwbHVnaW5LZXkkMSA9IG5ldyBQbHVnaW5LZXkoJ3dpZGdldCcpO1xudmFyIE1BUkdJTiA9IDU7XG52YXIgUG9wdXBXaWRnZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9wdXBXaWRnZXQodmlldywgZXZlbnRFbWl0dGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucG9wdXAgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbW92ZVdpZGdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wb3B1cCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJvb3RFbC5yZW1vdmVDaGlsZChfdGhpcy5wb3B1cCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucG9wdXAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJvb3RFbCA9IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gZXZlbnRFbWl0dGVyO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2JsdXInLCB0aGlzLnJlbW92ZVdpZGdldCk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignbG9hZFVJJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucm9vdEVsID0gY2xvc2VzdCh2aWV3LmRvbS5wYXJlbnRFbGVtZW50LCBcIi5cIiArIGNscygnZGVmYXVsdFVJJykpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdyZW1vdmVQb3B1cFdpZGdldCcsIHRoaXMucmVtb3ZlV2lkZ2V0KTtcbiAgICB9XG4gICAgUG9wdXBXaWRnZXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgIHZhciB3aWRnZXQgPSBwbHVnaW5LZXkkMS5nZXRTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVXaWRnZXQoKTtcbiAgICAgICAgaWYgKHdpZGdldCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB3aWRnZXQubm9kZSwgc3R5bGUgPSB3aWRnZXQuc3R5bGU7XG4gICAgICAgICAgICB2YXIgX2EgPSB2aWV3LmNvb3Jkc0F0UG9zKHdpZGdldC5wb3MpLCB0b3BfMSA9IF9hLnRvcCwgbGVmdCA9IF9hLmxlZnQsIGJvdHRvbSA9IF9hLmJvdHRvbTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBib3R0b20gLSB0b3BfMTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5yb290RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgcmVsVG9wUG9zID0gdG9wXzEgLSByZWN0LnRvcDtcbiAgICAgICAgICAgIGNzc18xKG5vZGUsIHsgb3BhY2l0eTogJzAnIH0pO1xuICAgICAgICAgICAgdGhpcy5yb290RWwuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICBjc3NfMShub2RlLCB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCAtIHJlY3QubGVmdCArIE1BUkdJTiArIFwicHhcIixcbiAgICAgICAgICAgICAgICB0b3A6IChzdHlsZSA9PT0gJ2JvdHRvbScgPyByZWxUb3BQb3MgKyBoZWlnaHQgLSBNQVJHSU4gOiByZWxUb3BQb3MgLSBoZWlnaHQpICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6ICcxJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wb3B1cCA9IG5vZGU7XG4gICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvcHVwV2lkZ2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVFdmVudEhhbmRsZXIoJ2JsdXInLCB0aGlzLnJlbW92ZVdpZGdldCk7XG4gICAgfTtcbiAgICByZXR1cm4gUG9wdXBXaWRnZXQ7XG59KCkpO1xuZnVuY3Rpb24gYWRkV2lkZ2V0KGV2ZW50RW1pdHRlcikge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBwbHVnaW5LZXkkMSxcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcHBseTogZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyLmdldE1ldGEoJ3dpZGdldCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdmlldzogZnVuY3Rpb24gKGVkaXRvclZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9wdXBXaWRnZXQoZWRpdG9yVmlldywgZXZlbnRFbWl0dGVyKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRGVmYXVsdEltYWdlQmxvYkhvb2soZXZlbnRFbWl0dGVyKSB7XG4gICAgZXZlbnRFbWl0dGVyLmxpc3RlbignYWRkSW1hZ2VCbG9iSG9vaycsIGZ1bmN0aW9uIChibG9iLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IF9hLnRhcmdldDtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0YXJnZXQucmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBlbWl0SW1hZ2VCbG9iSG9vayhldmVudEVtaXR0ZXIsIGJsb2IsIHR5cGUpIHtcbiAgICB2YXIgaG9vayA9IGZ1bmN0aW9uIChpbWFnZVVybCwgYWx0VGV4dCkge1xuICAgICAgICBldmVudEVtaXR0ZXIuZW1pdCgnY29tbWFuZCcsICdhZGRJbWFnZScsIHtcbiAgICAgICAgICAgIGltYWdlVXJsOiBpbWFnZVVybCxcbiAgICAgICAgICAgIGFsdFRleHQ6IGFsdFRleHQgfHwgYmxvYi5uYW1lIHx8ICdpbWFnZScsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZXZlbnRFbWl0dGVyLmVtaXQoJ2FkZEltYWdlQmxvYkhvb2snLCBibG9iLCBob29rLCB0eXBlKTtcbn1cbmZ1bmN0aW9uIHBhc3RlSW1hZ2VPbmx5KGl0ZW1zKSB7XG4gICAgdmFyIGltYWdlcyA9IHRvQXJyYXlfMShpdGVtcykuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlLmluZGV4T2YoJ2ltYWdlJykgIT09IC0xO1xuICAgIH0pO1xuICAgIGlmIChpbWFnZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBpdGVtID0gaW1hZ2VzWzBdO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZ2V0QXNGaWxlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGRyb3BJbWFnZShfYSkge1xuICAgIHZhciBldmVudEVtaXR0ZXIgPSBfYS5ldmVudEVtaXR0ZXI7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgZHJvcDogZnVuY3Rpb24gKF8sIGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gKF9hID0gZXYuZGF0YVRyYW5zZmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsZXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yRWFjaEFycmF5XzEoaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZS5pbmRleE9mKCdpbWFnZScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEltYWdlQmxvYkhvb2soZXZlbnRFbWl0dGVyLCBpdGVtLCBldi50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG52YXIgTm9kZSQyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGUoKSB7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ25vZGUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTm9kZS5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZTtcbn0oKSk7XG5cbmZ1bmN0aW9uIHdpZGdldE5vZGVWaWV3KHBtTm9kZSkge1xuICAgIHZhciBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgdmFyIG5vZGUgPSB3aWRnZXRUb0RPTShwbU5vZGUuYXR0cnMuaW5mbywgcG1Ob2RlLnRleHRDb250ZW50KTtcbiAgICBkb20uY2xhc3NOYW1lID0gJ3R1aS13aWRnZXQnO1xuICAgIGRvbS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICByZXR1cm4geyBkb206IGRvbSB9O1xufVxuZnVuY3Rpb24gaXNXaWRnZXROb2RlKHBtTm9kZSkge1xuICAgIHJldHVybiBwbU5vZGUudHlwZS5uYW1lID09PSAnd2lkZ2V0Jztcbn1cbnZhciBXaWRnZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoV2lkZ2V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpZGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2lkZ2V0LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3dpZGdldCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2lkZ2V0LnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5mbzogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBncm91cDogJ2lubGluZScsXG4gICAgICAgICAgICAgICAgaW5saW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd0ZXh0KicsXG4gICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXRvbTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogJ3R1aS13aWRnZXQnIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAnc3Bhbi50dWktd2lkZ2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBkb20udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gdGV4dC5tYXRjaCgvXFwkXFwkKHdpZGdldFxcZCspLyksIGluZm8gPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpbmZvOiBpbmZvIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFdpZGdldDtcbn0oTm9kZSQyKSk7XG5cbnZhciBFZGl0b3JCYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVkaXRvckJhc2UoZXZlbnRFbWl0dGVyKSB7XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NOYW1lID0gJ3RvYXN0dWktZWRpdG9yJztcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBldmVudEVtaXR0ZXI7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSB7IHRleHQ6ICcnIH07XG4gICAgfVxuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmNyZWF0ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRWRpdG9yU3RhdGUuY3JlYXRlKHtcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICAgICAgICBwbHVnaW5zOiB0aGlzLmNyZWF0ZVBsdWdpbnMoKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlciwgdmlldyA9IF9hLnZpZXcsIGVkaXRvclR5cGUgPSBfYS5lZGl0b3JUeXBlO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50RW1pdHRlci5lbWl0KCdmb2N1cycsIGVkaXRvclR5cGUpOyB9KTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50RW1pdHRlci5lbWl0KCdibHVyJywgZWRpdG9yVHlwZSk7IH0pO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuZW1pdENoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2NhcmV0Q2hhbmdlJywgdGhpcy5lZGl0b3JUeXBlKTtcbiAgICAgICAgaWYgKHRyLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHRoaXMuZWRpdG9yVHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFZGl0b3JCYXNlLnByb3RvdHlwZSwgXCJkZWZhdWx0UGx1Z2luc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5jcmVhdGVJbnB1dFJ1bGVzKCk7XG4gICAgICAgICAgICB2YXIgcGx1Z2lucyA9IF9fc3ByZWFkQXJyYXkkMShfX3NwcmVhZEFycmF5JDEoW10sIHRoaXMua2V5bWFwcyksIFtcbiAgICAgICAgICAgICAgICBrZXltYXAoX19hc3NpZ24kMSh7ICdTaGlmdC1FbnRlcic6IGJhc2VLZXltYXAuRW50ZXIgfSwgYmFzZUtleW1hcCkpLFxuICAgICAgICAgICAgICAgIGhpc3RvcnkoKSxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcih0aGlzLnBsYWNlaG9sZGVyKSxcbiAgICAgICAgICAgICAgICBhZGRXaWRnZXQodGhpcy5ldmVudEVtaXR0ZXIpLFxuICAgICAgICAgICAgICAgIGRyb3BJbWFnZSh0aGlzLmNvbnRleHQpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gcnVsZXMgPyBwbHVnaW5zLmNvbmNhdChydWxlcykgOiBwbHVnaW5zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuY3JlYXRlSW5wdXRSdWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdpZGdldFJ1bGVzID0gZ2V0V2lkZ2V0UnVsZXMoKTtcbiAgICAgICAgdmFyIHJ1bGVzID0gd2lkZ2V0UnVsZXMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHJ1bGUgPSBfYS5ydWxlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUocnVsZSwgZnVuY3Rpb24gKHN0YXRlLCBtYXRjaCwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciBzY2hlbWEgPSBzdGF0ZS5zY2hlbWEsIHRyID0gc3RhdGUudHIsIGRvYyA9IHN0YXRlLmRvYztcbiAgICAgICAgICAgICAgICB2YXIgYWxsTWF0Y2hlZCA9IG1hdGNoLmlucHV0Lm1hdGNoKG5ldyBSZWdFeHAocnVsZSwgJ2cnKSk7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGRvYy5yZXNvbHZlKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcG9zLnBhcmVudDtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChpc1dpZGdldE5vZGUocGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBwb3Mubm9kZShwb3MuZGVwdGggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBpc1dpZGdldE5vZGUoY2hpbGQpICYmIChjb3VudCArPSAxKTsgfSk7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgY29udGVudCBvbmx5IGlmIHRoZSBjb3VudCBvZiBtYXRjaGVkIHJ1bGVzIGluIHdob2xlIHRleHQgaXMgZ3JlYXRlciB0aGFuIGN1cnJlbnQgd2lkZ2V0IG5vZGUgY291bnRcbiAgICAgICAgICAgICAgICBpZiAoYWxsTWF0Y2hlZC5sZW5ndGggPiBjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGxhc3QkMShhbGxNYXRjaGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gY3JlYXRlTm9kZXNXaXRoV2lkZ2V0KGNvbnRlbnQsIHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkanVzdCBzdGFydCBwb3NpdGlvbiBiYXNlZCBvbiB3aWRnZXQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHIucmVwbGFjZVdpdGgoZW5kIC0gY29udGVudC5sZW5ndGggKyAxLCBlbmQsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBydWxlcy5sZW5ndGggPyBpbnB1dFJ1bGVzKHsgcnVsZXM6IHJ1bGVzIH0pIDogbnVsbDtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmNsZWFyVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuY3JlYXRlU2NoZW1hID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNjaGVtYSh7XG4gICAgICAgICAgICBub2RlczogdGhpcy5zcGVjcy5ub2RlcyxcbiAgICAgICAgICAgIG1hcmtzOiB0aGlzLnNwZWNzLm1hcmtzLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmNyZWF0ZUtleW1hcHMgPSBmdW5jdGlvbiAodXNlQ29tbWFuZFNob3J0Y3V0KSB7XG4gICAgICAgIHZhciBfYSA9IGdldERlZmF1bHRDb21tYW5kcygpLCB1bmRvID0gX2EudW5kbywgcmVkbyA9IF9hLnJlZG87XG4gICAgICAgIHZhciBhbGxLZXltYXBzID0gdGhpcy5zcGVjcy5rZXltYXBzKHVzZUNvbW1hbmRTaG9ydGN1dCk7XG4gICAgICAgIHZhciBoaXN0b3J5S2V5bWFwID0ge1xuICAgICAgICAgICAgJ01vZC16JzogdW5kbygpLFxuICAgICAgICAgICAgJ1NoaWZ0LU1vZC16JzogcmVkbygpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdXNlQ29tbWFuZFNob3J0Y3V0ID8gYWxsS2V5bWFwcy5jb25jYXQoa2V5bWFwKGhpc3RvcnlLZXltYXApKSA6IGFsbEtleW1hcHM7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5jcmVhdGVDb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlY3MuY29tbWFuZHModGhpcy52aWV3KTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmNyZWF0ZVBsdWdpblByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYVBsdWdpbnMubWFwKGZ1bmN0aW9uIChwbHVnaW4pIHsgcmV0dXJuIHBsdWdpbihfdGhpcy5ldmVudEVtaXR0ZXIpOyB9KTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgLy8gcHJldmVudCB0aGUgZXJyb3IgZm9yIElFMTFcbiAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudmlldy5mb2N1cygpO1xuICAgICAgICAgICAgX3RoaXMudmlldy5kaXNwYXRjaChfdGhpcy52aWV3LnN0YXRlLnRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20uYmx1cigpO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIHRoaXMudmlldy5kZXN0cm95KCk7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpc1twcm9wXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5tb3ZlQ3Vyc29yVG9TdGFydCA9IGZ1bmN0aW9uIChmb2N1cykge1xuICAgICAgICB2YXIgdHIgPSB0aGlzLnZpZXcuc3RhdGUudHI7XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgMSkpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICBpZiAoZm9jdXMpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUubW92ZUN1cnNvclRvRW5kID0gZnVuY3Rpb24gKGZvY3VzKSB7XG4gICAgICAgIHZhciB0ciA9IHRoaXMudmlldy5zdGF0ZS50cjtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCB0ci5kb2MuY29udGVudC5zaXplIC0gMSkpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICBpZiAoZm9jdXMpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHRvcCkge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnNjcm9sbFRvcCA9IHRvcDtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmdldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5kb20uc2Nyb2xsVG9wO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuc2V0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godGhpcy52aWV3LnN0YXRlLnRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgICBjc3NfMSh0aGlzLmVsLCB7IGhlaWdodDogaGVpZ2h0ICsgXCJweFwiIH0pO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuc2V0TWluSGVpZ2h0ID0gZnVuY3Rpb24gKG1pbkhlaWdodCkge1xuICAgICAgICBjc3NfMSh0aGlzLmVsLCB7IG1pbkhlaWdodDogbWluSGVpZ2h0ICsgXCJweFwiIH0pO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWw7XG4gICAgfTtcbiAgICByZXR1cm4gRWRpdG9yQmFzZTtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvbiBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvbiwgcmV0dXJuIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBmdW5jdGlvbj9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRnVuY3Rpb247XG59XG5cbnZhciBpc0Z1bmN0aW9uXzEgPSBpc0Z1bmN0aW9uO1xuXG52YXIgZGVmYXVsdENvbW1hbmRTaG9ydGN1dHMgPSBbXG4gICAgJ0VudGVyJyxcbiAgICAnU2hpZnQtRW50ZXInLFxuICAgICdNb2QtRW50ZXInLFxuICAgICdUYWInLFxuICAgICdTaGlmdC1UYWInLFxuICAgICdEZWxldGUnLFxuICAgICdCYWNrc3BhY2UnLFxuICAgICdNb2QtRGVsZXRlJyxcbiAgICAnTW9kLUJhY2tzcGFjZScsXG4gICAgJ0Fycm93VXAnLFxuICAgICdBcnJvd0Rvd24nLFxuICAgICdBcnJvd0xlZnQnLFxuICAgICdBcnJvd1JpZ2h0JyxcbiAgICAnTW9kLWQnLFxuICAgICdNb2QtRCcsXG4gICAgJ0FsdC1BcnJvd1VwJyxcbiAgICAnQWx0LUFycm93RG93bicsXG5dO1xuZnVuY3Rpb24gZXhlY0NvbW1hbmQodmlldywgY29tbWFuZCwgcGF5bG9hZCkge1xuICAgIHZpZXcuZm9jdXMoKTtcbiAgICByZXR1cm4gY29tbWFuZChwYXlsb2FkKSh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KTtcbn1cbnZhciBTcGVjTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcGVjTWFuYWdlcihzcGVjcykge1xuICAgICAgICB0aGlzLnNwZWNzID0gc3BlY3M7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTcGVjTWFuYWdlci5wcm90b3R5cGUsIFwibm9kZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwZWNzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc3BlYykgeyByZXR1cm4gc3BlYy50eXBlID09PSAnbm9kZSc7IH0pXG4gICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAobm9kZXMsIF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIG5vZGVzKSwgKF9iID0ge30sIF9iW25hbWVdID0gc2NoZW1hLCBfYikpO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNwZWNNYW5hZ2VyLnByb3RvdHlwZSwgXCJtYXJrc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BlY3NcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzcGVjKSB7IHJldHVybiBzcGVjLnR5cGUgPT09ICdtYXJrJzsgfSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChtYXJrcywgX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgbWFya3MpLCAoX2IgPSB7fSwgX2JbbmFtZV0gPSBzY2hlbWEsIF9iKSk7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTcGVjTWFuYWdlci5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAodmlldywgYWRkZWRDb21tYW5kcykge1xuICAgICAgICB2YXIgc3BlY0NvbW1hbmRzID0gdGhpcy5zcGVjc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBjb21tYW5kcyA9IF9hLmNvbW1hbmRzO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYWxsQ29tbWFuZHMsIHNwZWMpIHtcbiAgICAgICAgICAgIHZhciBjb21tYW5kcyA9IHt9O1xuICAgICAgICAgICAgdmFyIHNwZWNDb21tYW5kID0gc3BlYy5jb21tYW5kcygpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb25fMShzcGVjQ29tbWFuZCkpIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kc1tzcGVjLm5hbWVdID0gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGV4ZWNDb21tYW5kKHZpZXcsIHNwZWNDb21tYW5kLCBwYXlsb2FkKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNwZWNDb21tYW5kKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzW25hbWVdID0gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGV4ZWNDb21tYW5kKHZpZXcsIHNwZWNDb21tYW5kW25hbWVdLCBwYXlsb2FkKTsgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGFsbENvbW1hbmRzKSwgY29tbWFuZHMpO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHZhciBkZWZhdWx0Q29tbWFuZHMgPSBnZXREZWZhdWx0Q29tbWFuZHMoKTtcbiAgICAgICAgT2JqZWN0LmtleXMoZGVmYXVsdENvbW1hbmRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBzcGVjQ29tbWFuZHNbbmFtZV0gPSBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZXhlY0NvbW1hbmQodmlldywgZGVmYXVsdENvbW1hbmRzW25hbWVdLCBwYXlsb2FkKTsgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhZGRlZENvbW1hbmRzKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhZGRlZENvbW1hbmRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgc3BlY0NvbW1hbmRzW25hbWVdID0gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGV4ZWNDb21tYW5kKHZpZXcsIGFkZGVkQ29tbWFuZHNbbmFtZV0sIHBheWxvYWQpOyB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwZWNDb21tYW5kcztcbiAgICB9O1xuICAgIFNwZWNNYW5hZ2VyLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKHVzZUNvbW1hbmRTaG9ydGN1dCkge1xuICAgICAgICB2YXIgc3BlY0tleW1hcHMgPSB0aGlzLnNwZWNzLmZpbHRlcihmdW5jdGlvbiAoc3BlYykgeyByZXR1cm4gc3BlYy5rZXltYXBzOyB9KS5tYXAoZnVuY3Rpb24gKHNwZWMpIHsgcmV0dXJuIHNwZWMua2V5bWFwcygpOyB9KTtcbiAgICAgICAgcmV0dXJuIHNwZWNLZXltYXBzLm1hcChmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgaWYgKCF1c2VDb21tYW5kU2hvcnRjdXQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhrZXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbmNsdWRlcyhkZWZhdWx0Q29tbWFuZFNob3J0Y3V0cywga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGtleXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtleW1hcChrZXlzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTcGVjTWFuYWdlci5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuc3BlY3MuZm9yRWFjaChmdW5jdGlvbiAoc3BlYykge1xuICAgICAgICAgICAgc3BlYy5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBTcGVjTWFuYWdlcjtcbn0oKSk7XG5cbmZ1bmN0aW9uIHJlc29sdmVTZWxlY3Rpb25Qb3Moc2VsZWN0aW9uKSB7XG4gICAgdmFyIGZyb20gPSBzZWxlY3Rpb24uZnJvbSwgdG8gPSBzZWxlY3Rpb24udG87XG4gICAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gW2Zyb20gKyAxLCB0byAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gW2Zyb20sIHRvXTtcbn1cbmZ1bmN0aW9uIGdldE1kTGluZShyZXNvbHZlZFBvcykge1xuICAgIHJldHVybiByZXNvbHZlZFBvcy5pbmRleCgwKSArIDE7XG59XG5mdW5jdGlvbiBnZXRXaWRnZXROb2RlUG9zKG5vZGUsIGNoUG9zLCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSB2b2lkIDApIHsgZGlyZWN0aW9uID0gMTsgfVxuICAgIHZhciBhZGRpdGlvbmFsUG9zID0gMDtcbiAgICBub2RlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBwb3MpIHtcbiAgICAgICAgLy8gYWRkIG9yIHN1YnRyYWN0IHdpZGdldCBub2RlIHRhZ1xuICAgICAgICBpZiAoaXNXaWRnZXROb2RlKGNoaWxkKSAmJiBwb3MgKyAyIDwgY2hQb3MpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxQb3MgKz0gMiAqIGRpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhZGRpdGlvbmFsUG9zO1xufVxuZnVuY3Rpb24gZ2V0RWRpdG9yVG9NZFBvcyhkb2MsIGZyb20sIHRvKSB7XG4gICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSBmcm9tOyB9XG4gICAgdmFyIGNvbGxhcHNlZCA9IGZyb20gPT09IHRvO1xuICAgIHZhciBzdGFydFJlc29sdmVkUG9zID0gZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgdmFyIHN0YXJ0TGluZSA9IGdldE1kTGluZShzdGFydFJlc29sdmVkUG9zKTtcbiAgICB2YXIgZW5kTGluZSA9IHN0YXJ0TGluZTtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSBzdGFydFJlc29sdmVkUG9zLnN0YXJ0KDEpO1xuICAgIHZhciBlbmRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICBpZiAoIWNvbGxhcHNlZCkge1xuICAgICAgICAvLyBwcmV2ZW50IHRoZSBlbmQgb2Zmc2V0IGZyb20gcG9pbnRpbmcgdG8gdGhlIHJvb3QgZG9jdW1lbnQgcG9zaXRpb25cbiAgICAgICAgdmFyIGVuZFJlc29sdmVkUG9zID0gZG9jLnJlc29sdmUodG8gPT09IGRvYy5jb250ZW50LnNpemUgPyB0byAtIDEgOiB0byk7XG4gICAgICAgIGVuZE9mZnNldCA9IGVuZFJlc29sdmVkUG9zLnN0YXJ0KDEpO1xuICAgICAgICBlbmRMaW5lID0gZ2V0TWRMaW5lKGVuZFJlc29sdmVkUG9zKTtcbiAgICAgICAgLy8gVG8gcmVzb2x2ZSB0aGUgZW5kIG9mZnNldCBleGNsdWRpbmcgZG9jdW1lbnQgdGFnIHNpemVcbiAgICAgICAgaWYgKGVuZFJlc29sdmVkUG9zLnBvcyA9PT0gZG9jLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgdG8gPSBkb2MuY29udGVudC5zaXplIC0gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3RhcnRDaCA9IE1hdGgubWF4KGZyb20gLSBzdGFydE9mZnNldCArIDEsIDEpO1xuICAgIHZhciBlbmRDaCA9IE1hdGgubWF4KHRvIC0gZW5kT2Zmc2V0ICsgMSwgMSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgW3N0YXJ0TGluZSwgc3RhcnRDaCArIGdldFdpZGdldE5vZGVQb3MoZG9jLmNoaWxkKHN0YXJ0TGluZSAtIDEpLCBzdGFydENoLCAtMSldLFxuICAgICAgICBbZW5kTGluZSwgZW5kQ2ggKyBnZXRXaWRnZXROb2RlUG9zKGRvYy5jaGlsZChlbmRMaW5lIC0gMSksIGVuZENoLCAtMSldLFxuICAgIF07XG59XG5mdW5jdGlvbiBnZXRTdGFydFBvc0xpc3RQZXJMaW5lKGRvYywgZW5kSW5kZXgpIHtcbiAgICB2YXIgc3RhcnRQb3NMaXN0UGVyTGluZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBwb3MgPSAwOyBpIDwgZW5kSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY2hpbGQgPSBkb2MuY2hpbGQoaSk7XG4gICAgICAgIHN0YXJ0UG9zTGlzdFBlckxpbmVbaV0gPSBwb3M7XG4gICAgICAgIHBvcyArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0UG9zTGlzdFBlckxpbmU7XG59XG5mdW5jdGlvbiBnZXRNZFRvRWRpdG9yUG9zKGRvYywgc3RhcnRQb3MsIGVuZFBvcykge1xuICAgIHZhciBzdGFydFBvc0xpc3RQZXJMaW5lID0gZ2V0U3RhcnRQb3NMaXN0UGVyTGluZShkb2MsIGVuZFBvc1swXSk7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBzdGFydFBvc1swXSAtIDE7XG4gICAgdmFyIGVuZEluZGV4ID0gZW5kUG9zWzBdIC0gMTtcbiAgICB2YXIgc3RhcnROb2RlID0gZG9jLmNoaWxkKHN0YXJ0SW5kZXgpO1xuICAgIHZhciBlbmROb2RlID0gZG9jLmNoaWxkKGVuZEluZGV4KTtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGxpbmVcbiAgICB2YXIgZnJvbSA9IHN0YXJ0UG9zTGlzdFBlckxpbmVbc3RhcnRJbmRleF07XG4gICAgdmFyIHRvID0gc3RhcnRQb3NMaXN0UGVyTGluZVtlbmRJbmRleF07XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBjaGFyYWN0ZXIgb2Zmc2V0IG9mIHRoZSBsaW5lXG4gICAgZnJvbSArPSBzdGFydFBvc1sxXSArIGdldFdpZGdldE5vZGVQb3Moc3RhcnROb2RlLCBzdGFydFBvc1sxXSAtIDEpO1xuICAgIHRvICs9IGVuZFBvc1sxXSArIGdldFdpZGdldE5vZGVQb3MoZW5kTm9kZSwgZW5kUG9zWzFdIC0gMSk7XG4gICAgcmV0dXJuIFtmcm9tLCBNYXRoLm1pbih0bywgZG9jLmNvbnRlbnQuc2l6ZSldO1xufVxuZnVuY3Rpb24gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbikge1xuICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgJHRvID0gc2VsZWN0aW9uLiR0bztcbiAgICB2YXIgZnJvbSA9IHNlbGVjdGlvbi5mcm9tLCB0byA9IHNlbGVjdGlvbi50bztcbiAgICB2YXIgZG9jID0gJGZyb20uZG9jO1xuICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24pIHtcbiAgICAgICAgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tICsgMSk7XG4gICAgICAgICR0byA9IGRvYy5yZXNvbHZlKHRvIC0gMSk7XG4gICAgfVxuICAgIGlmICgkZnJvbS5kZXB0aCA9PT0gMCkge1xuICAgICAgICAkZnJvbSA9IGRvYy5yZXNvbHZlKGZyb20gLSAxKTtcbiAgICAgICAgJHRvID0gJGZyb207XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0RnJvbU9mZnNldDogJGZyb20uc3RhcnQoMSksXG4gICAgICAgIGVuZEZyb21PZmZzZXQ6ICR0by5zdGFydCgxKSxcbiAgICAgICAgc3RhcnRUb09mZnNldDogJGZyb20uZW5kKDEpLFxuICAgICAgICBlbmRUb09mZnNldDogJHRvLmVuZCgxKSxcbiAgICAgICAgc3RhcnRJbmRleDogJGZyb20uaW5kZXgoMCksXG4gICAgICAgIGVuZEluZGV4OiAkdG8uaW5kZXgoMCksXG4gICAgICAgIGZyb206ICRmcm9tLnBvcyxcbiAgICAgICAgdG86ICR0by5wb3MsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVDb250ZW50T2Zmc2V0UmFuZ2UoZG9jLCB0YXJnZXRJbmRleCkge1xuICAgIHZhciBzdGFydE9mZnNldCA9IDE7XG4gICAgdmFyIGVuZE9mZnNldCA9IDE7XG4gICAgZm9yICh2YXIgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCBkb2MuY2hpbGRDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBub2RlU2l6ZSA9IGRvYy5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIGNvbnRlbnQgc3RhcnQsIGVuZCBvZmZzZXQobm90IG5vZGUgb2Zmc2V0KVxuICAgICAgICBzdGFydE9mZnNldCA9IG9mZnNldCArIDE7XG4gICAgICAgIGVuZE9mZnNldCA9IG9mZnNldCArIG5vZGVTaXplIC0gMTtcbiAgICAgICAgaWYgKGkgPT09IHRhcmdldEluZGV4KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gbm9kZVNpemU7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCwgZW5kT2Zmc2V0OiBlbmRPZmZzZXQgfTtcbn1cblxudmFyIEhFQURJTkcgPSAnaGVhZGluZyc7XG52YXIgQkxPQ0tfUVVPVEUgPSAnYmxvY2tRdW90ZSc7XG52YXIgTElTVF9JVEVNID0gJ2xpc3RJdGVtJztcbnZhciBUQUJMRSA9ICd0YWJsZSc7XG52YXIgVEFCTEVfQ0VMTCA9ICd0YWJsZUNlbGwnO1xudmFyIENPREVfQkxPQ0sgPSAnY29kZUJsb2NrJztcbnZhciBUSEVNQVRJQ19CUkVBSyA9ICd0aGVtYXRpY0JyZWFrJztcbnZhciBMSU5LID0gJ2xpbmsnO1xudmFyIENPREUgPSAnY29kZSc7XG52YXIgTUVUQSA9ICdtZXRhJztcbnZhciBERUxJTSA9ICdkZWxpbWl0ZXInO1xudmFyIFRBU0tfREVMSU0gPSAndGFza0RlbGltaXRlcic7XG52YXIgVEVYVCA9ICdtYXJrZWRUZXh0JztcbnZhciBIVE1MID0gJ2h0bWwnO1xudmFyIENVU1RPTV9CTE9DSyA9ICdjdXN0b21CbG9jayc7XG52YXIgZGVsaW1TaXplID0ge1xuICAgIHN0cm9uZzogMixcbiAgICBlbXBoOiAxLFxuICAgIHN0cmlrZTogMixcbn07XG5mdW5jdGlvbiBtYXJrSW5mbyhzdGFydCwgZW5kLCB0eXBlLCBhdHRycykge1xuICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIHNwZWM6IHsgdHlwZTogdHlwZSwgYXR0cnM6IGF0dHJzIH0gfTtcbn1cbmZ1bmN0aW9uIGhlYWRpbmckMShfYSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBsZXZlbCA9IF9hLmxldmVsLCBoZWFkaW5nVHlwZSA9IF9hLmhlYWRpbmdUeXBlO1xuICAgIHZhciBtYXJrcyA9IFttYXJrSW5mbyhzdGFydCwgZW5kLCBIRUFESU5HLCB7IGxldmVsOiBsZXZlbCB9KV07XG4gICAgaWYgKGhlYWRpbmdUeXBlID09PSAnYXR4Jykge1xuICAgICAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKHN0YXJ0LCBhZGRPZmZzZXRQb3Moc3RhcnQsIGxldmVsKSwgREVMSU0pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1hcmtzLnB1c2gobWFya0luZm8oc2V0T2Zmc2V0UG9zKGVuZCwgMCksIGVuZCwgSEVBRElORywgeyBzZVRleHQ6IHRydWUgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya3M7XG59XG5mdW5jdGlvbiBlbXBoYXNpc0FuZFN0cmlrZXRocm91Z2goX2EsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgdmFyIHN0YXJ0RGVsaW1Qb3MgPSBhZGRPZmZzZXRQb3Moc3RhcnQsIGRlbGltU2l6ZVt0eXBlXSk7XG4gICAgdmFyIGVuZERlbGltUG9zID0gYWRkT2Zmc2V0UG9zKGVuZCwgLWRlbGltU2l6ZVt0eXBlXSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbWFya0luZm8oc3RhcnREZWxpbVBvcywgZW5kRGVsaW1Qb3MsIHR5cGUpLFxuICAgICAgICBtYXJrSW5mbyhzdGFydCwgc3RhcnREZWxpbVBvcywgREVMSU0pLFxuICAgICAgICBtYXJrSW5mbyhlbmREZWxpbVBvcywgZW5kLCBERUxJTSksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG1hcmtMaW5rKHN0YXJ0LCBlbmQsIGxpbmtUZXh0U3RhcnQsIGxhc3RDaGlsZENoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbWFya0luZm8oc3RhcnQsIGVuZCwgTElOSyksXG4gICAgICAgIG1hcmtJbmZvKHNldE9mZnNldFBvcyhzdGFydCwgbGlua1RleHRTdGFydFsxXSArIDEpLCBzZXRPZmZzZXRQb3MoZW5kLCBsYXN0Q2hpbGRDaCksIExJTkssIHtcbiAgICAgICAgICAgIGRlc2M6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICBtYXJrSW5mbyhzZXRPZmZzZXRQb3MoZW5kLCBsYXN0Q2hpbGRDaCArIDIpLCBhZGRPZmZzZXRQb3MoZW5kLCAtMSksIExJTkssIHsgdXJsOiB0cnVlIH0pLFxuICAgIF07XG59XG5mdW5jdGlvbiBpbWFnZSQxKF9hLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGxhc3RDaGlsZCA9IF9hLmxhc3RDaGlsZDtcbiAgICB2YXIgbGFzdENoaWxkQ2ggPSBsYXN0Q2hpbGQgPyBnZXRNZEVuZENoKGxhc3RDaGlsZCkgKyAxIDogMzsgLy8gMzogbGVuZ3RoIG9mICchW10nXG4gICAgdmFyIGxpbmtUZXh0RW5kID0gYWRkT2Zmc2V0UG9zKHN0YXJ0LCAxKTtcbiAgICByZXR1cm4gX19zcHJlYWRBcnJheSQxKFttYXJrSW5mbyhzdGFydCwgbGlua1RleHRFbmQsIE1FVEEpXSwgbWFya0xpbmsoc3RhcnQsIGVuZCwgbGlua1RleHRFbmQsIGxhc3RDaGlsZENoKSk7XG59XG5mdW5jdGlvbiBsaW5rKF9hLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGxhc3RDaGlsZCA9IF9hLmxhc3RDaGlsZCwgZXh0ZW5kZWRBdXRvbGluayA9IF9hLmV4dGVuZGVkQXV0b2xpbms7XG4gICAgdmFyIGxhc3RDaGlsZENoID0gbGFzdENoaWxkID8gZ2V0TWRFbmRDaChsYXN0Q2hpbGQpICsgMSA6IDI7IC8vIDI6IGxlbmd0aCBvZiAnW10nXG4gICAgcmV0dXJuIGV4dGVuZGVkQXV0b2xpbmtcbiAgICAgICAgPyBbbWFya0luZm8oc3RhcnQsIGVuZCwgTElOSywgeyBkZXNjOiB0cnVlIH0pXVxuICAgICAgICA6IG1hcmtMaW5rKHN0YXJ0LCBlbmQsIHN0YXJ0LCBsYXN0Q2hpbGRDaCk7XG59XG5mdW5jdGlvbiBjb2RlKF9hLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHRpY2tDb3VudCA9IF9hLnRpY2tDb3VudDtcbiAgICB2YXIgb3BlbkRlbGltRW5kID0gYWRkT2Zmc2V0UG9zKHN0YXJ0LCB0aWNrQ291bnQpO1xuICAgIHZhciBjbG9zZURlbGltU3RhcnQgPSBhZGRPZmZzZXRQb3MoZW5kLCAtdGlja0NvdW50KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBtYXJrSW5mbyhzdGFydCwgZW5kLCBDT0RFKSxcbiAgICAgICAgbWFya0luZm8oc3RhcnQsIG9wZW5EZWxpbUVuZCwgQ09ERSwgeyBzdGFydDogdHJ1ZSB9KSxcbiAgICAgICAgbWFya0luZm8ob3BlbkRlbGltRW5kLCBjbG9zZURlbGltU3RhcnQsIENPREUsIHsgbWFya2VkOiB0cnVlIH0pLFxuICAgICAgICBtYXJrSW5mbyhjbG9zZURlbGltU3RhcnQsIGVuZCwgQ09ERSwgeyBlbmQ6IHRydWUgfSksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGxpbmVCYWNrZ3JvdW5kKHBhcmVudCwgc3RhcnQsIGVuZCwgcHJlZml4KSB7XG4gICAgdmFyIGRlZmF1bHRCYWNrZ3JvdW5kID0ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kLFxuICAgICAgICBzcGVjOiB7XG4gICAgICAgICAgICBhdHRyczogeyBjbGFzc05hbWU6IHByZWZpeCArIFwiLWxpbmUtYmFja2dyb3VuZFwiLCBjb2RlU3RhcnQ6IHN0YXJ0WzBdLCBjb2RlRW5kOiBlbmRbMF0gfSxcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUJhY2tncm91bmQ6IHRydWUsXG4gICAgfTtcbiAgICByZXR1cm4gcGFyZW50LnR5cGUgIT09ICdpdGVtJyAmJiBwYXJlbnQudHlwZSAhPT0gJ2Jsb2NrUXVvdGUnXG4gICAgICAgID8gW1xuICAgICAgICAgICAgX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBkZWZhdWx0QmFja2dyb3VuZCksIHsgZW5kOiBzdGFydCwgc3BlYzogeyBhdHRyczogeyBjbGFzc05hbWU6IHByZWZpeCArIFwiLWxpbmUtYmFja2dyb3VuZCBzdGFydFwiIH0gfSB9KSxcbiAgICAgICAgICAgIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgZGVmYXVsdEJhY2tncm91bmQpLCB7IHN0YXJ0OiBbTWF0aC5taW4oc3RhcnRbMF0gKyAxLCBlbmRbMF0pLCBzdGFydFsxXV0gfSksXG4gICAgICAgIF1cbiAgICAgICAgOiBudWxsO1xufVxuZnVuY3Rpb24gY29kZUJsb2NrJDEobm9kZSwgc3RhcnQsIGVuZCwgZW5kTGluZSkge1xuICAgIHZhciBmZW5jZU9mZnNldCA9IG5vZGUuZmVuY2VPZmZzZXQsIGZlbmNlTGVuZ3RoID0gbm9kZS5mZW5jZUxlbmd0aCwgZmVuY2VDaGFyID0gbm9kZS5mZW5jZUNoYXIsIGluZm8gPSBub2RlLmluZm8sIGluZm9QYWRkaW5nID0gbm9kZS5pbmZvUGFkZGluZywgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgdmFyIGZlbmNlRW5kID0gZmVuY2VPZmZzZXQgKyBmZW5jZUxlbmd0aDtcbiAgICB2YXIgbWFya3MgPSBbbWFya0luZm8oc2V0T2Zmc2V0UG9zKHN0YXJ0LCAxKSwgZW5kLCBDT0RFX0JMT0NLKV07XG4gICAgaWYgKGZlbmNlQ2hhcikge1xuICAgICAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKHN0YXJ0LCBhZGRPZmZzZXRQb3Moc3RhcnQsIGZlbmNlRW5kKSwgREVMSU0pKTtcbiAgICB9XG4gICAgaWYgKGluZm8pIHtcbiAgICAgICAgbWFya3MucHVzaChtYXJrSW5mbyhhZGRPZmZzZXRQb3Moc3RhcnQsIGZlbmNlTGVuZ3RoKSwgYWRkT2Zmc2V0UG9zKHN0YXJ0LCBmZW5jZUxlbmd0aCArIGluZm9QYWRkaW5nICsgaW5mby5sZW5ndGgpLCBNRVRBKSk7XG4gICAgfVxuICAgIHZhciBjb2RlQmxvY2tFbmQgPSBcIl4oXFxcXHN7MCw0fSkoXCIgKyBmZW5jZUNoYXIgKyBcIntcIiArIGZlbmNlTGVuZ3RoICsgXCIsfSlcIjtcbiAgICB2YXIgcmVDb2RlQmxvY2tFbmQgPSBuZXcgUmVnRXhwKGNvZGVCbG9ja0VuZCk7XG4gICAgaWYgKHJlQ29kZUJsb2NrRW5kLnRlc3QoZW5kTGluZSkpIHtcbiAgICAgICAgbWFya3MucHVzaChtYXJrSW5mbyhzZXRPZmZzZXRQb3MoZW5kLCAxKSwgZW5kLCBERUxJTSkpO1xuICAgIH1cbiAgICB2YXIgbGluZUJhY2tncm91bmRNYXJrSW5mbyA9IGxpbmVCYWNrZ3JvdW5kKHBhcmVudCwgc3RhcnQsIGVuZCwgJ2NvZGUtYmxvY2snKTtcbiAgICByZXR1cm4gbGluZUJhY2tncm91bmRNYXJrSW5mbyA/IG1hcmtzLmNvbmNhdChsaW5lQmFja2dyb3VuZE1hcmtJbmZvKSA6IG1hcmtzO1xufVxuZnVuY3Rpb24gY3VzdG9tQmxvY2skMihub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIF9hID0gbm9kZSwgb2Zmc2V0ID0gX2Eub2Zmc2V0LCBzeW50YXhMZW5ndGggPSBfYS5zeW50YXhMZW5ndGgsIGluZm8gPSBfYS5pbmZvLCBwYXJlbnQgPSBfYS5wYXJlbnQ7XG4gICAgdmFyIHN5bnRheEVuZCA9IG9mZnNldCArIHN5bnRheExlbmd0aDtcbiAgICB2YXIgbWFya3MgPSBbbWFya0luZm8oc2V0T2Zmc2V0UG9zKHN0YXJ0LCAxKSwgZW5kLCBDVVNUT01fQkxPQ0spXTtcbiAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKHN0YXJ0LCBhZGRPZmZzZXRQb3Moc3RhcnQsIHN5bnRheEVuZCksIERFTElNKSk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgICAgbWFya3MucHVzaChtYXJrSW5mbyhhZGRPZmZzZXRQb3Moc3RhcnQsIHN5bnRheEVuZCksIGFkZE9mZnNldFBvcyhzdGFydCwgc3ludGF4TGVuZ3RoICsgaW5mby5sZW5ndGgpLCBNRVRBKSk7XG4gICAgfVxuICAgIG1hcmtzLnB1c2gobWFya0luZm8oc2V0T2Zmc2V0UG9zKGVuZCwgMSksIGVuZCwgREVMSU0pKTtcbiAgICB2YXIgbGluZUJhY2tncm91bmRNYXJrSW5mbyA9IGxpbmVCYWNrZ3JvdW5kKHBhcmVudCwgc3RhcnQsIGVuZCwgJ2N1c3RvbS1ibG9jaycpO1xuICAgIHJldHVybiBsaW5lQmFja2dyb3VuZE1hcmtJbmZvID8gbWFya3MuY29uY2F0KGxpbmVCYWNrZ3JvdW5kTWFya0luZm8pIDogbWFya3M7XG59XG5mdW5jdGlvbiBtYXJrTGlzdEl0ZW1DaGlsZHJlbihub2RlLCBtYXJrVHlwZSkge1xuICAgIHZhciBtYXJrcyA9IFtdO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3BhcmFncmFwaCcgfHwgdHlwZSA9PT0gJ2NvZGVCbG9jaycpIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2gobWFya0luZm8oW2dldE1kU3RhcnRMaW5lKG5vZGUpLCBnZXRNZFN0YXJ0Q2gobm9kZSkgLSAxXSwgW2dldE1kRW5kTGluZShub2RlKSwgZ2V0TWRFbmRDaChub2RlKSArIDFdLCBtYXJrVHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBtYXJrcztcbn1cbmZ1bmN0aW9uIG1hcmtQYXJhZ3JhcGhJbkJsb2NrUXVvdGUobm9kZSkge1xuICAgIHZhciBtYXJrcyA9IFtdO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIG1hcmtzLnB1c2gobWFya0luZm8oW2dldE1kU3RhcnRMaW5lKG5vZGUpLCBnZXRNZFN0YXJ0Q2gobm9kZSldLCBbZ2V0TWRFbmRMaW5lKG5vZGUpLCBnZXRNZEVuZENoKG5vZGUpICsgMV0sIFRFWFQpKTtcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtzO1xufVxuZnVuY3Rpb24gYmxvY2tRdW90ZSQyKG5vZGUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgbWFya3MgPSBub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC50eXBlICE9PSAnYmxvY2tRdW90ZScgPyBbbWFya0luZm8oc3RhcnQsIGVuZCwgQkxPQ0tfUVVPVEUpXSA6IFtdO1xuICAgIGlmIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgdmFyIGNoaWxkTWFya3MgPSBbXTtcbiAgICAgICAgaWYgKG5vZGUuZmlyc3RDaGlsZC50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgY2hpbGRNYXJrcyA9IG1hcmtQYXJhZ3JhcGhJbkJsb2NrUXVvdGUobm9kZS5maXJzdENoaWxkLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUuZmlyc3RDaGlsZC50eXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgICAgIGNoaWxkTWFya3MgPSBtYXJrTGlzdEl0ZW1DaGlsZHJlbihub2RlLmZpcnN0Q2hpbGQsIFRFWFQpO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtzID0gX19zcHJlYWRBcnJheSQxKF9fc3ByZWFkQXJyYXkkMShbXSwgbWFya3MpLCBjaGlsZE1hcmtzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtzO1xufVxuZnVuY3Rpb24gZ2V0U3BlY09mTGlzdEl0ZW1TdHlsZShub2RlKSB7XG4gICAgdmFyIGRlcHRoID0gMDtcbiAgICB3aGlsZSAobm9kZS5wYXJlbnQucGFyZW50ICYmIG5vZGUucGFyZW50LnBhcmVudC50eXBlID09PSAnaXRlbScpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50LnBhcmVudDtcbiAgICAgICAgZGVwdGggKz0gMTtcbiAgICB9XG4gICAgdmFyIGF0dHJzID0gW3sgb2RkOiB0cnVlIH0sIHsgZXZlbjogdHJ1ZSB9XVtkZXB0aCAlIDJdO1xuICAgIHJldHVybiBbTElTVF9JVEVNLCBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGF0dHJzKSwgeyBsaXN0U3R5bGU6IHRydWUgfSldO1xufVxuZnVuY3Rpb24gaXRlbSQxKG5vZGUsIHN0YXJ0KSB7XG4gICAgdmFyIF9hID0gbm9kZS5saXN0RGF0YSwgcGFkZGluZyA9IF9hLnBhZGRpbmcsIHRhc2sgPSBfYS50YXNrO1xuICAgIHZhciBzcGVjID0gZ2V0U3BlY09mTGlzdEl0ZW1TdHlsZShub2RlKTtcbiAgICB2YXIgbWFya3MgPSBbbWFya0luZm8uYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5JDEoW3N0YXJ0LCBhZGRPZmZzZXRQb3Moc3RhcnQsIHBhZGRpbmcpXSwgc3BlYykpXTtcbiAgICBpZiAodGFzaykge1xuICAgICAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKGFkZE9mZnNldFBvcyhzdGFydCwgcGFkZGluZyksIGFkZE9mZnNldFBvcyhzdGFydCwgcGFkZGluZyArIDMpLCBUQVNLX0RFTElNKSk7XG4gICAgICAgIG1hcmtzLnB1c2gobWFya0luZm8oYWRkT2Zmc2V0UG9zKHN0YXJ0LCBwYWRkaW5nICsgMSksIGFkZE9mZnNldFBvcyhzdGFydCwgcGFkZGluZyArIDIpLCBNRVRBKSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrcy5jb25jYXQobWFya0xpc3RJdGVtQ2hpbGRyZW4obm9kZS5maXJzdENoaWxkLCBURVhUKSk7XG59XG52YXIgbWFya05vZGVGdW5jTWFwID0ge1xuICAgIGhlYWRpbmc6IGhlYWRpbmckMSxcbiAgICBzdHJvbmc6IGVtcGhhc2lzQW5kU3RyaWtldGhyb3VnaCxcbiAgICBlbXBoOiBlbXBoYXNpc0FuZFN0cmlrZXRocm91Z2gsXG4gICAgc3RyaWtlOiBlbXBoYXNpc0FuZFN0cmlrZXRocm91Z2gsXG4gICAgbGluazogbGluayxcbiAgICBpbWFnZTogaW1hZ2UkMSxcbiAgICBjb2RlOiBjb2RlLFxuICAgIGNvZGVCbG9jazogY29kZUJsb2NrJDEsXG4gICAgYmxvY2tRdW90ZTogYmxvY2tRdW90ZSQyLFxuICAgIGl0ZW06IGl0ZW0kMSxcbiAgICBjdXN0b21CbG9jazogY3VzdG9tQmxvY2skMixcbn07XG52YXIgc2ltcGxlTWFya0NsYXNzTmFtZU1hcCA9IHtcbiAgICB0aGVtYXRpY0JyZWFrOiBUSEVNQVRJQ19CUkVBSyxcbiAgICB0YWJsZTogVEFCTEUsXG4gICAgdGFibGVDZWxsOiBUQUJMRV9DRUxMLFxuICAgIGh0bWxJbmxpbmU6IEhUTUwsXG59O1xuZnVuY3Rpb24gZ2V0TWFya0luZm8obm9kZSwgc3RhcnQsIGVuZCwgZW5kTGluZSkge1xuICAgIHZhciB0eXBlID0gbm9kZS50eXBlO1xuICAgIGlmIChpc0Z1bmN0aW9uXzEobWFya05vZGVGdW5jTWFwW3R5cGVdKSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBtYXJrTm9kZUZ1bmNNYXBbdHlwZV0obm9kZSwgc3RhcnQsIGVuZCwgZW5kTGluZSk7XG4gICAgfVxuICAgIGlmIChzaW1wbGVNYXJrQ2xhc3NOYW1lTWFwW3R5cGVdKSB7XG4gICAgICAgIHJldHVybiBbbWFya0luZm8oc3RhcnQsIGVuZCwgc2ltcGxlTWFya0NsYXNzTmFtZU1hcFt0eXBlXSldO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxudmFyIHJlbW92aW5nQmFja2dyb3VuZEluZGV4TWFwID0ge307XG5mdW5jdGlvbiBzeW50YXhIaWdobGlnaHQoX2EpIHtcbiAgICB2YXIgc2NoZW1hID0gX2Euc2NoZW1hLCB0b2FzdE1hcmsgPSBfYS50b2FzdE1hcms7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogZnVuY3Rpb24gKHRyYW5zYWN0aW9ucywgXywgbmV3U3RhdGUpIHtcbiAgICAgICAgICAgIHZhciB0ciA9IHRyYW5zYWN0aW9uc1swXTtcbiAgICAgICAgICAgIHZhciBuZXdUciA9IG5ld1N0YXRlLnRyO1xuICAgICAgICAgICAgaWYgKHRyLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFya0luZm9fMSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBlZGl0UmVzdWx0ID0gdHIuZ2V0TWV0YSgnZWRpdFJlc3VsdCcpO1xuICAgICAgICAgICAgICAgIGVkaXRSZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IHJlc3VsdC5ub2RlcywgcmVtb3ZlZE5vZGVSYW5nZSA9IHJlc3VsdC5yZW1vdmVkTm9kZVJhbmdlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrSW5mb18xID0gbWFya0luZm9fMS5jb25jYXQoZ2V0TWFya0ZvclJlbW92aW5nKG5ld1RyLCBub2RlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBub2Rlc18xID0gbm9kZXM7IF9pIDwgbm9kZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBub2Rlc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2Fsa2VyID0gcGFyZW50XzEud2Fsa2VyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChldmVudF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gZXZlbnRfMS5ub2RlLCBlbnRlcmluZyA9IGV2ZW50XzEuZW50ZXJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya0luZm9fMSA9IG1hcmtJbmZvXzEuY29uY2F0KGdldE1hcmtGb3JBZGRpbmcobm9kZSwgdG9hc3RNYXJrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRfMSA9IHdhbGtlci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlbW92ZWROb2RlUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhJbmRleCA9IG5ld1RyLmRvYy5jaGlsZENvdW50IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHJlbW92ZWROb2RlUmFuZ2UubGluZSwgc3RhcnRMaW5lID0gX2FbMF0sIGVuZExpbmUgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRMaW5lLCBtYXhJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBNYXRoLm1pbihlbmRMaW5lLCBtYXhJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZSB0aGUgaW5kZXggdG8gcmVtb3ZlIGNvZGUgYmxvY2ssIGN1c3RvbSBibG9jayBiYWNrZ3JvdW5kIHdoZW4gdGhlcmUgYXJlIG5vIGFkZGluZyBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPD0gZW5kSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92aW5nQmFja2dyb3VuZEluZGV4TWFwW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFwcGVuZE1hcmtUcihuZXdUciwgc2NoZW1hLCBtYXJrSW5mb18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdUci5zZXRNZXRhKCd3aWRnZXQnLCB0ci5nZXRNZXRhKCd3aWRnZXQnKSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc0RpZmZlcmVudEJsb2NrKGRvYywgaW5kZXgsIGF0dHJzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHJzKS5zb21lKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBhdHRyc1tuYW1lXSAhPT0gZG9jLmNoaWxkKGluZGV4KS5hdHRyc1tuYW1lXTsgfSk7XG59XG5mdW5jdGlvbiBhZGRMaW5lQmFja2dyb3VuZCh0ciwgZG9jLCBwYXJhZ3JhcGgsIGJsb2NrUG9zSW5mbywgYXR0cnMpIHtcbiAgICBpZiAoYXR0cnMgPT09IHZvaWQgMCkgeyBhdHRycyA9IHt9OyB9XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBibG9ja1Bvc0luZm8uc3RhcnRJbmRleCwgZW5kSW5kZXggPSBibG9ja1Bvc0luZm8uZW5kSW5kZXgsIGZyb20gPSBibG9ja1Bvc0luZm8uZnJvbSwgdG8gPSBibG9ja1Bvc0luZm8udG87XG4gICAgdmFyIHNob3VsZENoYW5nZUJsb2NrVHlwZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDw9IGVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgLy8gcHJldmVudCB0byByZW1vdmUgYmFja2dyb3VuZCBvZiB0aGUgbm9kZSB0aGF0IG5lZWQgdG8gaGF2ZSBiYWNrZ3JvdW5kXG4gICAgICAgIGRlbGV0ZSByZW1vdmluZ0JhY2tncm91bmRJbmRleE1hcFtpXTtcbiAgICAgICAgc2hvdWxkQ2hhbmdlQmxvY2tUeXBlID0gaXNEaWZmZXJlbnRCbG9jayhkb2MsIGksIGF0dHJzKTtcbiAgICB9XG4gICAgaWYgKHNob3VsZENoYW5nZUJsb2NrVHlwZSkge1xuICAgICAgICB0ci5zZXRCbG9ja1R5cGUoZnJvbSwgdG8sIHBhcmFncmFwaCwgYXR0cnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZE1hcmtUcih0ciwgc2NoZW1hLCBtYXJrcykge1xuICAgIHZhciBkb2MgPSB0ci5kb2M7XG4gICAgdmFyIHBhcmFncmFwaCA9IHNjaGVtYS5ub2Rlcy5wYXJhZ3JhcGg7XG4gICAgLy8gZ2V0IHN0YXJ0IHBvc2l0aW9uIHBlciBsaW5lIGZvciBsYXp5IGNhbGN1bGF0aW9uXG4gICAgdmFyIHN0YXJ0UG9zTGlzdFBlckxpbmUgPSBnZXRTdGFydFBvc0xpc3RQZXJMaW5lKGRvYywgZG9jLmNoaWxkQ291bnQpO1xuICAgIG1hcmtzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBzdGFydCA9IF9hLnN0YXJ0LCBlbmQgPSBfYS5lbmQsIHNwZWMgPSBfYS5zcGVjLCBsaW5lQmFja2dyb3VuZCA9IF9hLmxpbmVCYWNrZ3JvdW5kO1xuICAgICAgICB2YXIgc3RhcnRJbmRleCA9IE1hdGgubWluKHN0YXJ0WzBdLCBkb2MuY2hpbGRDb3VudCkgLSAxO1xuICAgICAgICB2YXIgZW5kSW5kZXggPSBNYXRoLm1pbihlbmRbMF0sIGRvYy5jaGlsZENvdW50KSAtIDE7XG4gICAgICAgIHZhciBzdGFydE5vZGUgPSBkb2MuY2hpbGQoc3RhcnRJbmRleCk7XG4gICAgICAgIHZhciBlbmROb2RlID0gZG9jLmNoaWxkKGVuZEluZGV4KTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBsaW5lXG4gICAgICAgIHZhciBmcm9tID0gc3RhcnRQb3NMaXN0UGVyTGluZVtzdGFydEluZGV4XTtcbiAgICAgICAgdmFyIHRvID0gc3RhcnRQb3NMaXN0UGVyTGluZVtlbmRJbmRleF07XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgY2hhcmFjdGVyIG9mZnNldCBvZiB0aGUgbGluZVxuICAgICAgICBmcm9tICs9IHN0YXJ0WzFdICsgZ2V0V2lkZ2V0Tm9kZVBvcyhzdGFydE5vZGUsIHN0YXJ0WzFdIC0gMSk7XG4gICAgICAgIHRvICs9IGVuZFsxXSArIGdldFdpZGdldE5vZGVQb3MoZW5kTm9kZSwgZW5kWzFdIC0gMSk7XG4gICAgICAgIGlmIChzcGVjKSB7XG4gICAgICAgICAgICBpZiAobGluZUJhY2tncm91bmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zSW5mbyA9IHsgZnJvbTogZnJvbSwgdG86IHRvLCBzdGFydEluZGV4OiBzdGFydEluZGV4LCBlbmRJbmRleDogZW5kSW5kZXggfTtcbiAgICAgICAgICAgICAgICBhZGRMaW5lQmFja2dyb3VuZCh0ciwgZG9jLCBwYXJhZ3JhcGgsIHBvc0luZm8sIHNwZWMuYXR0cnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHIuYWRkTWFyayhmcm9tLCB0bywgc2NoZW1hLm1hcmsoc3BlYy50eXBlLCBzcGVjLmF0dHJzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ci5yZW1vdmVNYXJrKGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJlbW92ZUJsb2NrQmFja2dyb3VuZCh0ciwgc3RhcnRQb3NMaXN0UGVyTGluZSwgcGFyYWdyYXBoKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUJsb2NrQmFja2dyb3VuZCh0ciwgc3RhcnRQb3NMaXN0UGVyTGluZSwgcGFyYWdyYXBoKSB7XG4gICAgT2JqZWN0LmtleXMocmVtb3ZpbmdCYWNrZ3JvdW5kSW5kZXhNYXApLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gTnVtYmVyKGluZGV4KTtcbiAgICAgICAgLy8gZ2V0IHRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgbGluZSB3aXRoIHRoZSBuZXh0IG5vZGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICAgIHZhciBlbmRJbmRleCA9IE1hdGgubWluKE51bWJlcihpbmRleCkgKyAxLCB0ci5kb2MuY2hpbGRDb3VudCAtIDEpO1xuICAgICAgICB2YXIgZnJvbSA9IHN0YXJ0UG9zTGlzdFBlckxpbmVbc3RhcnRJbmRleF07XG4gICAgICAgIC8vIHN1YnRyYWN0ICcxJyBmb3IgZ2V0dGluZyBlbmQgcG9zaXRpb24gb2YgdGhlIGxpbmVcbiAgICAgICAgdmFyIHRvID0gc3RhcnRQb3NMaXN0UGVyTGluZVtlbmRJbmRleF0gLSAxO1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIHRvICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdHIuc2V0QmxvY2tUeXBlKGZyb20sIHRvLCBwYXJhZ3JhcGgpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY2FjaGVJbmRleFRvUmVtb3ZlQmFja2dyb3VuZChkb2MsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgc2tpcExpbmVzID0gW107XG4gICAgcmVtb3ZpbmdCYWNrZ3JvdW5kSW5kZXhNYXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRbMF0gLSAxOyBpIDwgZW5kWzBdOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBkb2MuY2hpbGQoaSk7XG4gICAgICAgIHZhciBjb2RlRW5kID0gbm9kZS5hdHRycy5jb2RlRW5kO1xuICAgICAgICB2YXIgY29kZVN0YXJ0ID0gbm9kZS5hdHRycy5jb2RlU3RhcnQ7XG4gICAgICAgIGlmIChjb2RlU3RhcnQgJiYgY29kZUVuZCAmJiAhaW5jbHVkZXMoc2tpcExpbmVzLCBjb2RlU3RhcnQpKSB7XG4gICAgICAgICAgICBza2lwTGluZXMucHVzaChjb2RlU3RhcnQpO1xuICAgICAgICAgICAgY29kZUVuZCA9IE1hdGgubWluKGNvZGVFbmQsIGRvYy5jaGlsZENvdW50KTtcbiAgICAgICAgICAgIC8vIHNob3VsZCBzdWJ0cmFjdCAnMScgdG8gbWFya2Rvd24gbGluZSBwb3NpdGlvblxuICAgICAgICAgICAgLy8gYmVjYXVzZSBtYXJrZG93biBwYXJzZXIgaGFzICcxJyhub3QgemVybykgYXMgdGhlIHN0YXJ0IG51bWJlclxuICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBjb2RlU3RhcnQgLSAxO1xuICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gZW5kWzBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSBzdGFydEluZGV4OyBpbmRleCA8IGVuZEluZGV4OyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZpbmdCYWNrZ3JvdW5kSW5kZXhNYXBbaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE1hcmtGb3JSZW1vdmluZyhfYSwgbm9kZXMpIHtcbiAgICB2YXIgZG9jID0gX2EuZG9jO1xuICAgIHZhciBzdGFydCA9IG5vZGVzWzBdLnNvdXJjZXBvc1swXTtcbiAgICB2YXIgX2IgPSBsYXN0JDEobm9kZXMpLnNvdXJjZXBvcywgZW5kID0gX2JbMV07XG4gICAgdmFyIHN0YXJ0UG9zID0gW3N0YXJ0WzBdLCBzdGFydFsxXV07XG4gICAgdmFyIGVuZFBvcyA9IFtlbmRbMF0sIGVuZFsxXSArIDFdO1xuICAgIHZhciBtYXJrcyA9IFtdO1xuICAgIGNhY2hlSW5kZXhUb1JlbW92ZUJhY2tncm91bmQoZG9jLCBzdGFydCwgZW5kKTtcbiAgICBtYXJrcy5wdXNoKHsgc3RhcnQ6IHN0YXJ0UG9zLCBlbmQ6IGVuZFBvcyB9KTtcbiAgICByZXR1cm4gbWFya3M7XG59XG5mdW5jdGlvbiBnZXRNYXJrRm9yQWRkaW5nKG5vZGUsIHRvYXN0TWFyaykge1xuICAgIHZhciBsaW5lVGV4dHMgPSB0b2FzdE1hcmsuZ2V0TGluZVRleHRzKCk7XG4gICAgdmFyIHN0YXJ0UG9zID0gW2dldE1kU3RhcnRMaW5lKG5vZGUpLCBnZXRNZFN0YXJ0Q2gobm9kZSldO1xuICAgIHZhciBlbmRQb3MgPSBbZ2V0TWRFbmRMaW5lKG5vZGUpLCBnZXRNZEVuZENoKG5vZGUpICsgMV07XG4gICAgdmFyIG1hcmtJbmZvID0gZ2V0TWFya0luZm8obm9kZSwgc3RhcnRQb3MsIGVuZFBvcywgbGluZVRleHRzW2VuZFBvc1swXSAtIDFdKTtcbiAgICByZXR1cm4gbWFya0luZm8gIT09IG51bGwgJiYgbWFya0luZm8gIT09IHZvaWQgMCA/IG1hcmtJbmZvIDogW107XG59XG5cbnZhciBkZWZhdWx0VG9vbGJhclN0YXRlS2V5cyA9IFtcbiAgICAndGFza0xpc3QnLFxuICAgICdvcmRlcmVkTGlzdCcsXG4gICAgJ2J1bGxldExpc3QnLFxuICAgICd0YWJsZScsXG4gICAgJ3N0cm9uZycsXG4gICAgJ2VtcGgnLFxuICAgICdzdHJpa2UnLFxuICAgICdoZWFkaW5nJyxcbiAgICAndGhlbWF0aWNCcmVhaycsXG4gICAgJ2Jsb2NrUXVvdGUnLFxuICAgICdjb2RlJyxcbiAgICAnY29kZUJsb2NrJyxcbiAgICAnaW5kZW50JyxcbiAgICAnb3V0ZGVudCcsXG5dO1xuZnVuY3Rpb24gZ2V0VG9vbGJhclN0YXRlVHlwZSQxKG1kTm9kZSkge1xuICAgIHZhciB0eXBlID0gbWROb2RlLnR5cGU7XG4gICAgaWYgKGlzTGlzdE5vZGUkMShtZE5vZGUpKSB7XG4gICAgICAgIGlmIChtZE5vZGUubGlzdERhdGEudGFzaykge1xuICAgICAgICAgICAgcmV0dXJuICd0YXNrTGlzdCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1kTm9kZS5saXN0RGF0YS50eXBlID09PSAnb3JkZXJlZCcgPyAnb3JkZXJlZExpc3QnIDogJ2J1bGxldExpc3QnO1xuICAgIH1cbiAgICBpZiAodHlwZS5pbmRleE9mKCd0YWJsZScpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gJ3RhYmxlJztcbiAgICB9XG4gICAgaWYgKCFpbmNsdWRlcyhkZWZhdWx0VG9vbGJhclN0YXRlS2V5cywgdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xufVxuZnVuY3Rpb24gZ2V0VG9vbGJhclN0YXRlJDEodGFyZ2V0Tm9kZSkge1xuICAgIHZhciB0b29sYmFyU3RhdGUgPSB7XG4gICAgICAgIGluZGVudDogeyBhY3RpdmU6IGZhbHNlLCBkaXNhYmxlZDogdHJ1ZSB9LFxuICAgICAgICBvdXRkZW50OiB7IGFjdGl2ZTogZmFsc2UsIGRpc2FibGVkOiB0cnVlIH0sXG4gICAgfTtcbiAgICB2YXIgbGlzdEVuYWJsZWQgPSB0cnVlO1xuICAgIHRyYXZlcnNlUGFyZW50Tm9kZXModGFyZ2V0Tm9kZSwgZnVuY3Rpb24gKG1kTm9kZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFRvb2xiYXJTdGF0ZVR5cGUkMShtZE5vZGUpO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2J1bGxldExpc3QnIHx8IHR5cGUgPT09ICdvcmRlcmVkTGlzdCcpIHtcbiAgICAgICAgICAgIC8vIHRvIGFwcGx5IHRoZSBuZWFybGlzdCBsaXN0IHN0YXRlIGluIHRoZSBuZXN0ZWQgbGlzdFxuICAgICAgICAgICAgaWYgKGxpc3RFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdG9vbGJhclN0YXRlW3R5cGVdID0geyBhY3RpdmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB0b29sYmFyU3RhdGUuaW5kZW50LmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdG9vbGJhclN0YXRlLm91dGRlbnQuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsaXN0RW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9vbGJhclN0YXRlW3R5cGVdID0geyBhY3RpdmU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0b29sYmFyU3RhdGU7XG59XG5mdW5jdGlvbiBwcmV2aWV3SGlnaGxpZ2h0KF9hKSB7XG4gICAgdmFyIHRvYXN0TWFyayA9IF9hLnRvYXN0TWFyaywgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyO1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgdmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh2aWV3LCBwcmV2U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IHN0YXRlLmRvYywgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldlN0YXRlICYmIHByZXZTdGF0ZS5kb2MuZXEoZG9jKSAmJiBwcmV2U3RhdGUuc2VsZWN0aW9uLmVxKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHNlbGVjdGlvbi5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRDaE9mZnNldCA9IHN0YXRlLmRvYy5yZXNvbHZlKGZyb20pLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc3RhdGUuZG9jLmNvbnRlbnQuZmluZEluZGV4KGZyb20pLmluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoID0gZnJvbSAtIHN0YXJ0Q2hPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID09PSBzdGFydENoT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JQb3MgPSBbbGluZSwgY2hdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWROb2RlID0gdG9hc3RNYXJrLmZpbmROb2RlQXRQb3NpdGlvbihjdXJzb3JQb3MpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9vbGJhclN0YXRlID0gZ2V0VG9vbGJhclN0YXRlJDEobWROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ2NoYW5nZVRvb2xiYXJTdGF0ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvclBvczogY3Vyc29yUG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWROb2RlOiBtZE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sYmFyU3RhdGU6IHRvb2xiYXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdzZXRGb2N1c2VkTm9kZScsIG1kTm9kZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbnZhciBEb2MkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShEb2MsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRG9jKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEb2MucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnZG9jJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEb2MucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnYmxvY2srJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRG9jO1xufShOb2RlJDIpKTtcblxudmFyIE1hcmsgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFyaygpIHtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcmsucHJvdG90eXBlLCBcInR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnbWFyayc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYXJrLnByb3RvdHlwZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9O1xuICAgIHJldHVybiBNYXJrO1xufSgpKTtcblxuZnVuY3Rpb24gZ2V0VGV4dEJ5TWRMaW5lKGRvYywgbWRMaW5lKSB7XG4gICAgcmV0dXJuIGdldFRleHRDb250ZW50KGRvYywgbWRMaW5lIC0gMSk7XG59XG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudChkb2MsIGluZGV4KSB7XG4gICAgcmV0dXJuIGRvYy5jaGlsZChpbmRleCkudGV4dENvbnRlbnQ7XG59XG5cbnZhciByZUJsb2NrUXVvdGUgPSAvXlxccyo+ID8vO1xudmFyIEJsb2NrUXVvdGUkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShCbG9ja1F1b3RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrUXVvdGUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2NrUXVvdGUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnYmxvY2tRdW90ZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmxvY2tRdW90ZS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ2Jsb2NrLXF1b3RlJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBCbG9ja1F1b3RlLnByb3RvdHlwZS5jcmVhdGVCbG9ja1F1b3RlVGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBpc0Jsb2NrUXVvdGUpIHtcbiAgICAgICAgcmV0dXJuIGlzQmxvY2tRdW90ZSA/IHRleHQucmVwbGFjZShyZUJsb2NrUXVvdGUsICcnKS50cmltKCkgOiBcIj4gXCIgKyB0ZXh0LnRyaW0oKTtcbiAgICB9O1xuICAgIEJsb2NrUXVvdGUucHJvdG90eXBlLmV4dGVuZEJsb2NrUXVvdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCBkb2MgPSBfYS5kb2MsIHRyID0gX2EudHIsIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciBfYiA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBlbmRGcm9tT2Zmc2V0ID0gX2IuZW5kRnJvbU9mZnNldCwgZW5kVG9PZmZzZXQgPSBfYi5lbmRUb09mZnNldCwgZW5kSW5kZXggPSBfYi5lbmRJbmRleCwgdG8gPSBfYi50bztcbiAgICAgICAgICAgIHZhciB0ZXh0Q29udGVudCA9IGdldFRleHRDb250ZW50KGRvYywgZW5kSW5kZXgpO1xuICAgICAgICAgICAgdmFyIGlzQmxvY2tRdW90ZSA9IHJlQmxvY2tRdW90ZS50ZXN0KHRleHRDb250ZW50KTtcbiAgICAgICAgICAgIGlmIChpc0Jsb2NrUXVvdGUgJiYgdG8gPiBlbmRGcm9tT2Zmc2V0ICYmIHNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gIXRleHRDb250ZW50LnJlcGxhY2UocmVCbG9ja1F1b3RlLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZVJhbmdlKGVuZEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0KS5zcGxpdCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsaWNlZFRleHQgPSB0ZXh0Q29udGVudC5zbGljZSh0byAtIGVuZEZyb21PZmZzZXQpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgX3RoaXMuY3JlYXRlQmxvY2tRdW90ZVRleHQoc2xpY2VkVGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdEFuZEV4dGVuZEJsb2NrKHRyLCBlbmRUb09mZnNldCwgc2xpY2VkVGV4dCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEJsb2NrUXVvdGUucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgZG9jID0gc3RhdGUuZG9jO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIHN0YXJ0RnJvbU9mZnNldCA9IF9hLnN0YXJ0RnJvbU9mZnNldCwgZW5kVG9PZmZzZXQgPSBfYS5lbmRUb09mZnNldCwgc3RhcnRJbmRleCA9IF9hLnN0YXJ0SW5kZXgsIGVuZEluZGV4ID0gX2EuZW5kSW5kZXg7XG4gICAgICAgICAgICB2YXIgaXNCbG9ja1F1b3RlID0gcmVCbG9ja1F1b3RlLnRlc3QoZ2V0VGV4dENvbnRlbnQoZG9jLCBzdGFydEluZGV4KSk7XG4gICAgICAgICAgICB2YXIgdHIgPSByZXBsYWNlVGV4dE5vZGUoe1xuICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4OiBzdGFydEluZGV4LFxuICAgICAgICAgICAgICAgIGVuZEluZGV4OiBlbmRJbmRleCxcbiAgICAgICAgICAgICAgICBmcm9tOiBzdGFydEZyb21PZmZzZXQsXG4gICAgICAgICAgICAgICAgY3JlYXRlVGV4dDogZnVuY3Rpb24gKHRleHRDb250ZW50KSB7IHJldHVybiBfdGhpcy5jcmVhdGVCbG9ja1F1b3RlVGV4dCh0ZXh0Q29udGVudCwgaXNCbG9ja1F1b3RlKTsgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSkpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgQmxvY2tRdW90ZS5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJsb2NrUXVvdGVDb21tYW5kID0gdGhpcy5jb21tYW5kcygpKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnYWx0LXEnOiBibG9ja1F1b3RlQ29tbWFuZCxcbiAgICAgICAgICAgICdhbHQtUSc6IGJsb2NrUXVvdGVDb21tYW5kLFxuICAgICAgICAgICAgRW50ZXI6IHRoaXMuZXh0ZW5kQmxvY2tRdW90ZSgpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEJsb2NrUXVvdGU7XG59KE1hcmspKTtcblxudmFyIHJlTGlzdCA9IC8oXlxccyopKFstKitdIHxbXFxkXStcXC4gKS87XG52YXIgcmVPcmRlcmVkTGlzdCA9IC8oXlxccyopKFtcXGRdKStcXC4oIFxcW1sgeFhdXSk/IC87XG52YXIgcmVPcmRlcmVkTGlzdEdyb3VwID0gL14oXFxzKikoKFxcZCspKFsuKV1cXHMoPzpcXFsoPzp4fFxccylcXF1cXHMpPykpKC4qKS87XG52YXIgcmVDYW5CZVRhc2tMaXN0ID0gLyheXFxzKikoWy0qK118W1xcZF0rXFwuKSggXFxbWyB4WF1dKT8gLztcbnZhciByZUJ1bGxldExpc3RHcm91cCA9IC9eKFxccyopKFstKitdKyhcXHMoPzpcXFsoPzp4fFxccylcXF1cXHMpPykpKC4qKS87XG52YXIgcmVUYXNrTGlzdCA9IC8oXlxccyopKFstKitdIHxbXFxkXStcXC4gKShcXFtbIHhYXV0gKS87XG52YXIgcmVCdWxsZXRUYXNrTGlzdCA9IC8oXlxccyopKFstKitdKSggXFxbWyB4WF1dKSAvO1xuZnVuY3Rpb24gZ2V0TGlzdFR5cGUodGV4dCkge1xuICAgIHJldHVybiByZU9yZGVyZWRMaXN0LnRlc3QodGV4dCkgPyAnb3JkZXJlZCcgOiAnYnVsbGV0Jztcbn1cbmZ1bmN0aW9uIGdldExpc3REZXB0aChtZE5vZGUpIHtcbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHdoaWxlIChtZE5vZGUgJiYgbWROb2RlLnR5cGUgIT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgaWYgKG1kTm9kZS50eXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbWROb2RlID0gbWROb2RlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGRlcHRoO1xufVxuZnVuY3Rpb24gZmluZFNhbWVEZXB0aExpc3QodG9hc3RNYXJrLCBjdXJyZW50TGluZSwgZGVwdGgsIGJhY2t3YXJkKSB7XG4gICAgdmFyIGxpbmVUZXh0cyA9IHRvYXN0TWFyay5nZXRMaW5lVGV4dHMoKTtcbiAgICB2YXIgbGluZUxlbiA9IGxpbmVUZXh0cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBsaW5lID0gY3VycmVudExpbmU7XG4gICAgd2hpbGUgKGJhY2t3YXJkID8gbGluZSA8IGxpbmVMZW4gOiBsaW5lID4gMSkge1xuICAgICAgICBsaW5lID0gYmFja3dhcmQgPyBsaW5lICsgMSA6IGxpbmUgLSAxO1xuICAgICAgICB2YXIgbWROb2RlID0gdG9hc3RNYXJrLmZpbmRGaXJzdE5vZGVBdExpbmUobGluZSk7XG4gICAgICAgIHZhciBjdXJyZW50TGlzdERlcHRoID0gZ2V0TGlzdERlcHRoKG1kTm9kZSk7XG4gICAgICAgIGlmIChjdXJyZW50TGlzdERlcHRoID09PSBkZXB0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBsaW5lOiBsaW5lLCBkZXB0aDogZGVwdGgsIG1kTm9kZTogbWROb2RlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRMaXN0RGVwdGggPCBkZXB0aCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFNhbWVEZXB0aEl0ZW1zKF9hKSB7XG4gICAgdmFyIHRvYXN0TWFyayA9IF9hLnRvYXN0TWFyaywgbWROb2RlID0gX2EubWROb2RlLCBsaW5lID0gX2EubGluZTtcbiAgICB2YXIgZGVwdGggPSBnZXRMaXN0RGVwdGgobWROb2RlKTtcbiAgICB2YXIgZm9yd2FyZExpc3QgPSBmaW5kU2FtZURlcHRoTGlzdCh0b2FzdE1hcmssIGxpbmUsIGRlcHRoLCBmYWxzZSkucmV2ZXJzZSgpO1xuICAgIHZhciBiYWNrd2FyZExpc3QgPSBmaW5kU2FtZURlcHRoTGlzdCh0b2FzdE1hcmssIGxpbmUsIGRlcHRoLCB0cnVlKTtcbiAgICByZXR1cm4gZm9yd2FyZExpc3QuY29uY2F0KFt7IGxpbmU6IGxpbmUsIGRlcHRoOiBkZXB0aCwgbWROb2RlOiBtZE5vZGUgfV0pLmNvbmNhdChiYWNrd2FyZExpc3QpO1xufVxuZnVuY3Rpb24gdGV4dFRvQnVsbGV0KHRleHQpIHtcbiAgICBpZiAoIXJlTGlzdC50ZXN0KHRleHQpKSB7XG4gICAgICAgIHJldHVybiBcIiogXCIgKyB0ZXh0O1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IGdldExpc3RUeXBlKHRleHQpO1xuICAgIGlmICh0eXBlID09PSAnYnVsbGV0JyAmJiByZUNhbkJlVGFza0xpc3QudGVzdCh0ZXh0KSkge1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJlQnVsbGV0VGFza0xpc3QsICckMSQyICcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnb3JkZXJlZCcpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZU9yZGVyZWRMaXN0LCAnJDEqICcpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIHRleHRUb09yZGVyZWQodGV4dCwgb3JkaW5hbE51bSkge1xuICAgIGlmICghcmVMaXN0LnRlc3QodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIG9yZGluYWxOdW0gKyBcIi4gXCIgKyB0ZXh0O1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IGdldExpc3RUeXBlKHRleHQpO1xuICAgIGlmICh0eXBlID09PSAnYnVsbGV0JyB8fCAodHlwZSA9PT0gJ29yZGVyZWQnICYmIHJlQ2FuQmVUYXNrTGlzdC50ZXN0KHRleHQpKSkge1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJlQ2FuQmVUYXNrTGlzdCwgXCIkMVwiICsgb3JkaW5hbE51bSArIFwiLiBcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdvcmRlcmVkJykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmVPcmRlcmVkTGlzdEdyb3VwLmV4ZWModGV4dClbM107XG4gICAgICAgIGlmIChOdW1iZXIoc3RhcnQpICE9PSBvcmRpbmFsTnVtKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJlT3JkZXJlZExpc3QsIFwiJDFcIiArIG9yZGluYWxOdW0gKyBcIi4gXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gZ2V0Q2hhbmdlZEluZm8oZG9jLCBzYW1lRGVwdGhJdGVtcywgdHlwZSwgc3RhcnQpIHtcbiAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICB2YXIgZmlyc3RJbmRleCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgdmFyIGNoYW5nZWRSZXN1bHRzID0gc2FtZURlcHRoSXRlbXMubWFwKGZ1bmN0aW9uIChfYSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBfYS5saW5lO1xuICAgICAgICBmaXJzdEluZGV4ID0gTWF0aC5taW4obGluZSAtIDEsIGZpcnN0SW5kZXgpO1xuICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChsaW5lIC0gMSwgbGFzdEluZGV4KTtcbiAgICAgICAgdmFyIHRleHQgPSBnZXRUZXh0QnlNZExpbmUoZG9jLCBsaW5lKTtcbiAgICAgICAgdGV4dCA9IHR5cGUgPT09ICdidWxsZXQnID8gdGV4dFRvQnVsbGV0KHRleHQpIDogdGV4dFRvT3JkZXJlZCh0ZXh0LCBpbmRleCArIDEgKyBzdGFydCk7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IHRleHQsIGxpbmU6IGxpbmUgfTtcbiAgICB9KTtcbiAgICByZXR1cm4geyBjaGFuZ2VkUmVzdWx0czogY2hhbmdlZFJlc3VsdHMsIGZpcnN0SW5kZXg6IGZpcnN0SW5kZXgsIGxhc3RJbmRleDogbGFzdEluZGV4IH07XG59XG5mdW5jdGlvbiBnZXRCdWxsZXRPck9yZGVyZWQodHlwZSwgY29udGV4dCkge1xuICAgIHZhciBzYW1lRGVwdGhMaXN0SW5mbyA9IGdldFNhbWVEZXB0aEl0ZW1zKGNvbnRleHQpO1xuICAgIHJldHVybiBnZXRDaGFuZ2VkSW5mbyhjb250ZXh0LmRvYywgc2FtZURlcHRoTGlzdEluZm8sIHR5cGUpO1xufVxudmFyIG90aGVyTGlzdFRvTGlzdCA9IHtcbiAgICBidWxsZXQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBnZXRCdWxsZXRPck9yZGVyZWQoJ2J1bGxldCcsIGNvbnRleHQpO1xuICAgIH0sXG4gICAgb3JkZXJlZDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGdldEJ1bGxldE9yT3JkZXJlZCgnb3JkZXJlZCcsIGNvbnRleHQpO1xuICAgIH0sXG4gICAgdGFzazogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBtZE5vZGUgPSBfYS5tZE5vZGUsIGRvYyA9IF9hLmRvYywgbGluZSA9IF9hLmxpbmU7XG4gICAgICAgIHZhciB0ZXh0ID0gZ2V0VGV4dEJ5TWRMaW5lKGRvYywgbGluZSk7XG4gICAgICAgIGlmIChtZE5vZGUubGlzdERhdGEudGFzaykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZVRhc2tMaXN0LCAnJDEkMicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTGlzdE5vZGUkMShtZE5vZGUpKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJlTGlzdCwgJyQxJDJbIF0gJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlZFJlc3VsdHM6IFt7IHRleHQ6IHRleHQsIGxpbmU6IGxpbmUgfV0gfTtcbiAgICB9LFxufTtcbnZhciBvdGhlck5vZGVUb0xpc3QgPSB7XG4gICAgYnVsbGV0OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGRvYyA9IF9hLmRvYywgbGluZSA9IF9hLmxpbmU7XG4gICAgICAgIHZhciBsaW5lVGV4dCA9IGdldFRleHRCeU1kTGluZShkb2MsIGxpbmUpO1xuICAgICAgICB2YXIgY2hhbmdlZFJlc3VsdHMgPSBbeyB0ZXh0OiBcIiogXCIgKyBsaW5lVGV4dCwgbGluZTogbGluZSB9XTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlZFJlc3VsdHM6IGNoYW5nZWRSZXN1bHRzIH07XG4gICAgfSxcbiAgICBvcmRlcmVkOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHRvYXN0TWFyayA9IF9hLnRvYXN0TWFyaywgZG9jID0gX2EuZG9jLCBsaW5lID0gX2EubGluZSwgc3RhcnRMaW5lID0gX2Euc3RhcnRMaW5lO1xuICAgICAgICB2YXIgbGluZVRleHQgPSBnZXRUZXh0QnlNZExpbmUoZG9jLCBsaW5lKTtcbiAgICAgICAgdmFyIGZpcnN0T3JkZXJlZExpc3ROdW0gPSAxO1xuICAgICAgICB2YXIgZmlyc3RPcmRlcmVkTGlzdExpbmUgPSBzdGFydExpbmU7XG4gICAgICAgIHZhciBza2lwcGVkID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0TGluZSAtIDE7IGkgPiAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgIHZhciBtZE5vZGUgPSB0b2FzdE1hcmsuZmluZEZpcnN0Tm9kZUF0TGluZShpKTtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gZ2V0VGV4dEJ5TWRMaW5lKGRvYywgaSk7XG4gICAgICAgICAgICB2YXIgY2FuQmVMaXN0Tm9kZSA9IHRleHQgJiYgISFmaW5kQ2xvc2VzdE5vZGUobWROb2RlLCBmdW5jdGlvbiAodGFyZ2V0Tm9kZSkgeyByZXR1cm4gaXNMaXN0Tm9kZSQxKHRhcmdldE5vZGUpOyB9KTtcbiAgICAgICAgICAgIHZhciBzZWFyY2hSZXN1bHQgPSByZU9yZGVyZWRMaXN0R3JvdXAuZXhlYyhnZXRUZXh0QnlNZExpbmUoZG9jLCBpKSk7XG4gICAgICAgICAgICBpZiAoIXNlYXJjaFJlc3VsdCAmJiAhY2FuQmVMaXN0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWFyY2hSZXN1bHQgJiYgY2FuQmVMaXN0Tm9kZSkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgKz0gMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYiA9IHNlYXJjaFJlc3VsdCwgaW5kZW50ID0gX2JbMV0sIHN0YXJ0ID0gX2JbM107XG4gICAgICAgICAgICAvLyBiYXNpcyBvbiBvbmUgZGVwdGggbGlzdFxuICAgICAgICAgICAgaWYgKCFpbmRlbnQpIHtcbiAgICAgICAgICAgICAgICBmaXJzdE9yZGVyZWRMaXN0TnVtID0gTnVtYmVyKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBmaXJzdE9yZGVyZWRMaXN0TGluZSA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yZGluYWxOdW0gPSBmaXJzdE9yZGVyZWRMaXN0TnVtICsgbGluZSAtIGZpcnN0T3JkZXJlZExpc3RMaW5lIC0gc2tpcHBlZDtcbiAgICAgICAgdmFyIGNoYW5nZWRSZXN1bHRzID0gW3sgdGV4dDogb3JkaW5hbE51bSArIFwiLiBcIiArIGxpbmVUZXh0LCBsaW5lOiBsaW5lIH1dO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VkUmVzdWx0czogY2hhbmdlZFJlc3VsdHMgfTtcbiAgICB9LFxuICAgIHRhc2s6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZG9jID0gX2EuZG9jLCBsaW5lID0gX2EubGluZTtcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gZ2V0VGV4dEJ5TWRMaW5lKGRvYywgbGluZSk7XG4gICAgICAgIHZhciBjaGFuZ2VkUmVzdWx0cyA9IFt7IHRleHQ6IFwiKiBbIF0gXCIgKyBsaW5lVGV4dCwgbGluZTogbGluZSB9XTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlZFJlc3VsdHM6IGNoYW5nZWRSZXN1bHRzIH07XG4gICAgfSxcbn07XG52YXIgZXh0ZW5kTGlzdCA9IHtcbiAgICBidWxsZXQ6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbGluZSA9IF9hLmxpbmUsIGRvYyA9IF9hLmRvYztcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gZ2V0VGV4dEJ5TWRMaW5lKGRvYywgbGluZSk7XG4gICAgICAgIHZhciBfYiA9IHJlQnVsbGV0TGlzdEdyb3VwLmV4ZWMobGluZVRleHQpLCBpbmRlbnQgPSBfYlsxXSwgZGVsaW1pdGVyID0gX2JbMl07XG4gICAgICAgIHJldHVybiB7IGxpc3RTeW50YXg6IFwiXCIgKyBpbmRlbnQgKyBkZWxpbWl0ZXIgfTtcbiAgICB9LFxuICAgIG9yZGVyZWQ6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdG9hc3RNYXJrID0gX2EudG9hc3RNYXJrLCBsaW5lID0gX2EubGluZSwgbWROb2RlID0gX2EubWROb2RlLCBkb2MgPSBfYS5kb2M7XG4gICAgICAgIHZhciBkZXB0aCA9IGdldExpc3REZXB0aChtZE5vZGUpO1xuICAgICAgICB2YXIgbGluZVRleHQgPSBnZXRUZXh0QnlNZExpbmUoZG9jLCBsaW5lKTtcbiAgICAgICAgdmFyIF9iID0gcmVPcmRlcmVkTGlzdEdyb3VwLmV4ZWMobGluZVRleHQpLCBpbmRlbnQgPSBfYlsxXSwgc3RhcnQgPSBfYlszXSwgZGVsaW1pdGVyID0gX2JbNF07XG4gICAgICAgIHZhciBvcmRpbmFsTnVtID0gTnVtYmVyKHN0YXJ0KSArIDE7XG4gICAgICAgIHZhciBsaXN0U3ludGF4ID0gXCJcIiArIGluZGVudCArIG9yZGluYWxOdW0gKyBkZWxpbWl0ZXI7XG4gICAgICAgIHZhciBiYWNrd2FyZExpc3QgPSBmaW5kU2FtZURlcHRoTGlzdCh0b2FzdE1hcmssIGxpbmUsIGRlcHRoLCB0cnVlKTtcbiAgICAgICAgdmFyIGZpbHRlcmVkTGlzdCA9IGJhY2t3YXJkTGlzdC5maWx0ZXIoZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgICAgIHZhciBzZWFyY2hSZXN1bHQgPSByZU9yZGVyZWRMaXN0R3JvdXAuZXhlYyhnZXRUZXh0QnlNZExpbmUoZG9jLCBpbmZvLmxpbmUpKTtcbiAgICAgICAgICAgIHJldHVybiAoc2VhcmNoUmVzdWx0ICYmXG4gICAgICAgICAgICAgICAgc2VhcmNoUmVzdWx0WzFdLmxlbmd0aCA9PT0gaW5kZW50Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICEhZmluZENsb3Nlc3ROb2RlKGluZm8ubWROb2RlLCBmdW5jdGlvbiAodGFyZ2V0Tm9kZSkgeyByZXR1cm4gaXNPcmRlcmVkTGlzdE5vZGUodGFyZ2V0Tm9kZSk7IH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHsgbGlzdFN5bnRheDogbGlzdFN5bnRheCB9LCBnZXRDaGFuZ2VkSW5mbyhkb2MsIGZpbHRlcmVkTGlzdCwgJ29yZGVyZWQnLCBvcmRpbmFsTnVtKSk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBnZXRSZW9yZGVyZWRMaXN0SW5mbyhkb2MsIHNjaGVtYSwgbGluZSwgb3JkaW5hbE51bSwgcHJldkluZGVudExlbmd0aCkge1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBsaW5lVGV4dCA9IGdldFRleHRCeU1kTGluZShkb2MsIGxpbmUpO1xuICAgIHZhciBzZWFyY2hSZXN1bHQgPSByZU9yZGVyZWRMaXN0R3JvdXAuZXhlYyhsaW5lVGV4dCk7XG4gICAgd2hpbGUgKHNlYXJjaFJlc3VsdCkge1xuICAgICAgICB2YXIgaW5kZW50ID0gc2VhcmNoUmVzdWx0WzFdLCBkZWxpbWl0ZXIgPSBzZWFyY2hSZXN1bHRbNF0sIHRleHQgPSBzZWFyY2hSZXN1bHRbNV07XG4gICAgICAgIHZhciBpbmRlbnRMZW5ndGggPSBpbmRlbnQubGVuZ3RoO1xuICAgICAgICBpZiAoaW5kZW50TGVuZ3RoID09PSBwcmV2SW5kZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCBcIlwiICsgaW5kZW50ICsgb3JkaW5hbE51bSArIGRlbGltaXRlciArIHRleHQpKTtcbiAgICAgICAgICAgIG9yZGluYWxOdW0gKz0gMTtcbiAgICAgICAgICAgIGxpbmUgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRlbnRMZW5ndGggPiBwcmV2SW5kZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbmVzdGVkTGlzdEluZm8gPSBnZXRSZW9yZGVyZWRMaXN0SW5mbyhkb2MsIHNjaGVtYSwgbGluZSwgMSwgaW5kZW50TGVuZ3RoKTtcbiAgICAgICAgICAgIGxpbmUgPSBuZXN0ZWRMaXN0SW5mby5saW5lO1xuICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQobmVzdGVkTGlzdEluZm8ubm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRlbnRMZW5ndGggPCBwcmV2SW5kZW50TGVuZ3RoIHx8IGxpbmUgPiBkb2MuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGluZVRleHQgPSBnZXRUZXh0QnlNZExpbmUoZG9jLCBsaW5lKTtcbiAgICAgICAgc2VhcmNoUmVzdWx0ID0gcmVPcmRlcmVkTGlzdEdyb3VwLmV4ZWMobGluZVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4geyBub2Rlczogbm9kZXMsIGxpbmU6IGxpbmUgfTtcbn1cblxudmFyIHJlU3RhcnRTcGFjZSA9IC8oXlxcc3sxLDR9KSguKikvO1xuZnVuY3Rpb24gaXNCbG9ja1VuaXQoZnJvbSwgdG8sIHRleHQpIHtcbiAgICByZXR1cm4gZnJvbSA8IHRvIHx8IHJlTGlzdC50ZXN0KHRleHQpIHx8IHJlQmxvY2tRdW90ZS50ZXN0KHRleHQpO1xufVxuZnVuY3Rpb24gaXNJblRhYmxlQ2VsbE5vZGUoZG9jLCBzY2hlbWEsIHNlbGVjdGlvbikge1xuICAgIHZhciAkcG9zID0gc2VsZWN0aW9uLiRmcm9tO1xuICAgIGlmICgkcG9zLmRlcHRoID09PSAwKSB7XG4gICAgICAgICRwb3MgPSBkb2MucmVzb2x2ZSgkcG9zLnBvcyAtIDEpO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9ICRwb3Mubm9kZSgxKTtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSAkcG9zLnN0YXJ0KDEpO1xuICAgIHZhciBjb250ZW50U2l6ZSA9IG5vZGUuY29udGVudC5zaXplO1xuICAgIHJldHVybiAobm9kZS5yYW5nZUhhc01hcmsoMCwgY29udGVudFNpemUsIHNjaGVtYS5tYXJrcy50YWJsZSkgJiZcbiAgICAgICAgJHBvcy5wb3MgLSBzdGFydE9mZnNldCAhPT0gY29udGVudFNpemUgJiZcbiAgICAgICAgJHBvcy5wb3MgIT09IHN0YXJ0T2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdGlvbih0ciwgcG9zSW5mbykge1xuICAgIHZhciBmcm9tID0gcG9zSW5mby5mcm9tLCB0byA9IHBvc0luZm8udG87XG4gICAgaWYgKHBvc0luZm8udHlwZSA9PT0gJ2luZGVudCcpIHtcbiAgICAgICAgdmFyIHNvZnRUYWJMZW4gPSA0O1xuICAgICAgICBmcm9tICs9IHNvZnRUYWJMZW47XG4gICAgICAgIHRvICs9IChwb3NJbmZvLmxpbmVMZW4gKyAxKSAqIHNvZnRUYWJMZW47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgc3BhY2VMZW5MaXN0ID0gcG9zSW5mby5zcGFjZUxlbkxpc3Q7XG4gICAgICAgIGZyb20gLT0gc3BhY2VMZW5MaXN0WzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlTGVuTGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdG8gLT0gc3BhY2VMZW5MaXN0W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBmcm9tLCB0byk7XG59XG52YXIgUGFyYWdyYXBoJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoUGFyYWdyYXBoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhcmFncmFwaCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFyYWdyYXBoLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3BhcmFncmFwaCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFyYWdyYXBoLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ2lubGluZSonLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvZGVTdGFydDogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvZGVFbmQ6IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFt7IHRhZzogJ2RpdicgfV0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzLmNsYXNzTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbJ2RpdicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeChhdHRycy5jbGFzc05hbWUpIH0sIDBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFsnZGl2JywgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBQYXJhZ3JhcGgucHJvdG90eXBlLnJlb3JkZXJMaXN0ID0gZnVuY3Rpb24gKHN0YXJ0TGluZSwgZW5kTGluZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIHZpZXcgPSBfYS52aWV3LCB0b2FzdE1hcmsgPSBfYS50b2FzdE1hcmssIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgdmFyIF9iID0gdmlldy5zdGF0ZSwgdHIgPSBfYi50ciwgc2VsZWN0aW9uID0gX2Iuc2VsZWN0aW9uLCBkb2MgPSBfYi5kb2M7XG4gICAgICAgIHZhciBtZE5vZGUgPSB0b2FzdE1hcmsuZmluZEZpcnN0Tm9kZUF0TGluZShzdGFydExpbmUpO1xuICAgICAgICB2YXIgdG9wTGlzdE5vZGUgPSBtZE5vZGU7XG4gICAgICAgIHdoaWxlIChtZE5vZGUgJiYgIWlzQnVsbGV0TGlzdE5vZGUobWROb2RlKSAmJiBtZE5vZGUucGFyZW50LnR5cGUgIT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgICAgIG1kTm9kZSA9IG1kTm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoaXNPcmRlcmVkTGlzdE5vZGUobWROb2RlKSkge1xuICAgICAgICAgICAgICAgIHRvcExpc3ROb2RlID0gbWROb2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0b3BMaXN0Tm9kZSkge1xuICAgICAgICAgICAgc3RhcnRMaW5lID0gdG9wTGlzdE5vZGUuc291cmNlcG9zWzBdWzBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYyA9IHJlT3JkZXJlZExpc3RHcm91cC5leGVjKGdldFRleHRCeU1kTGluZShkb2MsIHN0YXJ0TGluZSkpLCBpbmRlbnQgPSBfY1sxXSwgc3RhcnQgPSBfY1szXTtcbiAgICAgICAgdmFyIGluZGVudExlbiA9IGluZGVudC5sZW5ndGg7XG4gICAgICAgIHZhciBfZCA9IGdldFJlb3JkZXJlZExpc3RJbmZvKGRvYywgc2NoZW1hLCBzdGFydExpbmUsIE51bWJlcihzdGFydCksIGluZGVudExlbiksIGxpbmUgPSBfZC5saW5lLCBub2RlcyA9IF9kLm5vZGVzO1xuICAgICAgICBlbmRMaW5lID0gTWF0aC5tYXgoZW5kTGluZSwgbGluZSAtIDEpO1xuICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSBnZXROb2RlQ29udGVudE9mZnNldFJhbmdlKGRvYywgc3RhcnRMaW5lIC0gMSkuc3RhcnRPZmZzZXQ7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydExpbmUgLSAxOyBpIDw9IGVuZExpbmUgLSAxOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBfZSA9IGRvYy5jaGlsZChpKSwgbm9kZVNpemUgPSBfZS5ub2RlU2l6ZSwgY29udGVudCA9IF9lLmNvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgbWFwcGVkRnJvbSA9IHRyLm1hcHBpbmcubWFwKHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciBtYXBwZWRUbyA9IG1hcHBlZEZyb20gKyBjb250ZW50LnNpemU7XG4gICAgICAgICAgICB0ci5yZXBsYWNlV2l0aChtYXBwZWRGcm9tLCBtYXBwZWRUbywgbm9kZXNbaSAtIHN0YXJ0TGluZSArIDFdKTtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ICs9IG5vZGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSBjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBzZWxlY3Rpb24uZnJvbSwgc2VsZWN0aW9uLnRvKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKSk7XG4gICAgfTtcbiAgICBQYXJhZ3JhcGgucHJvdG90eXBlLmluZGVudCA9IGZ1bmN0aW9uICh0YWJLZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRhYktleSA9PT0gdm9pZCAwKSB7IHRhYktleSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1hID0gc3RhdGUuc2NoZW1hLCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIGRvYyA9IHN0YXRlLmRvYztcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBmcm9tID0gX2EuZnJvbSwgdG8gPSBfYS50bywgc3RhcnRGcm9tT2Zmc2V0ID0gX2Euc3RhcnRGcm9tT2Zmc2V0LCBzdGFydEluZGV4ID0gX2Euc3RhcnRJbmRleCwgZW5kSW5kZXggPSBfYS5lbmRJbmRleDtcbiAgICAgICAgICAgIGlmICh0YWJLZXkgJiYgaXNJblRhYmxlQ2VsbE5vZGUoZG9jLCBzY2hlbWEsIHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhcnRMaW5lVGV4dCA9IGdldFRleHRDb250ZW50KGRvYywgc3RhcnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoKHRhYktleSAmJiBpc0Jsb2NrVW5pdChmcm9tLCB0bywgc3RhcnRMaW5lVGV4dCkpIHx8XG4gICAgICAgICAgICAgICAgKCF0YWJLZXkgJiYgcmVMaXN0LnRlc3Qoc3RhcnRMaW5lVGV4dCkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyID0gcmVwbGFjZVRleHROb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiBzdGFydEZyb21PZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGVuZEluZGV4OiBlbmRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlVGV4dDogZnVuY3Rpb24gKHRleHRDb250ZW50KSB7IHJldHVybiBcIiAgICBcIiArIHRleHRDb250ZW50OyB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBwb3NJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5kZW50JyxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTGVuOiBlbmRJbmRleCAtIHN0YXJ0SW5kZXgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oY3JlYXRlU2VsZWN0aW9uKHRyLCBwb3NJbmZvKSkpO1xuICAgICAgICAgICAgICAgIGlmIChyZU9yZGVyZWRMaXN0R3JvdXAudGVzdChzdGFydExpbmVUZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW9yZGVyTGlzdChzdGFydEluZGV4ICsgMSwgZW5kSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0YWJLZXkpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5pbnNlcnQodG8sIGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCAnICAgICcpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIFBhcmFncmFwaC5wcm90b3R5cGUub3V0ZGVudCA9IGZ1bmN0aW9uICh0YWJLZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRhYktleSA9PT0gdm9pZCAwKSB7IHRhYktleSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCBkb2MgPSBzdGF0ZS5kb2MsIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBmcm9tID0gX2EuZnJvbSwgdG8gPSBfYS50bywgc3RhcnRGcm9tT2Zmc2V0ID0gX2Euc3RhcnRGcm9tT2Zmc2V0LCBzdGFydEluZGV4ID0gX2Euc3RhcnRJbmRleCwgZW5kSW5kZXggPSBfYS5lbmRJbmRleDtcbiAgICAgICAgICAgIGlmICh0YWJLZXkgJiYgaXNJblRhYmxlQ2VsbE5vZGUoZG9jLCBzY2hlbWEsIHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhcnRMaW5lVGV4dCA9IGdldFRleHRDb250ZW50KGRvYywgc3RhcnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoKHRhYktleSAmJiBpc0Jsb2NrVW5pdChmcm9tLCB0bywgc3RhcnRMaW5lVGV4dCkpIHx8XG4gICAgICAgICAgICAgICAgKCF0YWJLZXkgJiYgcmVMaXN0LnRlc3Qoc3RhcnRMaW5lVGV4dCkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwYWNlTGVuTGlzdF8xID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHRyID0gcmVwbGFjZVRleHROb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiBzdGFydEZyb21PZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGVuZEluZGV4OiBlbmRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlVGV4dDogZnVuY3Rpb24gKHRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VhcmNoUmVzdWx0ID0gcmVTdGFydFNwYWNlLmV4ZWModGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2VMZW5MaXN0XzEucHVzaChzZWFyY2hSZXN1bHQgPyBzZWFyY2hSZXN1bHRbMV0ubGVuZ3RoIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dENvbnRlbnQucmVwbGFjZShyZVN0YXJ0U3BhY2UsICckMicpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBwb3NJbmZvID0geyB0eXBlOiAnb3V0ZGVudCcsIGZyb206IGZyb20sIHRvOiB0bywgc3BhY2VMZW5MaXN0OiBzcGFjZUxlbkxpc3RfMSB9O1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihjcmVhdGVTZWxlY3Rpb24odHIsIHBvc0luZm8pKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlT3JkZXJlZExpc3RHcm91cC50ZXN0KHN0YXJ0TGluZVRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlb3JkZXJMaXN0KHN0YXJ0SW5kZXggKyAxLCBlbmRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRhYktleSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFRleHQgPSBzdGFydExpbmVUZXh0LnNsaWNlKDAsIHRvIC0gc3RhcnRGcm9tT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRUZXh0V2l0aG91dFNwYWNlID0gc3RhcnRUZXh0LnJlcGxhY2UoL1xcc3sxLDR9JC8sICcnKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVsZXRTdGFydCA9IHRvIC0gKHN0YXJ0VGV4dC5sZW5ndGggLSBzdGFydFRleHRXaXRob3V0U3BhY2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGUoZGVsZXRTdGFydCwgdG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgUGFyYWdyYXBoLnByb3RvdHlwZS5kZWxldGVMaW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gX3RoaXMuY29udGV4dC52aWV3O1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmFuZ2VJbmZvKHN0YXRlLnNlbGVjdGlvbiksIHN0YXJ0RnJvbU9mZnNldCA9IF9hLnN0YXJ0RnJvbU9mZnNldCwgZW5kVG9PZmZzZXQgPSBfYS5lbmRUb09mZnNldDtcbiAgICAgICAgICAgIHZhciBkZWxldGVSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGVSYW5nZShzdGFydEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluQ29tbWFuZHMoZGVsZXRlUmFuZ2UsIGpvaW5Gb3J3YXJkKShzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgUGFyYWdyYXBoLnByb3RvdHlwZS5tb3ZlRG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSBzdGF0ZS5kb2MsIHRyID0gc3RhdGUudHIsIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIHN0YXJ0RnJvbU9mZnNldCA9IF9hLnN0YXJ0RnJvbU9mZnNldCwgZW5kVG9PZmZzZXQgPSBfYS5lbmRUb09mZnNldCwgZW5kSW5kZXggPSBfYS5lbmRJbmRleDtcbiAgICAgICAgICAgIGlmIChlbmRJbmRleCA8IGRvYy5jb250ZW50LmNoaWxkQ291bnQgLSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gZG9jLmNoaWxkKGVuZEluZGV4ICsgMSksIG5vZGVTaXplID0gX2Iubm9kZVNpemUsIHRleHRDb250ZW50ID0gX2IudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlKGVuZFRvT2Zmc2V0LCBlbmRUb09mZnNldCArIG5vZGVTaXplKVxuICAgICAgICAgICAgICAgICAgICAuc3BsaXQoc3RhcnRGcm9tT2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICAvLyBzdWJ0cmFjdCAyKHN0YXJ0LCBlbmQgdGFnIGxlbmd0aCkgdG8gaW5zZXJ0IHByZXYgbGluZVxuICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0KHRyLm1hcHBpbmcubWFwKHN0YXJ0RnJvbU9mZnNldCkgLSAyLCBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgdGV4dENvbnRlbnQpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBQYXJhZ3JhcGgucHJvdG90eXBlLm1vdmVVcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciB0ciA9IHN0YXRlLnRyLCBkb2MgPSBzdGF0ZS5kb2MsIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIHN0YXJ0RnJvbU9mZnNldCA9IF9hLnN0YXJ0RnJvbU9mZnNldCwgZW5kVG9PZmZzZXQgPSBfYS5lbmRUb09mZnNldCwgc3RhcnRJbmRleCA9IF9hLnN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBkb2MuY2hpbGQoc3RhcnRJbmRleCAtIDEpLCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplLCB0ZXh0Q29udGVudCA9IF9iLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShzdGFydEZyb21PZmZzZXQgLSBub2RlU2l6ZSwgc3RhcnRGcm9tT2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICAuc3BsaXQodHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpKVxuICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSwgY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIHRleHRDb250ZW50KSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgUGFyYWdyYXBoLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQoKSxcbiAgICAgICAgICAgIG91dGRlbnQ6IHRoaXMub3V0ZGVudCgpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgUGFyYWdyYXBoLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgVGFiOiB0aGlzLmluZGVudCh0cnVlKSgpLFxuICAgICAgICAgICAgJ1NoaWZ0LVRhYic6IHRoaXMub3V0ZGVudCh0cnVlKSgpLFxuICAgICAgICAgICAgJ01vZC1kJzogdGhpcy5kZWxldGVMaW5lcygpLFxuICAgICAgICAgICAgJ01vZC1EJzogdGhpcy5kZWxldGVMaW5lcygpLFxuICAgICAgICAgICAgJ0FsdC1BcnJvd1VwJzogdGhpcy5tb3ZlVXAoKSxcbiAgICAgICAgICAgICdBbHQtQXJyb3dEb3duJzogdGhpcy5tb3ZlRG93bigpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFBhcmFncmFwaDtcbn0oTm9kZSQyKSk7XG5cbnZhciBUZXh0JDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGV4dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXh0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RleHQnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHQucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBncm91cDogJ2lubGluZScsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRleHQ7XG59KE5vZGUkMikpO1xuXG52YXIgcmVIZWFkaW5nID0gL14jezEsNn1cXHMvO1xudmFyIEhlYWRpbmckMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShIZWFkaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRpbmcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlYWRpbmcucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnaGVhZGluZyc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVhZGluZy5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiB7IGRlZmF1bHQ6IDEgfSxcbiAgICAgICAgICAgICAgICAgICAgc2VUZXh0OiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGV2ZWwgPSBhdHRycy5sZXZlbCwgc2VUZXh0ID0gYXR0cnMuc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFwiaGVhZGluZ3xoZWFkaW5nXCIgKyBsZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyArPSAnfGRlbGltaXRlcnxzZXRleHQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXguYXBwbHkodm9pZCAwLCBjbGFzc05hbWVzLnNwbGl0KCd8JykpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgSGVhZGluZy5wcm90b3R5cGUuY3JlYXRlSGVhZGluZ1RleHQgPSBmdW5jdGlvbiAobGV2ZWwsIHRleHQsIGN1ckhlYWRpbmdTeW50YXgpIHtcbiAgICAgICAgdmFyIHRleHRDb250ZW50ID0gdGV4dC5yZXBsYWNlKGN1ckhlYWRpbmdTeW50YXgsICcnKS50cmltKCk7XG4gICAgICAgIHZhciBoZWFkaW5nVGV4dCA9ICcnO1xuICAgICAgICB3aGlsZSAobGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICBoZWFkaW5nVGV4dCArPSAnIyc7XG4gICAgICAgICAgICBsZXZlbCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkaW5nVGV4dCArIFwiIFwiICsgdGV4dENvbnRlbnQ7XG4gICAgfTtcbiAgICBIZWFkaW5nLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBwYXlsb2FkLmxldmVsO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmFuZ2VJbmZvKHN0YXRlLnNlbGVjdGlvbiksIHN0YXJ0RnJvbU9mZnNldCA9IF9hLnN0YXJ0RnJvbU9mZnNldCwgZW5kVG9PZmZzZXQgPSBfYS5lbmRUb09mZnNldCwgc3RhcnRJbmRleCA9IF9hLnN0YXJ0SW5kZXgsIGVuZEluZGV4ID0gX2EuZW5kSW5kZXg7XG4gICAgICAgICAgICB2YXIgdHIgPSByZXBsYWNlVGV4dE5vZGUoe1xuICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICBmcm9tOiBzdGFydEZyb21PZmZzZXQsXG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleDogc3RhcnRJbmRleCxcbiAgICAgICAgICAgICAgICBlbmRJbmRleDogZW5kSW5kZXgsXG4gICAgICAgICAgICAgICAgY3JlYXRlVGV4dDogZnVuY3Rpb24gKHRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVkSGVhZGluZyA9IHRleHRDb250ZW50Lm1hdGNoKHJlSGVhZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJIZWFkaW5nU3ludGF4ID0gbWF0Y2hlZEhlYWRpbmcgPyBtYXRjaGVkSGVhZGluZ1swXSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY3JlYXRlSGVhZGluZ1RleHQobGV2ZWwsIHRleHRDb250ZW50LCBjdXJIZWFkaW5nU3ludGF4KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgdHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICByZXR1cm4gSGVhZGluZztcbn0oTWFyaykpO1xuXG52YXIgZmVuY2VkQ29kZUJsb2NrU3ludGF4ID0gJ2BgYCc7XG52YXIgQ29kZUJsb2NrJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQ29kZUJsb2NrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvZGVCbG9jaygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29kZUJsb2NrLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NvZGVCbG9jayc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29kZUJsb2NrLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgnY29kZS1ibG9jaycpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29kZUJsb2NrLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHNjaGVtYSA9IHN0YXRlLnNjaGVtYSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBzdGFydEZyb21PZmZzZXQgPSBfYS5zdGFydEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2EuZW5kVG9PZmZzZXQ7XG4gICAgICAgICAgICB2YXIgZmVuY2VkTm9kZSA9IGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCBmZW5jZWRDb2RlQmxvY2tTeW50YXgpO1xuICAgICAgICAgICAgLy8gYWRkIGZlbmNlZCBzdGFydCBibG9ja1xuICAgICAgICAgICAgdHIuaW5zZXJ0KHN0YXJ0RnJvbU9mZnNldCwgZmVuY2VkTm9kZSkuc3BsaXQoc3RhcnRGcm9tT2Zmc2V0ICsgZmVuY2VkQ29kZUJsb2NrU3ludGF4Lmxlbmd0aCk7XG4gICAgICAgICAgICAvLyBhZGQgZmVuY2VkIGVuZCBibG9ja1xuICAgICAgICAgICAgdHIuc3BsaXQodHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpKS5pbnNlcnQodHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpLCBmZW5jZWROb2RlKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihcbiAgICAgICAgICAgIC8vIHN1YnRyYWN0IGZlbmNlZCBzeW50YXggbGVuZ3RoIGFuZCBvcGVuLCBjbG9zZSB0YWcoMilcbiAgICAgICAgICAgIGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSAtIChmZW5jZWRDb2RlQmxvY2tTeW50YXgubGVuZ3RoICsgMikpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIENvZGVCbG9jay5wcm90b3R5cGUua2VlcEluZGVudGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgdHIgPSBfYS50ciwgZG9jID0gX2EuZG9jLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgdG9hc3RNYXJrID0gX3RoaXMuY29udGV4dC50b2FzdE1hcms7XG4gICAgICAgICAgICB2YXIgX2IgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgc3RhcnRGcm9tT2Zmc2V0ID0gX2Iuc3RhcnRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCA9IF9iLmVuZFRvT2Zmc2V0LCBlbmRJbmRleCA9IF9iLmVuZEluZGV4LCBmcm9tID0gX2IuZnJvbSwgdG8gPSBfYi50bztcbiAgICAgICAgICAgIHZhciB0ZXh0Q29udGVudCA9IGdldFRleHRDb250ZW50KGRvYywgZW5kSW5kZXgpO1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHRvICYmIHRleHRDb250ZW50LnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVkID0gdGV4dENvbnRlbnQubWF0Y2goL15cXHMrLyk7XG4gICAgICAgICAgICAgICAgdmFyIG1kTm9kZSA9IHRvYXN0TWFyay5maW5kRmlyc3ROb2RlQXRMaW5lKGVuZEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ29kZUJsb2NrTm9kZShtZE5vZGUpICYmIG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwYWNlcyA9IG1hdGNoZWRbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbGljZWRUZXh0ID0gdGV4dENvbnRlbnQuc2xpY2UodG8gLSBzdGFydEZyb21PZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCBzcGFjZXMgKyBzbGljZWRUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRBbmRFeHRlbmRCbG9jayh0ciwgZW5kVG9PZmZzZXQsIHNsaWNlZFRleHQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvZGVCbG9jay5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvZGVCbG9ja0NvbW1hbmQgPSB0aGlzLmNvbW1hbmRzKCkoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdTaGlmdC1Nb2QtcCc6IGNvZGVCbG9ja0NvbW1hbmQsXG4gICAgICAgICAgICAnU2hpZnQtTW9kLVAnOiBjb2RlQmxvY2tDb21tYW5kLFxuICAgICAgICAgICAgRW50ZXI6IHRoaXMua2VlcEluZGVudGF0aW9uKCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29kZUJsb2NrO1xufShNYXJrKSk7XG5cbnZhciByZUVtcHR5VGFibGUgPSAvXFx8fFxccy9nO1xuZnVuY3Rpb24gY3JlYXRlVGFibGVIZWFkZXIoY29sdW1uQ291bnQpIHtcbiAgICByZXR1cm4gW2NyZWF0ZVRhYmxlUm93KGNvbHVtbkNvdW50KSwgY3JlYXRlVGFibGVSb3coY29sdW1uQ291bnQsIHRydWUpXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlQm9keSQxKGNvbHVtbkNvdW50LCByb3dDb3VudCkge1xuICAgIHZhciBib2R5Um93cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93Q291bnQ7IGkgKz0gMSkge1xuICAgICAgICBib2R5Um93cy5wdXNoKGNyZWF0ZVRhYmxlUm93KGNvbHVtbkNvdW50KSk7XG4gICAgfVxuICAgIHJldHVybiBib2R5Um93cztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlUm93KGNvbHVtbkNvdW50LCBkZWxpbSkge1xuICAgIHZhciByb3cgPSAnfCc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSArPSAxKSB7XG4gICAgICAgIHJvdyArPSBkZWxpbSA/ICcgLS0tIHwnIDogJyAgfCc7XG4gICAgfVxuICAgIHJldHVybiByb3c7XG59XG5mdW5jdGlvbiBjcmVhdGVUYXJnZXRUeXBlcyhtb3ZlTmV4dCkge1xuICAgIHJldHVybiBtb3ZlTmV4dFxuICAgICAgICA/IHsgdHlwZTogJ25leHQnLCBwYXJlbnRUeXBlOiAndGFibGVIZWFkJywgY2hpbGRUeXBlOiAnZmlyc3RDaGlsZCcgfVxuICAgICAgICA6IHsgdHlwZTogJ3ByZXYnLCBwYXJlbnRUeXBlOiAndGFibGVCb2R5JywgY2hpbGRUeXBlOiAnbGFzdENoaWxkJyB9O1xufVxudmFyIFRhYmxlJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RhYmxlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ3RhYmxlJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUYWJsZS5wcm90b3R5cGUuZXh0ZW5kVGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCBkb2MgPSBfYS5kb2MsIHRyID0gX2EudHIsIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9iID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIGVuZEZyb21PZmZzZXQgPSBfYi5lbmRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCA9IF9iLmVuZFRvT2Zmc2V0LCBlbmRJbmRleCA9IF9iLmVuZEluZGV4LCB0byA9IF9iLnRvO1xuICAgICAgICAgICAgdmFyIHRleHRDb250ZW50ID0gZ2V0VGV4dENvbnRlbnQoZG9jLCBlbmRJbmRleCk7XG4gICAgICAgICAgICAvLyBzaG91bGQgYWRkIGAxYCB0byBsaW5lIGZvciB0aGUgbWFya2Rvd24gcGFyc2VyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIG1hcmtkb3duIHBhcnNlciBoYXMgYDFgKG5vdCB6ZXJvKSBhcyB0aGUgc3RhcnQgbnVtYmVyXG4gICAgICAgICAgICB2YXIgbWRQb3MgPSBbZW5kSW5kZXggKyAxLCB0byAtIGVuZEZyb21PZmZzZXQgKyAxXTtcbiAgICAgICAgICAgIHZhciBtZE5vZGUgPSBfdGhpcy5jb250ZXh0LnRvYXN0TWFyay5maW5kTm9kZUF0UG9zaXRpb24obWRQb3MpO1xuICAgICAgICAgICAgdmFyIGNlbGxOb2RlID0gZmluZENsb3Nlc3ROb2RlKG1kTm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUYWJsZUNlbGxOb2RlKG5vZGUpICYmXG4gICAgICAgICAgICAgICAgICAgIChub2RlLnBhcmVudC50eXBlID09PSAndGFibGVEZWxpbVJvdycgfHwgbm9kZS5wYXJlbnQucGFyZW50LnR5cGUgPT09ICd0YWJsZUJvZHknKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNlbGxOb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRW1wdHkgPSAhdGV4dENvbnRlbnQucmVwbGFjZShyZUVtcHR5VGFibGUsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gY2VsbE5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5Db3VudCA9IHBhcmVudF8xLnBhcmVudC5wYXJlbnQuY29sdW1ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IGNyZWF0ZVRhYmxlUm93KGNvbHVtbkNvdW50KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICB0ci5kZWxldGVSYW5nZShlbmRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCkuc3BsaXQodHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3BsaXQoZW5kVG9PZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSwgY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIHJvdykpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgc3VidHJhY3QgYDJgIHRvIHNlbGVjdGlvbiBlbmQgcG9zaXRpb24gY29uc2lkZXJpbmcgYCB8YCB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSAtIDIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLm1vdmVUYWJsZUNlbGwgPSBmdW5jdGlvbiAobW92ZU5leHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHI7XG4gICAgICAgICAgICB2YXIgX2IgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgZW5kRnJvbU9mZnNldCA9IF9iLmVuZEZyb21PZmZzZXQsIGVuZEluZGV4ID0gX2IuZW5kSW5kZXgsIHRvID0gX2IudG87XG4gICAgICAgICAgICB2YXIgbWRQb3MgPSBbZW5kSW5kZXggKyAxLCB0byAtIGVuZEZyb21PZmZzZXRdO1xuICAgICAgICAgICAgdmFyIG1kTm9kZSA9IF90aGlzLmNvbnRleHQudG9hc3RNYXJrLmZpbmROb2RlQXRQb3NpdGlvbihtZFBvcyk7XG4gICAgICAgICAgICB2YXIgY2VsbE5vZGUgPSBmaW5kQ2xvc2VzdE5vZGUobWROb2RlLCBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gaXNUYWJsZUNlbGxOb2RlKG5vZGUpOyB9KTtcbiAgICAgICAgICAgIGlmIChjZWxsTm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMiA9IGNlbGxOb2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBjcmVhdGVUYXJnZXRUeXBlcyhtb3ZlTmV4dCksIHR5cGUgPSBfYy50eXBlLCBwYXJlbnRUeXBlID0gX2MucGFyZW50VHlwZSwgY2hpbGRUeXBlID0gX2MuY2hpbGRUeXBlO1xuICAgICAgICAgICAgICAgIHZhciBjaE9mZnNldCA9IGdldE1kRW5kQ2goY2VsbE5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChjZWxsTm9kZVt0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICBjaE9mZnNldCA9IGdldE1kRW5kQ2goY2VsbE5vZGVbdHlwZV0pIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSAhcGFyZW50XzJbdHlwZV0gJiYgcGFyZW50XzIucGFyZW50LnR5cGUgPT09IHBhcmVudFR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyZW50XzIucGFyZW50W3R5cGVdW2NoaWxkVHlwZV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGFyZW50XzJbdHlwZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnbmV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5leHQgcm93LCB0aGUgYmFzZSBvZmZzZXQgd291bGQgYmUgZW5kIHBvc2l0aW9uIG9mIHRoZSBuZXh0IHJvdydzIGZpcnN0IGNoaWxkLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgYmFzZSBvZmZzZXQgaXMgemVyby5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXNlT2Zmc2V0ID0gcm93ID8gZ2V0TWRFbmRDaChyb3dbY2hpbGRUeXBlXSkgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRhZyhvcGVuLCBjbG9zZSkgcG9zaXRpb24oJzInKSBmb3Igc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjaE9mZnNldCArPSBiYXNlT2Zmc2V0ICsgMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAncHJldicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIHByZXYgcm93LCB0aGUgdGFyZ2V0IHBvc2l0aW9uIHdvdWxkIGJlICctNCcgZm9yIGNhbGN1bGF0aW5nICcgfCcgY2hhcmFjdGVycyBhbmQgdGFnKG9wZW4sIGNsb3NlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgdGFyZ2V0IHBvc2l0aW9uIGlzIHplcm8uXG4gICAgICAgICAgICAgICAgICAgICAgICBjaE9mZnNldCA9IHJvdyA/IC00IDogMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgZW5kRnJvbU9mZnNldCArIGNoT2Zmc2V0KSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmFkZFRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHIsIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciBfYiA9IHBheWxvYWQsIGNvbHVtbkNvdW50ID0gX2IuY29sdW1uQ291bnQsIHJvd0NvdW50ID0gX2Iucm93Q291bnQ7XG4gICAgICAgICAgICB2YXIgZW5kVG9PZmZzZXQgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKS5lbmRUb09mZnNldDtcbiAgICAgICAgICAgIHZhciBoZWFkZXJSb3dzID0gY3JlYXRlVGFibGVIZWFkZXIoY29sdW1uQ291bnQpO1xuICAgICAgICAgICAgdmFyIGJvZHlSb3dzID0gY3JlYXRlVGFibGVCb2R5JDEoY29sdW1uQ291bnQsIHJvd0NvdW50IC0gMSk7XG4gICAgICAgICAgICB2YXIgcm93cyA9IF9fc3ByZWFkQXJyYXkkMShfX3NwcmVhZEFycmF5JDEoW10sIGhlYWRlclJvd3MpLCBib2R5Um93cyk7XG4gICAgICAgICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSkuaW5zZXJ0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSwgY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIHJvdykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBzaG91bGQgYWRkIGA0YCB0byBzZWxlY3Rpb24gcG9zaXRpb24gY29uc2lkZXJpbmcgYHwgYCB0ZXh0IGFuZCBzdGFydCBibG9jayB0YWcgbGVuZ3RoXG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgZW5kVG9PZmZzZXQgKyA0KSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IGFkZFRhYmxlOiB0aGlzLmFkZFRhYmxlKCkgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgRW50ZXI6IHRoaXMuZXh0ZW5kVGFibGUoKSxcbiAgICAgICAgICAgIFRhYjogdGhpcy5tb3ZlVGFibGVDZWxsKHRydWUpLFxuICAgICAgICAgICAgJ1NoaWZ0LVRhYic6IHRoaXMubW92ZVRhYmxlQ2VsbChmYWxzZSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGU7XG59KE1hcmspKTtcblxudmFyIHRoZW1hdGljQnJlYWtTeW50YXggPSAnKioqJztcbnZhciBUaGVtYXRpY0JyZWFrJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGhlbWF0aWNCcmVhaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaGVtYXRpY0JyZWFrKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaGVtYXRpY0JyZWFrLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RoZW1hdGljQnJlYWsnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRoZW1hdGljQnJlYWsucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCd0aGVtYXRpYy1icmVhaycpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGhlbWF0aWNCcmVhay5wcm90b3R5cGUuaHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWEsIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgZnJvbSA9IF9hLmZyb20sIHRvID0gX2EudG8sIGVuZFRvT2Zmc2V0ID0gX2EuZW5kVG9PZmZzZXQ7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCB0aGVtYXRpY0JyZWFrU3ludGF4KTtcbiAgICAgICAgICAgIHRyXG4gICAgICAgICAgICAgICAgLnNwbGl0KGZyb20pXG4gICAgICAgICAgICAgICAgLnJlcGxhY2VXaXRoKHRyLm1hcHBpbmcubWFwKGZyb20pLCB0ci5tYXBwaW5nLm1hcCh0byksIG5vZGUpXG4gICAgICAgICAgICAgICAgLnNwbGl0KHRyLm1hcHBpbmcubWFwKHRvKSkuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSkpO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBUaGVtYXRpY0JyZWFrLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgaHI6IHRoaXMuaHIoKSB9O1xuICAgIH07XG4gICAgVGhlbWF0aWNCcmVhay5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpbmVDb21tYW5kID0gdGhpcy5ocigpKCk7XG4gICAgICAgIHJldHVybiB7ICdNb2QtbCc6IGxpbmVDb21tYW5kLCAnTW9kLUwnOiBsaW5lQ29tbWFuZCB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRoZW1hdGljQnJlYWs7XG59KE1hcmspKTtcblxuZnVuY3Rpb24gY2Fubm90QmVMaXN0Tm9kZShfYSwgbGluZSkge1xuICAgIHZhciB0eXBlID0gX2EudHlwZSwgc291cmNlcG9zID0gX2Euc291cmNlcG9zO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgIHZhciBzdGFydExpbmUgPSBzb3VyY2Vwb3NbMF1bMF07XG4gICAgcmV0dXJuIGxpbmUgPD0gc3RhcnRMaW5lICYmICh0eXBlID09PSAnY29kZUJsb2NrJyB8fCB0eXBlID09PSAnaGVhZGluZycgfHwgdHlwZS5tYXRjaCgndGFibGUnKSk7XG59XG52YXIgTGlzdEl0ZW0kMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShMaXN0SXRlbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaXN0SXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGlzdEl0ZW0ucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnbGlzdEl0ZW0nO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3RJdGVtLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgb2RkOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgIGV2ZW46IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgbGlzdFN0eWxlOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2RkID0gYXR0cnMub2RkLCBldmVuID0gYXR0cnMuZXZlbiwgbGlzdFN0eWxlID0gYXR0cnMubGlzdFN0eWxlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9ICdsaXN0LWl0ZW0nO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzICs9ICd8bGlzdC1pdGVtLXN0eWxlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob2RkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzICs9ICd8bGlzdC1pdGVtLW9kZCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgKz0gJ3xsaXN0LWl0ZW0tZXZlbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeC5hcHBseSh2b2lkIDAsIGNsYXNzTmFtZXMuc3BsaXQoJ3wnKSkgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMaXN0SXRlbS5wcm90b3R5cGUuZXh0ZW5kTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIGRvYyA9IF9hLmRvYywgc2NoZW1hID0gX2Euc2NoZW1hLCB0ciA9IF9hLnRyO1xuICAgICAgICAgICAgdmFyIHRvYXN0TWFyayA9IF90aGlzLmNvbnRleHQudG9hc3RNYXJrO1xuICAgICAgICAgICAgdmFyIF9iID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIHRvID0gX2IudG8sIHN0YXJ0RnJvbU9mZnNldCA9IF9iLnN0YXJ0RnJvbU9mZnNldCwgZW5kRnJvbU9mZnNldCA9IF9iLmVuZEZyb21PZmZzZXQsIGVuZEluZGV4ID0gX2IuZW5kSW5kZXgsIGVuZFRvT2Zmc2V0ID0gX2IuZW5kVG9PZmZzZXQ7XG4gICAgICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSBnZXRUZXh0Q29udGVudChkb2MsIGVuZEluZGV4KTtcbiAgICAgICAgICAgIHZhciBpc0xpc3QgPSByZUxpc3QudGVzdCh0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICBpZiAoIWlzTGlzdCB8fCBzZWxlY3Rpb24uZnJvbSA9PT0gc3RhcnRGcm9tT2Zmc2V0IHx8ICFzZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXNFbXB0eSA9ICF0ZXh0Q29udGVudC5yZXBsYWNlKHJlQ2FuQmVUYXNrTGlzdCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlUmFuZ2UoZW5kRnJvbU9mZnNldCwgZW5kVG9PZmZzZXQpLnNwbGl0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tbWFuZFR5cGUgPSBnZXRMaXN0VHlwZSh0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGFkZCBgMWAgdG8gbGluZSBmb3IgdGhlIG1hcmtkb3duIHBhcnNlclxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgbWFya2Rvd24gcGFyc2VyIGhhcyBgMWAobm90IHplcm8pIGFzIHRoZSBzdGFydCBudW1iZXJcbiAgICAgICAgICAgICAgICB2YXIgbWROb2RlID0gdG9hc3RNYXJrLmZpbmRGaXJzdE5vZGVBdExpbmUoZW5kSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgc2xpY2VkVGV4dCA9IHRleHRDb250ZW50LnNsaWNlKHRvIC0gZW5kRnJvbU9mZnNldCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7IHRvYXN0TWFyazogdG9hc3RNYXJrLCBtZE5vZGU6IG1kTm9kZSwgZG9jOiBkb2MsIGxpbmU6IGVuZEluZGV4ICsgMSB9O1xuICAgICAgICAgICAgICAgIHZhciBfYyA9IGV4dGVuZExpc3RbY29tbWFuZFR5cGVdKGNvbnRleHQpLCBsaXN0U3ludGF4ID0gX2MubGlzdFN5bnRheCwgY2hhbmdlZFJlc3VsdHMgPSBfYy5jaGFuZ2VkUmVzdWx0cztcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2Ugb3JkaW5hbCBudW1iZXIgb2YgYmFja3dhcmQgb3JkZXJlZCBsaXN0XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRSZXN1bHRzID09PSBudWxsIHx8IGNoYW5nZWRSZXN1bHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFuZ2VkUmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIHRyLnNwbGl0KHRvKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGZpcnN0IG9yZGVyZWQgbGlzdCBpbmZvXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRSZXN1bHRzLnVuc2hpZnQoeyB0ZXh0OiBsaXN0U3ludGF4ICsgc2xpY2VkVGV4dCwgbGluZTogZW5kSW5kZXggKyAxIH0pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VUb0xpc3RQZXJMaW5lKHRyLCBjaGFuZ2VkUmVzdWx0cywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogdG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzdWJ0cmFjdCAxIGJlY2F1c2UgdGhlIGxpbmUgaGFzIGluY3JlYXNlZCB0aHJvdWdoICdzcGxpdCcgY29tbWFuZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TGluZTogY2hhbmdlZFJlc3VsdHNbMF0ubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZExpbmU6IGxhc3QkMShjaGFuZ2VkUmVzdWx0cykubGluZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkgLSBzbGljZWRUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHBvcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgbGlzdFN5bnRheCArIHNsaWNlZFRleHQpO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdEFuZEV4dGVuZEJsb2NrKHRyLCBlbmRUb09mZnNldCwgc2xpY2VkVGV4dCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBMaXN0SXRlbS5wcm90b3R5cGUudG9MaXN0ID0gZnVuY3Rpb24gKGNvbW1hbmRUeXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gX2EuZG9jLCB0ciA9IF9hLnRyLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb247XG4gICAgICAgICAgICB2YXIgdG9hc3RNYXJrID0gX3RoaXMuY29udGV4dC50b2FzdE1hcms7XG4gICAgICAgICAgICB2YXIgcmFuZ2VJbmZvID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbik7XG4gICAgICAgICAgICAvLyBzaG91bGQgYWRkIGAxYCB0byBsaW5lIGZvciB0aGUgbWFya2Rvd24gcGFyc2VyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIG1hcmtkb3duIHBhcnNlciBoYXMgYDFgKG5vdCB6ZXJvKSBhcyB0aGUgc3RhcnQgbnVtYmVyXG4gICAgICAgICAgICB2YXIgc3RhcnRMaW5lID0gcmFuZ2VJbmZvLnN0YXJ0SW5kZXggKyAxO1xuICAgICAgICAgICAgdmFyIGVuZExpbmUgPSByYW5nZUluZm8uZW5kSW5kZXggKyAxO1xuICAgICAgICAgICAgdmFyIGVuZFRvT2Zmc2V0ID0gcmFuZ2VJbmZvLmVuZFRvT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIHNraXBMaW5lcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgbGluZSA9IHN0YXJ0TGluZTsgbGluZSA8PSBlbmRMaW5lOyBsaW5lICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWROb2RlID0gdG9hc3RNYXJrLmZpbmRGaXJzdE5vZGVBdExpbmUobGluZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1kTm9kZSAmJiBjYW5ub3RCZUxpc3ROb2RlKG1kTm9kZSwgbGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRvIHNraXAgdW5uZWNlc3NhcnkgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgIGlmIChza2lwTGluZXMuaW5kZXhPZihsaW5lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0geyB0b2FzdE1hcms6IHRvYXN0TWFyaywgbWROb2RlOiBtZE5vZGUsIGRvYzogZG9jLCBsaW5lOiBsaW5lLCBzdGFydExpbmU6IHN0YXJ0TGluZSB9O1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkUmVzdWx0cyA9IChpc0xpc3ROb2RlJDEobWROb2RlKVxuICAgICAgICAgICAgICAgICAgICA/IG90aGVyTGlzdFRvTGlzdFtjb21tYW5kVHlwZV0oY29udGV4dClcbiAgICAgICAgICAgICAgICAgICAgOiBvdGhlck5vZGVUb0xpc3RbY29tbWFuZFR5cGVdKGNvbnRleHQpKS5jaGFuZ2VkUmVzdWx0cztcbiAgICAgICAgICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gX3RoaXMuY2hhbmdlVG9MaXN0UGVyTGluZSh0ciwgY2hhbmdlZFJlc3VsdHMsIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogZ2V0Tm9kZUNvbnRlbnRPZmZzZXRSYW5nZShkb2MsIGNoYW5nZWRSZXN1bHRzWzBdLmxpbmUgLSAxKS5zdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRMaW5lOiBjaGFuZ2VkUmVzdWx0c1swXS5saW5lLFxuICAgICAgICAgICAgICAgICAgICBlbmRMaW5lOiBsYXN0JDEoY2hhbmdlZFJlc3VsdHMpLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4RGlmZjogMSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbmRUb09mZnNldCA9IE1hdGgubWF4KGVuZE9mZnNldCwgZW5kVG9PZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkUmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICBza2lwTGluZXMgPSBza2lwTGluZXMuY29uY2F0KGNoYW5nZWRSZXN1bHRzLm1hcChmdW5jdGlvbiAoaW5mbykgeyByZXR1cm4gaW5mby5saW5lOyB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSkpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgTGlzdEl0ZW0ucHJvdG90eXBlLmNoYW5nZVRvTGlzdFBlckxpbmUgPSBmdW5jdGlvbiAodHIsIGNoYW5nZWRSZXN1bHRzLCBfYSkge1xuICAgICAgICB2YXIgZnJvbSA9IF9hLmZyb20sIHN0YXJ0TGluZSA9IF9hLnN0YXJ0TGluZSwgZW5kTGluZSA9IF9hLmVuZExpbmUsIF9iID0gX2EuaW5kZXhEaWZmLCBpbmRleERpZmYgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iO1xuICAgICAgICB2YXIgbWF4RW5kT2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIF9jID0gdHIuZG9jLmNoaWxkKGkpLCBub2RlU2l6ZSA9IF9jLm5vZGVTaXplLCBjb250ZW50ID0gX2MuY29udGVudDtcbiAgICAgICAgICAgIHZhciBtYXBwZWRGcm9tID0gdHIubWFwcGluZy5tYXAoZnJvbSk7XG4gICAgICAgICAgICB2YXIgbWFwcGVkVG8gPSBtYXBwZWRGcm9tICsgY29udGVudC5zaXplO1xuICAgICAgICAgICAgdmFyIGNoYW5nZWRSZXN1bHQgPSBjaGFuZ2VkUmVzdWx0cy5maWx0ZXIoZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0LmxpbmUgLSBpbmRleERpZmYgPT09IGk7IH0pWzBdO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0ci5yZXBsYWNlV2l0aChtYXBwZWRGcm9tLCBtYXBwZWRUbywgY3JlYXRlVGV4dE5vZGUkMSh0aGlzXzEuY29udGV4dC5zY2hlbWEsIGNoYW5nZWRSZXN1bHQudGV4dCkpO1xuICAgICAgICAgICAgICAgIG1heEVuZE9mZnNldCA9IE1hdGgubWF4KG1heEVuZE9mZnNldCwgZnJvbSArIGNvbnRlbnQuc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tICs9IG5vZGVTaXplO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0TGluZSAtIGluZGV4RGlmZjsgaSA8PSBlbmRMaW5lIC0gaW5kZXhEaWZmOyBpICs9IDEpIHtcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heEVuZE9mZnNldDtcbiAgICB9O1xuICAgIExpc3RJdGVtLnByb3RvdHlwZS50b2dnbGVUYXNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgdHIgPSBfYS50ciwgZG9jID0gX2EuZG9jLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgdG9hc3RNYXJrID0gX3RoaXMuY29udGV4dC50b2FzdE1hcms7XG4gICAgICAgICAgICB2YXIgX2IgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgc3RhcnRJbmRleCA9IF9iLnN0YXJ0SW5kZXgsIGVuZEluZGV4ID0gX2IuZW5kSW5kZXg7XG4gICAgICAgICAgICB2YXIgbmV3VHIgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPD0gZW5kSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBtZE5vZGUgPSB0b2FzdE1hcmsuZmluZEZpcnN0Tm9kZUF0TGluZShpICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGlzdE5vZGUkMShtZE5vZGUpICYmIG1kTm9kZS5saXN0RGF0YS50YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYyA9IG1kTm9kZS5saXN0RGF0YSwgY2hlY2tlZCA9IF9jLmNoZWNrZWQsIHBhZGRpbmcgPSBfYy5wYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGVDaGFyID0gY2hlY2tlZCA/ICcgJyA6ICd4JztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1kUG9zID0gbWROb2RlLnNvdXJjZXBvc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gZ2V0Tm9kZUNvbnRlbnRPZmZzZXRSYW5nZShkb2MsIG1kUG9zWzBdIC0gMSkuc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ICs9IG1kUG9zWzFdICsgcGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgbmV3VHIgPSB0ci5yZXBsYWNlV2l0aChzdGFydE9mZnNldCwgc3RhcnRPZmZzZXQgKyAxLCBzY2hlbWEudGV4dChzdGF0ZUNoYXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3VHIpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChuZXdUcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBMaXN0SXRlbS5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBidWxsZXRMaXN0OiB0aGlzLnRvTGlzdCgnYnVsbGV0JyksXG4gICAgICAgICAgICBvcmRlcmVkTGlzdDogdGhpcy50b0xpc3QoJ29yZGVyZWQnKSxcbiAgICAgICAgICAgIHRhc2tMaXN0OiB0aGlzLnRvTGlzdCgndGFzaycpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgTGlzdEl0ZW0ucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidWxsZXRDb21tYW5kID0gdGhpcy50b0xpc3QoJ2J1bGxldCcpKCk7XG4gICAgICAgIHZhciBvcmRlcmVkQ29tbWFuZCA9IHRoaXMudG9MaXN0KCdvcmRlcmVkJykoKTtcbiAgICAgICAgdmFyIHRhc2tDb21tYW5kID0gdGhpcy50b0xpc3QoJ3Rhc2snKSgpO1xuICAgICAgICB2YXIgdG9nbGVUYXNrQ29tbWFuZCA9IHRoaXMudG9nZ2xlVGFzaygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC11JzogYnVsbGV0Q29tbWFuZCxcbiAgICAgICAgICAgICdNb2QtVSc6IGJ1bGxldENvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLW8nOiBvcmRlcmVkQ29tbWFuZCxcbiAgICAgICAgICAgICdNb2QtTyc6IG9yZGVyZWRDb21tYW5kLFxuICAgICAgICAgICAgJ2FsdC10JzogdGFza0NvbW1hbmQsXG4gICAgICAgICAgICAnYWx0LVQnOiB0YXNrQ29tbWFuZCxcbiAgICAgICAgICAgICdTaGlmdC1DdHJsLXgnOiB0b2dsZVRhc2tDb21tYW5kLFxuICAgICAgICAgICAgJ1NoaWZ0LUN0cmwtWCc6IHRvZ2xlVGFza0NvbW1hbmQsXG4gICAgICAgICAgICBFbnRlcjogdGhpcy5leHRlbmRMaXN0KCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTGlzdEl0ZW07XG59KE1hcmspKTtcblxuZnVuY3Rpb24gdG9nZ2xlTWFyayhjb25kaXRpb24sIHN5bnRheCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciB0ciA9IF9hLnRyLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb247XG4gICAgICAgIHZhciBjb25kaXRpb25GbiA9ICFpc0Z1bmN0aW9uXzEoY29uZGl0aW9uKVxuICAgICAgICAgICAgPyBmdW5jdGlvbiAodGV4dCkgeyByZXR1cm4gY29uZGl0aW9uLnRlc3QodGV4dCk7IH1cbiAgICAgICAgICAgIDogY29uZGl0aW9uO1xuICAgICAgICB2YXIgc3ludGF4TGVuID0gc3ludGF4Lmxlbmd0aDtcbiAgICAgICAgdmFyIGRvYyA9IHRyLmRvYztcbiAgICAgICAgdmFyIF9iID0gcmVzb2x2ZVNlbGVjdGlvblBvcyhzZWxlY3Rpb24pLCBmcm9tID0gX2JbMF0sIHRvID0gX2JbMV07XG4gICAgICAgIHZhciBwcmV2UG9zID0gTWF0aC5tYXgoZnJvbSAtIHN5bnRheExlbiwgMSk7XG4gICAgICAgIHZhciBuZXh0UG9zID0gTWF0aC5taW4odG8gKyBzeW50YXhMZW4sIGRvYy5jb250ZW50LnNpemUgLSAxKTtcbiAgICAgICAgdmFyIHNsaWNlID0gc2VsZWN0aW9uLmNvbnRlbnQoKTtcbiAgICAgICAgdmFyIHRleHRDb250ZW50ID0gc2xpY2UuY29udGVudC50ZXh0QmV0d2VlbigwLCBzbGljZS5jb250ZW50LnNpemUsICdcXG4nKTtcbiAgICAgICAgdmFyIHByZXZUZXh0ID0gZG9jLnRleHRCZXR3ZWVuKHByZXZQb3MsIGZyb20sICdcXG4nKTtcbiAgICAgICAgdmFyIG5leHRUZXh0ID0gZG9jLnRleHRCZXR3ZWVuKHRvLCBuZXh0UG9zLCAnXFxuJyk7XG4gICAgICAgIHRleHRDb250ZW50ID0gXCJcIiArIHByZXZUZXh0ICsgdGV4dENvbnRlbnQgKyBuZXh0VGV4dDtcbiAgICAgICAgaWYgKHByZXZUZXh0ICYmIG5leHRUZXh0ICYmIGNvbmRpdGlvbkZuKHRleHRDb250ZW50KSkge1xuICAgICAgICAgICAgdHIuZGVsZXRlKG5leHRQb3MgLSBzeW50YXhMZW4sIG5leHRQb3MpLmRlbGV0ZShwcmV2UG9zLCBwcmV2UG9zICsgc3ludGF4TGVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyLmluc2VydFRleHQoc3ludGF4LCB0bykuaW5zZXJ0VGV4dChzeW50YXgsIGZyb20pO1xuICAgICAgICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IHNlbGVjdGlvbi5lbXB0eVxuICAgICAgICAgICAgICAgID8gY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgZnJvbSArIHN5bnRheExlbilcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIGZyb20gKyBzeW50YXhMZW4sIHRvICsgc3ludGF4TGVuKTtcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTsgfTtcbn1cblxudmFyIHJlU3Ryb25nID0gL14oXFwqezJ9fF97Mn0pLiooW1xcc1xcU10qKVxcMSQvbTtcbnZhciBzdHJvbmdTeW50YXggPSAnKionO1xudmFyIFN0cm9uZyQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFN0cm9uZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHJvbmcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cm9uZy5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdzdHJvbmcnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cm9uZy5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ3N0cm9uZycpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3Ryb25nLnByb3RvdHlwZS5ib2xkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdG9nZ2xlTWFyayhyZVN0cm9uZywgc3Ryb25nU3ludGF4KTtcbiAgICB9O1xuICAgIFN0cm9uZy5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IGJvbGQ6IHRoaXMuYm9sZCgpIH07XG4gICAgfTtcbiAgICBTdHJvbmcucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBib2xkQ29tbWFuZCA9IHRoaXMuYm9sZCgpKCk7XG4gICAgICAgIHJldHVybiB7ICdNb2QtYic6IGJvbGRDb21tYW5kLCAnTW9kLUInOiBib2xkQ29tbWFuZCB9O1xuICAgIH07XG4gICAgcmV0dXJuIFN0cm9uZztcbn0oTWFyaykpO1xuXG52YXIgcmVTdHJpa2UgPSAvXih+ezJ9KS4qKFtcXHNcXFNdKilcXDEkL207XG52YXIgc3RyaWtlU3ludGF4ID0gJ35+JztcbnZhciBTdHJpa2UkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShTdHJpa2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RyaWtlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpa2UucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnc3RyaWtlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpa2UucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdzdHJpa2UnKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFN0cmlrZS5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0b2dnbGVNYXJrKHJlU3RyaWtlLCBzdHJpa2VTeW50YXgpO1xuICAgIH07XG4gICAgU3RyaWtlLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RyaWtlQ29tbWFuZCA9IHRoaXMuY29tbWFuZHMoKSgpO1xuICAgICAgICByZXR1cm4geyAnTW9kLXMnOiBzdHJpa2VDb21tYW5kLCAnTW9kLVMnOiBzdHJpa2VDb21tYW5kIH07XG4gICAgfTtcbiAgICByZXR1cm4gU3RyaWtlO1xufShNYXJrKSk7XG5cbnZhciByZUVtcGggPSAvXihcXCp8XykuKihbXFxzXFxTXSopXFwxJC9tO1xudmFyIGVtcGhTeW50YXggPSAnKic7XG52YXIgRW1waCQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEVtcGgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1waCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1waC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdlbXBoJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbXBoLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgnZW1waCcpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRW1waC5wcm90b3R5cGUuaXRhbGljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdG9nZ2xlTWFyayhyZUVtcGgsIGVtcGhTeW50YXgpO1xuICAgIH07XG4gICAgRW1waC5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IGl0YWxpYzogdGhpcy5pdGFsaWMoKSB9O1xuICAgIH07XG4gICAgRW1waC5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl0YWxpY0NvbW1hbmQgPSB0aGlzLml0YWxpYygpKCk7XG4gICAgICAgIHJldHVybiB7ICdNb2QtaSc6IGl0YWxpY0NvbW1hbmQsICdNb2QtSSc6IGl0YWxpY0NvbW1hbmQgfTtcbiAgICB9O1xuICAgIHJldHVybiBFbXBoO1xufShNYXJrKSk7XG5cbnZhciByZUNvZGUgPSAvXihgKS4qKFtcXHNcXFNdKilcXDEkL207XG52YXIgY29kZVN5bnRheCA9ICdgJztcbnZhciBDb2RlJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQ29kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb2RlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2RlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NvZGUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvZGUucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgbWFya2VkOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKG1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gbWFyay5hdHRycywgc3RhcnQgPSBfYS5zdGFydCwgZW5kID0gX2EuZW5kLCBtYXJrZWQgPSBfYS5tYXJrZWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gJ2NvZGUnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgKz0gJ3xkZWxpbWl0ZXJ8c3RhcnQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgKz0gJ3xkZWxpbWl0ZXJ8ZW5kJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWFya2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzICs9ICd8bWFya2VkLXRleHQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXguYXBwbHkodm9pZCAwLCBjbGFzc05hbWVzLnNwbGl0KCd8JykpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29kZS5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0b2dnbGVNYXJrKHJlQ29kZSwgY29kZVN5bnRheCk7XG4gICAgfTtcbiAgICBDb2RlLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29kZUNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzKCkoKTtcbiAgICAgICAgcmV0dXJuIHsgJ1NoaWZ0LU1vZC1jJzogY29kZUNvbW1hbmQsICdTaGlmdC1Nb2QtQyc6IGNvZGVDb21tYW5kIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29kZTtcbn0oTWFyaykpO1xuXG52YXIgTGluayQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKExpbmssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGluaygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGluay5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdsaW5rJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5rLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBhdHRycy51cmwsIGRlc2MgPSBhdHRycy5kZXNjO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9ICdsaW5rJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyArPSAnfGxpbmstdXJsfG1hcmtlZC10ZXh0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyArPSAnfGxpbmstZGVzY3xtYXJrZWQtdGV4dCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeC5hcHBseSh2b2lkIDAsIGNsYXNzTmFtZXMuc3BsaXQoJ3wnKSkgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMaW5rLnByb3RvdHlwZS5hZGRMaW5rT3JJbWFnZSA9IGZ1bmN0aW9uIChjb21tYW5kVHlwZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHIsIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciBfYiA9IHJlc29sdmVTZWxlY3Rpb25Qb3Moc2VsZWN0aW9uKSwgZnJvbSA9IF9iWzBdLCB0byA9IF9iWzFdO1xuICAgICAgICAgICAgdmFyIF9jID0gcGF5bG9hZCwgbGlua1RleHQgPSBfYy5saW5rVGV4dCwgYWx0VGV4dCA9IF9jLmFsdFRleHQsIGxpbmtVcmwgPSBfYy5saW5rVXJsLCBpbWFnZVVybCA9IF9jLmltYWdlVXJsO1xuICAgICAgICAgICAgdmFyIHRleHQgPSBsaW5rVGV4dDtcbiAgICAgICAgICAgIHZhciB1cmwgPSBsaW5rVXJsO1xuICAgICAgICAgICAgdmFyIHN5bnRheCA9ICcnO1xuICAgICAgICAgICAgaWYgKGNvbW1hbmRUeXBlID09PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGFsdFRleHQ7XG4gICAgICAgICAgICAgICAgdXJsID0gaW1hZ2VVcmw7XG4gICAgICAgICAgICAgICAgc3ludGF4ID0gJyEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dCA9IGVzY2FwZVRleHRGb3JMaW5rKHRleHQpO1xuICAgICAgICAgICAgc3ludGF4ICs9IFwiW1wiICsgdGV4dCArIFwiXShcIiArIHVybCArIFwiKVwiO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIucmVwbGFjZVdpdGgoZnJvbSwgdG8sIGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCBzeW50YXgpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIExpbmsucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkSW1hZ2U6IHRoaXMuYWRkTGlua09ySW1hZ2UoJ2ltYWdlJyksXG4gICAgICAgICAgICBhZGRMaW5rOiB0aGlzLmFkZExpbmtPckltYWdlKCdsaW5rJyksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTGluaztcbn0oTWFyaykpO1xuXG52YXIgVGFza0RlbGltaXRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUYXNrRGVsaW1pdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhc2tEZWxpbWl0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhc2tEZWxpbWl0ZXIucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGFza0RlbGltaXRlcic7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFza0RlbGltaXRlci5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ2RlbGltaXRlcicsICdsaXN0LWl0ZW0nKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBUYXNrRGVsaW1pdGVyO1xufShNYXJrKSk7XG52YXIgRGVsaW1pdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKERlbGltaXRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWxpbWl0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlbGltaXRlci5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdkZWxpbWl0ZXInO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlbGltaXRlci5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ2RlbGltaXRlcicpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIERlbGltaXRlcjtcbn0oTWFyaykpO1xudmFyIE1ldGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoTWV0YSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXRhKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXRhLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21ldGEnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ldGEucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdtZXRhJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTWV0YTtcbn0oTWFyaykpO1xudmFyIE1hcmtlZFRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoTWFya2VkVGV4dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXJrZWRUZXh0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXJrZWRUZXh0LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21hcmtlZFRleHQnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcmtlZFRleHQucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdtYXJrZWQtdGV4dCcpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIE1hcmtlZFRleHQ7XG59KE1hcmspKTtcbnZhciBUYWJsZUNlbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGFibGVDZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlQ2VsbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVDZWxsLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RhYmxlQ2VsbCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVDZWxsLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgndGFibGUtY2VsbCcpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRhYmxlQ2VsbDtcbn0oTWFyaykpO1xuXG52YXIgSHRtbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShIdG1sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEh0bWwoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEh0bWwucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnaHRtbCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSHRtbC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ2h0bWwnKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBIdG1sO1xufShNYXJrKSk7XG5cbnZhciBjdXN0b21CbG9ja1N5bnRheCA9ICckJCc7XG52YXIgQ3VzdG9tQmxvY2skMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShDdXN0b21CbG9jaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDdXN0b21CbG9jaygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tQmxvY2sucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnY3VzdG9tQmxvY2snO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbUJsb2NrLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgnY3VzdG9tLWJsb2NrJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDdXN0b21CbG9jay5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgc2NoZW1hID0gc3RhdGUuc2NoZW1hLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIHN0YXJ0RnJvbU9mZnNldCA9IF9hLnN0YXJ0RnJvbU9mZnNldCwgZW5kVG9PZmZzZXQgPSBfYS5lbmRUb09mZnNldDtcbiAgICAgICAgICAgIGlmICghKHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5pbmZvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdXN0b21CbG9jayA9IFwiXCIgKyBjdXN0b21CbG9ja1N5bnRheCArIHBheWxvYWQuaW5mbztcbiAgICAgICAgICAgIHZhciBzdGFydE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgY3VzdG9tQmxvY2spO1xuICAgICAgICAgICAgdmFyIGVuZE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgY3VzdG9tQmxvY2tTeW50YXgpO1xuICAgICAgICAgICAgdHIuaW5zZXJ0KHN0YXJ0RnJvbU9mZnNldCwgc3RhcnROb2RlKS5zcGxpdChzdGFydEZyb21PZmZzZXQgKyBjdXN0b21CbG9jay5sZW5ndGgpO1xuICAgICAgICAgICAgdHIuc3BsaXQodHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpKS5pbnNlcnQodHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpLCBlbmROb2RlKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCB0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkgLSAoY3VzdG9tQmxvY2tTeW50YXgubGVuZ3RoICsgMikpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIHJldHVybiBDdXN0b21CbG9jaztcbn0oTWFyaykpO1xuXG52YXIgcmVUYXNrTWFya2VyS2V5ID0gL3h8YmFja3NwYWNlL2k7XG52YXIgcmVUYXNrTWFya2VyID0gL15cXFsoXFxzKikoeD8pKFxccyopXFxdKD86XFxzKykvaTtcbmZ1bmN0aW9uIHNtYXJ0VGFzayhfYSkge1xuICAgIHZhciBzY2hlbWEgPSBfYS5zY2hlbWEsIHRvYXN0TWFyayA9IF9hLnRvYXN0TWFyaztcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgICAgICBrZXl1cDogZnVuY3Rpb24gKHZpZXcsIGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gdmlldy5zdGF0ZSwgZG9jID0gX2IuZG9jLCB0ciA9IF9iLnRyLCBzZWxlY3Rpb24gPSBfYi5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uZW1wdHkgJiYgcmVUYXNrTWFya2VyS2V5LnRlc3QoZXYua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIHN0YXJ0SW5kZXggPSBfYy5zdGFydEluZGV4LCBzdGFydEZyb21PZmZzZXQgPSBfYy5zdGFydEZyb21PZmZzZXQsIGZyb20gPSBfYy5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGFkZCBgMWAgdG8gbGluZSBmb3IgdGhlIG1hcmtkb3duIHBhcnNlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBtYXJrZG93biBwYXJzZXIgaGFzIGAxYChub3QgemVybykgYXMgdGhlIHN0YXJ0IG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1kUG9zID0gW3N0YXJ0SW5kZXggKyAxLCBmcm9tIC0gc3RhcnRGcm9tT2Zmc2V0ICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWROb2RlID0gdG9hc3RNYXJrLmZpbmROb2RlQXRQb3NpdGlvbihtZFBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYU5vZGUgPSBmaW5kQ2xvc2VzdE5vZGUobWROb2RlLCBmdW5jdGlvbiAobm9kZSkgeyB2YXIgX2E7IHJldHVybiBub2RlLnR5cGUgPT09ICdwYXJhZ3JhcGgnICYmICgoX2EgPSBub2RlLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSAnaXRlbSc7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IHBhcmFOb2RlID09PSBudWxsIHx8IHBhcmFOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhTm9kZS5maXJzdENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdENoaWxkID0gcGFyYU5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IGZpcnN0Q2hpbGQubGl0ZXJhbC5tYXRjaChyZVRhc2tNYXJrZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydE1kUG9zID0gZmlyc3RDaGlsZC5zb3VyY2Vwb3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFNwYWNlcyA9IG1hdGNoZWRbMV0sIHN0YXRlQ2hhciA9IG1hdGNoZWRbMl0sIGxhc3RTcGFjZXMgPSBtYXRjaGVkWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BhY2VzID0gc3RhcnRTcGFjZXMubGVuZ3RoICsgbGFzdFNwYWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IGdldE5vZGVDb250ZW50T2Zmc2V0UmFuZ2UoZG9jLCBzdGFydE1kUG9zWzBdIC0gMSkuc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFBvcyA9IHN0YXJ0TWRQb3NbMV0gKyBzdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGVkUG9zID0gc3BhY2VzID8gc3BhY2VzICsgMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5yZXBsYWNlV2l0aChzdGFydFBvcywgYWRkZWRQb3MgKyBzdGFydFBvcywgc2NoZW1hLnRleHQoc3RhdGVDaGFyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghc3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5pbnNlcnRUZXh0KCcgJywgc3RhcnRQb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG52YXIgRVZFTlRfVFlQRSA9ICdjdXQnO1xudmFyIHJlTGluZUVuZGluZyQyID0gL1xcclxcbnxcXG58XFxyLztcbnZhciBNZEVkaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShNZEVkaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZEVkaXRvcihldmVudEVtaXR0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZXZlbnRFbWl0dGVyKSB8fCB0aGlzO1xuICAgICAgICB2YXIgdG9hc3RNYXJrID0gb3B0aW9ucy50b2FzdE1hcmssIF9hID0gb3B0aW9ucy51c2VDb21tYW5kU2hvcnRjdXQsIHVzZUNvbW1hbmRTaG9ydGN1dCA9IF9hID09PSB2b2lkIDAgPyB0cnVlIDogX2EsIF9iID0gb3B0aW9ucy5tZFBsdWdpbnMsIG1kUGx1Z2lucyA9IF9iID09PSB2b2lkIDAgPyBbXSA6IF9iO1xuICAgICAgICBfdGhpcy5lZGl0b3JUeXBlID0gJ21hcmtkb3duJztcbiAgICAgICAgX3RoaXMuZWwuY2xhc3NMaXN0LmFkZCgnbWQtbW9kZScpO1xuICAgICAgICBfdGhpcy50b2FzdE1hcmsgPSB0b2FzdE1hcms7XG4gICAgICAgIF90aGlzLmV4dHJhUGx1Z2lucyA9IG1kUGx1Z2lucztcbiAgICAgICAgX3RoaXMuc3BlY3MgPSBfdGhpcy5jcmVhdGVTcGVjcygpO1xuICAgICAgICBfdGhpcy5zY2hlbWEgPSBfdGhpcy5jcmVhdGVTY2hlbWEoKTtcbiAgICAgICAgX3RoaXMuY29udGV4dCA9IF90aGlzLmNyZWF0ZUNvbnRleHQoKTtcbiAgICAgICAgX3RoaXMua2V5bWFwcyA9IF90aGlzLmNyZWF0ZUtleW1hcHModXNlQ29tbWFuZFNob3J0Y3V0KTtcbiAgICAgICAgX3RoaXMudmlldyA9IF90aGlzLmNyZWF0ZVZpZXcoKTtcbiAgICAgICAgX3RoaXMuY29tbWFuZHMgPSBfdGhpcy5jcmVhdGVDb21tYW5kcygpO1xuICAgICAgICBfdGhpcy5zcGVjcy5zZXRDb250ZXh0KF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgX3RoaXMuY29udGV4dCksIHsgdmlldzogX3RoaXMudmlldyB9KSk7XG4gICAgICAgIF90aGlzLmNyZWF0ZUNsaXBib2FyZCgpO1xuICAgICAgICAvLyBUbyBwcmV2ZW50IHVubmVjZXNzYXJ5IGZvY3VzIHNldHRpbmcgZHVyaW5nIGluaXRpYWwgcmVuZGVyaW5nXG4gICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2NoYW5nZVByZXZpZXdUYWJXcml0ZScsIGZ1bmN0aW9uIChpc01hcmtkb3duVGFiTW91bnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRvZ2dsZUFjdGl2ZSh0cnVlLCBpc01hcmtkb3duVGFiTW91bnRlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdjaGFuZ2VQcmV2aWV3VGFiUHJldmlldycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRvZ2dsZUFjdGl2ZShmYWxzZSk7IH0pO1xuICAgICAgICBfdGhpcy5pbml0RXZlbnQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNZEVkaXRvci5wcm90b3R5cGUudG9nZ2xlQWN0aXZlID0gZnVuY3Rpb24gKGFjdGl2ZSwgaXNNYXJrZG93blRhYk1vdW50ZWQpIHtcbiAgICAgICAgdG9nZ2xlQ2xhc3ModGhpcy5lbCwgJ2FjdGl2ZScsIGFjdGl2ZSk7XG4gICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICAgIGlmICghaXNNYXJrZG93blRhYk1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmNyZWF0ZUNsaXBib2FyZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jbGlwYm9hcmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgICB0aGlzLmNsaXBib2FyZC5jbGFzc05hbWUgPSBjbHMoJ3BzZXVkby1jbGlwYm9hcmQnKTtcbiAgICAgICAgdGhpcy5jbGlwYm9hcmQuYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBjbGlwYm9hcmREYXRhID0gZXYuY2xpcGJvYXJkRGF0YSB8fCB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IGNsaXBib2FyZERhdGEgJiYgY2xpcGJvYXJkRGF0YS5pdGVtcztcbiAgICAgICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluUnRmSXRlbSA9IHRvQXJyYXlfMShpdGVtcykuc29tZShmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5raW5kID09PSAnc3RyaW5nJyAmJiBpdGVtLnR5cGUgPT09ICd0ZXh0L3J0Zic7IH0pO1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0IGNvbnRhaW5zIHJ0ZiwgaXQncyBtb3N0IGxpa2VseSBjb3B5IHBhc3RlIGZyb20gb2ZmaWNlIC0+IG5vIGltYWdlXG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWluUnRmSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VCbG9iID0gcGFzdGVJbWFnZU9ubHkoaXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEltYWdlQmxvYkhvb2soX3RoaXMuZXZlbnRFbWl0dGVyLCBpbWFnZUJsb2IsIGV2LnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gcHJvY2VzcyB0aGUgcGFzdGVkIGRhdGEgaW4gaW5wdXQgZXZlbnQgZm9yIElFMTFcbiAgICAgICAgdGhpcy5jbGlwYm9hcmQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gZXYudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgX3RoaXMucmVwbGFjZVNlbGVjdGlvbih0ZXh0KTtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldi50YXJnZXQudmFsdWUgPSAnJztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWwuaW5zZXJ0QmVmb3JlKHRoaXMuY2xpcGJvYXJkLCB0aGlzLnZpZXcuZG9tKTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9hc3RNYXJrOiB0aGlzLnRvYXN0TWFyayxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICAgICAgICBldmVudEVtaXR0ZXI6IHRoaXMuZXZlbnRFbWl0dGVyLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVNwZWNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNwZWNNYW5hZ2VyKFtcbiAgICAgICAgICAgIG5ldyBEb2MkMSgpLFxuICAgICAgICAgICAgbmV3IFBhcmFncmFwaCQxKCksXG4gICAgICAgICAgICBuZXcgV2lkZ2V0KCksXG4gICAgICAgICAgICBuZXcgVGV4dCQxKCksXG4gICAgICAgICAgICBuZXcgSGVhZGluZyQxKCksXG4gICAgICAgICAgICBuZXcgQmxvY2tRdW90ZSQxKCksXG4gICAgICAgICAgICBuZXcgQ29kZUJsb2NrJDEoKSxcbiAgICAgICAgICAgIG5ldyBDdXN0b21CbG9jayQxKCksXG4gICAgICAgICAgICBuZXcgVGFibGUkMSgpLFxuICAgICAgICAgICAgbmV3IFRhYmxlQ2VsbCgpLFxuICAgICAgICAgICAgbmV3IFRoZW1hdGljQnJlYWskMSgpLFxuICAgICAgICAgICAgbmV3IExpc3RJdGVtJDEoKSxcbiAgICAgICAgICAgIG5ldyBTdHJvbmckMSgpLFxuICAgICAgICAgICAgbmV3IFN0cmlrZSQxKCksXG4gICAgICAgICAgICBuZXcgRW1waCQxKCksXG4gICAgICAgICAgICBuZXcgQ29kZSQxKCksXG4gICAgICAgICAgICBuZXcgTGluayQxKCksXG4gICAgICAgICAgICBuZXcgRGVsaW1pdGVyKCksXG4gICAgICAgICAgICBuZXcgVGFza0RlbGltaXRlcigpLFxuICAgICAgICAgICAgbmV3IE1hcmtlZFRleHQoKSxcbiAgICAgICAgICAgIG5ldyBNZXRhKCksXG4gICAgICAgICAgICBuZXcgSHRtbCgpLFxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVQbHVnaW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheSQxKFtcbiAgICAgICAgICAgIHN5bnRheEhpZ2hsaWdodCh0aGlzLmNvbnRleHQpLFxuICAgICAgICAgICAgcHJldmlld0hpZ2hsaWdodCh0aGlzLmNvbnRleHQpLFxuICAgICAgICAgICAgc21hcnRUYXNrKHRoaXMuY29udGV4dClcbiAgICAgICAgXSwgdGhpcy5jcmVhdGVQbHVnaW5Qcm9wcygpKS5jb25jYXQodGhpcy5kZWZhdWx0UGx1Z2lucyk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuY3JlYXRlVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JWaWV3KHRoaXMuZWwsIHtcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLmNyZWF0ZVN0YXRlKCksXG4gICAgICAgICAgICBkaXNwYXRjaFRyYW5zYWN0aW9uOiBmdW5jdGlvbiAodHIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVNYXJrZG93bih0cik7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gX3RoaXMudmlldy5zdGF0ZS5hcHBseVRyYW5zYWN0aW9uKHRyKS5zdGF0ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0Q2hhbmdlRXZlbnQodHIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZUtleURvd246IGZ1bmN0aW9uIChfLCBldikge1xuICAgICAgICAgICAgICAgIGlmICgoZXYubWV0YUtleSB8fCBldi5jdHJsS2V5KSAmJiBldi5rZXkudG9VcHBlckNhc2UoKSA9PT0gJ1YnKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNsaXBib2FyZC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgna2V5ZG93bicsIF90aGlzLmVkaXRvclR5cGUsIGV2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgY29weTogZnVuY3Rpb24gKF8sIGV2KSB7IHJldHVybiBfdGhpcy5jYXB0dXJlQ29weShldik7IH0sXG4gICAgICAgICAgICAgICAgY3V0OiBmdW5jdGlvbiAoXywgZXYpIHsgcmV0dXJuIF90aGlzLmNhcHR1cmVDb3B5KGV2LCBFVkVOVF9UWVBFKTsgfSxcbiAgICAgICAgICAgICAgICBzY3JvbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3Njcm9sbCcsICdlZGl0b3InKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBrZXl1cDogZnVuY3Rpb24gKF8sIGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdrZXl1cCcsIF90aGlzLmVkaXRvclR5cGUsIGV2KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9kZVZpZXdzOiB7XG4gICAgICAgICAgICAgICAgd2lkZ2V0OiB3aWRnZXROb2RlVmlldyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmNyZWF0ZUNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjcy5jb21tYW5kcyh0aGlzLnZpZXcpO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmNhcHR1cmVDb3B5ID0gZnVuY3Rpb24gKGV2LCB0eXBlKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCB0ciA9IF9hLnRyO1xuICAgICAgICBpZiAoc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0Q2hhbmdlZChzZWxlY3Rpb24uY29udGVudCgpKTtcbiAgICAgICAgaWYgKGV2LmNsaXBib2FyZERhdGEpIHtcbiAgICAgICAgICAgIGV2LmNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2luZG93LmNsaXBib2FyZERhdGEuc2V0RGF0YSgnVGV4dCcsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBFVkVOVF9UWVBFKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godHIuZGVsZXRlU2VsZWN0aW9uKCkuc2Nyb2xsSW50b1ZpZXcoKS5zZXRNZXRhKCd1aUV2ZW50JywgRVZFTlRfVFlQRSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLnVwZGF0ZU1hcmtkb3duID0gZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0ci5zdGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGVwLnNsaWNlICYmICEoc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VBcm91bmRTdGVwKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gdHIuZG9jc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IFtzdGVwLmZyb20sIHN0ZXAudG9dLCBmcm9tID0gX2FbMF0sIHRvID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IGdldEVkaXRvclRvTWRQb3MoZG9jLCBmcm9tLCB0byksIHN0YXJ0UG9zID0gX2JbMF0sIGVuZFBvcyA9IF9iWzFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZCA9IF90aGlzLmdldENoYW5nZWQoc3RlcC5zbGljZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydFBvc1swXSA9PT0gZW5kUG9zWzBdICYmIHN0YXJ0UG9zWzFdID09PSBlbmRQb3NbMV0gJiYgY2hhbmdlZCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdFJlc3VsdCA9IF90aGlzLnRvYXN0TWFyay5lZGl0TWFya2Rvd24oc3RhcnRQb3MsIGVuZFBvcywgY2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5lbWl0KCd1cGRhdGVQcmV2aWV3JywgZWRpdFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoJ2VkaXRSZXN1bHQnLCBlZGl0UmVzdWx0KS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuZ2V0Q2hhbmdlZCA9IGZ1bmN0aW9uIChzbGljZSkge1xuICAgICAgICB2YXIgY2hhbmdlZCA9ICcnO1xuICAgICAgICB2YXIgZnJvbSA9IDA7XG4gICAgICAgIHZhciB0byA9IHNsaWNlLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgc2xpY2UuY29udGVudC5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGZ1bmN0aW9uIChub2RlLCBwb3MpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgKz0gbm9kZS50ZXh0LnNsaWNlKE1hdGgubWF4KGZyb20sIHBvcykgLSBwb3MsIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuaXNCbG9jayAmJiBwb3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCArPSAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSBzdGFydDsgfVxuICAgICAgICB2YXIgdHIgPSB0aGlzLnZpZXcuc3RhdGUudHI7XG4gICAgICAgIHZhciBfYSA9IGdldE1kVG9FZGl0b3JQb3ModHIuZG9jLCBzdGFydCwgZW5kKSwgZnJvbSA9IF9hWzBdLCB0byA9IF9hWzFdO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIGZyb20sIHRvKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUucmVwbGFjZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBuZXdUcjtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCB0ciA9IF9hLnRyLCBzY2hlbWEgPSBfYS5zY2hlbWEsIGRvYyA9IF9hLmRvYztcbiAgICAgICAgdmFyIGxpbmVUZXh0cyA9IHRleHQuc3BsaXQocmVMaW5lRW5kaW5nJDIpO1xuICAgICAgICB2YXIgbm9kZXMgPSBsaW5lVGV4dHMubWFwKGZ1bmN0aW9uIChsaW5lVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhcmFncmFwaChzY2hlbWEsIGNyZWF0ZU5vZGVzV2l0aFdpZGdldChsaW5lVGV4dCwgc2NoZW1hKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2xpY2UgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShub2RlcyksIDEsIDEpO1xuICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IGdldE1kVG9FZGl0b3JQb3MoZG9jLCBzdGFydCwgZW5kKSwgZnJvbSA9IF9iWzBdLCB0byA9IF9iWzFdO1xuICAgICAgICAgICAgbmV3VHIgPSB0ci5yZXBsYWNlUmFuZ2UoZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1RyID0gdHIucmVwbGFjZVNlbGVjdGlvbihzbGljZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKG5ld1RyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmRlbGV0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBuZXdUcjtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCB0ciA9IF9hLnRyLCBkb2MgPSBfYS5kb2M7XG4gICAgICAgIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IGdldE1kVG9FZGl0b3JQb3MoZG9jLCBzdGFydCwgZW5kKSwgZnJvbSA9IF9iWzBdLCB0byA9IF9iWzFdO1xuICAgICAgICAgICAgbmV3VHIgPSB0ci5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdUciA9IHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaChuZXdUci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5nZXRTZWxlY3RlZFRleHQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIGRvYyA9IF9hLmRvYywgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICB2YXIgZnJvbSA9IHNlbGVjdGlvbi5mcm9tLCB0byA9IHNlbGVjdGlvbi50bztcbiAgICAgICAgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IGdldE1kVG9FZGl0b3JQb3MoZG9jLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIGZyb20gPSBwb3NbMF07XG4gICAgICAgICAgICB0byA9IHBvc1sxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jLnRleHRCZXR3ZWVuKGZyb20sIHRvLCAnXFxuJyk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLCBmcm9tID0gX2EuZnJvbSwgdG8gPSBfYS50bztcbiAgICAgICAgcmV0dXJuIGdldEVkaXRvclRvTWRQb3ModGhpcy52aWV3LnN0YXRlLnRyLmRvYywgZnJvbSwgdG8pO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLnNldE1hcmtkb3duID0gZnVuY3Rpb24gKG1hcmtkb3duLCBjdXJzb3JUb0VuZCkge1xuICAgICAgICBpZiAoY3Vyc29yVG9FbmQgPT09IHZvaWQgMCkgeyBjdXJzb3JUb0VuZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIGxpbmVUZXh0cyA9IG1hcmtkb3duLnNwbGl0KHJlTGluZUVuZGluZyQyKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCB0ciA9IF9hLnRyLCBkb2MgPSBfYS5kb2MsIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgdmFyIG5vZGVzID0gbGluZVRleHRzLm1hcChmdW5jdGlvbiAobGluZVRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQYXJhZ3JhcGgoc2NoZW1hLCBjcmVhdGVOb2Rlc1dpdGhXaWRnZXQobGluZVRleHQsIHNjaGVtYSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyLnJlcGxhY2VXaXRoKDAsIGRvYy5jb250ZW50LnNpemUsIG5vZGVzKSk7XG4gICAgICAgIGlmIChjdXJzb3JUb0VuZCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9FbmQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5hZGRXaWRnZXQgPSBmdW5jdGlvbiAobm9kZSwgc3R5bGUsIG1kUG9zKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgdHIgPSBfYS50ciwgZG9jID0gX2EuZG9jLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb247XG4gICAgICAgIHZhciBwb3MgPSBtZFBvcyA/IGdldE1kVG9FZGl0b3JQb3MoZG9jLCBtZFBvcywgbWRQb3MpWzBdIDogc2VsZWN0aW9uLnRvO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godHIuc2V0TWV0YSgnd2lkZ2V0JywgeyBwb3M6IHBvcywgbm9kZTogbm9kZSwgc3R5bGU6IHN0eWxlIH0pKTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5yZXBsYWNlV2l0aFdpZGdldCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB0ZXh0KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgdHIgPSBfYS50ciwgc2NoZW1hID0gX2Euc2NoZW1hLCBkb2MgPSBfYS5kb2M7XG4gICAgICAgIHZhciBwb3MgPSBnZXRNZFRvRWRpdG9yUG9zKGRvYywgc3RhcnQsIGVuZCk7XG4gICAgICAgIHZhciBub2RlcyA9IGNyZWF0ZU5vZGVzV2l0aFdpZGdldCh0ZXh0LCBzY2hlbWEpO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godHIucmVwbGFjZVdpdGgocG9zWzBdLCBwb3NbMV0sIG5vZGVzKSk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuZ2V0UmFuZ2VJbmZvT2ZOb2RlID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIGRvYyA9IF9hLmRvYywgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICB2YXIgbWRQb3MgPSBwb3MgfHwgZ2V0RWRpdG9yVG9NZFBvcyhkb2MsIHNlbGVjdGlvbi5mcm9tKVswXTtcbiAgICAgICAgdmFyIG1kTm9kZSA9IHRoaXMudG9hc3RNYXJrLmZpbmROb2RlQXRQb3NpdGlvbihtZFBvcyk7XG4gICAgICAgIGlmIChtZE5vZGUudHlwZSA9PT0gJ3RleHQnICYmIG1kTm9kZS5wYXJlbnQudHlwZSAhPT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgIG1kTm9kZSA9IG1kTm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIDEgc3luYyBmb3IgcHJvc2VtaXJyb3IgcG9zaXRpb25cbiAgICAgICAgbWROb2RlLnNvdXJjZXBvc1sxXVsxXSArPSAxO1xuICAgICAgICByZXR1cm4geyByYW5nZTogbWROb2RlLnNvdXJjZXBvcywgdHlwZTogbWROb2RlLnR5cGUgfTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5nZXRNYXJrZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9hc3RNYXJrXG4gICAgICAgICAgICAuZ2V0TGluZVRleHRzKClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGxpbmVUZXh0KSB7IHJldHVybiB1bndyYXBXaWRnZXRTeW50YXgobGluZVRleHQpOyB9KVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmdldFRvYXN0TWFyayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9hc3RNYXJrO1xuICAgIH07XG4gICAgcmV0dXJuIE1kRWRpdG9yO1xufShFZGl0b3JCYXNlKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBHZXQgZXZlbnQgY29sbGVjdGlvbiBmb3Igc3BlY2lmaWMgSFRNTCBlbGVtZW50XG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgRVZFTlRfS0VZID0gJ19mZUV2ZW50S2V5JztcblxuLyoqXG4gKiBHZXQgZXZlbnQgY29sbGVjdGlvbiBmb3Igc3BlY2lmaWMgSFRNTCBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gSFRNTCBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50IHR5cGVcbiAqIEByZXR1cm5zIHthcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhZmVFdmVudCQyKGVsZW1lbnQsIHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IGVsZW1lbnRbRVZFTlRfS0VZXTtcbiAgdmFyIGhhbmRsZXJzO1xuXG4gIGlmICghZXZlbnRzKSB7XG4gICAgZXZlbnRzID0gZWxlbWVudFtFVkVOVF9LRVldID0ge307XG4gIH1cblxuICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKCFoYW5kbGVycykge1xuICAgIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdID0gW107XG4gIH1cblxuICByZXR1cm4gaGFuZGxlcnM7XG59XG5cbnZhciBfc2FmZUV2ZW50ID0gc2FmZUV2ZW50JDI7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBVbmJpbmQgRE9NIGV2ZW50c1xuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGlzU3RyaW5nJDEgPSBpc1N0cmluZ18xO1xudmFyIGZvckVhY2gkMSA9IGZvckVhY2hfMTtcblxudmFyIHNhZmVFdmVudCQxID0gX3NhZmVFdmVudDtcblxuLyoqXG4gKiBVbmJpbmQgRE9NIGV2ZW50c1xuICogSWYgYSBoYW5kbGVyIGZ1bmN0aW9uIGlzIG5vdCBwYXNzZWQsIHJlbW92ZSBhbGwgZXZlbnRzIG9mIHRoYXQgdHlwZS5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIHVuYmluZCBldmVudHNcbiAqIEBwYXJhbSB7KHN0cmluZ3xvYmplY3QpfSB0eXBlcyAtIFNwYWNlIHNwbGl0dGVkIGV2ZW50cyBuYW1lcyBvciBldmVudE5hbWU6aGFuZGxlciBvYmplY3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtoYW5kbGVyXSAtIGhhbmRsZXIgZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tRXZlbnRcbiAqIEBleGFtcGxlXG4gKiAvLyBGb2xsb3dpbmcgdGhlIGV4YW1wbGUgb2YgZG9tRXZlbnQjb25cbiAqIFxuICogLy8gVW5iaW5kIG9uZSBldmVudCBmcm9tIGFuIGVsZW1lbnQuXG4gKiBvZmYoZGl2LCAnY2xpY2snLCB0b2dnbGUpO1xuICogXG4gKiAvLyBVbmJpbmQgbXVsdGlwbGUgZXZlbnRzIHdpdGggYSBzYW1lIGhhbmRsZXIgZnJvbSBtdWx0aXBsZSBlbGVtZW50cyBhdCBvbmNlLlxuICogLy8gVXNlIGV2ZW50IG5hbWVzIHNwbGl0dGVkIGJ5IGEgc3BhY2UuXG4gKiBvZmYoZWxlbWVudCwgJ21vdXNlZW50ZXIgbW91c2VsZWF2ZScsIGNoYW5nZUNvbG9yKTtcbiAqIFxuICogLy8gVW5iaW5kIG11bHRpcGxlIGV2ZW50cyB3aXRoIGRpZmZlcmVudCBoYW5kbGVycyBmcm9tIGFuIGVsZW1lbnQgYXQgb25jZS5cbiAqIC8vIFVzZSBhbiBvYmplY3Qgd2hpY2ggb2Yga2V5IGlzIGFuIGV2ZW50IG5hbWUgYW5kIHZhbHVlIGlzIGEgaGFuZGxlciBmdW5jdGlvbi5cbiAqIG9mZihkaXYsIHtcbiAqICAga2V5ZG93bjogaGlnaGxpZ2h0LFxuICogICBrZXl1cDogZGVoaWdobGlnaHRcbiAqIH0pO1xuICogXG4gKiAvLyBVbmJpbmQgZXZlbnRzIHdpdGhvdXQgaGFuZGxlcnMuXG4gKiBvZmYoZGl2LCAnZHJhZycpO1xuICovXG5mdW5jdGlvbiBvZmYoZWxlbWVudCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgaWYgKGlzU3RyaW5nJDEodHlwZXMpKSB7XG4gICAgZm9yRWFjaCQxKHR5cGVzLnNwbGl0KC9cXHMrL2cpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB1bmJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyKTtcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvckVhY2gkMSh0eXBlcywgZnVuY3Rpb24oZnVuYywgdHlwZSkge1xuICAgIHVuYmluZEV2ZW50KGVsZW1lbnQsIHR5cGUsIGZ1bmMpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBVbmJpbmQgRE9NIGV2ZW50c1xuICogSWYgYSBoYW5kbGVyIGZ1bmN0aW9uIGlzIG5vdCBwYXNzZWQsIHJlbW92ZSBhbGwgZXZlbnRzIG9mIHRoYXQgdHlwZS5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIHVuYmluZCBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnRzIG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtoYW5kbGVyXSAtIGhhbmRsZXIgZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVuYmluZEV2ZW50KGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgdmFyIGV2ZW50cyA9IHNhZmVFdmVudCQxKGVsZW1lbnQsIHR5cGUpO1xuICB2YXIgaW5kZXg7XG5cbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgZm9yRWFjaCQxKGV2ZW50cywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCB0eXBlLCBpdGVtLndyYXBwZWRIYW5kbGVyKTtcbiAgICB9KTtcbiAgICBldmVudHMuc3BsaWNlKDAsIGV2ZW50cy5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGZvckVhY2gkMShldmVudHMsIGZ1bmN0aW9uKGl0ZW0sIGlkeCkge1xuICAgICAgaWYgKGhhbmRsZXIgPT09IGl0ZW0uaGFuZGxlcikge1xuICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIHR5cGUsIGl0ZW0ud3JhcHBlZEhhbmRsZXIpO1xuICAgICAgICBpbmRleCA9IGlkeDtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBBbiBlbGVtZW50IHRvIHJlbW92ZSBhbiBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBldmVudCB0eXBlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gZXZlbnQgaGFuZGxlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gZWxlbWVudCkge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgfSBlbHNlIGlmICgnZGV0YWNoRXZlbnQnIGluIGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcbiAgfVxufVxuXG52YXIgb2ZmXzEgPSBvZmY7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBCaW5kIERPTSBldmVudHNcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBpc1N0cmluZyA9IGlzU3RyaW5nXzE7XG52YXIgZm9yRWFjaCA9IGZvckVhY2hfMTtcblxudmFyIHNhZmVFdmVudCA9IF9zYWZlRXZlbnQ7XG5cbi8qKlxuICogQmluZCBET00gZXZlbnRzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gYmluZCBldmVudHNcbiAqIEBwYXJhbSB7KHN0cmluZ3xvYmplY3QpfSB0eXBlcyAtIFNwYWNlIHNwbGl0dGVkIGV2ZW50cyBuYW1lcyBvciBldmVudE5hbWU6aGFuZGxlciBvYmplY3RcbiAqIEBwYXJhbSB7KGZ1bmN0aW9ufG9iamVjdCl9IGhhbmRsZXIgLSBoYW5kbGVyIGZ1bmN0aW9uIG9yIGNvbnRleHQgZm9yIGhhbmRsZXIgbWV0aG9kXG4gKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIGNvbnRleHQgLSBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZC5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tRXZlbnRcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBkaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdkaXYnKTtcbiAqIFxuICogLy8gQmluZCBvbmUgZXZlbnQgdG8gYW4gZWxlbWVudC5cbiAqIG9uKGRpdiwgJ2NsaWNrJywgdG9nZ2xlKTtcbiAqIFxuICogLy8gQmluZCBtdWx0aXBsZSBldmVudHMgd2l0aCBhIHNhbWUgaGFuZGxlciB0byBtdWx0aXBsZSBlbGVtZW50cyBhdCBvbmNlLlxuICogLy8gVXNlIGV2ZW50IG5hbWVzIHNwbGl0dGVkIGJ5IGEgc3BhY2UuXG4gKiBvbihkaXYsICdtb3VzZWVudGVyIG1vdXNlbGVhdmUnLCBjaGFuZ2VDb2xvcik7XG4gKiBcbiAqIC8vIEJpbmQgbXVsdGlwbGUgZXZlbnRzIHdpdGggZGlmZmVyZW50IGhhbmRsZXJzIHRvIGFuIGVsZW1lbnQgYXQgb25jZS5cbiAqIC8vIFVzZSBhbiBvYmplY3Qgd2hpY2ggb2Yga2V5IGlzIGFuIGV2ZW50IG5hbWUgYW5kIHZhbHVlIGlzIGEgaGFuZGxlciBmdW5jdGlvbi5cbiAqIG9uKGRpdiwge1xuICogICBrZXlkb3duOiBoaWdobGlnaHQsXG4gKiAgIGtleXVwOiBkZWhpZ2hsaWdodFxuICogfSk7XG4gKiBcbiAqIC8vIFNldCBhIGNvbnRleHQgZm9yIGhhbmRsZXIgbWV0aG9kLlxuICogY29uc3QgbmFtZSA9ICdnbG9iYWwnO1xuICogY29uc3QgcmVwb3NpdG9yeSA9IHtuYW1lOiAnQ29kZVNuaXBwZXQnfTtcbiAqIG9uKGRpdiwgJ2RyYWcnLCBmdW5jdGlvbigpIHtcbiAqICAgY29uc29sZS5sb2codGhpcy5uYW1lKTtcbiAqIH0sIHJlcG9zaXRvcnkpO1xuICogLy8gUmVzdWx0IHdoZW4geW91IGRyYWcgYSBkaXY6IFwiQ29kZVNuaXBwZXRcIlxuICovXG5mdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlcywgaGFuZGxlciwgY29udGV4dCkge1xuICBpZiAoaXNTdHJpbmcodHlwZXMpKSB7XG4gICAgZm9yRWFjaCh0eXBlcy5zcGxpdCgvXFxzKy9nKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgYmluZEV2ZW50KGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIGNvbnRleHQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yRWFjaCh0eXBlcywgZnVuY3Rpb24oZnVuYywgdHlwZSkge1xuICAgIGJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBmdW5jLCBoYW5kbGVyKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQmluZCBET00gZXZlbnRzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byBiaW5kIGV2ZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBldmVudHMgbmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIGhhbmRsZXIgZnVuY3Rpb24gb3IgY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2RcbiAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gY29udGV4dCAtIGNvbnRleHQgZm9yIGhhbmRsZXIgbWV0aG9kLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYmluZEV2ZW50KGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgLyoqXG4gICAgICogRXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgLSBldmVudCBvYmplY3RcbiAgICAgKi9cbiAgZnVuY3Rpb24gZXZlbnRIYW5kbGVyKGUpIHtcbiAgICBoYW5kbGVyLmNhbGwoY29udGV4dCB8fCBlbGVtZW50LCBlIHx8IHdpbmRvdy5ldmVudCk7XG4gIH1cblxuICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZXZlbnRIYW5kbGVyKTtcbiAgfSBlbHNlIGlmICgnYXR0YWNoRXZlbnQnIGluIGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBldmVudEhhbmRsZXIpO1xuICB9XG4gIG1lbW9yaXplSGFuZGxlcihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBldmVudEhhbmRsZXIpO1xufVxuXG4vKipcbiAqIE1lbW9yaXplIERPTSBldmVudCBoYW5kbGVyIGZvciB1bmJpbmRpbmcuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byBiaW5kIGV2ZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBldmVudHMgbmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIGhhbmRsZXIgZnVuY3Rpb24gdGhhdCB1c2VyIHBhc3NlZCBhdCBvbigpIHVzZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gd3JhcHBlZEhhbmRsZXIgLSBoYW5kbGVyIGZ1bmN0aW9uIHRoYXQgd3JhcHBlZCBieSBkb21ldmVudCBmb3IgaW1wbGVtZW50aW5nIHNvbWUgZmVhdHVyZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1lbW9yaXplSGFuZGxlcihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCB3cmFwcGVkSGFuZGxlcikge1xuICB2YXIgZXZlbnRzID0gc2FmZUV2ZW50KGVsZW1lbnQsIHR5cGUpO1xuICB2YXIgZXhpc3RJbkV2ZW50cyA9IGZhbHNlO1xuXG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgIGV4aXN0SW5FdmVudHMgPSB0cnVlO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIGlmICghZXhpc3RJbkV2ZW50cykge1xuICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICB3cmFwcGVkSGFuZGxlcjogd3JhcHBlZEhhbmRsZXJcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgb25fMSA9IG9uO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbnZhciBlbmNvZGVDYWNoZSA9IHt9O1xuXG5cbi8vIENyZWF0ZSBhIGxvb2t1cCBhcnJheSB3aGVyZSBhbnl0aGluZyBidXQgY2hhcmFjdGVycyBpbiBgY2hhcnNgIHN0cmluZ1xuLy8gYW5kIGFscGhhbnVtZXJpYyBjaGFycyBpcyBwZXJjZW50LWVuY29kZWQuXG4vL1xuZnVuY3Rpb24gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSkge1xuICB2YXIgaSwgY2gsIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV07XG4gIGlmIChjYWNoZSkgeyByZXR1cm4gY2FjaGU7IH1cblxuICBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IDEyODsgaSsrKSB7XG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuXG4gICAgaWYgKC9eWzAtOWEtel0kL2kudGVzdChjaCkpIHtcbiAgICAgIC8vIGFsd2F5cyBhbGxvdyB1bmVuY29kZWQgYWxwaGFudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgIGNhY2hlLnB1c2goY2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZS5wdXNoKCclJyArICgnMCcgKyBpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMikpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleGNsdWRlLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FjaGVbZXhjbHVkZS5jaGFyQ29kZUF0KGkpXSA9IGV4Y2x1ZGVbaV07XG4gIH1cblxuICByZXR1cm4gY2FjaGU7XG59XG5cblxuLy8gRW5jb2RlIHVuc2FmZSBjaGFyYWN0ZXJzIHdpdGggcGVyY2VudC1lbmNvZGluZywgc2tpcHBpbmcgYWxyZWFkeVxuLy8gZW5jb2RlZCBzZXF1ZW5jZXMuXG4vL1xuLy8gIC0gc3RyaW5nICAgICAgIC0gc3RyaW5nIHRvIGVuY29kZVxuLy8gIC0gZXhjbHVkZSAgICAgIC0gbGlzdCBvZiBjaGFyYWN0ZXJzIHRvIGlnbm9yZSAoaW4gYWRkaXRpb24gdG8gYS16QS1aMC05KVxuLy8gIC0ga2VlcEVzY2FwZWQgIC0gZG9uJ3QgZW5jb2RlICclJyBpbiBhIGNvcnJlY3QgZXNjYXBlIHNlcXVlbmNlIChkZWZhdWx0OiB0cnVlKVxuLy9cbmZ1bmN0aW9uIGVuY29kZSQxKHN0cmluZywgZXhjbHVkZSwga2VlcEVzY2FwZWQpIHtcbiAgdmFyIGksIGwsIGNvZGUsIG5leHRDb2RlLCBjYWNoZSxcbiAgICAgIHJlc3VsdCA9ICcnO1xuXG4gIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBlbmNvZGUoc3RyaW5nLCBrZWVwRXNjYXBlZClcbiAgICBrZWVwRXNjYXBlZCAgPSBleGNsdWRlO1xuICAgIGV4Y2x1ZGUgPSBlbmNvZGUkMS5kZWZhdWx0Q2hhcnM7XG4gIH1cblxuICBpZiAodHlwZW9mIGtlZXBFc2NhcGVkID09PSAndW5kZWZpbmVkJykge1xuICAgIGtlZXBFc2NhcGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGNhY2hlID0gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSk7XG5cbiAgZm9yIChpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoa2VlcEVzY2FwZWQgJiYgY29kZSA9PT0gMHgyNSAvKiAlICovICYmIGkgKyAyIDwgbCkge1xuICAgICAgaWYgKC9eWzAtOWEtZl17Mn0kL2kudGVzdChzdHJpbmcuc2xpY2UoaSArIDEsIGkgKyAzKSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IHN0cmluZy5zbGljZShpLCBpICsgMyk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPCAxMjgpIHtcbiAgICAgIHJlc3VsdCArPSBjYWNoZVtjb2RlXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REZGRikge1xuICAgICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhEQkZGICYmIGkgKyAxIDwgbCkge1xuICAgICAgICBuZXh0Q29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgaWYgKG5leHRDb2RlID49IDB4REMwMCAmJiBuZXh0Q29kZSA8PSAweERGRkYpIHtcbiAgICAgICAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSArIHN0cmluZ1tpICsgMV0pO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ICs9ICclRUYlQkYlQkQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZW5jb2RlJDEuZGVmYXVsdENoYXJzICAgPSBcIjsvPzpAJj0rJCwtXy4hfionKCkjXCI7XG5lbmNvZGUkMS5jb21wb25lbnRDaGFycyA9IFwiLV8uIX4qJygpXCI7XG5cblxudmFyIGVuY29kZV8xID0gZW5jb2RlJDE7XG5cbnZhciBsaWIgPSB7fTtcblxudmFyIGRlY29kZSA9IHt9O1xuXG52YXIgQWFjdXRlJDEgPSBcIsOBXCI7XG52YXIgYWFjdXRlJDEgPSBcIsOhXCI7XG52YXIgQWJyZXZlID0gXCLEglwiO1xudmFyIGFicmV2ZSA9IFwixINcIjtcbnZhciBhYyA9IFwi4oi+XCI7XG52YXIgYWNkID0gXCLiiL9cIjtcbnZhciBhY0UgPSBcIuKIvsyzXCI7XG52YXIgQWNpcmMkMSA9IFwiw4JcIjtcbnZhciBhY2lyYyQxID0gXCLDolwiO1xudmFyIGFjdXRlJDEgPSBcIsK0XCI7XG52YXIgQWN5ID0gXCLQkFwiO1xudmFyIGFjeSA9IFwi0LBcIjtcbnZhciBBRWxpZyQxID0gXCLDhlwiO1xudmFyIGFlbGlnJDEgPSBcIsOmXCI7XG52YXIgYWYgPSBcIuKBoVwiO1xudmFyIEFmciA9IFwi8J2UhFwiO1xudmFyIGFmciA9IFwi8J2UnlwiO1xudmFyIEFncmF2ZSQxID0gXCLDgFwiO1xudmFyIGFncmF2ZSQxID0gXCLDoFwiO1xudmFyIGFsZWZzeW0gPSBcIuKEtVwiO1xudmFyIGFsZXBoID0gXCLihLVcIjtcbnZhciBBbHBoYSA9IFwizpFcIjtcbnZhciBhbHBoYSA9IFwizrFcIjtcbnZhciBBbWFjciA9IFwixIBcIjtcbnZhciBhbWFjciA9IFwixIFcIjtcbnZhciBhbWFsZyA9IFwi4qi/XCI7XG52YXIgYW1wJDIgPSBcIiZcIjtcbnZhciBBTVAkMSA9IFwiJlwiO1xudmFyIGFuZGFuZCA9IFwi4qmVXCI7XG52YXIgQW5kID0gXCLiqZNcIjtcbnZhciBhbmQgPSBcIuKIp1wiO1xudmFyIGFuZGQgPSBcIuKpnFwiO1xudmFyIGFuZHNsb3BlID0gXCLiqZhcIjtcbnZhciBhbmR2ID0gXCLiqZpcIjtcbnZhciBhbmcgPSBcIuKIoFwiO1xudmFyIGFuZ2UgPSBcIuKmpFwiO1xudmFyIGFuZ2xlID0gXCLiiKBcIjtcbnZhciBhbmdtc2RhYSA9IFwi4qaoXCI7XG52YXIgYW5nbXNkYWIgPSBcIuKmqVwiO1xudmFyIGFuZ21zZGFjID0gXCLipqpcIjtcbnZhciBhbmdtc2RhZCA9IFwi4qarXCI7XG52YXIgYW5nbXNkYWUgPSBcIuKmrFwiO1xudmFyIGFuZ21zZGFmID0gXCLipq1cIjtcbnZhciBhbmdtc2RhZyA9IFwi4qauXCI7XG52YXIgYW5nbXNkYWggPSBcIuKmr1wiO1xudmFyIGFuZ21zZCA9IFwi4oihXCI7XG52YXIgYW5ncnQgPSBcIuKIn1wiO1xudmFyIGFuZ3J0dmIgPSBcIuKKvlwiO1xudmFyIGFuZ3J0dmJkID0gXCLipp1cIjtcbnZhciBhbmdzcGggPSBcIuKIolwiO1xudmFyIGFuZ3N0ID0gXCLDhVwiO1xudmFyIGFuZ3phcnIgPSBcIuKNvFwiO1xudmFyIEFvZ29uID0gXCLEhFwiO1xudmFyIGFvZ29uID0gXCLEhVwiO1xudmFyIEFvcGYgPSBcIvCdlLhcIjtcbnZhciBhb3BmID0gXCLwnZWSXCI7XG52YXIgYXBhY2lyID0gXCLiqa9cIjtcbnZhciBhcCA9IFwi4omIXCI7XG52YXIgYXBFID0gXCLiqbBcIjtcbnZhciBhcGUgPSBcIuKJilwiO1xudmFyIGFwaWQgPSBcIuKJi1wiO1xudmFyIGFwb3MkMSA9IFwiJ1wiO1xudmFyIEFwcGx5RnVuY3Rpb24gPSBcIuKBoVwiO1xudmFyIGFwcHJveCA9IFwi4omIXCI7XG52YXIgYXBwcm94ZXEgPSBcIuKJilwiO1xudmFyIEFyaW5nJDEgPSBcIsOFXCI7XG52YXIgYXJpbmckMSA9IFwiw6VcIjtcbnZhciBBc2NyID0gXCLwnZKcXCI7XG52YXIgYXNjciA9IFwi8J2StlwiO1xudmFyIEFzc2lnbiA9IFwi4omUXCI7XG52YXIgYXN0ID0gXCIqXCI7XG52YXIgYXN5bXAgPSBcIuKJiFwiO1xudmFyIGFzeW1wZXEgPSBcIuKJjVwiO1xudmFyIEF0aWxkZSQxID0gXCLDg1wiO1xudmFyIGF0aWxkZSQxID0gXCLDo1wiO1xudmFyIEF1bWwkMSA9IFwiw4RcIjtcbnZhciBhdW1sJDEgPSBcIsOkXCI7XG52YXIgYXdjb25pbnQgPSBcIuKIs1wiO1xudmFyIGF3aW50ID0gXCLiqJFcIjtcbnZhciBiYWNrY29uZyA9IFwi4omMXCI7XG52YXIgYmFja2Vwc2lsb24gPSBcIs+2XCI7XG52YXIgYmFja3ByaW1lID0gXCLigLVcIjtcbnZhciBiYWNrc2ltID0gXCLiiL1cIjtcbnZhciBiYWNrc2ltZXEgPSBcIuKLjVwiO1xudmFyIEJhY2tzbGFzaCA9IFwi4oiWXCI7XG52YXIgQmFydiA9IFwi4qunXCI7XG52YXIgYmFydmVlID0gXCLiir1cIjtcbnZhciBiYXJ3ZWQgPSBcIuKMhVwiO1xudmFyIEJhcndlZCA9IFwi4oyGXCI7XG52YXIgYmFyd2VkZ2UgPSBcIuKMhVwiO1xudmFyIGJicmsgPSBcIuKOtVwiO1xudmFyIGJicmt0YnJrID0gXCLijrZcIjtcbnZhciBiY29uZyA9IFwi4omMXCI7XG52YXIgQmN5ID0gXCLQkVwiO1xudmFyIGJjeSA9IFwi0LFcIjtcbnZhciBiZHF1byA9IFwi4oCeXCI7XG52YXIgYmVjYXVzID0gXCLiiLVcIjtcbnZhciBiZWNhdXNlID0gXCLiiLVcIjtcbnZhciBCZWNhdXNlID0gXCLiiLVcIjtcbnZhciBiZW1wdHl2ID0gXCLiprBcIjtcbnZhciBiZXBzaSA9IFwiz7ZcIjtcbnZhciBiZXJub3UgPSBcIuKErFwiO1xudmFyIEJlcm5vdWxsaXMgPSBcIuKErFwiO1xudmFyIEJldGEgPSBcIs6SXCI7XG52YXIgYmV0YSA9IFwizrJcIjtcbnZhciBiZXRoID0gXCLihLZcIjtcbnZhciBiZXR3ZWVuID0gXCLiiaxcIjtcbnZhciBCZnIgPSBcIvCdlIVcIjtcbnZhciBiZnIgPSBcIvCdlJ9cIjtcbnZhciBiaWdjYXAgPSBcIuKLglwiO1xudmFyIGJpZ2NpcmMgPSBcIuKXr1wiO1xudmFyIGJpZ2N1cCA9IFwi4ouDXCI7XG52YXIgYmlnb2RvdCA9IFwi4qiAXCI7XG52YXIgYmlnb3BsdXMgPSBcIuKogVwiO1xudmFyIGJpZ290aW1lcyA9IFwi4qiCXCI7XG52YXIgYmlnc3FjdXAgPSBcIuKohlwiO1xudmFyIGJpZ3N0YXIgPSBcIuKYhVwiO1xudmFyIGJpZ3RyaWFuZ2xlZG93biA9IFwi4pa9XCI7XG52YXIgYmlndHJpYW5nbGV1cCA9IFwi4pazXCI7XG52YXIgYmlndXBsdXMgPSBcIuKohFwiO1xudmFyIGJpZ3ZlZSA9IFwi4ouBXCI7XG52YXIgYmlnd2VkZ2UgPSBcIuKLgFwiO1xudmFyIGJrYXJvdyA9IFwi4qSNXCI7XG52YXIgYmxhY2tsb3plbmdlID0gXCLip6tcIjtcbnZhciBibGFja3NxdWFyZSA9IFwi4paqXCI7XG52YXIgYmxhY2t0cmlhbmdsZSA9IFwi4pa0XCI7XG52YXIgYmxhY2t0cmlhbmdsZWRvd24gPSBcIuKWvlwiO1xudmFyIGJsYWNrdHJpYW5nbGVsZWZ0ID0gXCLil4JcIjtcbnZhciBibGFja3RyaWFuZ2xlcmlnaHQgPSBcIuKWuFwiO1xudmFyIGJsYW5rID0gXCLikKNcIjtcbnZhciBibGsxMiA9IFwi4paSXCI7XG52YXIgYmxrMTQgPSBcIuKWkVwiO1xudmFyIGJsazM0ID0gXCLilpNcIjtcbnZhciBibG9jayA9IFwi4paIXCI7XG52YXIgYm5lID0gXCI94oOlXCI7XG52YXIgYm5lcXVpdiA9IFwi4omh4oOlXCI7XG52YXIgYk5vdCA9IFwi4qutXCI7XG52YXIgYm5vdCA9IFwi4oyQXCI7XG52YXIgQm9wZiA9IFwi8J2UuVwiO1xudmFyIGJvcGYgPSBcIvCdlZNcIjtcbnZhciBib3QgPSBcIuKKpVwiO1xudmFyIGJvdHRvbSA9IFwi4oqlXCI7XG52YXIgYm93dGllID0gXCLii4hcIjtcbnZhciBib3hib3ggPSBcIuKniVwiO1xudmFyIGJveGRsID0gXCLilJBcIjtcbnZhciBib3hkTCA9IFwi4pWVXCI7XG52YXIgYm94RGwgPSBcIuKVllwiO1xudmFyIGJveERMID0gXCLilZdcIjtcbnZhciBib3hkciA9IFwi4pSMXCI7XG52YXIgYm94ZFIgPSBcIuKVklwiO1xudmFyIGJveERyID0gXCLilZNcIjtcbnZhciBib3hEUiA9IFwi4pWUXCI7XG52YXIgYm94aCA9IFwi4pSAXCI7XG52YXIgYm94SCA9IFwi4pWQXCI7XG52YXIgYm94aGQgPSBcIuKUrFwiO1xudmFyIGJveEhkID0gXCLilaRcIjtcbnZhciBib3hoRCA9IFwi4pWlXCI7XG52YXIgYm94SEQgPSBcIuKVplwiO1xudmFyIGJveGh1ID0gXCLilLRcIjtcbnZhciBib3hIdSA9IFwi4pWnXCI7XG52YXIgYm94aFUgPSBcIuKVqFwiO1xudmFyIGJveEhVID0gXCLilalcIjtcbnZhciBib3htaW51cyA9IFwi4oqfXCI7XG52YXIgYm94cGx1cyA9IFwi4oqeXCI7XG52YXIgYm94dGltZXMgPSBcIuKKoFwiO1xudmFyIGJveHVsID0gXCLilJhcIjtcbnZhciBib3h1TCA9IFwi4pWbXCI7XG52YXIgYm94VWwgPSBcIuKVnFwiO1xudmFyIGJveFVMID0gXCLilZ1cIjtcbnZhciBib3h1ciA9IFwi4pSUXCI7XG52YXIgYm94dVIgPSBcIuKVmFwiO1xudmFyIGJveFVyID0gXCLilZlcIjtcbnZhciBib3hVUiA9IFwi4pWaXCI7XG52YXIgYm94diA9IFwi4pSCXCI7XG52YXIgYm94ViA9IFwi4pWRXCI7XG52YXIgYm94dmggPSBcIuKUvFwiO1xudmFyIGJveHZIID0gXCLilapcIjtcbnZhciBib3hWaCA9IFwi4pWrXCI7XG52YXIgYm94VkggPSBcIuKVrFwiO1xudmFyIGJveHZsID0gXCLilKRcIjtcbnZhciBib3h2TCA9IFwi4pWhXCI7XG52YXIgYm94VmwgPSBcIuKVolwiO1xudmFyIGJveFZMID0gXCLilaNcIjtcbnZhciBib3h2ciA9IFwi4pScXCI7XG52YXIgYm94dlIgPSBcIuKVnlwiO1xudmFyIGJveFZyID0gXCLilZ9cIjtcbnZhciBib3hWUiA9IFwi4pWgXCI7XG52YXIgYnByaW1lID0gXCLigLVcIjtcbnZhciBicmV2ZSA9IFwiy5hcIjtcbnZhciBCcmV2ZSA9IFwiy5hcIjtcbnZhciBicnZiYXIkMSA9IFwiwqZcIjtcbnZhciBic2NyID0gXCLwnZK3XCI7XG52YXIgQnNjciA9IFwi4oSsXCI7XG52YXIgYnNlbWkgPSBcIuKBj1wiO1xudmFyIGJzaW0gPSBcIuKIvVwiO1xudmFyIGJzaW1lID0gXCLii41cIjtcbnZhciBic29sYiA9IFwi4qeFXCI7XG52YXIgYnNvbCA9IFwiXFxcXFwiO1xudmFyIGJzb2xoc3ViID0gXCLin4hcIjtcbnZhciBidWxsID0gXCLigKJcIjtcbnZhciBidWxsZXQgPSBcIuKAolwiO1xudmFyIGJ1bXAgPSBcIuKJjlwiO1xudmFyIGJ1bXBFID0gXCLiqq5cIjtcbnZhciBidW1wZSA9IFwi4omPXCI7XG52YXIgQnVtcGVxID0gXCLiiY5cIjtcbnZhciBidW1wZXEgPSBcIuKJj1wiO1xudmFyIENhY3V0ZSA9IFwixIZcIjtcbnZhciBjYWN1dGUgPSBcIsSHXCI7XG52YXIgY2FwYW5kID0gXCLiqYRcIjtcbnZhciBjYXBicmN1cCA9IFwi4qmJXCI7XG52YXIgY2FwY2FwID0gXCLiqYtcIjtcbnZhciBjYXAgPSBcIuKIqVwiO1xudmFyIENhcCA9IFwi4ouSXCI7XG52YXIgY2FwY3VwID0gXCLiqYdcIjtcbnZhciBjYXBkb3QgPSBcIuKpgFwiO1xudmFyIENhcGl0YWxEaWZmZXJlbnRpYWxEID0gXCLihYVcIjtcbnZhciBjYXBzID0gXCLiiKnvuIBcIjtcbnZhciBjYXJldCA9IFwi4oGBXCI7XG52YXIgY2Fyb24gPSBcIsuHXCI7XG52YXIgQ2F5bGV5cyA9IFwi4oStXCI7XG52YXIgY2NhcHMgPSBcIuKpjVwiO1xudmFyIENjYXJvbiA9IFwixIxcIjtcbnZhciBjY2Fyb24gPSBcIsSNXCI7XG52YXIgQ2NlZGlsJDEgPSBcIsOHXCI7XG52YXIgY2NlZGlsJDEgPSBcIsOnXCI7XG52YXIgQ2NpcmMgPSBcIsSIXCI7XG52YXIgY2NpcmMgPSBcIsSJXCI7XG52YXIgQ2NvbmludCA9IFwi4oiwXCI7XG52YXIgY2N1cHMgPSBcIuKpjFwiO1xudmFyIGNjdXBzc20gPSBcIuKpkFwiO1xudmFyIENkb3QgPSBcIsSKXCI7XG52YXIgY2RvdCA9IFwixItcIjtcbnZhciBjZWRpbCQxID0gXCLCuFwiO1xudmFyIENlZGlsbGEgPSBcIsK4XCI7XG52YXIgY2VtcHR5diA9IFwi4qayXCI7XG52YXIgY2VudCQxID0gXCLColwiO1xudmFyIGNlbnRlcmRvdCA9IFwiwrdcIjtcbnZhciBDZW50ZXJEb3QgPSBcIsK3XCI7XG52YXIgY2ZyID0gXCLwnZSgXCI7XG52YXIgQ2ZyID0gXCLihK1cIjtcbnZhciBDSGN5ID0gXCLQp1wiO1xudmFyIGNoY3kgPSBcItGHXCI7XG52YXIgY2hlY2sgPSBcIuKck1wiO1xudmFyIGNoZWNrbWFyayA9IFwi4pyTXCI7XG52YXIgQ2hpID0gXCLOp1wiO1xudmFyIGNoaSA9IFwiz4dcIjtcbnZhciBjaXJjID0gXCLLhlwiO1xudmFyIGNpcmNlcSA9IFwi4omXXCI7XG52YXIgY2lyY2xlYXJyb3dsZWZ0ID0gXCLihrpcIjtcbnZhciBjaXJjbGVhcnJvd3JpZ2h0ID0gXCLihrtcIjtcbnZhciBjaXJjbGVkYXN0ID0gXCLiiptcIjtcbnZhciBjaXJjbGVkY2lyYyA9IFwi4oqaXCI7XG52YXIgY2lyY2xlZGRhc2ggPSBcIuKKnVwiO1xudmFyIENpcmNsZURvdCA9IFwi4oqZXCI7XG52YXIgY2lyY2xlZFIgPSBcIsKuXCI7XG52YXIgY2lyY2xlZFMgPSBcIuKTiFwiO1xudmFyIENpcmNsZU1pbnVzID0gXCLiipZcIjtcbnZhciBDaXJjbGVQbHVzID0gXCLiipVcIjtcbnZhciBDaXJjbGVUaW1lcyA9IFwi4oqXXCI7XG52YXIgY2lyID0gXCLil4tcIjtcbnZhciBjaXJFID0gXCLip4NcIjtcbnZhciBjaXJlID0gXCLiiZdcIjtcbnZhciBjaXJmbmludCA9IFwi4qiQXCI7XG52YXIgY2lybWlkID0gXCLiq69cIjtcbnZhciBjaXJzY2lyID0gXCLip4JcIjtcbnZhciBDbG9ja3dpc2VDb250b3VySW50ZWdyYWwgPSBcIuKIslwiO1xudmFyIENsb3NlQ3VybHlEb3VibGVRdW90ZSA9IFwi4oCdXCI7XG52YXIgQ2xvc2VDdXJseVF1b3RlID0gXCLigJlcIjtcbnZhciBjbHVicyA9IFwi4pmjXCI7XG52YXIgY2x1YnN1aXQgPSBcIuKZo1wiO1xudmFyIGNvbG9uID0gXCI6XCI7XG52YXIgQ29sb24gPSBcIuKIt1wiO1xudmFyIENvbG9uZSA9IFwi4qm0XCI7XG52YXIgY29sb25lID0gXCLiiZRcIjtcbnZhciBjb2xvbmVxID0gXCLiiZRcIjtcbnZhciBjb21tYSA9IFwiLFwiO1xudmFyIGNvbW1hdCA9IFwiQFwiO1xudmFyIGNvbXAgPSBcIuKIgVwiO1xudmFyIGNvbXBmbiA9IFwi4oiYXCI7XG52YXIgY29tcGxlbWVudCA9IFwi4oiBXCI7XG52YXIgY29tcGxleGVzID0gXCLihIJcIjtcbnZhciBjb25nID0gXCLiiYVcIjtcbnZhciBjb25nZG90ID0gXCLiqa1cIjtcbnZhciBDb25ncnVlbnQgPSBcIuKJoVwiO1xudmFyIGNvbmludCA9IFwi4oiuXCI7XG52YXIgQ29uaW50ID0gXCLiiK9cIjtcbnZhciBDb250b3VySW50ZWdyYWwgPSBcIuKIrlwiO1xudmFyIGNvcGYgPSBcIvCdlZRcIjtcbnZhciBDb3BmID0gXCLihIJcIjtcbnZhciBjb3Byb2QgPSBcIuKIkFwiO1xudmFyIENvcHJvZHVjdCA9IFwi4oiQXCI7XG52YXIgY29weSQxID0gXCLCqVwiO1xudmFyIENPUFkkMSA9IFwiwqlcIjtcbnZhciBjb3B5c3IgPSBcIuKEl1wiO1xudmFyIENvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwgPSBcIuKIs1wiO1xudmFyIGNyYXJyID0gXCLihrVcIjtcbnZhciBjcm9zcyA9IFwi4pyXXCI7XG52YXIgQ3Jvc3MgPSBcIuKor1wiO1xudmFyIENzY3IgPSBcIvCdkp5cIjtcbnZhciBjc2NyID0gXCLwnZK4XCI7XG52YXIgY3N1YiA9IFwi4quPXCI7XG52YXIgY3N1YmUgPSBcIuKrkVwiO1xudmFyIGNzdXAgPSBcIuKrkFwiO1xudmFyIGNzdXBlID0gXCLiq5JcIjtcbnZhciBjdGRvdCA9IFwi4ouvXCI7XG52YXIgY3VkYXJybCA9IFwi4qS4XCI7XG52YXIgY3VkYXJyciA9IFwi4qS1XCI7XG52YXIgY3VlcHIgPSBcIuKLnlwiO1xudmFyIGN1ZXNjID0gXCLii59cIjtcbnZhciBjdWxhcnIgPSBcIuKGtlwiO1xudmFyIGN1bGFycnAgPSBcIuKkvVwiO1xudmFyIGN1cGJyY2FwID0gXCLiqYhcIjtcbnZhciBjdXBjYXAgPSBcIuKphlwiO1xudmFyIEN1cENhcCA9IFwi4omNXCI7XG52YXIgY3VwID0gXCLiiKpcIjtcbnZhciBDdXAgPSBcIuKLk1wiO1xudmFyIGN1cGN1cCA9IFwi4qmKXCI7XG52YXIgY3VwZG90ID0gXCLiio1cIjtcbnZhciBjdXBvciA9IFwi4qmFXCI7XG52YXIgY3VwcyA9IFwi4oiq77iAXCI7XG52YXIgY3VyYXJyID0gXCLihrdcIjtcbnZhciBjdXJhcnJtID0gXCLipLxcIjtcbnZhciBjdXJseWVxcHJlYyA9IFwi4oueXCI7XG52YXIgY3VybHllcXN1Y2MgPSBcIuKLn1wiO1xudmFyIGN1cmx5dmVlID0gXCLii45cIjtcbnZhciBjdXJseXdlZGdlID0gXCLii49cIjtcbnZhciBjdXJyZW4kMSA9IFwiwqRcIjtcbnZhciBjdXJ2ZWFycm93bGVmdCA9IFwi4oa2XCI7XG52YXIgY3VydmVhcnJvd3JpZ2h0ID0gXCLihrdcIjtcbnZhciBjdXZlZSA9IFwi4ouOXCI7XG52YXIgY3V3ZWQgPSBcIuKLj1wiO1xudmFyIGN3Y29uaW50ID0gXCLiiLJcIjtcbnZhciBjd2ludCA9IFwi4oixXCI7XG52YXIgY3lsY3R5ID0gXCLijK1cIjtcbnZhciBkYWdnZXIgPSBcIuKAoFwiO1xudmFyIERhZ2dlciA9IFwi4oChXCI7XG52YXIgZGFsZXRoID0gXCLihLhcIjtcbnZhciBkYXJyID0gXCLihpNcIjtcbnZhciBEYXJyID0gXCLihqFcIjtcbnZhciBkQXJyID0gXCLih5NcIjtcbnZhciBkYXNoID0gXCLigJBcIjtcbnZhciBEYXNodiA9IFwi4qukXCI7XG52YXIgZGFzaHYgPSBcIuKKo1wiO1xudmFyIGRia2Fyb3cgPSBcIuKkj1wiO1xudmFyIGRibGFjID0gXCLLnVwiO1xudmFyIERjYXJvbiA9IFwixI5cIjtcbnZhciBkY2Fyb24gPSBcIsSPXCI7XG52YXIgRGN5ID0gXCLQlFwiO1xudmFyIGRjeSA9IFwi0LRcIjtcbnZhciBkZGFnZ2VyID0gXCLigKFcIjtcbnZhciBkZGFyciA9IFwi4oeKXCI7XG52YXIgREQgPSBcIuKFhVwiO1xudmFyIGRkID0gXCLihYZcIjtcbnZhciBERG90cmFoZCA9IFwi4qSRXCI7XG52YXIgZGRvdHNlcSA9IFwi4qm3XCI7XG52YXIgZGVnJDEgPSBcIsKwXCI7XG52YXIgRGVsID0gXCLiiIdcIjtcbnZhciBEZWx0YSA9IFwizpRcIjtcbnZhciBkZWx0YSA9IFwizrRcIjtcbnZhciBkZW1wdHl2ID0gXCLiprFcIjtcbnZhciBkZmlzaHQgPSBcIuKlv1wiO1xudmFyIERmciA9IFwi8J2Uh1wiO1xudmFyIGRmciA9IFwi8J2UoVwiO1xudmFyIGRIYXIgPSBcIuKlpVwiO1xudmFyIGRoYXJsID0gXCLih4NcIjtcbnZhciBkaGFyciA9IFwi4oeCXCI7XG52YXIgRGlhY3JpdGljYWxBY3V0ZSA9IFwiwrRcIjtcbnZhciBEaWFjcml0aWNhbERvdCA9IFwiy5lcIjtcbnZhciBEaWFjcml0aWNhbERvdWJsZUFjdXRlID0gXCLLnVwiO1xudmFyIERpYWNyaXRpY2FsR3JhdmUgPSBcImBcIjtcbnZhciBEaWFjcml0aWNhbFRpbGRlID0gXCLLnFwiO1xudmFyIGRpYW0gPSBcIuKLhFwiO1xudmFyIGRpYW1vbmQgPSBcIuKLhFwiO1xudmFyIERpYW1vbmQgPSBcIuKLhFwiO1xudmFyIGRpYW1vbmRzdWl0ID0gXCLimaZcIjtcbnZhciBkaWFtcyA9IFwi4pmmXCI7XG52YXIgZGllID0gXCLCqFwiO1xudmFyIERpZmZlcmVudGlhbEQgPSBcIuKFhlwiO1xudmFyIGRpZ2FtbWEgPSBcIs+dXCI7XG52YXIgZGlzaW4gPSBcIuKLslwiO1xudmFyIGRpdiA9IFwiw7dcIjtcbnZhciBkaXZpZGUkMSA9IFwiw7dcIjtcbnZhciBkaXZpZGVvbnRpbWVzID0gXCLii4dcIjtcbnZhciBkaXZvbnggPSBcIuKLh1wiO1xudmFyIERKY3kgPSBcItCCXCI7XG52YXIgZGpjeSA9IFwi0ZJcIjtcbnZhciBkbGNvcm4gPSBcIuKMnlwiO1xudmFyIGRsY3JvcCA9IFwi4oyNXCI7XG52YXIgZG9sbGFyID0gXCIkXCI7XG52YXIgRG9wZiA9IFwi8J2Uu1wiO1xudmFyIGRvcGYgPSBcIvCdlZVcIjtcbnZhciBEb3QgPSBcIsKoXCI7XG52YXIgZG90ID0gXCLLmVwiO1xudmFyIERvdERvdCA9IFwi4oOcXCI7XG52YXIgZG90ZXEgPSBcIuKJkFwiO1xudmFyIGRvdGVxZG90ID0gXCLiiZFcIjtcbnZhciBEb3RFcXVhbCA9IFwi4omQXCI7XG52YXIgZG90bWludXMgPSBcIuKIuFwiO1xudmFyIGRvdHBsdXMgPSBcIuKIlFwiO1xudmFyIGRvdHNxdWFyZSA9IFwi4oqhXCI7XG52YXIgZG91YmxlYmFyd2VkZ2UgPSBcIuKMhlwiO1xudmFyIERvdWJsZUNvbnRvdXJJbnRlZ3JhbCA9IFwi4oivXCI7XG52YXIgRG91YmxlRG90ID0gXCLCqFwiO1xudmFyIERvdWJsZURvd25BcnJvdyA9IFwi4oeTXCI7XG52YXIgRG91YmxlTGVmdEFycm93ID0gXCLih5BcIjtcbnZhciBEb3VibGVMZWZ0UmlnaHRBcnJvdyA9IFwi4oeUXCI7XG52YXIgRG91YmxlTGVmdFRlZSA9IFwi4qukXCI7XG52YXIgRG91YmxlTG9uZ0xlZnRBcnJvdyA9IFwi4p+4XCI7XG52YXIgRG91YmxlTG9uZ0xlZnRSaWdodEFycm93ID0gXCLin7pcIjtcbnZhciBEb3VibGVMb25nUmlnaHRBcnJvdyA9IFwi4p+5XCI7XG52YXIgRG91YmxlUmlnaHRBcnJvdyA9IFwi4oeSXCI7XG52YXIgRG91YmxlUmlnaHRUZWUgPSBcIuKKqFwiO1xudmFyIERvdWJsZVVwQXJyb3cgPSBcIuKHkVwiO1xudmFyIERvdWJsZVVwRG93bkFycm93ID0gXCLih5VcIjtcbnZhciBEb3VibGVWZXJ0aWNhbEJhciA9IFwi4oilXCI7XG52YXIgRG93bkFycm93QmFyID0gXCLipJNcIjtcbnZhciBkb3duYXJyb3cgPSBcIuKGk1wiO1xudmFyIERvd25BcnJvdyA9IFwi4oaTXCI7XG52YXIgRG93bmFycm93ID0gXCLih5NcIjtcbnZhciBEb3duQXJyb3dVcEFycm93ID0gXCLih7VcIjtcbnZhciBEb3duQnJldmUgPSBcIsyRXCI7XG52YXIgZG93bmRvd25hcnJvd3MgPSBcIuKHilwiO1xudmFyIGRvd25oYXJwb29ubGVmdCA9IFwi4oeDXCI7XG52YXIgZG93bmhhcnBvb25yaWdodCA9IFwi4oeCXCI7XG52YXIgRG93bkxlZnRSaWdodFZlY3RvciA9IFwi4qWQXCI7XG52YXIgRG93bkxlZnRUZWVWZWN0b3IgPSBcIuKlnlwiO1xudmFyIERvd25MZWZ0VmVjdG9yQmFyID0gXCLipZZcIjtcbnZhciBEb3duTGVmdFZlY3RvciA9IFwi4oa9XCI7XG52YXIgRG93blJpZ2h0VGVlVmVjdG9yID0gXCLipZ9cIjtcbnZhciBEb3duUmlnaHRWZWN0b3JCYXIgPSBcIuKll1wiO1xudmFyIERvd25SaWdodFZlY3RvciA9IFwi4oeBXCI7XG52YXIgRG93blRlZUFycm93ID0gXCLihqdcIjtcbnZhciBEb3duVGVlID0gXCLiiqRcIjtcbnZhciBkcmJrYXJvdyA9IFwi4qSQXCI7XG52YXIgZHJjb3JuID0gXCLijJ9cIjtcbnZhciBkcmNyb3AgPSBcIuKMjFwiO1xudmFyIERzY3IgPSBcIvCdkp9cIjtcbnZhciBkc2NyID0gXCLwnZK5XCI7XG52YXIgRFNjeSA9IFwi0IVcIjtcbnZhciBkc2N5ID0gXCLRlVwiO1xudmFyIGRzb2wgPSBcIuKntlwiO1xudmFyIERzdHJvayA9IFwixJBcIjtcbnZhciBkc3Ryb2sgPSBcIsSRXCI7XG52YXIgZHRkb3QgPSBcIuKLsVwiO1xudmFyIGR0cmkgPSBcIuKWv1wiO1xudmFyIGR0cmlmID0gXCLilr5cIjtcbnZhciBkdWFyciA9IFwi4oe1XCI7XG52YXIgZHVoYXIgPSBcIuKlr1wiO1xudmFyIGR3YW5nbGUgPSBcIuKmplwiO1xudmFyIERaY3kgPSBcItCPXCI7XG52YXIgZHpjeSA9IFwi0Z9cIjtcbnZhciBkemlncmFyciA9IFwi4p+/XCI7XG52YXIgRWFjdXRlJDEgPSBcIsOJXCI7XG52YXIgZWFjdXRlJDEgPSBcIsOpXCI7XG52YXIgZWFzdGVyID0gXCLiqa5cIjtcbnZhciBFY2Fyb24gPSBcIsSaXCI7XG52YXIgZWNhcm9uID0gXCLEm1wiO1xudmFyIEVjaXJjJDEgPSBcIsOKXCI7XG52YXIgZWNpcmMkMSA9IFwiw6pcIjtcbnZhciBlY2lyID0gXCLiiZZcIjtcbnZhciBlY29sb24gPSBcIuKJlVwiO1xudmFyIEVjeSA9IFwi0K1cIjtcbnZhciBlY3kgPSBcItGNXCI7XG52YXIgZUREb3QgPSBcIuKpt1wiO1xudmFyIEVkb3QgPSBcIsSWXCI7XG52YXIgZWRvdCA9IFwixJdcIjtcbnZhciBlRG90ID0gXCLiiZFcIjtcbnZhciBlZSA9IFwi4oWHXCI7XG52YXIgZWZEb3QgPSBcIuKJklwiO1xudmFyIEVmciA9IFwi8J2UiFwiO1xudmFyIGVmciA9IFwi8J2UolwiO1xudmFyIGVnID0gXCLiqppcIjtcbnZhciBFZ3JhdmUkMSA9IFwiw4hcIjtcbnZhciBlZ3JhdmUkMSA9IFwiw6hcIjtcbnZhciBlZ3MgPSBcIuKqllwiO1xudmFyIGVnc2RvdCA9IFwi4qqYXCI7XG52YXIgZWwgPSBcIuKqmVwiO1xudmFyIEVsZW1lbnQkMSA9IFwi4oiIXCI7XG52YXIgZWxpbnRlcnMgPSBcIuKPp1wiO1xudmFyIGVsbCA9IFwi4oSTXCI7XG52YXIgZWxzID0gXCLiqpVcIjtcbnZhciBlbHNkb3QgPSBcIuKql1wiO1xudmFyIEVtYWNyID0gXCLEklwiO1xudmFyIGVtYWNyID0gXCLEk1wiO1xudmFyIGVtcHR5ID0gXCLiiIVcIjtcbnZhciBlbXB0eXNldCA9IFwi4oiFXCI7XG52YXIgRW1wdHlTbWFsbFNxdWFyZSA9IFwi4pe7XCI7XG52YXIgZW1wdHl2ID0gXCLiiIVcIjtcbnZhciBFbXB0eVZlcnlTbWFsbFNxdWFyZSA9IFwi4parXCI7XG52YXIgZW1zcDEzID0gXCLigIRcIjtcbnZhciBlbXNwMTQgPSBcIuKAhVwiO1xudmFyIGVtc3AgPSBcIuKAg1wiO1xudmFyIEVORyA9IFwixYpcIjtcbnZhciBlbmcgPSBcIsWLXCI7XG52YXIgZW5zcCA9IFwi4oCCXCI7XG52YXIgRW9nb24gPSBcIsSYXCI7XG52YXIgZW9nb24gPSBcIsSZXCI7XG52YXIgRW9wZiA9IFwi8J2UvFwiO1xudmFyIGVvcGYgPSBcIvCdlZZcIjtcbnZhciBlcGFyID0gXCLii5VcIjtcbnZhciBlcGFyc2wgPSBcIuKno1wiO1xudmFyIGVwbHVzID0gXCLiqbFcIjtcbnZhciBlcHNpID0gXCLOtVwiO1xudmFyIEVwc2lsb24gPSBcIs6VXCI7XG52YXIgZXBzaWxvbiA9IFwizrVcIjtcbnZhciBlcHNpdiA9IFwiz7VcIjtcbnZhciBlcWNpcmMgPSBcIuKJllwiO1xudmFyIGVxY29sb24gPSBcIuKJlVwiO1xudmFyIGVxc2ltID0gXCLiiYJcIjtcbnZhciBlcXNsYW50Z3RyID0gXCLiqpZcIjtcbnZhciBlcXNsYW50bGVzcyA9IFwi4qqVXCI7XG52YXIgRXF1YWwgPSBcIuKptVwiO1xudmFyIGVxdWFscyA9IFwiPVwiO1xudmFyIEVxdWFsVGlsZGUgPSBcIuKJglwiO1xudmFyIGVxdWVzdCA9IFwi4omfXCI7XG52YXIgRXF1aWxpYnJpdW0gPSBcIuKHjFwiO1xudmFyIGVxdWl2ID0gXCLiiaFcIjtcbnZhciBlcXVpdkREID0gXCLiqbhcIjtcbnZhciBlcXZwYXJzbCA9IFwi4qelXCI7XG52YXIgZXJhcnIgPSBcIuKlsVwiO1xudmFyIGVyRG90ID0gXCLiiZNcIjtcbnZhciBlc2NyID0gXCLihK9cIjtcbnZhciBFc2NyID0gXCLihLBcIjtcbnZhciBlc2RvdCA9IFwi4omQXCI7XG52YXIgRXNpbSA9IFwi4qmzXCI7XG52YXIgZXNpbSA9IFwi4omCXCI7XG52YXIgRXRhID0gXCLOl1wiO1xudmFyIGV0YSA9IFwizrdcIjtcbnZhciBFVEgkMSA9IFwiw5BcIjtcbnZhciBldGgkMSA9IFwiw7BcIjtcbnZhciBFdW1sJDEgPSBcIsOLXCI7XG52YXIgZXVtbCQxID0gXCLDq1wiO1xudmFyIGV1cm8gPSBcIuKCrFwiO1xudmFyIGV4Y2wgPSBcIiFcIjtcbnZhciBleGlzdCA9IFwi4oiDXCI7XG52YXIgRXhpc3RzID0gXCLiiINcIjtcbnZhciBleHBlY3RhdGlvbiA9IFwi4oSwXCI7XG52YXIgZXhwb25lbnRpYWxlID0gXCLihYdcIjtcbnZhciBFeHBvbmVudGlhbEUgPSBcIuKFh1wiO1xudmFyIGZhbGxpbmdkb3RzZXEgPSBcIuKJklwiO1xudmFyIEZjeSA9IFwi0KRcIjtcbnZhciBmY3kgPSBcItGEXCI7XG52YXIgZmVtYWxlID0gXCLimYBcIjtcbnZhciBmZmlsaWcgPSBcIu+sg1wiO1xudmFyIGZmbGlnID0gXCLvrIBcIjtcbnZhciBmZmxsaWcgPSBcIu+shFwiO1xudmFyIEZmciA9IFwi8J2UiVwiO1xudmFyIGZmciA9IFwi8J2Uo1wiO1xudmFyIGZpbGlnID0gXCLvrIFcIjtcbnZhciBGaWxsZWRTbWFsbFNxdWFyZSA9IFwi4pe8XCI7XG52YXIgRmlsbGVkVmVyeVNtYWxsU3F1YXJlID0gXCLilqpcIjtcbnZhciBmamxpZyA9IFwiZmpcIjtcbnZhciBmbGF0ID0gXCLima1cIjtcbnZhciBmbGxpZyA9IFwi76yCXCI7XG52YXIgZmx0bnMgPSBcIuKWsVwiO1xudmFyIGZub2YgPSBcIsaSXCI7XG52YXIgRm9wZiA9IFwi8J2UvVwiO1xudmFyIGZvcGYgPSBcIvCdlZdcIjtcbnZhciBmb3JhbGwgPSBcIuKIgFwiO1xudmFyIEZvckFsbCA9IFwi4oiAXCI7XG52YXIgZm9yayA9IFwi4ouUXCI7XG52YXIgZm9ya3YgPSBcIuKrmVwiO1xudmFyIEZvdXJpZXJ0cmYgPSBcIuKEsVwiO1xudmFyIGZwYXJ0aW50ID0gXCLiqI1cIjtcbnZhciBmcmFjMTIkMSA9IFwiwr1cIjtcbnZhciBmcmFjMTMgPSBcIuKFk1wiO1xudmFyIGZyYWMxNCQxID0gXCLCvFwiO1xudmFyIGZyYWMxNSA9IFwi4oWVXCI7XG52YXIgZnJhYzE2ID0gXCLihZlcIjtcbnZhciBmcmFjMTggPSBcIuKFm1wiO1xudmFyIGZyYWMyMyA9IFwi4oWUXCI7XG52YXIgZnJhYzI1ID0gXCLihZZcIjtcbnZhciBmcmFjMzQkMSA9IFwiwr5cIjtcbnZhciBmcmFjMzUgPSBcIuKFl1wiO1xudmFyIGZyYWMzOCA9IFwi4oWcXCI7XG52YXIgZnJhYzQ1ID0gXCLihZhcIjtcbnZhciBmcmFjNTYgPSBcIuKFmlwiO1xudmFyIGZyYWM1OCA9IFwi4oWdXCI7XG52YXIgZnJhYzc4ID0gXCLihZ5cIjtcbnZhciBmcmFzbCA9IFwi4oGEXCI7XG52YXIgZnJvd24gPSBcIuKMolwiO1xudmFyIGZzY3IgPSBcIvCdkrtcIjtcbnZhciBGc2NyID0gXCLihLFcIjtcbnZhciBnYWN1dGUgPSBcIse1XCI7XG52YXIgR2FtbWEgPSBcIs6TXCI7XG52YXIgZ2FtbWEgPSBcIs6zXCI7XG52YXIgR2FtbWFkID0gXCLPnFwiO1xudmFyIGdhbW1hZCA9IFwiz51cIjtcbnZhciBnYXAgPSBcIuKqhlwiO1xudmFyIEdicmV2ZSA9IFwixJ5cIjtcbnZhciBnYnJldmUgPSBcIsSfXCI7XG52YXIgR2NlZGlsID0gXCLEolwiO1xudmFyIEdjaXJjID0gXCLEnFwiO1xudmFyIGdjaXJjID0gXCLEnVwiO1xudmFyIEdjeSA9IFwi0JNcIjtcbnZhciBnY3kgPSBcItCzXCI7XG52YXIgR2RvdCA9IFwixKBcIjtcbnZhciBnZG90ID0gXCLEoVwiO1xudmFyIGdlID0gXCLiiaVcIjtcbnZhciBnRSA9IFwi4omnXCI7XG52YXIgZ0VsID0gXCLiqoxcIjtcbnZhciBnZWwgPSBcIuKLm1wiO1xudmFyIGdlcSA9IFwi4omlXCI7XG52YXIgZ2VxcSA9IFwi4omnXCI7XG52YXIgZ2Vxc2xhbnQgPSBcIuKpvlwiO1xudmFyIGdlc2NjID0gXCLiqqlcIjtcbnZhciBnZXMgPSBcIuKpvlwiO1xudmFyIGdlc2RvdCA9IFwi4qqAXCI7XG52YXIgZ2VzZG90byA9IFwi4qqCXCI7XG52YXIgZ2VzZG90b2wgPSBcIuKqhFwiO1xudmFyIGdlc2wgPSBcIuKLm++4gFwiO1xudmFyIGdlc2xlcyA9IFwi4qqUXCI7XG52YXIgR2ZyID0gXCLwnZSKXCI7XG52YXIgZ2ZyID0gXCLwnZSkXCI7XG52YXIgZ2cgPSBcIuKJq1wiO1xudmFyIEdnID0gXCLii5lcIjtcbnZhciBnZ2cgPSBcIuKLmVwiO1xudmFyIGdpbWVsID0gXCLihLdcIjtcbnZhciBHSmN5ID0gXCLQg1wiO1xudmFyIGdqY3kgPSBcItGTXCI7XG52YXIgZ2xhID0gXCLiqqVcIjtcbnZhciBnbCA9IFwi4om3XCI7XG52YXIgZ2xFID0gXCLiqpJcIjtcbnZhciBnbGogPSBcIuKqpFwiO1xudmFyIGduYXAgPSBcIuKqilwiO1xudmFyIGduYXBwcm94ID0gXCLiqopcIjtcbnZhciBnbmUgPSBcIuKqiFwiO1xudmFyIGduRSA9IFwi4ompXCI7XG52YXIgZ25lcSA9IFwi4qqIXCI7XG52YXIgZ25lcXEgPSBcIuKJqVwiO1xudmFyIGduc2ltID0gXCLii6dcIjtcbnZhciBHb3BmID0gXCLwnZS+XCI7XG52YXIgZ29wZiA9IFwi8J2VmFwiO1xudmFyIGdyYXZlID0gXCJgXCI7XG52YXIgR3JlYXRlckVxdWFsID0gXCLiiaVcIjtcbnZhciBHcmVhdGVyRXF1YWxMZXNzID0gXCLii5tcIjtcbnZhciBHcmVhdGVyRnVsbEVxdWFsID0gXCLiiadcIjtcbnZhciBHcmVhdGVyR3JlYXRlciA9IFwi4qqiXCI7XG52YXIgR3JlYXRlckxlc3MgPSBcIuKJt1wiO1xudmFyIEdyZWF0ZXJTbGFudEVxdWFsID0gXCLiqb5cIjtcbnZhciBHcmVhdGVyVGlsZGUgPSBcIuKJs1wiO1xudmFyIEdzY3IgPSBcIvCdkqJcIjtcbnZhciBnc2NyID0gXCLihIpcIjtcbnZhciBnc2ltID0gXCLiibNcIjtcbnZhciBnc2ltZSA9IFwi4qqOXCI7XG52YXIgZ3NpbWwgPSBcIuKqkFwiO1xudmFyIGd0Y2MgPSBcIuKqp1wiO1xudmFyIGd0Y2lyID0gXCLiqbpcIjtcbnZhciBndCQyID0gXCI+XCI7XG52YXIgR1QkMSA9IFwiPlwiO1xudmFyIEd0ID0gXCLiiatcIjtcbnZhciBndGRvdCA9IFwi4ouXXCI7XG52YXIgZ3RsUGFyID0gXCLippVcIjtcbnZhciBndHF1ZXN0ID0gXCLiqbxcIjtcbnZhciBndHJhcHByb3ggPSBcIuKqhlwiO1xudmFyIGd0cmFyciA9IFwi4qW4XCI7XG52YXIgZ3RyZG90ID0gXCLii5dcIjtcbnZhciBndHJlcWxlc3MgPSBcIuKLm1wiO1xudmFyIGd0cmVxcWxlc3MgPSBcIuKqjFwiO1xudmFyIGd0cmxlc3MgPSBcIuKJt1wiO1xudmFyIGd0cnNpbSA9IFwi4omzXCI7XG52YXIgZ3ZlcnRuZXFxID0gXCLiianvuIBcIjtcbnZhciBndm5FID0gXCLiianvuIBcIjtcbnZhciBIYWNlayA9IFwiy4dcIjtcbnZhciBoYWlyc3AgPSBcIuKAilwiO1xudmFyIGhhbGYgPSBcIsK9XCI7XG52YXIgaGFtaWx0ID0gXCLihItcIjtcbnZhciBIQVJEY3kgPSBcItCqXCI7XG52YXIgaGFyZGN5ID0gXCLRilwiO1xudmFyIGhhcnJjaXIgPSBcIuKliFwiO1xudmFyIGhhcnIgPSBcIuKGlFwiO1xudmFyIGhBcnIgPSBcIuKHlFwiO1xudmFyIGhhcnJ3ID0gXCLihq1cIjtcbnZhciBIYXQgPSBcIl5cIjtcbnZhciBoYmFyID0gXCLihI9cIjtcbnZhciBIY2lyYyA9IFwixKRcIjtcbnZhciBoY2lyYyA9IFwixKVcIjtcbnZhciBoZWFydHMgPSBcIuKZpVwiO1xudmFyIGhlYXJ0c3VpdCA9IFwi4pmlXCI7XG52YXIgaGVsbGlwID0gXCLigKZcIjtcbnZhciBoZXJjb24gPSBcIuKKuVwiO1xudmFyIGhmciA9IFwi8J2UpVwiO1xudmFyIEhmciA9IFwi4oSMXCI7XG52YXIgSGlsYmVydFNwYWNlID0gXCLihItcIjtcbnZhciBoa3NlYXJvdyA9IFwi4qSlXCI7XG52YXIgaGtzd2Fyb3cgPSBcIuKkplwiO1xudmFyIGhvYXJyID0gXCLih79cIjtcbnZhciBob210aHQgPSBcIuKIu1wiO1xudmFyIGhvb2tsZWZ0YXJyb3cgPSBcIuKGqVwiO1xudmFyIGhvb2tyaWdodGFycm93ID0gXCLihqpcIjtcbnZhciBob3BmID0gXCLwnZWZXCI7XG52YXIgSG9wZiA9IFwi4oSNXCI7XG52YXIgaG9yYmFyID0gXCLigJVcIjtcbnZhciBIb3Jpem9udGFsTGluZSA9IFwi4pSAXCI7XG52YXIgaHNjciA9IFwi8J2SvVwiO1xudmFyIEhzY3IgPSBcIuKEi1wiO1xudmFyIGhzbGFzaCA9IFwi4oSPXCI7XG52YXIgSHN0cm9rID0gXCLEplwiO1xudmFyIGhzdHJvayA9IFwixKdcIjtcbnZhciBIdW1wRG93bkh1bXAgPSBcIuKJjlwiO1xudmFyIEh1bXBFcXVhbCA9IFwi4omPXCI7XG52YXIgaHlidWxsID0gXCLigYNcIjtcbnZhciBoeXBoZW4gPSBcIuKAkFwiO1xudmFyIElhY3V0ZSQxID0gXCLDjVwiO1xudmFyIGlhY3V0ZSQxID0gXCLDrVwiO1xudmFyIGljID0gXCLigaNcIjtcbnZhciBJY2lyYyQxID0gXCLDjlwiO1xudmFyIGljaXJjJDEgPSBcIsOuXCI7XG52YXIgSWN5ID0gXCLQmFwiO1xudmFyIGljeSA9IFwi0LhcIjtcbnZhciBJZG90ID0gXCLEsFwiO1xudmFyIElFY3kgPSBcItCVXCI7XG52YXIgaWVjeSA9IFwi0LVcIjtcbnZhciBpZXhjbCQxID0gXCLCoVwiO1xudmFyIGlmZiA9IFwi4oeUXCI7XG52YXIgaWZyID0gXCLwnZSmXCI7XG52YXIgSWZyID0gXCLihJFcIjtcbnZhciBJZ3JhdmUkMSA9IFwiw4xcIjtcbnZhciBpZ3JhdmUkMSA9IFwiw6xcIjtcbnZhciBpaSA9IFwi4oWIXCI7XG52YXIgaWlpaW50ID0gXCLiqIxcIjtcbnZhciBpaWludCA9IFwi4oitXCI7XG52YXIgaWluZmluID0gXCLip5xcIjtcbnZhciBpaW90YSA9IFwi4oSpXCI7XG52YXIgSUpsaWcgPSBcIsSyXCI7XG52YXIgaWpsaWcgPSBcIsSzXCI7XG52YXIgSW1hY3IgPSBcIsSqXCI7XG52YXIgaW1hY3IgPSBcIsSrXCI7XG52YXIgaW1hZ2UgPSBcIuKEkVwiO1xudmFyIEltYWdpbmFyeUkgPSBcIuKFiFwiO1xudmFyIGltYWdsaW5lID0gXCLihJBcIjtcbnZhciBpbWFncGFydCA9IFwi4oSRXCI7XG52YXIgaW1hdGggPSBcIsSxXCI7XG52YXIgSW0gPSBcIuKEkVwiO1xudmFyIGltb2YgPSBcIuKKt1wiO1xudmFyIGltcGVkID0gXCLGtVwiO1xudmFyIEltcGxpZXMgPSBcIuKHklwiO1xudmFyIGluY2FyZSA9IFwi4oSFXCI7XG52YXIgaW5maW4gPSBcIuKInlwiO1xudmFyIGluZmludGllID0gXCLip51cIjtcbnZhciBpbm9kb3QgPSBcIsSxXCI7XG52YXIgaW50Y2FsID0gXCLiirpcIjtcbnZhciBpbnQgPSBcIuKIq1wiO1xudmFyIEludCA9IFwi4oisXCI7XG52YXIgaW50ZWdlcnMgPSBcIuKEpFwiO1xudmFyIEludGVncmFsID0gXCLiiKtcIjtcbnZhciBpbnRlcmNhbCA9IFwi4oq6XCI7XG52YXIgSW50ZXJzZWN0aW9uID0gXCLii4JcIjtcbnZhciBpbnRsYXJoayA9IFwi4qiXXCI7XG52YXIgaW50cHJvZCA9IFwi4qi8XCI7XG52YXIgSW52aXNpYmxlQ29tbWEgPSBcIuKBo1wiO1xudmFyIEludmlzaWJsZVRpbWVzID0gXCLigaJcIjtcbnZhciBJT2N5ID0gXCLQgVwiO1xudmFyIGlvY3kgPSBcItGRXCI7XG52YXIgSW9nb24gPSBcIsSuXCI7XG52YXIgaW9nb24gPSBcIsSvXCI7XG52YXIgSW9wZiA9IFwi8J2VgFwiO1xudmFyIGlvcGYgPSBcIvCdlZpcIjtcbnZhciBJb3RhID0gXCLOmVwiO1xudmFyIGlvdGEgPSBcIs65XCI7XG52YXIgaXByb2QgPSBcIuKovFwiO1xudmFyIGlxdWVzdCQxID0gXCLCv1wiO1xudmFyIGlzY3IgPSBcIvCdkr5cIjtcbnZhciBJc2NyID0gXCLihJBcIjtcbnZhciBpc2luID0gXCLiiIhcIjtcbnZhciBpc2luZG90ID0gXCLii7VcIjtcbnZhciBpc2luRSA9IFwi4ou5XCI7XG52YXIgaXNpbnMgPSBcIuKLtFwiO1xudmFyIGlzaW5zdiA9IFwi4ouzXCI7XG52YXIgaXNpbnYgPSBcIuKIiFwiO1xudmFyIGl0ID0gXCLigaJcIjtcbnZhciBJdGlsZGUgPSBcIsSoXCI7XG52YXIgaXRpbGRlID0gXCLEqVwiO1xudmFyIEl1a2N5ID0gXCLQhlwiO1xudmFyIGl1a2N5ID0gXCLRllwiO1xudmFyIEl1bWwkMSA9IFwiw49cIjtcbnZhciBpdW1sJDEgPSBcIsOvXCI7XG52YXIgSmNpcmMgPSBcIsS0XCI7XG52YXIgamNpcmMgPSBcIsS1XCI7XG52YXIgSmN5ID0gXCLQmVwiO1xudmFyIGpjeSA9IFwi0LlcIjtcbnZhciBKZnIgPSBcIvCdlI1cIjtcbnZhciBqZnIgPSBcIvCdlKdcIjtcbnZhciBqbWF0aCA9IFwiyLdcIjtcbnZhciBKb3BmID0gXCLwnZWBXCI7XG52YXIgam9wZiA9IFwi8J2Vm1wiO1xudmFyIEpzY3IgPSBcIvCdkqVcIjtcbnZhciBqc2NyID0gXCLwnZK/XCI7XG52YXIgSnNlcmN5ID0gXCLQiFwiO1xudmFyIGpzZXJjeSA9IFwi0ZhcIjtcbnZhciBKdWtjeSA9IFwi0IRcIjtcbnZhciBqdWtjeSA9IFwi0ZRcIjtcbnZhciBLYXBwYSA9IFwizppcIjtcbnZhciBrYXBwYSA9IFwizrpcIjtcbnZhciBrYXBwYXYgPSBcIs+wXCI7XG52YXIgS2NlZGlsID0gXCLEtlwiO1xudmFyIGtjZWRpbCA9IFwixLdcIjtcbnZhciBLY3kgPSBcItCaXCI7XG52YXIga2N5ID0gXCLQulwiO1xudmFyIEtmciA9IFwi8J2UjlwiO1xudmFyIGtmciA9IFwi8J2UqFwiO1xudmFyIGtncmVlbiA9IFwixLhcIjtcbnZhciBLSGN5ID0gXCLQpVwiO1xudmFyIGtoY3kgPSBcItGFXCI7XG52YXIgS0pjeSA9IFwi0IxcIjtcbnZhciBramN5ID0gXCLRnFwiO1xudmFyIEtvcGYgPSBcIvCdlYJcIjtcbnZhciBrb3BmID0gXCLwnZWcXCI7XG52YXIgS3NjciA9IFwi8J2SplwiO1xudmFyIGtzY3IgPSBcIvCdk4BcIjtcbnZhciBsQWFyciA9IFwi4oeaXCI7XG52YXIgTGFjdXRlID0gXCLEuVwiO1xudmFyIGxhY3V0ZSA9IFwixLpcIjtcbnZhciBsYWVtcHR5diA9IFwi4qa0XCI7XG52YXIgbGFncmFuID0gXCLihJJcIjtcbnZhciBMYW1iZGEgPSBcIs6bXCI7XG52YXIgbGFtYmRhID0gXCLOu1wiO1xudmFyIGxhbmcgPSBcIuKfqFwiO1xudmFyIExhbmcgPSBcIuKfqlwiO1xudmFyIGxhbmdkID0gXCLippFcIjtcbnZhciBsYW5nbGUgPSBcIuKfqFwiO1xudmFyIGxhcCA9IFwi4qqFXCI7XG52YXIgTGFwbGFjZXRyZiA9IFwi4oSSXCI7XG52YXIgbGFxdW8kMSA9IFwiwqtcIjtcbnZhciBsYXJyYiA9IFwi4oekXCI7XG52YXIgbGFycmJmcyA9IFwi4qSfXCI7XG52YXIgbGFyciA9IFwi4oaQXCI7XG52YXIgTGFyciA9IFwi4oaeXCI7XG52YXIgbEFyciA9IFwi4oeQXCI7XG52YXIgbGFycmZzID0gXCLipJ1cIjtcbnZhciBsYXJyaGsgPSBcIuKGqVwiO1xudmFyIGxhcnJscCA9IFwi4oarXCI7XG52YXIgbGFycnBsID0gXCLipLlcIjtcbnZhciBsYXJyc2ltID0gXCLipbNcIjtcbnZhciBsYXJydGwgPSBcIuKGolwiO1xudmFyIGxhdGFpbCA9IFwi4qSZXCI7XG52YXIgbEF0YWlsID0gXCLipJtcIjtcbnZhciBsYXQgPSBcIuKqq1wiO1xudmFyIGxhdGUgPSBcIuKqrVwiO1xudmFyIGxhdGVzID0gXCLiqq3vuIBcIjtcbnZhciBsYmFyciA9IFwi4qSMXCI7XG52YXIgbEJhcnIgPSBcIuKkjlwiO1xudmFyIGxiYnJrID0gXCLinbJcIjtcbnZhciBsYnJhY2UgPSBcIntcIjtcbnZhciBsYnJhY2sgPSBcIltcIjtcbnZhciBsYnJrZSA9IFwi4qaLXCI7XG52YXIgbGJya3NsZCA9IFwi4qaPXCI7XG52YXIgbGJya3NsdSA9IFwi4qaNXCI7XG52YXIgTGNhcm9uID0gXCLEvVwiO1xudmFyIGxjYXJvbiA9IFwixL5cIjtcbnZhciBMY2VkaWwgPSBcIsS7XCI7XG52YXIgbGNlZGlsID0gXCLEvFwiO1xudmFyIGxjZWlsID0gXCLijIhcIjtcbnZhciBsY3ViID0gXCJ7XCI7XG52YXIgTGN5ID0gXCLQm1wiO1xudmFyIGxjeSA9IFwi0LtcIjtcbnZhciBsZGNhID0gXCLipLZcIjtcbnZhciBsZHF1byA9IFwi4oCcXCI7XG52YXIgbGRxdW9yID0gXCLigJ5cIjtcbnZhciBsZHJkaGFyID0gXCLipadcIjtcbnZhciBsZHJ1c2hhciA9IFwi4qWLXCI7XG52YXIgbGRzaCA9IFwi4oayXCI7XG52YXIgbGUgPSBcIuKJpFwiO1xudmFyIGxFID0gXCLiiaZcIjtcbnZhciBMZWZ0QW5nbGVCcmFja2V0ID0gXCLin6hcIjtcbnZhciBMZWZ0QXJyb3dCYXIgPSBcIuKHpFwiO1xudmFyIGxlZnRhcnJvdyA9IFwi4oaQXCI7XG52YXIgTGVmdEFycm93ID0gXCLihpBcIjtcbnZhciBMZWZ0YXJyb3cgPSBcIuKHkFwiO1xudmFyIExlZnRBcnJvd1JpZ2h0QXJyb3cgPSBcIuKHhlwiO1xudmFyIGxlZnRhcnJvd3RhaWwgPSBcIuKGolwiO1xudmFyIExlZnRDZWlsaW5nID0gXCLijIhcIjtcbnZhciBMZWZ0RG91YmxlQnJhY2tldCA9IFwi4p+mXCI7XG52YXIgTGVmdERvd25UZWVWZWN0b3IgPSBcIuKloVwiO1xudmFyIExlZnREb3duVmVjdG9yQmFyID0gXCLipZlcIjtcbnZhciBMZWZ0RG93blZlY3RvciA9IFwi4oeDXCI7XG52YXIgTGVmdEZsb29yID0gXCLijIpcIjtcbnZhciBsZWZ0aGFycG9vbmRvd24gPSBcIuKGvVwiO1xudmFyIGxlZnRoYXJwb29udXAgPSBcIuKGvFwiO1xudmFyIGxlZnRsZWZ0YXJyb3dzID0gXCLih4dcIjtcbnZhciBsZWZ0cmlnaHRhcnJvdyA9IFwi4oaUXCI7XG52YXIgTGVmdFJpZ2h0QXJyb3cgPSBcIuKGlFwiO1xudmFyIExlZnRyaWdodGFycm93ID0gXCLih5RcIjtcbnZhciBsZWZ0cmlnaHRhcnJvd3MgPSBcIuKHhlwiO1xudmFyIGxlZnRyaWdodGhhcnBvb25zID0gXCLih4tcIjtcbnZhciBsZWZ0cmlnaHRzcXVpZ2Fycm93ID0gXCLihq1cIjtcbnZhciBMZWZ0UmlnaHRWZWN0b3IgPSBcIuKljlwiO1xudmFyIExlZnRUZWVBcnJvdyA9IFwi4oakXCI7XG52YXIgTGVmdFRlZSA9IFwi4oqjXCI7XG52YXIgTGVmdFRlZVZlY3RvciA9IFwi4qWaXCI7XG52YXIgbGVmdHRocmVldGltZXMgPSBcIuKLi1wiO1xudmFyIExlZnRUcmlhbmdsZUJhciA9IFwi4qePXCI7XG52YXIgTGVmdFRyaWFuZ2xlID0gXCLiirJcIjtcbnZhciBMZWZ0VHJpYW5nbGVFcXVhbCA9IFwi4oq0XCI7XG52YXIgTGVmdFVwRG93blZlY3RvciA9IFwi4qWRXCI7XG52YXIgTGVmdFVwVGVlVmVjdG9yID0gXCLipaBcIjtcbnZhciBMZWZ0VXBWZWN0b3JCYXIgPSBcIuKlmFwiO1xudmFyIExlZnRVcFZlY3RvciA9IFwi4oa/XCI7XG52YXIgTGVmdFZlY3RvckJhciA9IFwi4qWSXCI7XG52YXIgTGVmdFZlY3RvciA9IFwi4oa8XCI7XG52YXIgbEVnID0gXCLiqotcIjtcbnZhciBsZWcgPSBcIuKLmlwiO1xudmFyIGxlcSA9IFwi4omkXCI7XG52YXIgbGVxcSA9IFwi4ommXCI7XG52YXIgbGVxc2xhbnQgPSBcIuKpvVwiO1xudmFyIGxlc2NjID0gXCLiqqhcIjtcbnZhciBsZXMgPSBcIuKpvVwiO1xudmFyIGxlc2RvdCA9IFwi4qm/XCI7XG52YXIgbGVzZG90byA9IFwi4qqBXCI7XG52YXIgbGVzZG90b3IgPSBcIuKqg1wiO1xudmFyIGxlc2cgPSBcIuKLmu+4gFwiO1xudmFyIGxlc2dlcyA9IFwi4qqTXCI7XG52YXIgbGVzc2FwcHJveCA9IFwi4qqFXCI7XG52YXIgbGVzc2RvdCA9IFwi4ouWXCI7XG52YXIgbGVzc2VxZ3RyID0gXCLii5pcIjtcbnZhciBsZXNzZXFxZ3RyID0gXCLiqotcIjtcbnZhciBMZXNzRXF1YWxHcmVhdGVyID0gXCLii5pcIjtcbnZhciBMZXNzRnVsbEVxdWFsID0gXCLiiaZcIjtcbnZhciBMZXNzR3JlYXRlciA9IFwi4om2XCI7XG52YXIgbGVzc2d0ciA9IFwi4om2XCI7XG52YXIgTGVzc0xlc3MgPSBcIuKqoVwiO1xudmFyIGxlc3NzaW0gPSBcIuKJslwiO1xudmFyIExlc3NTbGFudEVxdWFsID0gXCLiqb1cIjtcbnZhciBMZXNzVGlsZGUgPSBcIuKJslwiO1xudmFyIGxmaXNodCA9IFwi4qW8XCI7XG52YXIgbGZsb29yID0gXCLijIpcIjtcbnZhciBMZnIgPSBcIvCdlI9cIjtcbnZhciBsZnIgPSBcIvCdlKlcIjtcbnZhciBsZyA9IFwi4om2XCI7XG52YXIgbGdFID0gXCLiqpFcIjtcbnZhciBsSGFyID0gXCLipaJcIjtcbnZhciBsaGFyZCA9IFwi4oa9XCI7XG52YXIgbGhhcnUgPSBcIuKGvFwiO1xudmFyIGxoYXJ1bCA9IFwi4qWqXCI7XG52YXIgbGhibGsgPSBcIuKWhFwiO1xudmFyIExKY3kgPSBcItCJXCI7XG52YXIgbGpjeSA9IFwi0ZlcIjtcbnZhciBsbGFyciA9IFwi4oeHXCI7XG52YXIgbGwgPSBcIuKJqlwiO1xudmFyIExsID0gXCLii5hcIjtcbnZhciBsbGNvcm5lciA9IFwi4oyeXCI7XG52YXIgTGxlZnRhcnJvdyA9IFwi4oeaXCI7XG52YXIgbGxoYXJkID0gXCLipatcIjtcbnZhciBsbHRyaSA9IFwi4pe6XCI7XG52YXIgTG1pZG90ID0gXCLEv1wiO1xudmFyIGxtaWRvdCA9IFwixYBcIjtcbnZhciBsbW91c3RhY2hlID0gXCLijrBcIjtcbnZhciBsbW91c3QgPSBcIuKOsFwiO1xudmFyIGxuYXAgPSBcIuKqiVwiO1xudmFyIGxuYXBwcm94ID0gXCLiqolcIjtcbnZhciBsbmUgPSBcIuKqh1wiO1xudmFyIGxuRSA9IFwi4omoXCI7XG52YXIgbG5lcSA9IFwi4qqHXCI7XG52YXIgbG5lcXEgPSBcIuKJqFwiO1xudmFyIGxuc2ltID0gXCLii6ZcIjtcbnZhciBsb2FuZyA9IFwi4p+sXCI7XG52YXIgbG9hcnIgPSBcIuKHvVwiO1xudmFyIGxvYnJrID0gXCLin6ZcIjtcbnZhciBsb25nbGVmdGFycm93ID0gXCLin7VcIjtcbnZhciBMb25nTGVmdEFycm93ID0gXCLin7VcIjtcbnZhciBMb25nbGVmdGFycm93ID0gXCLin7hcIjtcbnZhciBsb25nbGVmdHJpZ2h0YXJyb3cgPSBcIuKft1wiO1xudmFyIExvbmdMZWZ0UmlnaHRBcnJvdyA9IFwi4p+3XCI7XG52YXIgTG9uZ2xlZnRyaWdodGFycm93ID0gXCLin7pcIjtcbnZhciBsb25nbWFwc3RvID0gXCLin7xcIjtcbnZhciBsb25ncmlnaHRhcnJvdyA9IFwi4p+2XCI7XG52YXIgTG9uZ1JpZ2h0QXJyb3cgPSBcIuKftlwiO1xudmFyIExvbmdyaWdodGFycm93ID0gXCLin7lcIjtcbnZhciBsb29wYXJyb3dsZWZ0ID0gXCLihqtcIjtcbnZhciBsb29wYXJyb3dyaWdodCA9IFwi4oasXCI7XG52YXIgbG9wYXIgPSBcIuKmhVwiO1xudmFyIExvcGYgPSBcIvCdlYNcIjtcbnZhciBsb3BmID0gXCLwnZWdXCI7XG52YXIgbG9wbHVzID0gXCLiqK1cIjtcbnZhciBsb3RpbWVzID0gXCLiqLRcIjtcbnZhciBsb3dhc3QgPSBcIuKIl1wiO1xudmFyIGxvd2JhciA9IFwiX1wiO1xudmFyIExvd2VyTGVmdEFycm93ID0gXCLihplcIjtcbnZhciBMb3dlclJpZ2h0QXJyb3cgPSBcIuKGmFwiO1xudmFyIGxveiA9IFwi4peKXCI7XG52YXIgbG96ZW5nZSA9IFwi4peKXCI7XG52YXIgbG96ZiA9IFwi4qerXCI7XG52YXIgbHBhciA9IFwiKFwiO1xudmFyIGxwYXJsdCA9IFwi4qaTXCI7XG52YXIgbHJhcnIgPSBcIuKHhlwiO1xudmFyIGxyY29ybmVyID0gXCLijJ9cIjtcbnZhciBscmhhciA9IFwi4oeLXCI7XG52YXIgbHJoYXJkID0gXCLipa1cIjtcbnZhciBscm0gPSBcIuKAjlwiO1xudmFyIGxydHJpID0gXCLiir9cIjtcbnZhciBsc2FxdW8gPSBcIuKAuVwiO1xudmFyIGxzY3IgPSBcIvCdk4FcIjtcbnZhciBMc2NyID0gXCLihJJcIjtcbnZhciBsc2ggPSBcIuKGsFwiO1xudmFyIExzaCA9IFwi4oawXCI7XG52YXIgbHNpbSA9IFwi4omyXCI7XG52YXIgbHNpbWUgPSBcIuKqjVwiO1xudmFyIGxzaW1nID0gXCLiqo9cIjtcbnZhciBsc3FiID0gXCJbXCI7XG52YXIgbHNxdW8gPSBcIuKAmFwiO1xudmFyIGxzcXVvciA9IFwi4oCaXCI7XG52YXIgTHN0cm9rID0gXCLFgVwiO1xudmFyIGxzdHJvayA9IFwixYJcIjtcbnZhciBsdGNjID0gXCLiqqZcIjtcbnZhciBsdGNpciA9IFwi4qm5XCI7XG52YXIgbHQkMiA9IFwiPFwiO1xudmFyIExUJDEgPSBcIjxcIjtcbnZhciBMdCA9IFwi4omqXCI7XG52YXIgbHRkb3QgPSBcIuKLllwiO1xudmFyIGx0aHJlZSA9IFwi4ouLXCI7XG52YXIgbHRpbWVzID0gXCLii4lcIjtcbnZhciBsdGxhcnIgPSBcIuKltlwiO1xudmFyIGx0cXVlc3QgPSBcIuKpu1wiO1xudmFyIGx0cmkgPSBcIuKXg1wiO1xudmFyIGx0cmllID0gXCLiirRcIjtcbnZhciBsdHJpZiA9IFwi4peCXCI7XG52YXIgbHRyUGFyID0gXCLippZcIjtcbnZhciBsdXJkc2hhciA9IFwi4qWKXCI7XG52YXIgbHVydWhhciA9IFwi4qWmXCI7XG52YXIgbHZlcnRuZXFxID0gXCLiiajvuIBcIjtcbnZhciBsdm5FID0gXCLiiajvuIBcIjtcbnZhciBtYWNyJDEgPSBcIsKvXCI7XG52YXIgbWFsZSA9IFwi4pmCXCI7XG52YXIgbWFsdCA9IFwi4pygXCI7XG52YXIgbWFsdGVzZSA9IFwi4pygXCI7XG52YXIgbWFwID0gXCLihqZcIjtcbnZhciBtYXBzdG8gPSBcIuKGplwiO1xudmFyIG1hcHN0b2Rvd24gPSBcIuKGp1wiO1xudmFyIG1hcHN0b2xlZnQgPSBcIuKGpFwiO1xudmFyIG1hcHN0b3VwID0gXCLihqVcIjtcbnZhciBtYXJrZXIgPSBcIuKWrlwiO1xudmFyIG1jb21tYSA9IFwi4qipXCI7XG52YXIgTWN5ID0gXCLQnFwiO1xudmFyIG1jeSA9IFwi0LxcIjtcbnZhciBtZGFzaCA9IFwi4oCUXCI7XG52YXIgbUREb3QgPSBcIuKIulwiO1xudmFyIG1lYXN1cmVkYW5nbGUgPSBcIuKIoVwiO1xudmFyIE1lZGl1bVNwYWNlID0gXCLigZ9cIjtcbnZhciBNZWxsaW50cmYgPSBcIuKEs1wiO1xudmFyIE1mciA9IFwi8J2UkFwiO1xudmFyIG1mciA9IFwi8J2UqlwiO1xudmFyIG1obyA9IFwi4oSnXCI7XG52YXIgbWljcm8kMSA9IFwiwrVcIjtcbnZhciBtaWRhc3QgPSBcIipcIjtcbnZhciBtaWRjaXIgPSBcIuKrsFwiO1xudmFyIG1pZCA9IFwi4oijXCI7XG52YXIgbWlkZG90JDEgPSBcIsK3XCI7XG52YXIgbWludXNiID0gXCLiip9cIjtcbnZhciBtaW51cyA9IFwi4oiSXCI7XG52YXIgbWludXNkID0gXCLiiLhcIjtcbnZhciBtaW51c2R1ID0gXCLiqKpcIjtcbnZhciBNaW51c1BsdXMgPSBcIuKIk1wiO1xudmFyIG1sY3AgPSBcIuKrm1wiO1xudmFyIG1sZHIgPSBcIuKAplwiO1xudmFyIG1ucGx1cyA9IFwi4oiTXCI7XG52YXIgbW9kZWxzID0gXCLiiqdcIjtcbnZhciBNb3BmID0gXCLwnZWEXCI7XG52YXIgbW9wZiA9IFwi8J2VnlwiO1xudmFyIG1wID0gXCLiiJNcIjtcbnZhciBtc2NyID0gXCLwnZOCXCI7XG52YXIgTXNjciA9IFwi4oSzXCI7XG52YXIgbXN0cG9zID0gXCLiiL5cIjtcbnZhciBNdSA9IFwizpxcIjtcbnZhciBtdSA9IFwizrxcIjtcbnZhciBtdWx0aW1hcCA9IFwi4oq4XCI7XG52YXIgbXVtYXAgPSBcIuKKuFwiO1xudmFyIG5hYmxhID0gXCLiiIdcIjtcbnZhciBOYWN1dGUgPSBcIsWDXCI7XG52YXIgbmFjdXRlID0gXCLFhFwiO1xudmFyIG5hbmcgPSBcIuKIoOKDklwiO1xudmFyIG5hcCA9IFwi4omJXCI7XG52YXIgbmFwRSA9IFwi4qmwzLhcIjtcbnZhciBuYXBpZCA9IFwi4omLzLhcIjtcbnZhciBuYXBvcyA9IFwixYlcIjtcbnZhciBuYXBwcm94ID0gXCLiiYlcIjtcbnZhciBuYXR1cmFsID0gXCLima5cIjtcbnZhciBuYXR1cmFscyA9IFwi4oSVXCI7XG52YXIgbmF0dXIgPSBcIuKZrlwiO1xudmFyIG5ic3AkMSA9IFwiwqBcIjtcbnZhciBuYnVtcCA9IFwi4omOzLhcIjtcbnZhciBuYnVtcGUgPSBcIuKJj8y4XCI7XG52YXIgbmNhcCA9IFwi4qmDXCI7XG52YXIgTmNhcm9uID0gXCLFh1wiO1xudmFyIG5jYXJvbiA9IFwixYhcIjtcbnZhciBOY2VkaWwgPSBcIsWFXCI7XG52YXIgbmNlZGlsID0gXCLFhlwiO1xudmFyIG5jb25nID0gXCLiiYdcIjtcbnZhciBuY29uZ2RvdCA9IFwi4qmtzLhcIjtcbnZhciBuY3VwID0gXCLiqYJcIjtcbnZhciBOY3kgPSBcItCdXCI7XG52YXIgbmN5ID0gXCLQvVwiO1xudmFyIG5kYXNoID0gXCLigJNcIjtcbnZhciBuZWFyaGsgPSBcIuKkpFwiO1xudmFyIG5lYXJyID0gXCLihpdcIjtcbnZhciBuZUFyciA9IFwi4oeXXCI7XG52YXIgbmVhcnJvdyA9IFwi4oaXXCI7XG52YXIgbmUgPSBcIuKJoFwiO1xudmFyIG5lZG90ID0gXCLiiZDMuFwiO1xudmFyIE5lZ2F0aXZlTWVkaXVtU3BhY2UgPSBcIuKAi1wiO1xudmFyIE5lZ2F0aXZlVGhpY2tTcGFjZSA9IFwi4oCLXCI7XG52YXIgTmVnYXRpdmVUaGluU3BhY2UgPSBcIuKAi1wiO1xudmFyIE5lZ2F0aXZlVmVyeVRoaW5TcGFjZSA9IFwi4oCLXCI7XG52YXIgbmVxdWl2ID0gXCLiiaJcIjtcbnZhciBuZXNlYXIgPSBcIuKkqFwiO1xudmFyIG5lc2ltID0gXCLiiYLMuFwiO1xudmFyIE5lc3RlZEdyZWF0ZXJHcmVhdGVyID0gXCLiiatcIjtcbnZhciBOZXN0ZWRMZXNzTGVzcyA9IFwi4omqXCI7XG52YXIgTmV3TGluZSA9IFwiXFxuXCI7XG52YXIgbmV4aXN0ID0gXCLiiIRcIjtcbnZhciBuZXhpc3RzID0gXCLiiIRcIjtcbnZhciBOZnIgPSBcIvCdlJFcIjtcbnZhciBuZnIgPSBcIvCdlKtcIjtcbnZhciBuZ0UgPSBcIuKJp8y4XCI7XG52YXIgbmdlID0gXCLiibFcIjtcbnZhciBuZ2VxID0gXCLiibFcIjtcbnZhciBuZ2VxcSA9IFwi4omnzLhcIjtcbnZhciBuZ2Vxc2xhbnQgPSBcIuKpvsy4XCI7XG52YXIgbmdlcyA9IFwi4qm+zLhcIjtcbnZhciBuR2cgPSBcIuKLmcy4XCI7XG52YXIgbmdzaW0gPSBcIuKJtVwiO1xudmFyIG5HdCA9IFwi4omr4oOSXCI7XG52YXIgbmd0ID0gXCLiia9cIjtcbnZhciBuZ3RyID0gXCLiia9cIjtcbnZhciBuR3R2ID0gXCLiiavMuFwiO1xudmFyIG5oYXJyID0gXCLihq5cIjtcbnZhciBuaEFyciA9IFwi4oeOXCI7XG52YXIgbmhwYXIgPSBcIuKrslwiO1xudmFyIG5pID0gXCLiiItcIjtcbnZhciBuaXMgPSBcIuKLvFwiO1xudmFyIG5pc2QgPSBcIuKLulwiO1xudmFyIG5pdiA9IFwi4oiLXCI7XG52YXIgTkpjeSA9IFwi0IpcIjtcbnZhciBuamN5ID0gXCLRmlwiO1xudmFyIG5sYXJyID0gXCLihppcIjtcbnZhciBubEFyciA9IFwi4oeNXCI7XG52YXIgbmxkciA9IFwi4oClXCI7XG52YXIgbmxFID0gXCLiiabMuFwiO1xudmFyIG5sZSA9IFwi4omwXCI7XG52YXIgbmxlZnRhcnJvdyA9IFwi4oaaXCI7XG52YXIgbkxlZnRhcnJvdyA9IFwi4oeNXCI7XG52YXIgbmxlZnRyaWdodGFycm93ID0gXCLihq5cIjtcbnZhciBuTGVmdHJpZ2h0YXJyb3cgPSBcIuKHjlwiO1xudmFyIG5sZXEgPSBcIuKJsFwiO1xudmFyIG5sZXFxID0gXCLiiabMuFwiO1xudmFyIG5sZXFzbGFudCA9IFwi4qm9zLhcIjtcbnZhciBubGVzID0gXCLiqb3MuFwiO1xudmFyIG5sZXNzID0gXCLiia5cIjtcbnZhciBuTGwgPSBcIuKLmMy4XCI7XG52YXIgbmxzaW0gPSBcIuKJtFwiO1xudmFyIG5MdCA9IFwi4omq4oOSXCI7XG52YXIgbmx0ID0gXCLiia5cIjtcbnZhciBubHRyaSA9IFwi4ouqXCI7XG52YXIgbmx0cmllID0gXCLii6xcIjtcbnZhciBuTHR2ID0gXCLiiarMuFwiO1xudmFyIG5taWQgPSBcIuKIpFwiO1xudmFyIE5vQnJlYWsgPSBcIuKBoFwiO1xudmFyIE5vbkJyZWFraW5nU3BhY2UgPSBcIsKgXCI7XG52YXIgbm9wZiA9IFwi8J2Vn1wiO1xudmFyIE5vcGYgPSBcIuKElVwiO1xudmFyIE5vdCA9IFwi4qusXCI7XG52YXIgbm90JDEgPSBcIsKsXCI7XG52YXIgTm90Q29uZ3J1ZW50ID0gXCLiiaJcIjtcbnZhciBOb3RDdXBDYXAgPSBcIuKJrVwiO1xudmFyIE5vdERvdWJsZVZlcnRpY2FsQmFyID0gXCLiiKZcIjtcbnZhciBOb3RFbGVtZW50ID0gXCLiiIlcIjtcbnZhciBOb3RFcXVhbCA9IFwi4omgXCI7XG52YXIgTm90RXF1YWxUaWxkZSA9IFwi4omCzLhcIjtcbnZhciBOb3RFeGlzdHMgPSBcIuKIhFwiO1xudmFyIE5vdEdyZWF0ZXIgPSBcIuKJr1wiO1xudmFyIE5vdEdyZWF0ZXJFcXVhbCA9IFwi4omxXCI7XG52YXIgTm90R3JlYXRlckZ1bGxFcXVhbCA9IFwi4omnzLhcIjtcbnZhciBOb3RHcmVhdGVyR3JlYXRlciA9IFwi4omrzLhcIjtcbnZhciBOb3RHcmVhdGVyTGVzcyA9IFwi4om5XCI7XG52YXIgTm90R3JlYXRlclNsYW50RXF1YWwgPSBcIuKpvsy4XCI7XG52YXIgTm90R3JlYXRlclRpbGRlID0gXCLiibVcIjtcbnZhciBOb3RIdW1wRG93bkh1bXAgPSBcIuKJjsy4XCI7XG52YXIgTm90SHVtcEVxdWFsID0gXCLiiY/MuFwiO1xudmFyIG5vdGluID0gXCLiiIlcIjtcbnZhciBub3RpbmRvdCA9IFwi4ou1zLhcIjtcbnZhciBub3RpbkUgPSBcIuKLucy4XCI7XG52YXIgbm90aW52YSA9IFwi4oiJXCI7XG52YXIgbm90aW52YiA9IFwi4ou3XCI7XG52YXIgbm90aW52YyA9IFwi4ou2XCI7XG52YXIgTm90TGVmdFRyaWFuZ2xlQmFyID0gXCLip4/MuFwiO1xudmFyIE5vdExlZnRUcmlhbmdsZSA9IFwi4ouqXCI7XG52YXIgTm90TGVmdFRyaWFuZ2xlRXF1YWwgPSBcIuKLrFwiO1xudmFyIE5vdExlc3MgPSBcIuKJrlwiO1xudmFyIE5vdExlc3NFcXVhbCA9IFwi4omwXCI7XG52YXIgTm90TGVzc0dyZWF0ZXIgPSBcIuKJuFwiO1xudmFyIE5vdExlc3NMZXNzID0gXCLiiarMuFwiO1xudmFyIE5vdExlc3NTbGFudEVxdWFsID0gXCLiqb3MuFwiO1xudmFyIE5vdExlc3NUaWxkZSA9IFwi4om0XCI7XG52YXIgTm90TmVzdGVkR3JlYXRlckdyZWF0ZXIgPSBcIuKqosy4XCI7XG52YXIgTm90TmVzdGVkTGVzc0xlc3MgPSBcIuKqocy4XCI7XG52YXIgbm90bmkgPSBcIuKIjFwiO1xudmFyIG5vdG5pdmEgPSBcIuKIjFwiO1xudmFyIG5vdG5pdmIgPSBcIuKLvlwiO1xudmFyIG5vdG5pdmMgPSBcIuKLvVwiO1xudmFyIE5vdFByZWNlZGVzID0gXCLiioBcIjtcbnZhciBOb3RQcmVjZWRlc0VxdWFsID0gXCLiqq/MuFwiO1xudmFyIE5vdFByZWNlZGVzU2xhbnRFcXVhbCA9IFwi4ougXCI7XG52YXIgTm90UmV2ZXJzZUVsZW1lbnQgPSBcIuKIjFwiO1xudmFyIE5vdFJpZ2h0VHJpYW5nbGVCYXIgPSBcIuKnkMy4XCI7XG52YXIgTm90UmlnaHRUcmlhbmdsZSA9IFwi4ourXCI7XG52YXIgTm90UmlnaHRUcmlhbmdsZUVxdWFsID0gXCLii61cIjtcbnZhciBOb3RTcXVhcmVTdWJzZXQgPSBcIuKKj8y4XCI7XG52YXIgTm90U3F1YXJlU3Vic2V0RXF1YWwgPSBcIuKLolwiO1xudmFyIE5vdFNxdWFyZVN1cGVyc2V0ID0gXCLiipDMuFwiO1xudmFyIE5vdFNxdWFyZVN1cGVyc2V0RXF1YWwgPSBcIuKLo1wiO1xudmFyIE5vdFN1YnNldCA9IFwi4oqC4oOSXCI7XG52YXIgTm90U3Vic2V0RXF1YWwgPSBcIuKKiFwiO1xudmFyIE5vdFN1Y2NlZWRzID0gXCLiioFcIjtcbnZhciBOb3RTdWNjZWVkc0VxdWFsID0gXCLiqrDMuFwiO1xudmFyIE5vdFN1Y2NlZWRzU2xhbnRFcXVhbCA9IFwi4ouhXCI7XG52YXIgTm90U3VjY2VlZHNUaWxkZSA9IFwi4om/zLhcIjtcbnZhciBOb3RTdXBlcnNldCA9IFwi4oqD4oOSXCI7XG52YXIgTm90U3VwZXJzZXRFcXVhbCA9IFwi4oqJXCI7XG52YXIgTm90VGlsZGUgPSBcIuKJgVwiO1xudmFyIE5vdFRpbGRlRXF1YWwgPSBcIuKJhFwiO1xudmFyIE5vdFRpbGRlRnVsbEVxdWFsID0gXCLiiYdcIjtcbnZhciBOb3RUaWxkZVRpbGRlID0gXCLiiYlcIjtcbnZhciBOb3RWZXJ0aWNhbEJhciA9IFwi4oikXCI7XG52YXIgbnBhcmFsbGVsID0gXCLiiKZcIjtcbnZhciBucGFyID0gXCLiiKZcIjtcbnZhciBucGFyc2wgPSBcIuKrveKDpVwiO1xudmFyIG5wYXJ0ID0gXCLiiILMuFwiO1xudmFyIG5wb2xpbnQgPSBcIuKolFwiO1xudmFyIG5wciA9IFwi4oqAXCI7XG52YXIgbnByY3VlID0gXCLii6BcIjtcbnZhciBucHJlYyA9IFwi4oqAXCI7XG52YXIgbnByZWNlcSA9IFwi4qqvzLhcIjtcbnZhciBucHJlID0gXCLiqq/MuFwiO1xudmFyIG5yYXJyYyA9IFwi4qSzzLhcIjtcbnZhciBucmFyciA9IFwi4oabXCI7XG52YXIgbnJBcnIgPSBcIuKHj1wiO1xudmFyIG5yYXJydyA9IFwi4oadzLhcIjtcbnZhciBucmlnaHRhcnJvdyA9IFwi4oabXCI7XG52YXIgblJpZ2h0YXJyb3cgPSBcIuKHj1wiO1xudmFyIG5ydHJpID0gXCLii6tcIjtcbnZhciBucnRyaWUgPSBcIuKLrVwiO1xudmFyIG5zYyA9IFwi4oqBXCI7XG52YXIgbnNjY3VlID0gXCLii6FcIjtcbnZhciBuc2NlID0gXCLiqrDMuFwiO1xudmFyIE5zY3IgPSBcIvCdkqlcIjtcbnZhciBuc2NyID0gXCLwnZODXCI7XG52YXIgbnNob3J0bWlkID0gXCLiiKRcIjtcbnZhciBuc2hvcnRwYXJhbGxlbCA9IFwi4oimXCI7XG52YXIgbnNpbSA9IFwi4omBXCI7XG52YXIgbnNpbWUgPSBcIuKJhFwiO1xudmFyIG5zaW1lcSA9IFwi4omEXCI7XG52YXIgbnNtaWQgPSBcIuKIpFwiO1xudmFyIG5zcGFyID0gXCLiiKZcIjtcbnZhciBuc3FzdWJlID0gXCLii6JcIjtcbnZhciBuc3FzdXBlID0gXCLii6NcIjtcbnZhciBuc3ViID0gXCLiioRcIjtcbnZhciBuc3ViRSA9IFwi4quFzLhcIjtcbnZhciBuc3ViZSA9IFwi4oqIXCI7XG52YXIgbnN1YnNldCA9IFwi4oqC4oOSXCI7XG52YXIgbnN1YnNldGVxID0gXCLiiohcIjtcbnZhciBuc3Vic2V0ZXFxID0gXCLiq4XMuFwiO1xudmFyIG5zdWNjID0gXCLiioFcIjtcbnZhciBuc3VjY2VxID0gXCLiqrDMuFwiO1xudmFyIG5zdXAgPSBcIuKKhVwiO1xudmFyIG5zdXBFID0gXCLiq4bMuFwiO1xudmFyIG5zdXBlID0gXCLiiolcIjtcbnZhciBuc3Vwc2V0ID0gXCLiioPig5JcIjtcbnZhciBuc3Vwc2V0ZXEgPSBcIuKKiVwiO1xudmFyIG5zdXBzZXRlcXEgPSBcIuKrhsy4XCI7XG52YXIgbnRnbCA9IFwi4om5XCI7XG52YXIgTnRpbGRlJDEgPSBcIsORXCI7XG52YXIgbnRpbGRlJDEgPSBcIsOxXCI7XG52YXIgbnRsZyA9IFwi4om4XCI7XG52YXIgbnRyaWFuZ2xlbGVmdCA9IFwi4ouqXCI7XG52YXIgbnRyaWFuZ2xlbGVmdGVxID0gXCLii6xcIjtcbnZhciBudHJpYW5nbGVyaWdodCA9IFwi4ourXCI7XG52YXIgbnRyaWFuZ2xlcmlnaHRlcSA9IFwi4outXCI7XG52YXIgTnUgPSBcIs6dXCI7XG52YXIgbnUgPSBcIs69XCI7XG52YXIgbnVtID0gXCIjXCI7XG52YXIgbnVtZXJvID0gXCLihJZcIjtcbnZhciBudW1zcCA9IFwi4oCHXCI7XG52YXIgbnZhcCA9IFwi4omN4oOSXCI7XG52YXIgbnZkYXNoID0gXCLiiqxcIjtcbnZhciBudkRhc2ggPSBcIuKKrVwiO1xudmFyIG5WZGFzaCA9IFwi4oquXCI7XG52YXIgblZEYXNoID0gXCLiiq9cIjtcbnZhciBudmdlID0gXCLiiaXig5JcIjtcbnZhciBudmd0ID0gXCI+4oOSXCI7XG52YXIgbnZIYXJyID0gXCLipIRcIjtcbnZhciBudmluZmluID0gXCLip55cIjtcbnZhciBudmxBcnIgPSBcIuKkglwiO1xudmFyIG52bGUgPSBcIuKJpOKDklwiO1xudmFyIG52bHQgPSBcIjzig5JcIjtcbnZhciBudmx0cmllID0gXCLiirTig5JcIjtcbnZhciBudnJBcnIgPSBcIuKkg1wiO1xudmFyIG52cnRyaWUgPSBcIuKKteKDklwiO1xudmFyIG52c2ltID0gXCLiiLzig5JcIjtcbnZhciBud2FyaGsgPSBcIuKko1wiO1xudmFyIG53YXJyID0gXCLihpZcIjtcbnZhciBud0FyciA9IFwi4oeWXCI7XG52YXIgbndhcnJvdyA9IFwi4oaWXCI7XG52YXIgbnduZWFyID0gXCLipKdcIjtcbnZhciBPYWN1dGUkMSA9IFwiw5NcIjtcbnZhciBvYWN1dGUkMSA9IFwiw7NcIjtcbnZhciBvYXN0ID0gXCLiiptcIjtcbnZhciBPY2lyYyQxID0gXCLDlFwiO1xudmFyIG9jaXJjJDEgPSBcIsO0XCI7XG52YXIgb2NpciA9IFwi4oqaXCI7XG52YXIgT2N5ID0gXCLQnlwiO1xudmFyIG9jeSA9IFwi0L5cIjtcbnZhciBvZGFzaCA9IFwi4oqdXCI7XG52YXIgT2RibGFjID0gXCLFkFwiO1xudmFyIG9kYmxhYyA9IFwixZFcIjtcbnZhciBvZGl2ID0gXCLiqLhcIjtcbnZhciBvZG90ID0gXCLiiplcIjtcbnZhciBvZHNvbGQgPSBcIuKmvFwiO1xudmFyIE9FbGlnID0gXCLFklwiO1xudmFyIG9lbGlnID0gXCLFk1wiO1xudmFyIG9mY2lyID0gXCLipr9cIjtcbnZhciBPZnIgPSBcIvCdlJJcIjtcbnZhciBvZnIgPSBcIvCdlKxcIjtcbnZhciBvZ29uID0gXCLLm1wiO1xudmFyIE9ncmF2ZSQxID0gXCLDklwiO1xudmFyIG9ncmF2ZSQxID0gXCLDslwiO1xudmFyIG9ndCA9IFwi4qeBXCI7XG52YXIgb2hiYXIgPSBcIuKmtVwiO1xudmFyIG9obSA9IFwizqlcIjtcbnZhciBvaW50ID0gXCLiiK5cIjtcbnZhciBvbGFyciA9IFwi4oa6XCI7XG52YXIgb2xjaXIgPSBcIuKmvlwiO1xudmFyIG9sY3Jvc3MgPSBcIuKmu1wiO1xudmFyIG9saW5lID0gXCLigL5cIjtcbnZhciBvbHQgPSBcIuKngFwiO1xudmFyIE9tYWNyID0gXCLFjFwiO1xudmFyIG9tYWNyID0gXCLFjVwiO1xudmFyIE9tZWdhID0gXCLOqVwiO1xudmFyIG9tZWdhID0gXCLPiVwiO1xudmFyIE9taWNyb24gPSBcIs6fXCI7XG52YXIgb21pY3JvbiA9IFwizr9cIjtcbnZhciBvbWlkID0gXCLiprZcIjtcbnZhciBvbWludXMgPSBcIuKKllwiO1xudmFyIE9vcGYgPSBcIvCdlYZcIjtcbnZhciBvb3BmID0gXCLwnZWgXCI7XG52YXIgb3BhciA9IFwi4qa3XCI7XG52YXIgT3BlbkN1cmx5RG91YmxlUXVvdGUgPSBcIuKAnFwiO1xudmFyIE9wZW5DdXJseVF1b3RlID0gXCLigJhcIjtcbnZhciBvcGVycCA9IFwi4qa5XCI7XG52YXIgb3BsdXMgPSBcIuKKlVwiO1xudmFyIG9yYXJyID0gXCLihrtcIjtcbnZhciBPciA9IFwi4qmUXCI7XG52YXIgb3IgPSBcIuKIqFwiO1xudmFyIG9yZCA9IFwi4qmdXCI7XG52YXIgb3JkZXIgPSBcIuKEtFwiO1xudmFyIG9yZGVyb2YgPSBcIuKEtFwiO1xudmFyIG9yZGYkMSA9IFwiwqpcIjtcbnZhciBvcmRtJDEgPSBcIsK6XCI7XG52YXIgb3JpZ29mID0gXCLiirZcIjtcbnZhciBvcm9yID0gXCLiqZZcIjtcbnZhciBvcnNsb3BlID0gXCLiqZdcIjtcbnZhciBvcnYgPSBcIuKpm1wiO1xudmFyIG9TID0gXCLik4hcIjtcbnZhciBPc2NyID0gXCLwnZKqXCI7XG52YXIgb3NjciA9IFwi4oS0XCI7XG52YXIgT3NsYXNoJDEgPSBcIsOYXCI7XG52YXIgb3NsYXNoJDEgPSBcIsO4XCI7XG52YXIgb3NvbCA9IFwi4oqYXCI7XG52YXIgT3RpbGRlJDEgPSBcIsOVXCI7XG52YXIgb3RpbGRlJDEgPSBcIsO1XCI7XG52YXIgb3RpbWVzYXMgPSBcIuKotlwiO1xudmFyIE90aW1lcyA9IFwi4qi3XCI7XG52YXIgb3RpbWVzID0gXCLiipdcIjtcbnZhciBPdW1sJDEgPSBcIsOWXCI7XG52YXIgb3VtbCQxID0gXCLDtlwiO1xudmFyIG92YmFyID0gXCLijL1cIjtcbnZhciBPdmVyQmFyID0gXCLigL5cIjtcbnZhciBPdmVyQnJhY2UgPSBcIuKPnlwiO1xudmFyIE92ZXJCcmFja2V0ID0gXCLijrRcIjtcbnZhciBPdmVyUGFyZW50aGVzaXMgPSBcIuKPnFwiO1xudmFyIHBhcmEkMSA9IFwiwrZcIjtcbnZhciBwYXJhbGxlbCA9IFwi4oilXCI7XG52YXIgcGFyID0gXCLiiKVcIjtcbnZhciBwYXJzaW0gPSBcIuKrs1wiO1xudmFyIHBhcnNsID0gXCLiq71cIjtcbnZhciBwYXJ0ID0gXCLiiIJcIjtcbnZhciBQYXJ0aWFsRCA9IFwi4oiCXCI7XG52YXIgUGN5ID0gXCLQn1wiO1xudmFyIHBjeSA9IFwi0L9cIjtcbnZhciBwZXJjbnQgPSBcIiVcIjtcbnZhciBwZXJpb2QgPSBcIi5cIjtcbnZhciBwZXJtaWwgPSBcIuKAsFwiO1xudmFyIHBlcnAgPSBcIuKKpVwiO1xudmFyIHBlcnRlbmsgPSBcIuKAsVwiO1xudmFyIFBmciA9IFwi8J2Uk1wiO1xudmFyIHBmciA9IFwi8J2UrVwiO1xudmFyIFBoaSA9IFwizqZcIjtcbnZhciBwaGkgPSBcIs+GXCI7XG52YXIgcGhpdiA9IFwiz5VcIjtcbnZhciBwaG1tYXQgPSBcIuKEs1wiO1xudmFyIHBob25lID0gXCLimI5cIjtcbnZhciBQaSA9IFwizqBcIjtcbnZhciBwaSA9IFwiz4BcIjtcbnZhciBwaXRjaGZvcmsgPSBcIuKLlFwiO1xudmFyIHBpdiA9IFwiz5ZcIjtcbnZhciBwbGFuY2sgPSBcIuKEj1wiO1xudmFyIHBsYW5ja2ggPSBcIuKEjlwiO1xudmFyIHBsYW5rdiA9IFwi4oSPXCI7XG52YXIgcGx1c2FjaXIgPSBcIuKoo1wiO1xudmFyIHBsdXNiID0gXCLiip5cIjtcbnZhciBwbHVzY2lyID0gXCLiqKJcIjtcbnZhciBwbHVzID0gXCIrXCI7XG52YXIgcGx1c2RvID0gXCLiiJRcIjtcbnZhciBwbHVzZHUgPSBcIuKopVwiO1xudmFyIHBsdXNlID0gXCLiqbJcIjtcbnZhciBQbHVzTWludXMgPSBcIsKxXCI7XG52YXIgcGx1c21uJDEgPSBcIsKxXCI7XG52YXIgcGx1c3NpbSA9IFwi4qimXCI7XG52YXIgcGx1c3R3byA9IFwi4qinXCI7XG52YXIgcG0gPSBcIsKxXCI7XG52YXIgUG9pbmNhcmVwbGFuZSA9IFwi4oSMXCI7XG52YXIgcG9pbnRpbnQgPSBcIuKolVwiO1xudmFyIHBvcGYgPSBcIvCdlaFcIjtcbnZhciBQb3BmID0gXCLihJlcIjtcbnZhciBwb3VuZCQxID0gXCLCo1wiO1xudmFyIHByYXAgPSBcIuKqt1wiO1xudmFyIFByID0gXCLiqrtcIjtcbnZhciBwciA9IFwi4om6XCI7XG52YXIgcHJjdWUgPSBcIuKJvFwiO1xudmFyIHByZWNhcHByb3ggPSBcIuKqt1wiO1xudmFyIHByZWMgPSBcIuKJulwiO1xudmFyIHByZWNjdXJseWVxID0gXCLiibxcIjtcbnZhciBQcmVjZWRlcyA9IFwi4om6XCI7XG52YXIgUHJlY2VkZXNFcXVhbCA9IFwi4qqvXCI7XG52YXIgUHJlY2VkZXNTbGFudEVxdWFsID0gXCLiibxcIjtcbnZhciBQcmVjZWRlc1RpbGRlID0gXCLiib5cIjtcbnZhciBwcmVjZXEgPSBcIuKqr1wiO1xudmFyIHByZWNuYXBwcm94ID0gXCLiqrlcIjtcbnZhciBwcmVjbmVxcSA9IFwi4qq1XCI7XG52YXIgcHJlY25zaW0gPSBcIuKLqFwiO1xudmFyIHByZSA9IFwi4qqvXCI7XG52YXIgcHJFID0gXCLiqrNcIjtcbnZhciBwcmVjc2ltID0gXCLiib5cIjtcbnZhciBwcmltZSA9IFwi4oCyXCI7XG52YXIgUHJpbWUgPSBcIuKAs1wiO1xudmFyIHByaW1lcyA9IFwi4oSZXCI7XG52YXIgcHJuYXAgPSBcIuKquVwiO1xudmFyIHBybkUgPSBcIuKqtVwiO1xudmFyIHBybnNpbSA9IFwi4ouoXCI7XG52YXIgcHJvZCA9IFwi4oiPXCI7XG52YXIgUHJvZHVjdCA9IFwi4oiPXCI7XG52YXIgcHJvZmFsYXIgPSBcIuKMrlwiO1xudmFyIHByb2ZsaW5lID0gXCLijJJcIjtcbnZhciBwcm9mc3VyZiA9IFwi4oyTXCI7XG52YXIgcHJvcCA9IFwi4oidXCI7XG52YXIgUHJvcG9ydGlvbmFsID0gXCLiiJ1cIjtcbnZhciBQcm9wb3J0aW9uID0gXCLiiLdcIjtcbnZhciBwcm9wdG8gPSBcIuKInVwiO1xudmFyIHByc2ltID0gXCLiib5cIjtcbnZhciBwcnVyZWwgPSBcIuKKsFwiO1xudmFyIFBzY3IgPSBcIvCdkqtcIjtcbnZhciBwc2NyID0gXCLwnZOFXCI7XG52YXIgUHNpID0gXCLOqFwiO1xudmFyIHBzaSA9IFwiz4hcIjtcbnZhciBwdW5jc3AgPSBcIuKAiFwiO1xudmFyIFFmciA9IFwi8J2UlFwiO1xudmFyIHFmciA9IFwi8J2UrlwiO1xudmFyIHFpbnQgPSBcIuKojFwiO1xudmFyIHFvcGYgPSBcIvCdlaJcIjtcbnZhciBRb3BmID0gXCLihJpcIjtcbnZhciBxcHJpbWUgPSBcIuKBl1wiO1xudmFyIFFzY3IgPSBcIvCdkqxcIjtcbnZhciBxc2NyID0gXCLwnZOGXCI7XG52YXIgcXVhdGVybmlvbnMgPSBcIuKEjVwiO1xudmFyIHF1YXRpbnQgPSBcIuKollwiO1xudmFyIHF1ZXN0ID0gXCI/XCI7XG52YXIgcXVlc3RlcSA9IFwi4omfXCI7XG52YXIgcXVvdCQyID0gXCJcXFwiXCI7XG52YXIgUVVPVCQxID0gXCJcXFwiXCI7XG52YXIgckFhcnIgPSBcIuKHm1wiO1xudmFyIHJhY2UgPSBcIuKIvcyxXCI7XG52YXIgUmFjdXRlID0gXCLFlFwiO1xudmFyIHJhY3V0ZSA9IFwixZVcIjtcbnZhciByYWRpYyA9IFwi4oiaXCI7XG52YXIgcmFlbXB0eXYgPSBcIuKms1wiO1xudmFyIHJhbmcgPSBcIuKfqVwiO1xudmFyIFJhbmcgPSBcIuKfq1wiO1xudmFyIHJhbmdkID0gXCLippJcIjtcbnZhciByYW5nZSA9IFwi4qalXCI7XG52YXIgcmFuZ2xlID0gXCLin6lcIjtcbnZhciByYXF1byQxID0gXCLCu1wiO1xudmFyIHJhcnJhcCA9IFwi4qW1XCI7XG52YXIgcmFycmIgPSBcIuKHpVwiO1xudmFyIHJhcnJiZnMgPSBcIuKkoFwiO1xudmFyIHJhcnJjID0gXCLipLNcIjtcbnZhciByYXJyID0gXCLihpJcIjtcbnZhciBSYXJyID0gXCLihqBcIjtcbnZhciByQXJyID0gXCLih5JcIjtcbnZhciByYXJyZnMgPSBcIuKknlwiO1xudmFyIHJhcnJoayA9IFwi4oaqXCI7XG52YXIgcmFycmxwID0gXCLihqxcIjtcbnZhciByYXJycGwgPSBcIuKlhVwiO1xudmFyIHJhcnJzaW0gPSBcIuKltFwiO1xudmFyIFJhcnJ0bCA9IFwi4qSWXCI7XG52YXIgcmFycnRsID0gXCLihqNcIjtcbnZhciByYXJydyA9IFwi4oadXCI7XG52YXIgcmF0YWlsID0gXCLipJpcIjtcbnZhciByQXRhaWwgPSBcIuKknFwiO1xudmFyIHJhdGlvID0gXCLiiLZcIjtcbnZhciByYXRpb25hbHMgPSBcIuKEmlwiO1xudmFyIHJiYXJyID0gXCLipI1cIjtcbnZhciByQmFyciA9IFwi4qSPXCI7XG52YXIgUkJhcnIgPSBcIuKkkFwiO1xudmFyIHJiYnJrID0gXCLinbNcIjtcbnZhciByYnJhY2UgPSBcIn1cIjtcbnZhciByYnJhY2sgPSBcIl1cIjtcbnZhciByYnJrZSA9IFwi4qaMXCI7XG52YXIgcmJya3NsZCA9IFwi4qaOXCI7XG52YXIgcmJya3NsdSA9IFwi4qaQXCI7XG52YXIgUmNhcm9uID0gXCLFmFwiO1xudmFyIHJjYXJvbiA9IFwixZlcIjtcbnZhciBSY2VkaWwgPSBcIsWWXCI7XG52YXIgcmNlZGlsID0gXCLFl1wiO1xudmFyIHJjZWlsID0gXCLijIlcIjtcbnZhciByY3ViID0gXCJ9XCI7XG52YXIgUmN5ID0gXCLQoFwiO1xudmFyIHJjeSA9IFwi0YBcIjtcbnZhciByZGNhID0gXCLipLdcIjtcbnZhciByZGxkaGFyID0gXCLipalcIjtcbnZhciByZHF1byA9IFwi4oCdXCI7XG52YXIgcmRxdW9yID0gXCLigJ1cIjtcbnZhciByZHNoID0gXCLihrNcIjtcbnZhciByZWFsID0gXCLihJxcIjtcbnZhciByZWFsaW5lID0gXCLihJtcIjtcbnZhciByZWFscGFydCA9IFwi4oScXCI7XG52YXIgcmVhbHMgPSBcIuKEnVwiO1xudmFyIFJlID0gXCLihJxcIjtcbnZhciByZWN0ID0gXCLilq1cIjtcbnZhciByZWckMSA9IFwiwq5cIjtcbnZhciBSRUckMSA9IFwiwq5cIjtcbnZhciBSZXZlcnNlRWxlbWVudCA9IFwi4oiLXCI7XG52YXIgUmV2ZXJzZUVxdWlsaWJyaXVtID0gXCLih4tcIjtcbnZhciBSZXZlcnNlVXBFcXVpbGlicml1bSA9IFwi4qWvXCI7XG52YXIgcmZpc2h0ID0gXCLipb1cIjtcbnZhciByZmxvb3IgPSBcIuKMi1wiO1xudmFyIHJmciA9IFwi8J2Ur1wiO1xudmFyIFJmciA9IFwi4oScXCI7XG52YXIgckhhciA9IFwi4qWkXCI7XG52YXIgcmhhcmQgPSBcIuKHgVwiO1xudmFyIHJoYXJ1ID0gXCLih4BcIjtcbnZhciByaGFydWwgPSBcIuKlrFwiO1xudmFyIFJobyA9IFwizqFcIjtcbnZhciByaG8gPSBcIs+BXCI7XG52YXIgcmhvdiA9IFwiz7FcIjtcbnZhciBSaWdodEFuZ2xlQnJhY2tldCA9IFwi4p+pXCI7XG52YXIgUmlnaHRBcnJvd0JhciA9IFwi4oelXCI7XG52YXIgcmlnaHRhcnJvdyA9IFwi4oaSXCI7XG52YXIgUmlnaHRBcnJvdyA9IFwi4oaSXCI7XG52YXIgUmlnaHRhcnJvdyA9IFwi4oeSXCI7XG52YXIgUmlnaHRBcnJvd0xlZnRBcnJvdyA9IFwi4oeEXCI7XG52YXIgcmlnaHRhcnJvd3RhaWwgPSBcIuKGo1wiO1xudmFyIFJpZ2h0Q2VpbGluZyA9IFwi4oyJXCI7XG52YXIgUmlnaHREb3VibGVCcmFja2V0ID0gXCLin6dcIjtcbnZhciBSaWdodERvd25UZWVWZWN0b3IgPSBcIuKlnVwiO1xudmFyIFJpZ2h0RG93blZlY3RvckJhciA9IFwi4qWVXCI7XG52YXIgUmlnaHREb3duVmVjdG9yID0gXCLih4JcIjtcbnZhciBSaWdodEZsb29yID0gXCLijItcIjtcbnZhciByaWdodGhhcnBvb25kb3duID0gXCLih4FcIjtcbnZhciByaWdodGhhcnBvb251cCA9IFwi4oeAXCI7XG52YXIgcmlnaHRsZWZ0YXJyb3dzID0gXCLih4RcIjtcbnZhciByaWdodGxlZnRoYXJwb29ucyA9IFwi4oeMXCI7XG52YXIgcmlnaHRyaWdodGFycm93cyA9IFwi4oeJXCI7XG52YXIgcmlnaHRzcXVpZ2Fycm93ID0gXCLihp1cIjtcbnZhciBSaWdodFRlZUFycm93ID0gXCLihqZcIjtcbnZhciBSaWdodFRlZSA9IFwi4oqiXCI7XG52YXIgUmlnaHRUZWVWZWN0b3IgPSBcIuKlm1wiO1xudmFyIHJpZ2h0dGhyZWV0aW1lcyA9IFwi4ouMXCI7XG52YXIgUmlnaHRUcmlhbmdsZUJhciA9IFwi4qeQXCI7XG52YXIgUmlnaHRUcmlhbmdsZSA9IFwi4oqzXCI7XG52YXIgUmlnaHRUcmlhbmdsZUVxdWFsID0gXCLiirVcIjtcbnZhciBSaWdodFVwRG93blZlY3RvciA9IFwi4qWPXCI7XG52YXIgUmlnaHRVcFRlZVZlY3RvciA9IFwi4qWcXCI7XG52YXIgUmlnaHRVcFZlY3RvckJhciA9IFwi4qWUXCI7XG52YXIgUmlnaHRVcFZlY3RvciA9IFwi4oa+XCI7XG52YXIgUmlnaHRWZWN0b3JCYXIgPSBcIuKlk1wiO1xudmFyIFJpZ2h0VmVjdG9yID0gXCLih4BcIjtcbnZhciByaW5nID0gXCLLmlwiO1xudmFyIHJpc2luZ2RvdHNlcSA9IFwi4omTXCI7XG52YXIgcmxhcnIgPSBcIuKHhFwiO1xudmFyIHJsaGFyID0gXCLih4xcIjtcbnZhciBybG0gPSBcIuKAj1wiO1xudmFyIHJtb3VzdGFjaGUgPSBcIuKOsVwiO1xudmFyIHJtb3VzdCA9IFwi4o6xXCI7XG52YXIgcm5taWQgPSBcIuKrrlwiO1xudmFyIHJvYW5nID0gXCLin61cIjtcbnZhciByb2FyciA9IFwi4oe+XCI7XG52YXIgcm9icmsgPSBcIuKfp1wiO1xudmFyIHJvcGFyID0gXCLipoZcIjtcbnZhciByb3BmID0gXCLwnZWjXCI7XG52YXIgUm9wZiA9IFwi4oSdXCI7XG52YXIgcm9wbHVzID0gXCLiqK5cIjtcbnZhciByb3RpbWVzID0gXCLiqLVcIjtcbnZhciBSb3VuZEltcGxpZXMgPSBcIuKlsFwiO1xudmFyIHJwYXIgPSBcIilcIjtcbnZhciBycGFyZ3QgPSBcIuKmlFwiO1xudmFyIHJwcG9saW50ID0gXCLiqJJcIjtcbnZhciBycmFyciA9IFwi4oeJXCI7XG52YXIgUnJpZ2h0YXJyb3cgPSBcIuKHm1wiO1xudmFyIHJzYXF1byA9IFwi4oC6XCI7XG52YXIgcnNjciA9IFwi8J2Th1wiO1xudmFyIFJzY3IgPSBcIuKEm1wiO1xudmFyIHJzaCA9IFwi4oaxXCI7XG52YXIgUnNoID0gXCLihrFcIjtcbnZhciByc3FiID0gXCJdXCI7XG52YXIgcnNxdW8gPSBcIuKAmVwiO1xudmFyIHJzcXVvciA9IFwi4oCZXCI7XG52YXIgcnRocmVlID0gXCLii4xcIjtcbnZhciBydGltZXMgPSBcIuKLilwiO1xudmFyIHJ0cmkgPSBcIuKWuVwiO1xudmFyIHJ0cmllID0gXCLiirVcIjtcbnZhciBydHJpZiA9IFwi4pa4XCI7XG52YXIgcnRyaWx0cmkgPSBcIuKnjlwiO1xudmFyIFJ1bGVEZWxheWVkID0gXCLip7RcIjtcbnZhciBydWx1aGFyID0gXCLipahcIjtcbnZhciByeCA9IFwi4oSeXCI7XG52YXIgU2FjdXRlID0gXCLFmlwiO1xudmFyIHNhY3V0ZSA9IFwixZtcIjtcbnZhciBzYnF1byA9IFwi4oCaXCI7XG52YXIgc2NhcCA9IFwi4qq4XCI7XG52YXIgU2Nhcm9uID0gXCLFoFwiO1xudmFyIHNjYXJvbiA9IFwixaFcIjtcbnZhciBTYyA9IFwi4qq8XCI7XG52YXIgc2MgPSBcIuKJu1wiO1xudmFyIHNjY3VlID0gXCLiib1cIjtcbnZhciBzY2UgPSBcIuKqsFwiO1xudmFyIHNjRSA9IFwi4qq0XCI7XG52YXIgU2NlZGlsID0gXCLFnlwiO1xudmFyIHNjZWRpbCA9IFwixZ9cIjtcbnZhciBTY2lyYyA9IFwixZxcIjtcbnZhciBzY2lyYyA9IFwixZ1cIjtcbnZhciBzY25hcCA9IFwi4qq6XCI7XG52YXIgc2NuRSA9IFwi4qq2XCI7XG52YXIgc2Nuc2ltID0gXCLii6lcIjtcbnZhciBzY3BvbGludCA9IFwi4qiTXCI7XG52YXIgc2NzaW0gPSBcIuKJv1wiO1xudmFyIFNjeSA9IFwi0KFcIjtcbnZhciBzY3kgPSBcItGBXCI7XG52YXIgc2RvdGIgPSBcIuKKoVwiO1xudmFyIHNkb3QgPSBcIuKLhVwiO1xudmFyIHNkb3RlID0gXCLiqaZcIjtcbnZhciBzZWFyaGsgPSBcIuKkpVwiO1xudmFyIHNlYXJyID0gXCLihphcIjtcbnZhciBzZUFyciA9IFwi4oeYXCI7XG52YXIgc2VhcnJvdyA9IFwi4oaYXCI7XG52YXIgc2VjdCQxID0gXCLCp1wiO1xudmFyIHNlbWkgPSBcIjtcIjtcbnZhciBzZXN3YXIgPSBcIuKkqVwiO1xudmFyIHNldG1pbnVzID0gXCLiiJZcIjtcbnZhciBzZXRtbiA9IFwi4oiWXCI7XG52YXIgc2V4dCA9IFwi4py2XCI7XG52YXIgU2ZyID0gXCLwnZSWXCI7XG52YXIgc2ZyID0gXCLwnZSwXCI7XG52YXIgc2Zyb3duID0gXCLijKJcIjtcbnZhciBzaGFycCA9IFwi4pmvXCI7XG52YXIgU0hDSGN5ID0gXCLQqVwiO1xudmFyIHNoY2hjeSA9IFwi0YlcIjtcbnZhciBTSGN5ID0gXCLQqFwiO1xudmFyIHNoY3kgPSBcItGIXCI7XG52YXIgU2hvcnREb3duQXJyb3cgPSBcIuKGk1wiO1xudmFyIFNob3J0TGVmdEFycm93ID0gXCLihpBcIjtcbnZhciBzaG9ydG1pZCA9IFwi4oijXCI7XG52YXIgc2hvcnRwYXJhbGxlbCA9IFwi4oilXCI7XG52YXIgU2hvcnRSaWdodEFycm93ID0gXCLihpJcIjtcbnZhciBTaG9ydFVwQXJyb3cgPSBcIuKGkVwiO1xudmFyIHNoeSQxID0gXCLCrVwiO1xudmFyIFNpZ21hID0gXCLOo1wiO1xudmFyIHNpZ21hID0gXCLPg1wiO1xudmFyIHNpZ21hZiA9IFwiz4JcIjtcbnZhciBzaWdtYXYgPSBcIs+CXCI7XG52YXIgc2ltID0gXCLiiLxcIjtcbnZhciBzaW1kb3QgPSBcIuKpqlwiO1xudmFyIHNpbWUgPSBcIuKJg1wiO1xudmFyIHNpbWVxID0gXCLiiYNcIjtcbnZhciBzaW1nID0gXCLiqp5cIjtcbnZhciBzaW1nRSA9IFwi4qqgXCI7XG52YXIgc2ltbCA9IFwi4qqdXCI7XG52YXIgc2ltbEUgPSBcIuKqn1wiO1xudmFyIHNpbW5lID0gXCLiiYZcIjtcbnZhciBzaW1wbHVzID0gXCLiqKRcIjtcbnZhciBzaW1yYXJyID0gXCLipbJcIjtcbnZhciBzbGFyciA9IFwi4oaQXCI7XG52YXIgU21hbGxDaXJjbGUgPSBcIuKImFwiO1xudmFyIHNtYWxsc2V0bWludXMgPSBcIuKIllwiO1xudmFyIHNtYXNocCA9IFwi4qizXCI7XG52YXIgc21lcGFyc2wgPSBcIuKnpFwiO1xudmFyIHNtaWQgPSBcIuKIo1wiO1xudmFyIHNtaWxlID0gXCLijKNcIjtcbnZhciBzbXQgPSBcIuKqqlwiO1xudmFyIHNtdGUgPSBcIuKqrFwiO1xudmFyIHNtdGVzID0gXCLiqqzvuIBcIjtcbnZhciBTT0ZUY3kgPSBcItCsXCI7XG52YXIgc29mdGN5ID0gXCLRjFwiO1xudmFyIHNvbGJhciA9IFwi4oy/XCI7XG52YXIgc29sYiA9IFwi4qeEXCI7XG52YXIgc29sID0gXCIvXCI7XG52YXIgU29wZiA9IFwi8J2VilwiO1xudmFyIHNvcGYgPSBcIvCdlaRcIjtcbnZhciBzcGFkZXMgPSBcIuKZoFwiO1xudmFyIHNwYWRlc3VpdCA9IFwi4pmgXCI7XG52YXIgc3BhciA9IFwi4oilXCI7XG52YXIgc3FjYXAgPSBcIuKKk1wiO1xudmFyIHNxY2FwcyA9IFwi4oqT77iAXCI7XG52YXIgc3FjdXAgPSBcIuKKlFwiO1xudmFyIHNxY3VwcyA9IFwi4oqU77iAXCI7XG52YXIgU3FydCA9IFwi4oiaXCI7XG52YXIgc3FzdWIgPSBcIuKKj1wiO1xudmFyIHNxc3ViZSA9IFwi4oqRXCI7XG52YXIgc3FzdWJzZXQgPSBcIuKKj1wiO1xudmFyIHNxc3Vic2V0ZXEgPSBcIuKKkVwiO1xudmFyIHNxc3VwID0gXCLiipBcIjtcbnZhciBzcXN1cGUgPSBcIuKKklwiO1xudmFyIHNxc3Vwc2V0ID0gXCLiipBcIjtcbnZhciBzcXN1cHNldGVxID0gXCLiipJcIjtcbnZhciBzcXVhcmUgPSBcIuKWoVwiO1xudmFyIFNxdWFyZSA9IFwi4pahXCI7XG52YXIgU3F1YXJlSW50ZXJzZWN0aW9uID0gXCLiipNcIjtcbnZhciBTcXVhcmVTdWJzZXQgPSBcIuKKj1wiO1xudmFyIFNxdWFyZVN1YnNldEVxdWFsID0gXCLiipFcIjtcbnZhciBTcXVhcmVTdXBlcnNldCA9IFwi4oqQXCI7XG52YXIgU3F1YXJlU3VwZXJzZXRFcXVhbCA9IFwi4oqSXCI7XG52YXIgU3F1YXJlVW5pb24gPSBcIuKKlFwiO1xudmFyIHNxdWFyZiA9IFwi4paqXCI7XG52YXIgc3F1ID0gXCLilqFcIjtcbnZhciBzcXVmID0gXCLilqpcIjtcbnZhciBzcmFyciA9IFwi4oaSXCI7XG52YXIgU3NjciA9IFwi8J2SrlwiO1xudmFyIHNzY3IgPSBcIvCdk4hcIjtcbnZhciBzc2V0bW4gPSBcIuKIllwiO1xudmFyIHNzbWlsZSA9IFwi4oyjXCI7XG52YXIgc3N0YXJmID0gXCLii4ZcIjtcbnZhciBTdGFyID0gXCLii4ZcIjtcbnZhciBzdGFyID0gXCLimIZcIjtcbnZhciBzdGFyZiA9IFwi4piFXCI7XG52YXIgc3RyYWlnaHRlcHNpbG9uID0gXCLPtVwiO1xudmFyIHN0cmFpZ2h0cGhpID0gXCLPlVwiO1xudmFyIHN0cm5zID0gXCLCr1wiO1xudmFyIHN1YiA9IFwi4oqCXCI7XG52YXIgU3ViID0gXCLii5BcIjtcbnZhciBzdWJkb3QgPSBcIuKqvVwiO1xudmFyIHN1YkUgPSBcIuKrhVwiO1xudmFyIHN1YmUgPSBcIuKKhlwiO1xudmFyIHN1YmVkb3QgPSBcIuKrg1wiO1xudmFyIHN1Ym11bHQgPSBcIuKrgVwiO1xudmFyIHN1Ym5FID0gXCLiq4tcIjtcbnZhciBzdWJuZSA9IFwi4oqKXCI7XG52YXIgc3VicGx1cyA9IFwi4qq/XCI7XG52YXIgc3VicmFyciA9IFwi4qW5XCI7XG52YXIgc3Vic2V0ID0gXCLiioJcIjtcbnZhciBTdWJzZXQgPSBcIuKLkFwiO1xudmFyIHN1YnNldGVxID0gXCLiioZcIjtcbnZhciBzdWJzZXRlcXEgPSBcIuKrhVwiO1xudmFyIFN1YnNldEVxdWFsID0gXCLiioZcIjtcbnZhciBzdWJzZXRuZXEgPSBcIuKKilwiO1xudmFyIHN1YnNldG5lcXEgPSBcIuKri1wiO1xudmFyIHN1YnNpbSA9IFwi4quHXCI7XG52YXIgc3Vic3ViID0gXCLiq5VcIjtcbnZhciBzdWJzdXAgPSBcIuKrk1wiO1xudmFyIHN1Y2NhcHByb3ggPSBcIuKquFwiO1xudmFyIHN1Y2MgPSBcIuKJu1wiO1xudmFyIHN1Y2NjdXJseWVxID0gXCLiib1cIjtcbnZhciBTdWNjZWVkcyA9IFwi4om7XCI7XG52YXIgU3VjY2VlZHNFcXVhbCA9IFwi4qqwXCI7XG52YXIgU3VjY2VlZHNTbGFudEVxdWFsID0gXCLiib1cIjtcbnZhciBTdWNjZWVkc1RpbGRlID0gXCLiib9cIjtcbnZhciBzdWNjZXEgPSBcIuKqsFwiO1xudmFyIHN1Y2NuYXBwcm94ID0gXCLiqrpcIjtcbnZhciBzdWNjbmVxcSA9IFwi4qq2XCI7XG52YXIgc3VjY25zaW0gPSBcIuKLqVwiO1xudmFyIHN1Y2NzaW0gPSBcIuKJv1wiO1xudmFyIFN1Y2hUaGF0ID0gXCLiiItcIjtcbnZhciBzdW0gPSBcIuKIkVwiO1xudmFyIFN1bSA9IFwi4oiRXCI7XG52YXIgc3VuZyA9IFwi4pmqXCI7XG52YXIgc3VwMSQxID0gXCLCuVwiO1xudmFyIHN1cDIkMSA9IFwiwrJcIjtcbnZhciBzdXAzJDEgPSBcIsKzXCI7XG52YXIgc3VwID0gXCLiioNcIjtcbnZhciBTdXAgPSBcIuKLkVwiO1xudmFyIHN1cGRvdCA9IFwi4qq+XCI7XG52YXIgc3VwZHN1YiA9IFwi4quYXCI7XG52YXIgc3VwRSA9IFwi4quGXCI7XG52YXIgc3VwZSA9IFwi4oqHXCI7XG52YXIgc3VwZWRvdCA9IFwi4quEXCI7XG52YXIgU3VwZXJzZXQgPSBcIuKKg1wiO1xudmFyIFN1cGVyc2V0RXF1YWwgPSBcIuKKh1wiO1xudmFyIHN1cGhzb2wgPSBcIuKfiVwiO1xudmFyIHN1cGhzdWIgPSBcIuKrl1wiO1xudmFyIHN1cGxhcnIgPSBcIuKlu1wiO1xudmFyIHN1cG11bHQgPSBcIuKrglwiO1xudmFyIHN1cG5FID0gXCLiq4xcIjtcbnZhciBzdXBuZSA9IFwi4oqLXCI7XG52YXIgc3VwcGx1cyA9IFwi4quAXCI7XG52YXIgc3Vwc2V0ID0gXCLiioNcIjtcbnZhciBTdXBzZXQgPSBcIuKLkVwiO1xudmFyIHN1cHNldGVxID0gXCLiiodcIjtcbnZhciBzdXBzZXRlcXEgPSBcIuKrhlwiO1xudmFyIHN1cHNldG5lcSA9IFwi4oqLXCI7XG52YXIgc3Vwc2V0bmVxcSA9IFwi4quMXCI7XG52YXIgc3Vwc2ltID0gXCLiq4hcIjtcbnZhciBzdXBzdWIgPSBcIuKrlFwiO1xudmFyIHN1cHN1cCA9IFwi4quWXCI7XG52YXIgc3dhcmhrID0gXCLipKZcIjtcbnZhciBzd2FyciA9IFwi4oaZXCI7XG52YXIgc3dBcnIgPSBcIuKHmVwiO1xudmFyIHN3YXJyb3cgPSBcIuKGmVwiO1xudmFyIHN3bndhciA9IFwi4qSqXCI7XG52YXIgc3psaWckMSA9IFwiw59cIjtcbnZhciBUYWIgPSBcIlxcdFwiO1xudmFyIHRhcmdldCA9IFwi4oyWXCI7XG52YXIgVGF1ID0gXCLOpFwiO1xudmFyIHRhdSA9IFwiz4RcIjtcbnZhciB0YnJrID0gXCLijrRcIjtcbnZhciBUY2Fyb24gPSBcIsWkXCI7XG52YXIgdGNhcm9uID0gXCLFpVwiO1xudmFyIFRjZWRpbCA9IFwixaJcIjtcbnZhciB0Y2VkaWwgPSBcIsWjXCI7XG52YXIgVGN5ID0gXCLQolwiO1xudmFyIHRjeSA9IFwi0YJcIjtcbnZhciB0ZG90ID0gXCLig5tcIjtcbnZhciB0ZWxyZWMgPSBcIuKMlVwiO1xudmFyIFRmciA9IFwi8J2Ul1wiO1xudmFyIHRmciA9IFwi8J2UsVwiO1xudmFyIHRoZXJlNCA9IFwi4oi0XCI7XG52YXIgdGhlcmVmb3JlID0gXCLiiLRcIjtcbnZhciBUaGVyZWZvcmUgPSBcIuKItFwiO1xudmFyIFRoZXRhID0gXCLOmFwiO1xudmFyIHRoZXRhID0gXCLOuFwiO1xudmFyIHRoZXRhc3ltID0gXCLPkVwiO1xudmFyIHRoZXRhdiA9IFwiz5FcIjtcbnZhciB0aGlja2FwcHJveCA9IFwi4omIXCI7XG52YXIgdGhpY2tzaW0gPSBcIuKIvFwiO1xudmFyIFRoaWNrU3BhY2UgPSBcIuKBn+KAilwiO1xudmFyIFRoaW5TcGFjZSA9IFwi4oCJXCI7XG52YXIgdGhpbnNwID0gXCLigIlcIjtcbnZhciB0aGthcCA9IFwi4omIXCI7XG52YXIgdGhrc2ltID0gXCLiiLxcIjtcbnZhciBUSE9STiQxID0gXCLDnlwiO1xudmFyIHRob3JuJDEgPSBcIsO+XCI7XG52YXIgdGlsZGUgPSBcIsucXCI7XG52YXIgVGlsZGUgPSBcIuKIvFwiO1xudmFyIFRpbGRlRXF1YWwgPSBcIuKJg1wiO1xudmFyIFRpbGRlRnVsbEVxdWFsID0gXCLiiYVcIjtcbnZhciBUaWxkZVRpbGRlID0gXCLiiYhcIjtcbnZhciB0aW1lc2JhciA9IFwi4qixXCI7XG52YXIgdGltZXNiID0gXCLiiqBcIjtcbnZhciB0aW1lcyQxID0gXCLDl1wiO1xudmFyIHRpbWVzZCA9IFwi4qiwXCI7XG52YXIgdGludCA9IFwi4oitXCI7XG52YXIgdG9lYSA9IFwi4qSoXCI7XG52YXIgdG9wYm90ID0gXCLijLZcIjtcbnZhciB0b3BjaXIgPSBcIuKrsVwiO1xudmFyIHRvcCA9IFwi4oqkXCI7XG52YXIgVG9wZiA9IFwi8J2Vi1wiO1xudmFyIHRvcGYgPSBcIvCdlaVcIjtcbnZhciB0b3Bmb3JrID0gXCLiq5pcIjtcbnZhciB0b3NhID0gXCLipKlcIjtcbnZhciB0cHJpbWUgPSBcIuKAtFwiO1xudmFyIHRyYWRlID0gXCLihKJcIjtcbnZhciBUUkFERSA9IFwi4oSiXCI7XG52YXIgdHJpYW5nbGUgPSBcIuKWtVwiO1xudmFyIHRyaWFuZ2xlZG93biA9IFwi4pa/XCI7XG52YXIgdHJpYW5nbGVsZWZ0ID0gXCLil4NcIjtcbnZhciB0cmlhbmdsZWxlZnRlcSA9IFwi4oq0XCI7XG52YXIgdHJpYW5nbGVxID0gXCLiiZxcIjtcbnZhciB0cmlhbmdsZXJpZ2h0ID0gXCLilrlcIjtcbnZhciB0cmlhbmdsZXJpZ2h0ZXEgPSBcIuKKtVwiO1xudmFyIHRyaWRvdCA9IFwi4pesXCI7XG52YXIgdHJpZSA9IFwi4omcXCI7XG52YXIgdHJpbWludXMgPSBcIuKoulwiO1xudmFyIFRyaXBsZURvdCA9IFwi4oObXCI7XG52YXIgdHJpcGx1cyA9IFwi4qi5XCI7XG52YXIgdHJpc2IgPSBcIuKnjVwiO1xudmFyIHRyaXRpbWUgPSBcIuKou1wiO1xudmFyIHRycGV6aXVtID0gXCLij6JcIjtcbnZhciBUc2NyID0gXCLwnZKvXCI7XG52YXIgdHNjciA9IFwi8J2TiVwiO1xudmFyIFRTY3kgPSBcItCmXCI7XG52YXIgdHNjeSA9IFwi0YZcIjtcbnZhciBUU0hjeSA9IFwi0ItcIjtcbnZhciB0c2hjeSA9IFwi0ZtcIjtcbnZhciBUc3Ryb2sgPSBcIsWmXCI7XG52YXIgdHN0cm9rID0gXCLFp1wiO1xudmFyIHR3aXh0ID0gXCLiiaxcIjtcbnZhciB0d29oZWFkbGVmdGFycm93ID0gXCLihp5cIjtcbnZhciB0d29oZWFkcmlnaHRhcnJvdyA9IFwi4oagXCI7XG52YXIgVWFjdXRlJDEgPSBcIsOaXCI7XG52YXIgdWFjdXRlJDEgPSBcIsO6XCI7XG52YXIgdWFyciA9IFwi4oaRXCI7XG52YXIgVWFyciA9IFwi4oafXCI7XG52YXIgdUFyciA9IFwi4oeRXCI7XG52YXIgVWFycm9jaXIgPSBcIuKliVwiO1xudmFyIFVicmN5ID0gXCLQjlwiO1xudmFyIHVicmN5ID0gXCLRnlwiO1xudmFyIFVicmV2ZSA9IFwixaxcIjtcbnZhciB1YnJldmUgPSBcIsWtXCI7XG52YXIgVWNpcmMkMSA9IFwiw5tcIjtcbnZhciB1Y2lyYyQxID0gXCLDu1wiO1xudmFyIFVjeSA9IFwi0KNcIjtcbnZhciB1Y3kgPSBcItGDXCI7XG52YXIgdWRhcnIgPSBcIuKHhVwiO1xudmFyIFVkYmxhYyA9IFwixbBcIjtcbnZhciB1ZGJsYWMgPSBcIsWxXCI7XG52YXIgdWRoYXIgPSBcIuKlrlwiO1xudmFyIHVmaXNodCA9IFwi4qW+XCI7XG52YXIgVWZyID0gXCLwnZSYXCI7XG52YXIgdWZyID0gXCLwnZSyXCI7XG52YXIgVWdyYXZlJDEgPSBcIsOZXCI7XG52YXIgdWdyYXZlJDEgPSBcIsO5XCI7XG52YXIgdUhhciA9IFwi4qWjXCI7XG52YXIgdWhhcmwgPSBcIuKGv1wiO1xudmFyIHVoYXJyID0gXCLihr5cIjtcbnZhciB1aGJsayA9IFwi4paAXCI7XG52YXIgdWxjb3JuID0gXCLijJxcIjtcbnZhciB1bGNvcm5lciA9IFwi4oycXCI7XG52YXIgdWxjcm9wID0gXCLijI9cIjtcbnZhciB1bHRyaSA9IFwi4pe4XCI7XG52YXIgVW1hY3IgPSBcIsWqXCI7XG52YXIgdW1hY3IgPSBcIsWrXCI7XG52YXIgdW1sJDEgPSBcIsKoXCI7XG52YXIgVW5kZXJCYXIgPSBcIl9cIjtcbnZhciBVbmRlckJyYWNlID0gXCLij59cIjtcbnZhciBVbmRlckJyYWNrZXQgPSBcIuKOtVwiO1xudmFyIFVuZGVyUGFyZW50aGVzaXMgPSBcIuKPnVwiO1xudmFyIFVuaW9uID0gXCLii4NcIjtcbnZhciBVbmlvblBsdXMgPSBcIuKKjlwiO1xudmFyIFVvZ29uID0gXCLFslwiO1xudmFyIHVvZ29uID0gXCLFs1wiO1xudmFyIFVvcGYgPSBcIvCdlYxcIjtcbnZhciB1b3BmID0gXCLwnZWmXCI7XG52YXIgVXBBcnJvd0JhciA9IFwi4qSSXCI7XG52YXIgdXBhcnJvdyA9IFwi4oaRXCI7XG52YXIgVXBBcnJvdyA9IFwi4oaRXCI7XG52YXIgVXBhcnJvdyA9IFwi4oeRXCI7XG52YXIgVXBBcnJvd0Rvd25BcnJvdyA9IFwi4oeFXCI7XG52YXIgdXBkb3duYXJyb3cgPSBcIuKGlVwiO1xudmFyIFVwRG93bkFycm93ID0gXCLihpVcIjtcbnZhciBVcGRvd25hcnJvdyA9IFwi4oeVXCI7XG52YXIgVXBFcXVpbGlicml1bSA9IFwi4qWuXCI7XG52YXIgdXBoYXJwb29ubGVmdCA9IFwi4oa/XCI7XG52YXIgdXBoYXJwb29ucmlnaHQgPSBcIuKGvlwiO1xudmFyIHVwbHVzID0gXCLiio5cIjtcbnZhciBVcHBlckxlZnRBcnJvdyA9IFwi4oaWXCI7XG52YXIgVXBwZXJSaWdodEFycm93ID0gXCLihpdcIjtcbnZhciB1cHNpID0gXCLPhVwiO1xudmFyIFVwc2kgPSBcIs+SXCI7XG52YXIgdXBzaWggPSBcIs+SXCI7XG52YXIgVXBzaWxvbiA9IFwizqVcIjtcbnZhciB1cHNpbG9uID0gXCLPhVwiO1xudmFyIFVwVGVlQXJyb3cgPSBcIuKGpVwiO1xudmFyIFVwVGVlID0gXCLiiqVcIjtcbnZhciB1cHVwYXJyb3dzID0gXCLih4hcIjtcbnZhciB1cmNvcm4gPSBcIuKMnVwiO1xudmFyIHVyY29ybmVyID0gXCLijJ1cIjtcbnZhciB1cmNyb3AgPSBcIuKMjlwiO1xudmFyIFVyaW5nID0gXCLFrlwiO1xudmFyIHVyaW5nID0gXCLFr1wiO1xudmFyIHVydHJpID0gXCLil7lcIjtcbnZhciBVc2NyID0gXCLwnZKwXCI7XG52YXIgdXNjciA9IFwi8J2TilwiO1xudmFyIHV0ZG90ID0gXCLii7BcIjtcbnZhciBVdGlsZGUgPSBcIsWoXCI7XG52YXIgdXRpbGRlID0gXCLFqVwiO1xudmFyIHV0cmkgPSBcIuKWtVwiO1xudmFyIHV0cmlmID0gXCLilrRcIjtcbnZhciB1dWFyciA9IFwi4oeIXCI7XG52YXIgVXVtbCQxID0gXCLDnFwiO1xudmFyIHV1bWwkMSA9IFwiw7xcIjtcbnZhciB1d2FuZ2xlID0gXCLipqdcIjtcbnZhciB2YW5ncnQgPSBcIuKmnFwiO1xudmFyIHZhcmVwc2lsb24gPSBcIs+1XCI7XG52YXIgdmFya2FwcGEgPSBcIs+wXCI7XG52YXIgdmFybm90aGluZyA9IFwi4oiFXCI7XG52YXIgdmFycGhpID0gXCLPlVwiO1xudmFyIHZhcnBpID0gXCLPllwiO1xudmFyIHZhcnByb3B0byA9IFwi4oidXCI7XG52YXIgdmFyciA9IFwi4oaVXCI7XG52YXIgdkFyciA9IFwi4oeVXCI7XG52YXIgdmFycmhvID0gXCLPsVwiO1xudmFyIHZhcnNpZ21hID0gXCLPglwiO1xudmFyIHZhcnN1YnNldG5lcSA9IFwi4oqK77iAXCI7XG52YXIgdmFyc3Vic2V0bmVxcSA9IFwi4quL77iAXCI7XG52YXIgdmFyc3Vwc2V0bmVxID0gXCLiiovvuIBcIjtcbnZhciB2YXJzdXBzZXRuZXFxID0gXCLiq4zvuIBcIjtcbnZhciB2YXJ0aGV0YSA9IFwiz5FcIjtcbnZhciB2YXJ0cmlhbmdsZWxlZnQgPSBcIuKKslwiO1xudmFyIHZhcnRyaWFuZ2xlcmlnaHQgPSBcIuKKs1wiO1xudmFyIHZCYXIgPSBcIuKrqFwiO1xudmFyIFZiYXIgPSBcIuKrq1wiO1xudmFyIHZCYXJ2ID0gXCLiq6lcIjtcbnZhciBWY3kgPSBcItCSXCI7XG52YXIgdmN5ID0gXCLQslwiO1xudmFyIHZkYXNoID0gXCLiiqJcIjtcbnZhciB2RGFzaCA9IFwi4oqoXCI7XG52YXIgVmRhc2ggPSBcIuKKqVwiO1xudmFyIFZEYXNoID0gXCLiiqtcIjtcbnZhciBWZGFzaGwgPSBcIuKrplwiO1xudmFyIHZlZWJhciA9IFwi4oq7XCI7XG52YXIgdmVlID0gXCLiiKhcIjtcbnZhciBWZWUgPSBcIuKLgVwiO1xudmFyIHZlZWVxID0gXCLiiZpcIjtcbnZhciB2ZWxsaXAgPSBcIuKLrlwiO1xudmFyIHZlcmJhciA9IFwifFwiO1xudmFyIFZlcmJhciA9IFwi4oCWXCI7XG52YXIgdmVydCA9IFwifFwiO1xudmFyIFZlcnQgPSBcIuKAllwiO1xudmFyIFZlcnRpY2FsQmFyID0gXCLiiKNcIjtcbnZhciBWZXJ0aWNhbExpbmUgPSBcInxcIjtcbnZhciBWZXJ0aWNhbFNlcGFyYXRvciA9IFwi4p2YXCI7XG52YXIgVmVydGljYWxUaWxkZSA9IFwi4omAXCI7XG52YXIgVmVyeVRoaW5TcGFjZSA9IFwi4oCKXCI7XG52YXIgVmZyID0gXCLwnZSZXCI7XG52YXIgdmZyID0gXCLwnZSzXCI7XG52YXIgdmx0cmkgPSBcIuKKslwiO1xudmFyIHZuc3ViID0gXCLiioLig5JcIjtcbnZhciB2bnN1cCA9IFwi4oqD4oOSXCI7XG52YXIgVm9wZiA9IFwi8J2VjVwiO1xudmFyIHZvcGYgPSBcIvCdladcIjtcbnZhciB2cHJvcCA9IFwi4oidXCI7XG52YXIgdnJ0cmkgPSBcIuKKs1wiO1xudmFyIFZzY3IgPSBcIvCdkrFcIjtcbnZhciB2c2NyID0gXCLwnZOLXCI7XG52YXIgdnN1Ym5FID0gXCLiq4vvuIBcIjtcbnZhciB2c3VibmUgPSBcIuKKiu+4gFwiO1xudmFyIHZzdXBuRSA9IFwi4quM77iAXCI7XG52YXIgdnN1cG5lID0gXCLiiovvuIBcIjtcbnZhciBWdmRhc2ggPSBcIuKKqlwiO1xudmFyIHZ6aWd6YWcgPSBcIuKmmlwiO1xudmFyIFdjaXJjID0gXCLFtFwiO1xudmFyIHdjaXJjID0gXCLFtVwiO1xudmFyIHdlZGJhciA9IFwi4qmfXCI7XG52YXIgd2VkZ2UgPSBcIuKIp1wiO1xudmFyIFdlZGdlID0gXCLii4BcIjtcbnZhciB3ZWRnZXEgPSBcIuKJmVwiO1xudmFyIHdlaWVycCA9IFwi4oSYXCI7XG52YXIgV2ZyID0gXCLwnZSaXCI7XG52YXIgd2ZyID0gXCLwnZS0XCI7XG52YXIgV29wZiA9IFwi8J2VjlwiO1xudmFyIHdvcGYgPSBcIvCdlahcIjtcbnZhciB3cCA9IFwi4oSYXCI7XG52YXIgd3IgPSBcIuKJgFwiO1xudmFyIHdyZWF0aCA9IFwi4omAXCI7XG52YXIgV3NjciA9IFwi8J2SslwiO1xudmFyIHdzY3IgPSBcIvCdk4xcIjtcbnZhciB4Y2FwID0gXCLii4JcIjtcbnZhciB4Y2lyYyA9IFwi4pevXCI7XG52YXIgeGN1cCA9IFwi4ouDXCI7XG52YXIgeGR0cmkgPSBcIuKWvVwiO1xudmFyIFhmciA9IFwi8J2Um1wiO1xudmFyIHhmciA9IFwi8J2UtVwiO1xudmFyIHhoYXJyID0gXCLin7dcIjtcbnZhciB4aEFyciA9IFwi4p+6XCI7XG52YXIgWGkgPSBcIs6eXCI7XG52YXIgeGkgPSBcIs6+XCI7XG52YXIgeGxhcnIgPSBcIuKftVwiO1xudmFyIHhsQXJyID0gXCLin7hcIjtcbnZhciB4bWFwID0gXCLin7xcIjtcbnZhciB4bmlzID0gXCLii7tcIjtcbnZhciB4b2RvdCA9IFwi4qiAXCI7XG52YXIgWG9wZiA9IFwi8J2Vj1wiO1xudmFyIHhvcGYgPSBcIvCdlalcIjtcbnZhciB4b3BsdXMgPSBcIuKogVwiO1xudmFyIHhvdGltZSA9IFwi4qiCXCI7XG52YXIgeHJhcnIgPSBcIuKftlwiO1xudmFyIHhyQXJyID0gXCLin7lcIjtcbnZhciBYc2NyID0gXCLwnZKzXCI7XG52YXIgeHNjciA9IFwi8J2TjVwiO1xudmFyIHhzcWN1cCA9IFwi4qiGXCI7XG52YXIgeHVwbHVzID0gXCLiqIRcIjtcbnZhciB4dXRyaSA9IFwi4pazXCI7XG52YXIgeHZlZSA9IFwi4ouBXCI7XG52YXIgeHdlZGdlID0gXCLii4BcIjtcbnZhciBZYWN1dGUkMSA9IFwiw51cIjtcbnZhciB5YWN1dGUkMSA9IFwiw71cIjtcbnZhciBZQWN5ID0gXCLQr1wiO1xudmFyIHlhY3kgPSBcItGPXCI7XG52YXIgWWNpcmMgPSBcIsW2XCI7XG52YXIgeWNpcmMgPSBcIsW3XCI7XG52YXIgWWN5ID0gXCLQq1wiO1xudmFyIHljeSA9IFwi0YtcIjtcbnZhciB5ZW4kMSA9IFwiwqVcIjtcbnZhciBZZnIgPSBcIvCdlJxcIjtcbnZhciB5ZnIgPSBcIvCdlLZcIjtcbnZhciBZSWN5ID0gXCLQh1wiO1xudmFyIHlpY3kgPSBcItGXXCI7XG52YXIgWW9wZiA9IFwi8J2VkFwiO1xudmFyIHlvcGYgPSBcIvCdlapcIjtcbnZhciBZc2NyID0gXCLwnZK0XCI7XG52YXIgeXNjciA9IFwi8J2TjlwiO1xudmFyIFlVY3kgPSBcItCuXCI7XG52YXIgeXVjeSA9IFwi0Y5cIjtcbnZhciB5dW1sJDEgPSBcIsO/XCI7XG52YXIgWXVtbCA9IFwixbhcIjtcbnZhciBaYWN1dGUgPSBcIsW5XCI7XG52YXIgemFjdXRlID0gXCLFulwiO1xudmFyIFpjYXJvbiA9IFwixb1cIjtcbnZhciB6Y2Fyb24gPSBcIsW+XCI7XG52YXIgWmN5ID0gXCLQl1wiO1xudmFyIHpjeSA9IFwi0LdcIjtcbnZhciBaZG90ID0gXCLFu1wiO1xudmFyIHpkb3QgPSBcIsW8XCI7XG52YXIgemVldHJmID0gXCLihKhcIjtcbnZhciBaZXJvV2lkdGhTcGFjZSA9IFwi4oCLXCI7XG52YXIgWmV0YSA9IFwizpZcIjtcbnZhciB6ZXRhID0gXCLOtlwiO1xudmFyIHpmciA9IFwi8J2Ut1wiO1xudmFyIFpmciA9IFwi4oSoXCI7XG52YXIgWkhjeSA9IFwi0JZcIjtcbnZhciB6aGN5ID0gXCLQtlwiO1xudmFyIHppZ3JhcnIgPSBcIuKHnVwiO1xudmFyIHpvcGYgPSBcIvCdlatcIjtcbnZhciBab3BmID0gXCLihKRcIjtcbnZhciBac2NyID0gXCLwnZK1XCI7XG52YXIgenNjciA9IFwi8J2Tj1wiO1xudmFyIHp3aiA9IFwi4oCNXCI7XG52YXIgenduaiA9IFwi4oCMXCI7XG52YXIgcmVxdWlyZSQkMSQxID0ge1xuXHRBYWN1dGU6IEFhY3V0ZSQxLFxuXHRhYWN1dGU6IGFhY3V0ZSQxLFxuXHRBYnJldmU6IEFicmV2ZSxcblx0YWJyZXZlOiBhYnJldmUsXG5cdGFjOiBhYyxcblx0YWNkOiBhY2QsXG5cdGFjRTogYWNFLFxuXHRBY2lyYzogQWNpcmMkMSxcblx0YWNpcmM6IGFjaXJjJDEsXG5cdGFjdXRlOiBhY3V0ZSQxLFxuXHRBY3k6IEFjeSxcblx0YWN5OiBhY3ksXG5cdEFFbGlnOiBBRWxpZyQxLFxuXHRhZWxpZzogYWVsaWckMSxcblx0YWY6IGFmLFxuXHRBZnI6IEFmcixcblx0YWZyOiBhZnIsXG5cdEFncmF2ZTogQWdyYXZlJDEsXG5cdGFncmF2ZTogYWdyYXZlJDEsXG5cdGFsZWZzeW06IGFsZWZzeW0sXG5cdGFsZXBoOiBhbGVwaCxcblx0QWxwaGE6IEFscGhhLFxuXHRhbHBoYTogYWxwaGEsXG5cdEFtYWNyOiBBbWFjcixcblx0YW1hY3I6IGFtYWNyLFxuXHRhbWFsZzogYW1hbGcsXG5cdGFtcDogYW1wJDIsXG5cdEFNUDogQU1QJDEsXG5cdGFuZGFuZDogYW5kYW5kLFxuXHRBbmQ6IEFuZCxcblx0YW5kOiBhbmQsXG5cdGFuZGQ6IGFuZGQsXG5cdGFuZHNsb3BlOiBhbmRzbG9wZSxcblx0YW5kdjogYW5kdixcblx0YW5nOiBhbmcsXG5cdGFuZ2U6IGFuZ2UsXG5cdGFuZ2xlOiBhbmdsZSxcblx0YW5nbXNkYWE6IGFuZ21zZGFhLFxuXHRhbmdtc2RhYjogYW5nbXNkYWIsXG5cdGFuZ21zZGFjOiBhbmdtc2RhYyxcblx0YW5nbXNkYWQ6IGFuZ21zZGFkLFxuXHRhbmdtc2RhZTogYW5nbXNkYWUsXG5cdGFuZ21zZGFmOiBhbmdtc2RhZixcblx0YW5nbXNkYWc6IGFuZ21zZGFnLFxuXHRhbmdtc2RhaDogYW5nbXNkYWgsXG5cdGFuZ21zZDogYW5nbXNkLFxuXHRhbmdydDogYW5ncnQsXG5cdGFuZ3J0dmI6IGFuZ3J0dmIsXG5cdGFuZ3J0dmJkOiBhbmdydHZiZCxcblx0YW5nc3BoOiBhbmdzcGgsXG5cdGFuZ3N0OiBhbmdzdCxcblx0YW5nemFycjogYW5nemFycixcblx0QW9nb246IEFvZ29uLFxuXHRhb2dvbjogYW9nb24sXG5cdEFvcGY6IEFvcGYsXG5cdGFvcGY6IGFvcGYsXG5cdGFwYWNpcjogYXBhY2lyLFxuXHRhcDogYXAsXG5cdGFwRTogYXBFLFxuXHRhcGU6IGFwZSxcblx0YXBpZDogYXBpZCxcblx0YXBvczogYXBvcyQxLFxuXHRBcHBseUZ1bmN0aW9uOiBBcHBseUZ1bmN0aW9uLFxuXHRhcHByb3g6IGFwcHJveCxcblx0YXBwcm94ZXE6IGFwcHJveGVxLFxuXHRBcmluZzogQXJpbmckMSxcblx0YXJpbmc6IGFyaW5nJDEsXG5cdEFzY3I6IEFzY3IsXG5cdGFzY3I6IGFzY3IsXG5cdEFzc2lnbjogQXNzaWduLFxuXHRhc3Q6IGFzdCxcblx0YXN5bXA6IGFzeW1wLFxuXHRhc3ltcGVxOiBhc3ltcGVxLFxuXHRBdGlsZGU6IEF0aWxkZSQxLFxuXHRhdGlsZGU6IGF0aWxkZSQxLFxuXHRBdW1sOiBBdW1sJDEsXG5cdGF1bWw6IGF1bWwkMSxcblx0YXdjb25pbnQ6IGF3Y29uaW50LFxuXHRhd2ludDogYXdpbnQsXG5cdGJhY2tjb25nOiBiYWNrY29uZyxcblx0YmFja2Vwc2lsb246IGJhY2tlcHNpbG9uLFxuXHRiYWNrcHJpbWU6IGJhY2twcmltZSxcblx0YmFja3NpbTogYmFja3NpbSxcblx0YmFja3NpbWVxOiBiYWNrc2ltZXEsXG5cdEJhY2tzbGFzaDogQmFja3NsYXNoLFxuXHRCYXJ2OiBCYXJ2LFxuXHRiYXJ2ZWU6IGJhcnZlZSxcblx0YmFyd2VkOiBiYXJ3ZWQsXG5cdEJhcndlZDogQmFyd2VkLFxuXHRiYXJ3ZWRnZTogYmFyd2VkZ2UsXG5cdGJicms6IGJicmssXG5cdGJicmt0YnJrOiBiYnJrdGJyayxcblx0YmNvbmc6IGJjb25nLFxuXHRCY3k6IEJjeSxcblx0YmN5OiBiY3ksXG5cdGJkcXVvOiBiZHF1byxcblx0YmVjYXVzOiBiZWNhdXMsXG5cdGJlY2F1c2U6IGJlY2F1c2UsXG5cdEJlY2F1c2U6IEJlY2F1c2UsXG5cdGJlbXB0eXY6IGJlbXB0eXYsXG5cdGJlcHNpOiBiZXBzaSxcblx0YmVybm91OiBiZXJub3UsXG5cdEJlcm5vdWxsaXM6IEJlcm5vdWxsaXMsXG5cdEJldGE6IEJldGEsXG5cdGJldGE6IGJldGEsXG5cdGJldGg6IGJldGgsXG5cdGJldHdlZW46IGJldHdlZW4sXG5cdEJmcjogQmZyLFxuXHRiZnI6IGJmcixcblx0YmlnY2FwOiBiaWdjYXAsXG5cdGJpZ2NpcmM6IGJpZ2NpcmMsXG5cdGJpZ2N1cDogYmlnY3VwLFxuXHRiaWdvZG90OiBiaWdvZG90LFxuXHRiaWdvcGx1czogYmlnb3BsdXMsXG5cdGJpZ290aW1lczogYmlnb3RpbWVzLFxuXHRiaWdzcWN1cDogYmlnc3FjdXAsXG5cdGJpZ3N0YXI6IGJpZ3N0YXIsXG5cdGJpZ3RyaWFuZ2xlZG93bjogYmlndHJpYW5nbGVkb3duLFxuXHRiaWd0cmlhbmdsZXVwOiBiaWd0cmlhbmdsZXVwLFxuXHRiaWd1cGx1czogYmlndXBsdXMsXG5cdGJpZ3ZlZTogYmlndmVlLFxuXHRiaWd3ZWRnZTogYmlnd2VkZ2UsXG5cdGJrYXJvdzogYmthcm93LFxuXHRibGFja2xvemVuZ2U6IGJsYWNrbG96ZW5nZSxcblx0YmxhY2tzcXVhcmU6IGJsYWNrc3F1YXJlLFxuXHRibGFja3RyaWFuZ2xlOiBibGFja3RyaWFuZ2xlLFxuXHRibGFja3RyaWFuZ2xlZG93bjogYmxhY2t0cmlhbmdsZWRvd24sXG5cdGJsYWNrdHJpYW5nbGVsZWZ0OiBibGFja3RyaWFuZ2xlbGVmdCxcblx0YmxhY2t0cmlhbmdsZXJpZ2h0OiBibGFja3RyaWFuZ2xlcmlnaHQsXG5cdGJsYW5rOiBibGFuayxcblx0YmxrMTI6IGJsazEyLFxuXHRibGsxNDogYmxrMTQsXG5cdGJsazM0OiBibGszNCxcblx0YmxvY2s6IGJsb2NrLFxuXHRibmU6IGJuZSxcblx0Ym5lcXVpdjogYm5lcXVpdixcblx0Yk5vdDogYk5vdCxcblx0Ym5vdDogYm5vdCxcblx0Qm9wZjogQm9wZixcblx0Ym9wZjogYm9wZixcblx0Ym90OiBib3QsXG5cdGJvdHRvbTogYm90dG9tLFxuXHRib3d0aWU6IGJvd3RpZSxcblx0Ym94Ym94OiBib3hib3gsXG5cdGJveGRsOiBib3hkbCxcblx0Ym94ZEw6IGJveGRMLFxuXHRib3hEbDogYm94RGwsXG5cdGJveERMOiBib3hETCxcblx0Ym94ZHI6IGJveGRyLFxuXHRib3hkUjogYm94ZFIsXG5cdGJveERyOiBib3hEcixcblx0Ym94RFI6IGJveERSLFxuXHRib3hoOiBib3hoLFxuXHRib3hIOiBib3hILFxuXHRib3hoZDogYm94aGQsXG5cdGJveEhkOiBib3hIZCxcblx0Ym94aEQ6IGJveGhELFxuXHRib3hIRDogYm94SEQsXG5cdGJveGh1OiBib3hodSxcblx0Ym94SHU6IGJveEh1LFxuXHRib3hoVTogYm94aFUsXG5cdGJveEhVOiBib3hIVSxcblx0Ym94bWludXM6IGJveG1pbnVzLFxuXHRib3hwbHVzOiBib3hwbHVzLFxuXHRib3h0aW1lczogYm94dGltZXMsXG5cdGJveHVsOiBib3h1bCxcblx0Ym94dUw6IGJveHVMLFxuXHRib3hVbDogYm94VWwsXG5cdGJveFVMOiBib3hVTCxcblx0Ym94dXI6IGJveHVyLFxuXHRib3h1UjogYm94dVIsXG5cdGJveFVyOiBib3hVcixcblx0Ym94VVI6IGJveFVSLFxuXHRib3h2OiBib3h2LFxuXHRib3hWOiBib3hWLFxuXHRib3h2aDogYm94dmgsXG5cdGJveHZIOiBib3h2SCxcblx0Ym94Vmg6IGJveFZoLFxuXHRib3hWSDogYm94VkgsXG5cdGJveHZsOiBib3h2bCxcblx0Ym94dkw6IGJveHZMLFxuXHRib3hWbDogYm94VmwsXG5cdGJveFZMOiBib3hWTCxcblx0Ym94dnI6IGJveHZyLFxuXHRib3h2UjogYm94dlIsXG5cdGJveFZyOiBib3hWcixcblx0Ym94VlI6IGJveFZSLFxuXHRicHJpbWU6IGJwcmltZSxcblx0YnJldmU6IGJyZXZlLFxuXHRCcmV2ZTogQnJldmUsXG5cdGJydmJhcjogYnJ2YmFyJDEsXG5cdGJzY3I6IGJzY3IsXG5cdEJzY3I6IEJzY3IsXG5cdGJzZW1pOiBic2VtaSxcblx0YnNpbTogYnNpbSxcblx0YnNpbWU6IGJzaW1lLFxuXHRic29sYjogYnNvbGIsXG5cdGJzb2w6IGJzb2wsXG5cdGJzb2xoc3ViOiBic29saHN1Yixcblx0YnVsbDogYnVsbCxcblx0YnVsbGV0OiBidWxsZXQsXG5cdGJ1bXA6IGJ1bXAsXG5cdGJ1bXBFOiBidW1wRSxcblx0YnVtcGU6IGJ1bXBlLFxuXHRCdW1wZXE6IEJ1bXBlcSxcblx0YnVtcGVxOiBidW1wZXEsXG5cdENhY3V0ZTogQ2FjdXRlLFxuXHRjYWN1dGU6IGNhY3V0ZSxcblx0Y2FwYW5kOiBjYXBhbmQsXG5cdGNhcGJyY3VwOiBjYXBicmN1cCxcblx0Y2FwY2FwOiBjYXBjYXAsXG5cdGNhcDogY2FwLFxuXHRDYXA6IENhcCxcblx0Y2FwY3VwOiBjYXBjdXAsXG5cdGNhcGRvdDogY2FwZG90LFxuXHRDYXBpdGFsRGlmZmVyZW50aWFsRDogQ2FwaXRhbERpZmZlcmVudGlhbEQsXG5cdGNhcHM6IGNhcHMsXG5cdGNhcmV0OiBjYXJldCxcblx0Y2Fyb246IGNhcm9uLFxuXHRDYXlsZXlzOiBDYXlsZXlzLFxuXHRjY2FwczogY2NhcHMsXG5cdENjYXJvbjogQ2Nhcm9uLFxuXHRjY2Fyb246IGNjYXJvbixcblx0Q2NlZGlsOiBDY2VkaWwkMSxcblx0Y2NlZGlsOiBjY2VkaWwkMSxcblx0Q2NpcmM6IENjaXJjLFxuXHRjY2lyYzogY2NpcmMsXG5cdENjb25pbnQ6IENjb25pbnQsXG5cdGNjdXBzOiBjY3Vwcyxcblx0Y2N1cHNzbTogY2N1cHNzbSxcblx0Q2RvdDogQ2RvdCxcblx0Y2RvdDogY2RvdCxcblx0Y2VkaWw6IGNlZGlsJDEsXG5cdENlZGlsbGE6IENlZGlsbGEsXG5cdGNlbXB0eXY6IGNlbXB0eXYsXG5cdGNlbnQ6IGNlbnQkMSxcblx0Y2VudGVyZG90OiBjZW50ZXJkb3QsXG5cdENlbnRlckRvdDogQ2VudGVyRG90LFxuXHRjZnI6IGNmcixcblx0Q2ZyOiBDZnIsXG5cdENIY3k6IENIY3ksXG5cdGNoY3k6IGNoY3ksXG5cdGNoZWNrOiBjaGVjayxcblx0Y2hlY2ttYXJrOiBjaGVja21hcmssXG5cdENoaTogQ2hpLFxuXHRjaGk6IGNoaSxcblx0Y2lyYzogY2lyYyxcblx0Y2lyY2VxOiBjaXJjZXEsXG5cdGNpcmNsZWFycm93bGVmdDogY2lyY2xlYXJyb3dsZWZ0LFxuXHRjaXJjbGVhcnJvd3JpZ2h0OiBjaXJjbGVhcnJvd3JpZ2h0LFxuXHRjaXJjbGVkYXN0OiBjaXJjbGVkYXN0LFxuXHRjaXJjbGVkY2lyYzogY2lyY2xlZGNpcmMsXG5cdGNpcmNsZWRkYXNoOiBjaXJjbGVkZGFzaCxcblx0Q2lyY2xlRG90OiBDaXJjbGVEb3QsXG5cdGNpcmNsZWRSOiBjaXJjbGVkUixcblx0Y2lyY2xlZFM6IGNpcmNsZWRTLFxuXHRDaXJjbGVNaW51czogQ2lyY2xlTWludXMsXG5cdENpcmNsZVBsdXM6IENpcmNsZVBsdXMsXG5cdENpcmNsZVRpbWVzOiBDaXJjbGVUaW1lcyxcblx0Y2lyOiBjaXIsXG5cdGNpckU6IGNpckUsXG5cdGNpcmU6IGNpcmUsXG5cdGNpcmZuaW50OiBjaXJmbmludCxcblx0Y2lybWlkOiBjaXJtaWQsXG5cdGNpcnNjaXI6IGNpcnNjaXIsXG5cdENsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDogQ2xvY2t3aXNlQ29udG91ckludGVncmFsLFxuXHRDbG9zZUN1cmx5RG91YmxlUXVvdGU6IENsb3NlQ3VybHlEb3VibGVRdW90ZSxcblx0Q2xvc2VDdXJseVF1b3RlOiBDbG9zZUN1cmx5UXVvdGUsXG5cdGNsdWJzOiBjbHVicyxcblx0Y2x1YnN1aXQ6IGNsdWJzdWl0LFxuXHRjb2xvbjogY29sb24sXG5cdENvbG9uOiBDb2xvbixcblx0Q29sb25lOiBDb2xvbmUsXG5cdGNvbG9uZTogY29sb25lLFxuXHRjb2xvbmVxOiBjb2xvbmVxLFxuXHRjb21tYTogY29tbWEsXG5cdGNvbW1hdDogY29tbWF0LFxuXHRjb21wOiBjb21wLFxuXHRjb21wZm46IGNvbXBmbixcblx0Y29tcGxlbWVudDogY29tcGxlbWVudCxcblx0Y29tcGxleGVzOiBjb21wbGV4ZXMsXG5cdGNvbmc6IGNvbmcsXG5cdGNvbmdkb3Q6IGNvbmdkb3QsXG5cdENvbmdydWVudDogQ29uZ3J1ZW50LFxuXHRjb25pbnQ6IGNvbmludCxcblx0Q29uaW50OiBDb25pbnQsXG5cdENvbnRvdXJJbnRlZ3JhbDogQ29udG91ckludGVncmFsLFxuXHRjb3BmOiBjb3BmLFxuXHRDb3BmOiBDb3BmLFxuXHRjb3Byb2Q6IGNvcHJvZCxcblx0Q29wcm9kdWN0OiBDb3Byb2R1Y3QsXG5cdGNvcHk6IGNvcHkkMSxcblx0Q09QWTogQ09QWSQxLFxuXHRjb3B5c3I6IGNvcHlzcixcblx0Q291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDogQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCxcblx0Y3JhcnI6IGNyYXJyLFxuXHRjcm9zczogY3Jvc3MsXG5cdENyb3NzOiBDcm9zcyxcblx0Q3NjcjogQ3Njcixcblx0Y3NjcjogY3Njcixcblx0Y3N1YjogY3N1Yixcblx0Y3N1YmU6IGNzdWJlLFxuXHRjc3VwOiBjc3VwLFxuXHRjc3VwZTogY3N1cGUsXG5cdGN0ZG90OiBjdGRvdCxcblx0Y3VkYXJybDogY3VkYXJybCxcblx0Y3VkYXJycjogY3VkYXJycixcblx0Y3VlcHI6IGN1ZXByLFxuXHRjdWVzYzogY3Vlc2MsXG5cdGN1bGFycjogY3VsYXJyLFxuXHRjdWxhcnJwOiBjdWxhcnJwLFxuXHRjdXBicmNhcDogY3VwYnJjYXAsXG5cdGN1cGNhcDogY3VwY2FwLFxuXHRDdXBDYXA6IEN1cENhcCxcblx0Y3VwOiBjdXAsXG5cdEN1cDogQ3VwLFxuXHRjdXBjdXA6IGN1cGN1cCxcblx0Y3VwZG90OiBjdXBkb3QsXG5cdGN1cG9yOiBjdXBvcixcblx0Y3VwczogY3Vwcyxcblx0Y3VyYXJyOiBjdXJhcnIsXG5cdGN1cmFycm06IGN1cmFycm0sXG5cdGN1cmx5ZXFwcmVjOiBjdXJseWVxcHJlYyxcblx0Y3VybHllcXN1Y2M6IGN1cmx5ZXFzdWNjLFxuXHRjdXJseXZlZTogY3VybHl2ZWUsXG5cdGN1cmx5d2VkZ2U6IGN1cmx5d2VkZ2UsXG5cdGN1cnJlbjogY3VycmVuJDEsXG5cdGN1cnZlYXJyb3dsZWZ0OiBjdXJ2ZWFycm93bGVmdCxcblx0Y3VydmVhcnJvd3JpZ2h0OiBjdXJ2ZWFycm93cmlnaHQsXG5cdGN1dmVlOiBjdXZlZSxcblx0Y3V3ZWQ6IGN1d2VkLFxuXHRjd2NvbmludDogY3djb25pbnQsXG5cdGN3aW50OiBjd2ludCxcblx0Y3lsY3R5OiBjeWxjdHksXG5cdGRhZ2dlcjogZGFnZ2VyLFxuXHREYWdnZXI6IERhZ2dlcixcblx0ZGFsZXRoOiBkYWxldGgsXG5cdGRhcnI6IGRhcnIsXG5cdERhcnI6IERhcnIsXG5cdGRBcnI6IGRBcnIsXG5cdGRhc2g6IGRhc2gsXG5cdERhc2h2OiBEYXNodixcblx0ZGFzaHY6IGRhc2h2LFxuXHRkYmthcm93OiBkYmthcm93LFxuXHRkYmxhYzogZGJsYWMsXG5cdERjYXJvbjogRGNhcm9uLFxuXHRkY2Fyb246IGRjYXJvbixcblx0RGN5OiBEY3ksXG5cdGRjeTogZGN5LFxuXHRkZGFnZ2VyOiBkZGFnZ2VyLFxuXHRkZGFycjogZGRhcnIsXG5cdEREOiBERCxcblx0ZGQ6IGRkLFxuXHRERG90cmFoZDogRERvdHJhaGQsXG5cdGRkb3RzZXE6IGRkb3RzZXEsXG5cdGRlZzogZGVnJDEsXG5cdERlbDogRGVsLFxuXHREZWx0YTogRGVsdGEsXG5cdGRlbHRhOiBkZWx0YSxcblx0ZGVtcHR5djogZGVtcHR5dixcblx0ZGZpc2h0OiBkZmlzaHQsXG5cdERmcjogRGZyLFxuXHRkZnI6IGRmcixcblx0ZEhhcjogZEhhcixcblx0ZGhhcmw6IGRoYXJsLFxuXHRkaGFycjogZGhhcnIsXG5cdERpYWNyaXRpY2FsQWN1dGU6IERpYWNyaXRpY2FsQWN1dGUsXG5cdERpYWNyaXRpY2FsRG90OiBEaWFjcml0aWNhbERvdCxcblx0RGlhY3JpdGljYWxEb3VibGVBY3V0ZTogRGlhY3JpdGljYWxEb3VibGVBY3V0ZSxcblx0RGlhY3JpdGljYWxHcmF2ZTogRGlhY3JpdGljYWxHcmF2ZSxcblx0RGlhY3JpdGljYWxUaWxkZTogRGlhY3JpdGljYWxUaWxkZSxcblx0ZGlhbTogZGlhbSxcblx0ZGlhbW9uZDogZGlhbW9uZCxcblx0RGlhbW9uZDogRGlhbW9uZCxcblx0ZGlhbW9uZHN1aXQ6IGRpYW1vbmRzdWl0LFxuXHRkaWFtczogZGlhbXMsXG5cdGRpZTogZGllLFxuXHREaWZmZXJlbnRpYWxEOiBEaWZmZXJlbnRpYWxELFxuXHRkaWdhbW1hOiBkaWdhbW1hLFxuXHRkaXNpbjogZGlzaW4sXG5cdGRpdjogZGl2LFxuXHRkaXZpZGU6IGRpdmlkZSQxLFxuXHRkaXZpZGVvbnRpbWVzOiBkaXZpZGVvbnRpbWVzLFxuXHRkaXZvbng6IGRpdm9ueCxcblx0REpjeTogREpjeSxcblx0ZGpjeTogZGpjeSxcblx0ZGxjb3JuOiBkbGNvcm4sXG5cdGRsY3JvcDogZGxjcm9wLFxuXHRkb2xsYXI6IGRvbGxhcixcblx0RG9wZjogRG9wZixcblx0ZG9wZjogZG9wZixcblx0RG90OiBEb3QsXG5cdGRvdDogZG90LFxuXHREb3REb3Q6IERvdERvdCxcblx0ZG90ZXE6IGRvdGVxLFxuXHRkb3RlcWRvdDogZG90ZXFkb3QsXG5cdERvdEVxdWFsOiBEb3RFcXVhbCxcblx0ZG90bWludXM6IGRvdG1pbnVzLFxuXHRkb3RwbHVzOiBkb3RwbHVzLFxuXHRkb3RzcXVhcmU6IGRvdHNxdWFyZSxcblx0ZG91YmxlYmFyd2VkZ2U6IGRvdWJsZWJhcndlZGdlLFxuXHREb3VibGVDb250b3VySW50ZWdyYWw6IERvdWJsZUNvbnRvdXJJbnRlZ3JhbCxcblx0RG91YmxlRG90OiBEb3VibGVEb3QsXG5cdERvdWJsZURvd25BcnJvdzogRG91YmxlRG93bkFycm93LFxuXHREb3VibGVMZWZ0QXJyb3c6IERvdWJsZUxlZnRBcnJvdyxcblx0RG91YmxlTGVmdFJpZ2h0QXJyb3c6IERvdWJsZUxlZnRSaWdodEFycm93LFxuXHREb3VibGVMZWZ0VGVlOiBEb3VibGVMZWZ0VGVlLFxuXHREb3VibGVMb25nTGVmdEFycm93OiBEb3VibGVMb25nTGVmdEFycm93LFxuXHREb3VibGVMb25nTGVmdFJpZ2h0QXJyb3c6IERvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyxcblx0RG91YmxlTG9uZ1JpZ2h0QXJyb3c6IERvdWJsZUxvbmdSaWdodEFycm93LFxuXHREb3VibGVSaWdodEFycm93OiBEb3VibGVSaWdodEFycm93LFxuXHREb3VibGVSaWdodFRlZTogRG91YmxlUmlnaHRUZWUsXG5cdERvdWJsZVVwQXJyb3c6IERvdWJsZVVwQXJyb3csXG5cdERvdWJsZVVwRG93bkFycm93OiBEb3VibGVVcERvd25BcnJvdyxcblx0RG91YmxlVmVydGljYWxCYXI6IERvdWJsZVZlcnRpY2FsQmFyLFxuXHREb3duQXJyb3dCYXI6IERvd25BcnJvd0Jhcixcblx0ZG93bmFycm93OiBkb3duYXJyb3csXG5cdERvd25BcnJvdzogRG93bkFycm93LFxuXHREb3duYXJyb3c6IERvd25hcnJvdyxcblx0RG93bkFycm93VXBBcnJvdzogRG93bkFycm93VXBBcnJvdyxcblx0RG93bkJyZXZlOiBEb3duQnJldmUsXG5cdGRvd25kb3duYXJyb3dzOiBkb3duZG93bmFycm93cyxcblx0ZG93bmhhcnBvb25sZWZ0OiBkb3duaGFycG9vbmxlZnQsXG5cdGRvd25oYXJwb29ucmlnaHQ6IGRvd25oYXJwb29ucmlnaHQsXG5cdERvd25MZWZ0UmlnaHRWZWN0b3I6IERvd25MZWZ0UmlnaHRWZWN0b3IsXG5cdERvd25MZWZ0VGVlVmVjdG9yOiBEb3duTGVmdFRlZVZlY3Rvcixcblx0RG93bkxlZnRWZWN0b3JCYXI6IERvd25MZWZ0VmVjdG9yQmFyLFxuXHREb3duTGVmdFZlY3RvcjogRG93bkxlZnRWZWN0b3IsXG5cdERvd25SaWdodFRlZVZlY3RvcjogRG93blJpZ2h0VGVlVmVjdG9yLFxuXHREb3duUmlnaHRWZWN0b3JCYXI6IERvd25SaWdodFZlY3RvckJhcixcblx0RG93blJpZ2h0VmVjdG9yOiBEb3duUmlnaHRWZWN0b3IsXG5cdERvd25UZWVBcnJvdzogRG93blRlZUFycm93LFxuXHREb3duVGVlOiBEb3duVGVlLFxuXHRkcmJrYXJvdzogZHJia2Fyb3csXG5cdGRyY29ybjogZHJjb3JuLFxuXHRkcmNyb3A6IGRyY3JvcCxcblx0RHNjcjogRHNjcixcblx0ZHNjcjogZHNjcixcblx0RFNjeTogRFNjeSxcblx0ZHNjeTogZHNjeSxcblx0ZHNvbDogZHNvbCxcblx0RHN0cm9rOiBEc3Ryb2ssXG5cdGRzdHJvazogZHN0cm9rLFxuXHRkdGRvdDogZHRkb3QsXG5cdGR0cmk6IGR0cmksXG5cdGR0cmlmOiBkdHJpZixcblx0ZHVhcnI6IGR1YXJyLFxuXHRkdWhhcjogZHVoYXIsXG5cdGR3YW5nbGU6IGR3YW5nbGUsXG5cdERaY3k6IERaY3ksXG5cdGR6Y3k6IGR6Y3ksXG5cdGR6aWdyYXJyOiBkemlncmFycixcblx0RWFjdXRlOiBFYWN1dGUkMSxcblx0ZWFjdXRlOiBlYWN1dGUkMSxcblx0ZWFzdGVyOiBlYXN0ZXIsXG5cdEVjYXJvbjogRWNhcm9uLFxuXHRlY2Fyb246IGVjYXJvbixcblx0RWNpcmM6IEVjaXJjJDEsXG5cdGVjaXJjOiBlY2lyYyQxLFxuXHRlY2lyOiBlY2lyLFxuXHRlY29sb246IGVjb2xvbixcblx0RWN5OiBFY3ksXG5cdGVjeTogZWN5LFxuXHRlRERvdDogZUREb3QsXG5cdEVkb3Q6IEVkb3QsXG5cdGVkb3Q6IGVkb3QsXG5cdGVEb3Q6IGVEb3QsXG5cdGVlOiBlZSxcblx0ZWZEb3Q6IGVmRG90LFxuXHRFZnI6IEVmcixcblx0ZWZyOiBlZnIsXG5cdGVnOiBlZyxcblx0RWdyYXZlOiBFZ3JhdmUkMSxcblx0ZWdyYXZlOiBlZ3JhdmUkMSxcblx0ZWdzOiBlZ3MsXG5cdGVnc2RvdDogZWdzZG90LFxuXHRlbDogZWwsXG5cdEVsZW1lbnQ6IEVsZW1lbnQkMSxcblx0ZWxpbnRlcnM6IGVsaW50ZXJzLFxuXHRlbGw6IGVsbCxcblx0ZWxzOiBlbHMsXG5cdGVsc2RvdDogZWxzZG90LFxuXHRFbWFjcjogRW1hY3IsXG5cdGVtYWNyOiBlbWFjcixcblx0ZW1wdHk6IGVtcHR5LFxuXHRlbXB0eXNldDogZW1wdHlzZXQsXG5cdEVtcHR5U21hbGxTcXVhcmU6IEVtcHR5U21hbGxTcXVhcmUsXG5cdGVtcHR5djogZW1wdHl2LFxuXHRFbXB0eVZlcnlTbWFsbFNxdWFyZTogRW1wdHlWZXJ5U21hbGxTcXVhcmUsXG5cdGVtc3AxMzogZW1zcDEzLFxuXHRlbXNwMTQ6IGVtc3AxNCxcblx0ZW1zcDogZW1zcCxcblx0RU5HOiBFTkcsXG5cdGVuZzogZW5nLFxuXHRlbnNwOiBlbnNwLFxuXHRFb2dvbjogRW9nb24sXG5cdGVvZ29uOiBlb2dvbixcblx0RW9wZjogRW9wZixcblx0ZW9wZjogZW9wZixcblx0ZXBhcjogZXBhcixcblx0ZXBhcnNsOiBlcGFyc2wsXG5cdGVwbHVzOiBlcGx1cyxcblx0ZXBzaTogZXBzaSxcblx0RXBzaWxvbjogRXBzaWxvbixcblx0ZXBzaWxvbjogZXBzaWxvbixcblx0ZXBzaXY6IGVwc2l2LFxuXHRlcWNpcmM6IGVxY2lyYyxcblx0ZXFjb2xvbjogZXFjb2xvbixcblx0ZXFzaW06IGVxc2ltLFxuXHRlcXNsYW50Z3RyOiBlcXNsYW50Z3RyLFxuXHRlcXNsYW50bGVzczogZXFzbGFudGxlc3MsXG5cdEVxdWFsOiBFcXVhbCxcblx0ZXF1YWxzOiBlcXVhbHMsXG5cdEVxdWFsVGlsZGU6IEVxdWFsVGlsZGUsXG5cdGVxdWVzdDogZXF1ZXN0LFxuXHRFcXVpbGlicml1bTogRXF1aWxpYnJpdW0sXG5cdGVxdWl2OiBlcXVpdixcblx0ZXF1aXZERDogZXF1aXZERCxcblx0ZXF2cGFyc2w6IGVxdnBhcnNsLFxuXHRlcmFycjogZXJhcnIsXG5cdGVyRG90OiBlckRvdCxcblx0ZXNjcjogZXNjcixcblx0RXNjcjogRXNjcixcblx0ZXNkb3Q6IGVzZG90LFxuXHRFc2ltOiBFc2ltLFxuXHRlc2ltOiBlc2ltLFxuXHRFdGE6IEV0YSxcblx0ZXRhOiBldGEsXG5cdEVUSDogRVRIJDEsXG5cdGV0aDogZXRoJDEsXG5cdEV1bWw6IEV1bWwkMSxcblx0ZXVtbDogZXVtbCQxLFxuXHRldXJvOiBldXJvLFxuXHRleGNsOiBleGNsLFxuXHRleGlzdDogZXhpc3QsXG5cdEV4aXN0czogRXhpc3RzLFxuXHRleHBlY3RhdGlvbjogZXhwZWN0YXRpb24sXG5cdGV4cG9uZW50aWFsZTogZXhwb25lbnRpYWxlLFxuXHRFeHBvbmVudGlhbEU6IEV4cG9uZW50aWFsRSxcblx0ZmFsbGluZ2RvdHNlcTogZmFsbGluZ2RvdHNlcSxcblx0RmN5OiBGY3ksXG5cdGZjeTogZmN5LFxuXHRmZW1hbGU6IGZlbWFsZSxcblx0ZmZpbGlnOiBmZmlsaWcsXG5cdGZmbGlnOiBmZmxpZyxcblx0ZmZsbGlnOiBmZmxsaWcsXG5cdEZmcjogRmZyLFxuXHRmZnI6IGZmcixcblx0ZmlsaWc6IGZpbGlnLFxuXHRGaWxsZWRTbWFsbFNxdWFyZTogRmlsbGVkU21hbGxTcXVhcmUsXG5cdEZpbGxlZFZlcnlTbWFsbFNxdWFyZTogRmlsbGVkVmVyeVNtYWxsU3F1YXJlLFxuXHRmamxpZzogZmpsaWcsXG5cdGZsYXQ6IGZsYXQsXG5cdGZsbGlnOiBmbGxpZyxcblx0Zmx0bnM6IGZsdG5zLFxuXHRmbm9mOiBmbm9mLFxuXHRGb3BmOiBGb3BmLFxuXHRmb3BmOiBmb3BmLFxuXHRmb3JhbGw6IGZvcmFsbCxcblx0Rm9yQWxsOiBGb3JBbGwsXG5cdGZvcms6IGZvcmssXG5cdGZvcmt2OiBmb3Jrdixcblx0Rm91cmllcnRyZjogRm91cmllcnRyZixcblx0ZnBhcnRpbnQ6IGZwYXJ0aW50LFxuXHRmcmFjMTI6IGZyYWMxMiQxLFxuXHRmcmFjMTM6IGZyYWMxMyxcblx0ZnJhYzE0OiBmcmFjMTQkMSxcblx0ZnJhYzE1OiBmcmFjMTUsXG5cdGZyYWMxNjogZnJhYzE2LFxuXHRmcmFjMTg6IGZyYWMxOCxcblx0ZnJhYzIzOiBmcmFjMjMsXG5cdGZyYWMyNTogZnJhYzI1LFxuXHRmcmFjMzQ6IGZyYWMzNCQxLFxuXHRmcmFjMzU6IGZyYWMzNSxcblx0ZnJhYzM4OiBmcmFjMzgsXG5cdGZyYWM0NTogZnJhYzQ1LFxuXHRmcmFjNTY6IGZyYWM1Nixcblx0ZnJhYzU4OiBmcmFjNTgsXG5cdGZyYWM3ODogZnJhYzc4LFxuXHRmcmFzbDogZnJhc2wsXG5cdGZyb3duOiBmcm93bixcblx0ZnNjcjogZnNjcixcblx0RnNjcjogRnNjcixcblx0Z2FjdXRlOiBnYWN1dGUsXG5cdEdhbW1hOiBHYW1tYSxcblx0Z2FtbWE6IGdhbW1hLFxuXHRHYW1tYWQ6IEdhbW1hZCxcblx0Z2FtbWFkOiBnYW1tYWQsXG5cdGdhcDogZ2FwLFxuXHRHYnJldmU6IEdicmV2ZSxcblx0Z2JyZXZlOiBnYnJldmUsXG5cdEdjZWRpbDogR2NlZGlsLFxuXHRHY2lyYzogR2NpcmMsXG5cdGdjaXJjOiBnY2lyYyxcblx0R2N5OiBHY3ksXG5cdGdjeTogZ2N5LFxuXHRHZG90OiBHZG90LFxuXHRnZG90OiBnZG90LFxuXHRnZTogZ2UsXG5cdGdFOiBnRSxcblx0Z0VsOiBnRWwsXG5cdGdlbDogZ2VsLFxuXHRnZXE6IGdlcSxcblx0Z2VxcTogZ2VxcSxcblx0Z2Vxc2xhbnQ6IGdlcXNsYW50LFxuXHRnZXNjYzogZ2VzY2MsXG5cdGdlczogZ2VzLFxuXHRnZXNkb3Q6IGdlc2RvdCxcblx0Z2VzZG90bzogZ2VzZG90byxcblx0Z2VzZG90b2w6IGdlc2RvdG9sLFxuXHRnZXNsOiBnZXNsLFxuXHRnZXNsZXM6IGdlc2xlcyxcblx0R2ZyOiBHZnIsXG5cdGdmcjogZ2ZyLFxuXHRnZzogZ2csXG5cdEdnOiBHZyxcblx0Z2dnOiBnZ2csXG5cdGdpbWVsOiBnaW1lbCxcblx0R0pjeTogR0pjeSxcblx0Z2pjeTogZ2pjeSxcblx0Z2xhOiBnbGEsXG5cdGdsOiBnbCxcblx0Z2xFOiBnbEUsXG5cdGdsajogZ2xqLFxuXHRnbmFwOiBnbmFwLFxuXHRnbmFwcHJveDogZ25hcHByb3gsXG5cdGduZTogZ25lLFxuXHRnbkU6IGduRSxcblx0Z25lcTogZ25lcSxcblx0Z25lcXE6IGduZXFxLFxuXHRnbnNpbTogZ25zaW0sXG5cdEdvcGY6IEdvcGYsXG5cdGdvcGY6IGdvcGYsXG5cdGdyYXZlOiBncmF2ZSxcblx0R3JlYXRlckVxdWFsOiBHcmVhdGVyRXF1YWwsXG5cdEdyZWF0ZXJFcXVhbExlc3M6IEdyZWF0ZXJFcXVhbExlc3MsXG5cdEdyZWF0ZXJGdWxsRXF1YWw6IEdyZWF0ZXJGdWxsRXF1YWwsXG5cdEdyZWF0ZXJHcmVhdGVyOiBHcmVhdGVyR3JlYXRlcixcblx0R3JlYXRlckxlc3M6IEdyZWF0ZXJMZXNzLFxuXHRHcmVhdGVyU2xhbnRFcXVhbDogR3JlYXRlclNsYW50RXF1YWwsXG5cdEdyZWF0ZXJUaWxkZTogR3JlYXRlclRpbGRlLFxuXHRHc2NyOiBHc2NyLFxuXHRnc2NyOiBnc2NyLFxuXHRnc2ltOiBnc2ltLFxuXHRnc2ltZTogZ3NpbWUsXG5cdGdzaW1sOiBnc2ltbCxcblx0Z3RjYzogZ3RjYyxcblx0Z3RjaXI6IGd0Y2lyLFxuXHRndDogZ3QkMixcblx0R1Q6IEdUJDEsXG5cdEd0OiBHdCxcblx0Z3Rkb3Q6IGd0ZG90LFxuXHRndGxQYXI6IGd0bFBhcixcblx0Z3RxdWVzdDogZ3RxdWVzdCxcblx0Z3RyYXBwcm94OiBndHJhcHByb3gsXG5cdGd0cmFycjogZ3RyYXJyLFxuXHRndHJkb3Q6IGd0cmRvdCxcblx0Z3RyZXFsZXNzOiBndHJlcWxlc3MsXG5cdGd0cmVxcWxlc3M6IGd0cmVxcWxlc3MsXG5cdGd0cmxlc3M6IGd0cmxlc3MsXG5cdGd0cnNpbTogZ3Ryc2ltLFxuXHRndmVydG5lcXE6IGd2ZXJ0bmVxcSxcblx0Z3ZuRTogZ3ZuRSxcblx0SGFjZWs6IEhhY2VrLFxuXHRoYWlyc3A6IGhhaXJzcCxcblx0aGFsZjogaGFsZixcblx0aGFtaWx0OiBoYW1pbHQsXG5cdEhBUkRjeTogSEFSRGN5LFxuXHRoYXJkY3k6IGhhcmRjeSxcblx0aGFycmNpcjogaGFycmNpcixcblx0aGFycjogaGFycixcblx0aEFycjogaEFycixcblx0aGFycnc6IGhhcnJ3LFxuXHRIYXQ6IEhhdCxcblx0aGJhcjogaGJhcixcblx0SGNpcmM6IEhjaXJjLFxuXHRoY2lyYzogaGNpcmMsXG5cdGhlYXJ0czogaGVhcnRzLFxuXHRoZWFydHN1aXQ6IGhlYXJ0c3VpdCxcblx0aGVsbGlwOiBoZWxsaXAsXG5cdGhlcmNvbjogaGVyY29uLFxuXHRoZnI6IGhmcixcblx0SGZyOiBIZnIsXG5cdEhpbGJlcnRTcGFjZTogSGlsYmVydFNwYWNlLFxuXHRoa3NlYXJvdzogaGtzZWFyb3csXG5cdGhrc3dhcm93OiBoa3N3YXJvdyxcblx0aG9hcnI6IGhvYXJyLFxuXHRob210aHQ6IGhvbXRodCxcblx0aG9va2xlZnRhcnJvdzogaG9va2xlZnRhcnJvdyxcblx0aG9va3JpZ2h0YXJyb3c6IGhvb2tyaWdodGFycm93LFxuXHRob3BmOiBob3BmLFxuXHRIb3BmOiBIb3BmLFxuXHRob3JiYXI6IGhvcmJhcixcblx0SG9yaXpvbnRhbExpbmU6IEhvcml6b250YWxMaW5lLFxuXHRoc2NyOiBoc2NyLFxuXHRIc2NyOiBIc2NyLFxuXHRoc2xhc2g6IGhzbGFzaCxcblx0SHN0cm9rOiBIc3Ryb2ssXG5cdGhzdHJvazogaHN0cm9rLFxuXHRIdW1wRG93bkh1bXA6IEh1bXBEb3duSHVtcCxcblx0SHVtcEVxdWFsOiBIdW1wRXF1YWwsXG5cdGh5YnVsbDogaHlidWxsLFxuXHRoeXBoZW46IGh5cGhlbixcblx0SWFjdXRlOiBJYWN1dGUkMSxcblx0aWFjdXRlOiBpYWN1dGUkMSxcblx0aWM6IGljLFxuXHRJY2lyYzogSWNpcmMkMSxcblx0aWNpcmM6IGljaXJjJDEsXG5cdEljeTogSWN5LFxuXHRpY3k6IGljeSxcblx0SWRvdDogSWRvdCxcblx0SUVjeTogSUVjeSxcblx0aWVjeTogaWVjeSxcblx0aWV4Y2w6IGlleGNsJDEsXG5cdGlmZjogaWZmLFxuXHRpZnI6IGlmcixcblx0SWZyOiBJZnIsXG5cdElncmF2ZTogSWdyYXZlJDEsXG5cdGlncmF2ZTogaWdyYXZlJDEsXG5cdGlpOiBpaSxcblx0aWlpaW50OiBpaWlpbnQsXG5cdGlpaW50OiBpaWludCxcblx0aWluZmluOiBpaW5maW4sXG5cdGlpb3RhOiBpaW90YSxcblx0SUpsaWc6IElKbGlnLFxuXHRpamxpZzogaWpsaWcsXG5cdEltYWNyOiBJbWFjcixcblx0aW1hY3I6IGltYWNyLFxuXHRpbWFnZTogaW1hZ2UsXG5cdEltYWdpbmFyeUk6IEltYWdpbmFyeUksXG5cdGltYWdsaW5lOiBpbWFnbGluZSxcblx0aW1hZ3BhcnQ6IGltYWdwYXJ0LFxuXHRpbWF0aDogaW1hdGgsXG5cdEltOiBJbSxcblx0aW1vZjogaW1vZixcblx0aW1wZWQ6IGltcGVkLFxuXHRJbXBsaWVzOiBJbXBsaWVzLFxuXHRpbmNhcmU6IGluY2FyZSxcblx0XCJpblwiOiBcIuKIiFwiLFxuXHRpbmZpbjogaW5maW4sXG5cdGluZmludGllOiBpbmZpbnRpZSxcblx0aW5vZG90OiBpbm9kb3QsXG5cdGludGNhbDogaW50Y2FsLFxuXHRpbnQ6IGludCxcblx0SW50OiBJbnQsXG5cdGludGVnZXJzOiBpbnRlZ2Vycyxcblx0SW50ZWdyYWw6IEludGVncmFsLFxuXHRpbnRlcmNhbDogaW50ZXJjYWwsXG5cdEludGVyc2VjdGlvbjogSW50ZXJzZWN0aW9uLFxuXHRpbnRsYXJoazogaW50bGFyaGssXG5cdGludHByb2Q6IGludHByb2QsXG5cdEludmlzaWJsZUNvbW1hOiBJbnZpc2libGVDb21tYSxcblx0SW52aXNpYmxlVGltZXM6IEludmlzaWJsZVRpbWVzLFxuXHRJT2N5OiBJT2N5LFxuXHRpb2N5OiBpb2N5LFxuXHRJb2dvbjogSW9nb24sXG5cdGlvZ29uOiBpb2dvbixcblx0SW9wZjogSW9wZixcblx0aW9wZjogaW9wZixcblx0SW90YTogSW90YSxcblx0aW90YTogaW90YSxcblx0aXByb2Q6IGlwcm9kLFxuXHRpcXVlc3Q6IGlxdWVzdCQxLFxuXHRpc2NyOiBpc2NyLFxuXHRJc2NyOiBJc2NyLFxuXHRpc2luOiBpc2luLFxuXHRpc2luZG90OiBpc2luZG90LFxuXHRpc2luRTogaXNpbkUsXG5cdGlzaW5zOiBpc2lucyxcblx0aXNpbnN2OiBpc2luc3YsXG5cdGlzaW52OiBpc2ludixcblx0aXQ6IGl0LFxuXHRJdGlsZGU6IEl0aWxkZSxcblx0aXRpbGRlOiBpdGlsZGUsXG5cdEl1a2N5OiBJdWtjeSxcblx0aXVrY3k6IGl1a2N5LFxuXHRJdW1sOiBJdW1sJDEsXG5cdGl1bWw6IGl1bWwkMSxcblx0SmNpcmM6IEpjaXJjLFxuXHRqY2lyYzogamNpcmMsXG5cdEpjeTogSmN5LFxuXHRqY3k6IGpjeSxcblx0SmZyOiBKZnIsXG5cdGpmcjogamZyLFxuXHRqbWF0aDogam1hdGgsXG5cdEpvcGY6IEpvcGYsXG5cdGpvcGY6IGpvcGYsXG5cdEpzY3I6IEpzY3IsXG5cdGpzY3I6IGpzY3IsXG5cdEpzZXJjeTogSnNlcmN5LFxuXHRqc2VyY3k6IGpzZXJjeSxcblx0SnVrY3k6IEp1a2N5LFxuXHRqdWtjeToganVrY3ksXG5cdEthcHBhOiBLYXBwYSxcblx0a2FwcGE6IGthcHBhLFxuXHRrYXBwYXY6IGthcHBhdixcblx0S2NlZGlsOiBLY2VkaWwsXG5cdGtjZWRpbDoga2NlZGlsLFxuXHRLY3k6IEtjeSxcblx0a2N5OiBrY3ksXG5cdEtmcjogS2ZyLFxuXHRrZnI6IGtmcixcblx0a2dyZWVuOiBrZ3JlZW4sXG5cdEtIY3k6IEtIY3ksXG5cdGtoY3k6IGtoY3ksXG5cdEtKY3k6IEtKY3ksXG5cdGtqY3k6IGtqY3ksXG5cdEtvcGY6IEtvcGYsXG5cdGtvcGY6IGtvcGYsXG5cdEtzY3I6IEtzY3IsXG5cdGtzY3I6IGtzY3IsXG5cdGxBYXJyOiBsQWFycixcblx0TGFjdXRlOiBMYWN1dGUsXG5cdGxhY3V0ZTogbGFjdXRlLFxuXHRsYWVtcHR5djogbGFlbXB0eXYsXG5cdGxhZ3JhbjogbGFncmFuLFxuXHRMYW1iZGE6IExhbWJkYSxcblx0bGFtYmRhOiBsYW1iZGEsXG5cdGxhbmc6IGxhbmcsXG5cdExhbmc6IExhbmcsXG5cdGxhbmdkOiBsYW5nZCxcblx0bGFuZ2xlOiBsYW5nbGUsXG5cdGxhcDogbGFwLFxuXHRMYXBsYWNldHJmOiBMYXBsYWNldHJmLFxuXHRsYXF1bzogbGFxdW8kMSxcblx0bGFycmI6IGxhcnJiLFxuXHRsYXJyYmZzOiBsYXJyYmZzLFxuXHRsYXJyOiBsYXJyLFxuXHRMYXJyOiBMYXJyLFxuXHRsQXJyOiBsQXJyLFxuXHRsYXJyZnM6IGxhcnJmcyxcblx0bGFycmhrOiBsYXJyaGssXG5cdGxhcnJscDogbGFycmxwLFxuXHRsYXJycGw6IGxhcnJwbCxcblx0bGFycnNpbTogbGFycnNpbSxcblx0bGFycnRsOiBsYXJydGwsXG5cdGxhdGFpbDogbGF0YWlsLFxuXHRsQXRhaWw6IGxBdGFpbCxcblx0bGF0OiBsYXQsXG5cdGxhdGU6IGxhdGUsXG5cdGxhdGVzOiBsYXRlcyxcblx0bGJhcnI6IGxiYXJyLFxuXHRsQmFycjogbEJhcnIsXG5cdGxiYnJrOiBsYmJyayxcblx0bGJyYWNlOiBsYnJhY2UsXG5cdGxicmFjazogbGJyYWNrLFxuXHRsYnJrZTogbGJya2UsXG5cdGxicmtzbGQ6IGxicmtzbGQsXG5cdGxicmtzbHU6IGxicmtzbHUsXG5cdExjYXJvbjogTGNhcm9uLFxuXHRsY2Fyb246IGxjYXJvbixcblx0TGNlZGlsOiBMY2VkaWwsXG5cdGxjZWRpbDogbGNlZGlsLFxuXHRsY2VpbDogbGNlaWwsXG5cdGxjdWI6IGxjdWIsXG5cdExjeTogTGN5LFxuXHRsY3k6IGxjeSxcblx0bGRjYTogbGRjYSxcblx0bGRxdW86IGxkcXVvLFxuXHRsZHF1b3I6IGxkcXVvcixcblx0bGRyZGhhcjogbGRyZGhhcixcblx0bGRydXNoYXI6IGxkcnVzaGFyLFxuXHRsZHNoOiBsZHNoLFxuXHRsZTogbGUsXG5cdGxFOiBsRSxcblx0TGVmdEFuZ2xlQnJhY2tldDogTGVmdEFuZ2xlQnJhY2tldCxcblx0TGVmdEFycm93QmFyOiBMZWZ0QXJyb3dCYXIsXG5cdGxlZnRhcnJvdzogbGVmdGFycm93LFxuXHRMZWZ0QXJyb3c6IExlZnRBcnJvdyxcblx0TGVmdGFycm93OiBMZWZ0YXJyb3csXG5cdExlZnRBcnJvd1JpZ2h0QXJyb3c6IExlZnRBcnJvd1JpZ2h0QXJyb3csXG5cdGxlZnRhcnJvd3RhaWw6IGxlZnRhcnJvd3RhaWwsXG5cdExlZnRDZWlsaW5nOiBMZWZ0Q2VpbGluZyxcblx0TGVmdERvdWJsZUJyYWNrZXQ6IExlZnREb3VibGVCcmFja2V0LFxuXHRMZWZ0RG93blRlZVZlY3RvcjogTGVmdERvd25UZWVWZWN0b3IsXG5cdExlZnREb3duVmVjdG9yQmFyOiBMZWZ0RG93blZlY3RvckJhcixcblx0TGVmdERvd25WZWN0b3I6IExlZnREb3duVmVjdG9yLFxuXHRMZWZ0Rmxvb3I6IExlZnRGbG9vcixcblx0bGVmdGhhcnBvb25kb3duOiBsZWZ0aGFycG9vbmRvd24sXG5cdGxlZnRoYXJwb29udXA6IGxlZnRoYXJwb29udXAsXG5cdGxlZnRsZWZ0YXJyb3dzOiBsZWZ0bGVmdGFycm93cyxcblx0bGVmdHJpZ2h0YXJyb3c6IGxlZnRyaWdodGFycm93LFxuXHRMZWZ0UmlnaHRBcnJvdzogTGVmdFJpZ2h0QXJyb3csXG5cdExlZnRyaWdodGFycm93OiBMZWZ0cmlnaHRhcnJvdyxcblx0bGVmdHJpZ2h0YXJyb3dzOiBsZWZ0cmlnaHRhcnJvd3MsXG5cdGxlZnRyaWdodGhhcnBvb25zOiBsZWZ0cmlnaHRoYXJwb29ucyxcblx0bGVmdHJpZ2h0c3F1aWdhcnJvdzogbGVmdHJpZ2h0c3F1aWdhcnJvdyxcblx0TGVmdFJpZ2h0VmVjdG9yOiBMZWZ0UmlnaHRWZWN0b3IsXG5cdExlZnRUZWVBcnJvdzogTGVmdFRlZUFycm93LFxuXHRMZWZ0VGVlOiBMZWZ0VGVlLFxuXHRMZWZ0VGVlVmVjdG9yOiBMZWZ0VGVlVmVjdG9yLFxuXHRsZWZ0dGhyZWV0aW1lczogbGVmdHRocmVldGltZXMsXG5cdExlZnRUcmlhbmdsZUJhcjogTGVmdFRyaWFuZ2xlQmFyLFxuXHRMZWZ0VHJpYW5nbGU6IExlZnRUcmlhbmdsZSxcblx0TGVmdFRyaWFuZ2xlRXF1YWw6IExlZnRUcmlhbmdsZUVxdWFsLFxuXHRMZWZ0VXBEb3duVmVjdG9yOiBMZWZ0VXBEb3duVmVjdG9yLFxuXHRMZWZ0VXBUZWVWZWN0b3I6IExlZnRVcFRlZVZlY3Rvcixcblx0TGVmdFVwVmVjdG9yQmFyOiBMZWZ0VXBWZWN0b3JCYXIsXG5cdExlZnRVcFZlY3RvcjogTGVmdFVwVmVjdG9yLFxuXHRMZWZ0VmVjdG9yQmFyOiBMZWZ0VmVjdG9yQmFyLFxuXHRMZWZ0VmVjdG9yOiBMZWZ0VmVjdG9yLFxuXHRsRWc6IGxFZyxcblx0bGVnOiBsZWcsXG5cdGxlcTogbGVxLFxuXHRsZXFxOiBsZXFxLFxuXHRsZXFzbGFudDogbGVxc2xhbnQsXG5cdGxlc2NjOiBsZXNjYyxcblx0bGVzOiBsZXMsXG5cdGxlc2RvdDogbGVzZG90LFxuXHRsZXNkb3RvOiBsZXNkb3RvLFxuXHRsZXNkb3RvcjogbGVzZG90b3IsXG5cdGxlc2c6IGxlc2csXG5cdGxlc2dlczogbGVzZ2VzLFxuXHRsZXNzYXBwcm94OiBsZXNzYXBwcm94LFxuXHRsZXNzZG90OiBsZXNzZG90LFxuXHRsZXNzZXFndHI6IGxlc3NlcWd0cixcblx0bGVzc2VxcWd0cjogbGVzc2VxcWd0cixcblx0TGVzc0VxdWFsR3JlYXRlcjogTGVzc0VxdWFsR3JlYXRlcixcblx0TGVzc0Z1bGxFcXVhbDogTGVzc0Z1bGxFcXVhbCxcblx0TGVzc0dyZWF0ZXI6IExlc3NHcmVhdGVyLFxuXHRsZXNzZ3RyOiBsZXNzZ3RyLFxuXHRMZXNzTGVzczogTGVzc0xlc3MsXG5cdGxlc3NzaW06IGxlc3NzaW0sXG5cdExlc3NTbGFudEVxdWFsOiBMZXNzU2xhbnRFcXVhbCxcblx0TGVzc1RpbGRlOiBMZXNzVGlsZGUsXG5cdGxmaXNodDogbGZpc2h0LFxuXHRsZmxvb3I6IGxmbG9vcixcblx0TGZyOiBMZnIsXG5cdGxmcjogbGZyLFxuXHRsZzogbGcsXG5cdGxnRTogbGdFLFxuXHRsSGFyOiBsSGFyLFxuXHRsaGFyZDogbGhhcmQsXG5cdGxoYXJ1OiBsaGFydSxcblx0bGhhcnVsOiBsaGFydWwsXG5cdGxoYmxrOiBsaGJsayxcblx0TEpjeTogTEpjeSxcblx0bGpjeTogbGpjeSxcblx0bGxhcnI6IGxsYXJyLFxuXHRsbDogbGwsXG5cdExsOiBMbCxcblx0bGxjb3JuZXI6IGxsY29ybmVyLFxuXHRMbGVmdGFycm93OiBMbGVmdGFycm93LFxuXHRsbGhhcmQ6IGxsaGFyZCxcblx0bGx0cmk6IGxsdHJpLFxuXHRMbWlkb3Q6IExtaWRvdCxcblx0bG1pZG90OiBsbWlkb3QsXG5cdGxtb3VzdGFjaGU6IGxtb3VzdGFjaGUsXG5cdGxtb3VzdDogbG1vdXN0LFxuXHRsbmFwOiBsbmFwLFxuXHRsbmFwcHJveDogbG5hcHByb3gsXG5cdGxuZTogbG5lLFxuXHRsbkU6IGxuRSxcblx0bG5lcTogbG5lcSxcblx0bG5lcXE6IGxuZXFxLFxuXHRsbnNpbTogbG5zaW0sXG5cdGxvYW5nOiBsb2FuZyxcblx0bG9hcnI6IGxvYXJyLFxuXHRsb2JyazogbG9icmssXG5cdGxvbmdsZWZ0YXJyb3c6IGxvbmdsZWZ0YXJyb3csXG5cdExvbmdMZWZ0QXJyb3c6IExvbmdMZWZ0QXJyb3csXG5cdExvbmdsZWZ0YXJyb3c6IExvbmdsZWZ0YXJyb3csXG5cdGxvbmdsZWZ0cmlnaHRhcnJvdzogbG9uZ2xlZnRyaWdodGFycm93LFxuXHRMb25nTGVmdFJpZ2h0QXJyb3c6IExvbmdMZWZ0UmlnaHRBcnJvdyxcblx0TG9uZ2xlZnRyaWdodGFycm93OiBMb25nbGVmdHJpZ2h0YXJyb3csXG5cdGxvbmdtYXBzdG86IGxvbmdtYXBzdG8sXG5cdGxvbmdyaWdodGFycm93OiBsb25ncmlnaHRhcnJvdyxcblx0TG9uZ1JpZ2h0QXJyb3c6IExvbmdSaWdodEFycm93LFxuXHRMb25ncmlnaHRhcnJvdzogTG9uZ3JpZ2h0YXJyb3csXG5cdGxvb3BhcnJvd2xlZnQ6IGxvb3BhcnJvd2xlZnQsXG5cdGxvb3BhcnJvd3JpZ2h0OiBsb29wYXJyb3dyaWdodCxcblx0bG9wYXI6IGxvcGFyLFxuXHRMb3BmOiBMb3BmLFxuXHRsb3BmOiBsb3BmLFxuXHRsb3BsdXM6IGxvcGx1cyxcblx0bG90aW1lczogbG90aW1lcyxcblx0bG93YXN0OiBsb3dhc3QsXG5cdGxvd2JhcjogbG93YmFyLFxuXHRMb3dlckxlZnRBcnJvdzogTG93ZXJMZWZ0QXJyb3csXG5cdExvd2VyUmlnaHRBcnJvdzogTG93ZXJSaWdodEFycm93LFxuXHRsb3o6IGxveixcblx0bG96ZW5nZTogbG96ZW5nZSxcblx0bG96ZjogbG96Zixcblx0bHBhcjogbHBhcixcblx0bHBhcmx0OiBscGFybHQsXG5cdGxyYXJyOiBscmFycixcblx0bHJjb3JuZXI6IGxyY29ybmVyLFxuXHRscmhhcjogbHJoYXIsXG5cdGxyaGFyZDogbHJoYXJkLFxuXHRscm06IGxybSxcblx0bHJ0cmk6IGxydHJpLFxuXHRsc2FxdW86IGxzYXF1byxcblx0bHNjcjogbHNjcixcblx0THNjcjogTHNjcixcblx0bHNoOiBsc2gsXG5cdExzaDogTHNoLFxuXHRsc2ltOiBsc2ltLFxuXHRsc2ltZTogbHNpbWUsXG5cdGxzaW1nOiBsc2ltZyxcblx0bHNxYjogbHNxYixcblx0bHNxdW86IGxzcXVvLFxuXHRsc3F1b3I6IGxzcXVvcixcblx0THN0cm9rOiBMc3Ryb2ssXG5cdGxzdHJvazogbHN0cm9rLFxuXHRsdGNjOiBsdGNjLFxuXHRsdGNpcjogbHRjaXIsXG5cdGx0OiBsdCQyLFxuXHRMVDogTFQkMSxcblx0THQ6IEx0LFxuXHRsdGRvdDogbHRkb3QsXG5cdGx0aHJlZTogbHRocmVlLFxuXHRsdGltZXM6IGx0aW1lcyxcblx0bHRsYXJyOiBsdGxhcnIsXG5cdGx0cXVlc3Q6IGx0cXVlc3QsXG5cdGx0cmk6IGx0cmksXG5cdGx0cmllOiBsdHJpZSxcblx0bHRyaWY6IGx0cmlmLFxuXHRsdHJQYXI6IGx0clBhcixcblx0bHVyZHNoYXI6IGx1cmRzaGFyLFxuXHRsdXJ1aGFyOiBsdXJ1aGFyLFxuXHRsdmVydG5lcXE6IGx2ZXJ0bmVxcSxcblx0bHZuRTogbHZuRSxcblx0bWFjcjogbWFjciQxLFxuXHRtYWxlOiBtYWxlLFxuXHRtYWx0OiBtYWx0LFxuXHRtYWx0ZXNlOiBtYWx0ZXNlLFxuXHRcIk1hcFwiOiBcIuKkhVwiLFxuXHRtYXA6IG1hcCxcblx0bWFwc3RvOiBtYXBzdG8sXG5cdG1hcHN0b2Rvd246IG1hcHN0b2Rvd24sXG5cdG1hcHN0b2xlZnQ6IG1hcHN0b2xlZnQsXG5cdG1hcHN0b3VwOiBtYXBzdG91cCxcblx0bWFya2VyOiBtYXJrZXIsXG5cdG1jb21tYTogbWNvbW1hLFxuXHRNY3k6IE1jeSxcblx0bWN5OiBtY3ksXG5cdG1kYXNoOiBtZGFzaCxcblx0bUREb3Q6IG1ERG90LFxuXHRtZWFzdXJlZGFuZ2xlOiBtZWFzdXJlZGFuZ2xlLFxuXHRNZWRpdW1TcGFjZTogTWVkaXVtU3BhY2UsXG5cdE1lbGxpbnRyZjogTWVsbGludHJmLFxuXHRNZnI6IE1mcixcblx0bWZyOiBtZnIsXG5cdG1obzogbWhvLFxuXHRtaWNybzogbWljcm8kMSxcblx0bWlkYXN0OiBtaWRhc3QsXG5cdG1pZGNpcjogbWlkY2lyLFxuXHRtaWQ6IG1pZCxcblx0bWlkZG90OiBtaWRkb3QkMSxcblx0bWludXNiOiBtaW51c2IsXG5cdG1pbnVzOiBtaW51cyxcblx0bWludXNkOiBtaW51c2QsXG5cdG1pbnVzZHU6IG1pbnVzZHUsXG5cdE1pbnVzUGx1czogTWludXNQbHVzLFxuXHRtbGNwOiBtbGNwLFxuXHRtbGRyOiBtbGRyLFxuXHRtbnBsdXM6IG1ucGx1cyxcblx0bW9kZWxzOiBtb2RlbHMsXG5cdE1vcGY6IE1vcGYsXG5cdG1vcGY6IG1vcGYsXG5cdG1wOiBtcCxcblx0bXNjcjogbXNjcixcblx0TXNjcjogTXNjcixcblx0bXN0cG9zOiBtc3Rwb3MsXG5cdE11OiBNdSxcblx0bXU6IG11LFxuXHRtdWx0aW1hcDogbXVsdGltYXAsXG5cdG11bWFwOiBtdW1hcCxcblx0bmFibGE6IG5hYmxhLFxuXHROYWN1dGU6IE5hY3V0ZSxcblx0bmFjdXRlOiBuYWN1dGUsXG5cdG5hbmc6IG5hbmcsXG5cdG5hcDogbmFwLFxuXHRuYXBFOiBuYXBFLFxuXHRuYXBpZDogbmFwaWQsXG5cdG5hcG9zOiBuYXBvcyxcblx0bmFwcHJveDogbmFwcHJveCxcblx0bmF0dXJhbDogbmF0dXJhbCxcblx0bmF0dXJhbHM6IG5hdHVyYWxzLFxuXHRuYXR1cjogbmF0dXIsXG5cdG5ic3A6IG5ic3AkMSxcblx0bmJ1bXA6IG5idW1wLFxuXHRuYnVtcGU6IG5idW1wZSxcblx0bmNhcDogbmNhcCxcblx0TmNhcm9uOiBOY2Fyb24sXG5cdG5jYXJvbjogbmNhcm9uLFxuXHROY2VkaWw6IE5jZWRpbCxcblx0bmNlZGlsOiBuY2VkaWwsXG5cdG5jb25nOiBuY29uZyxcblx0bmNvbmdkb3Q6IG5jb25nZG90LFxuXHRuY3VwOiBuY3VwLFxuXHROY3k6IE5jeSxcblx0bmN5OiBuY3ksXG5cdG5kYXNoOiBuZGFzaCxcblx0bmVhcmhrOiBuZWFyaGssXG5cdG5lYXJyOiBuZWFycixcblx0bmVBcnI6IG5lQXJyLFxuXHRuZWFycm93OiBuZWFycm93LFxuXHRuZTogbmUsXG5cdG5lZG90OiBuZWRvdCxcblx0TmVnYXRpdmVNZWRpdW1TcGFjZTogTmVnYXRpdmVNZWRpdW1TcGFjZSxcblx0TmVnYXRpdmVUaGlja1NwYWNlOiBOZWdhdGl2ZVRoaWNrU3BhY2UsXG5cdE5lZ2F0aXZlVGhpblNwYWNlOiBOZWdhdGl2ZVRoaW5TcGFjZSxcblx0TmVnYXRpdmVWZXJ5VGhpblNwYWNlOiBOZWdhdGl2ZVZlcnlUaGluU3BhY2UsXG5cdG5lcXVpdjogbmVxdWl2LFxuXHRuZXNlYXI6IG5lc2Vhcixcblx0bmVzaW06IG5lc2ltLFxuXHROZXN0ZWRHcmVhdGVyR3JlYXRlcjogTmVzdGVkR3JlYXRlckdyZWF0ZXIsXG5cdE5lc3RlZExlc3NMZXNzOiBOZXN0ZWRMZXNzTGVzcyxcblx0TmV3TGluZTogTmV3TGluZSxcblx0bmV4aXN0OiBuZXhpc3QsXG5cdG5leGlzdHM6IG5leGlzdHMsXG5cdE5mcjogTmZyLFxuXHRuZnI6IG5mcixcblx0bmdFOiBuZ0UsXG5cdG5nZTogbmdlLFxuXHRuZ2VxOiBuZ2VxLFxuXHRuZ2VxcTogbmdlcXEsXG5cdG5nZXFzbGFudDogbmdlcXNsYW50LFxuXHRuZ2VzOiBuZ2VzLFxuXHRuR2c6IG5HZyxcblx0bmdzaW06IG5nc2ltLFxuXHRuR3Q6IG5HdCxcblx0bmd0OiBuZ3QsXG5cdG5ndHI6IG5ndHIsXG5cdG5HdHY6IG5HdHYsXG5cdG5oYXJyOiBuaGFycixcblx0bmhBcnI6IG5oQXJyLFxuXHRuaHBhcjogbmhwYXIsXG5cdG5pOiBuaSxcblx0bmlzOiBuaXMsXG5cdG5pc2Q6IG5pc2QsXG5cdG5pdjogbml2LFxuXHROSmN5OiBOSmN5LFxuXHRuamN5OiBuamN5LFxuXHRubGFycjogbmxhcnIsXG5cdG5sQXJyOiBubEFycixcblx0bmxkcjogbmxkcixcblx0bmxFOiBubEUsXG5cdG5sZTogbmxlLFxuXHRubGVmdGFycm93OiBubGVmdGFycm93LFxuXHRuTGVmdGFycm93OiBuTGVmdGFycm93LFxuXHRubGVmdHJpZ2h0YXJyb3c6IG5sZWZ0cmlnaHRhcnJvdyxcblx0bkxlZnRyaWdodGFycm93OiBuTGVmdHJpZ2h0YXJyb3csXG5cdG5sZXE6IG5sZXEsXG5cdG5sZXFxOiBubGVxcSxcblx0bmxlcXNsYW50OiBubGVxc2xhbnQsXG5cdG5sZXM6IG5sZXMsXG5cdG5sZXNzOiBubGVzcyxcblx0bkxsOiBuTGwsXG5cdG5sc2ltOiBubHNpbSxcblx0bkx0OiBuTHQsXG5cdG5sdDogbmx0LFxuXHRubHRyaTogbmx0cmksXG5cdG5sdHJpZTogbmx0cmllLFxuXHRuTHR2OiBuTHR2LFxuXHRubWlkOiBubWlkLFxuXHROb0JyZWFrOiBOb0JyZWFrLFxuXHROb25CcmVha2luZ1NwYWNlOiBOb25CcmVha2luZ1NwYWNlLFxuXHRub3BmOiBub3BmLFxuXHROb3BmOiBOb3BmLFxuXHROb3Q6IE5vdCxcblx0bm90OiBub3QkMSxcblx0Tm90Q29uZ3J1ZW50OiBOb3RDb25ncnVlbnQsXG5cdE5vdEN1cENhcDogTm90Q3VwQ2FwLFxuXHROb3REb3VibGVWZXJ0aWNhbEJhcjogTm90RG91YmxlVmVydGljYWxCYXIsXG5cdE5vdEVsZW1lbnQ6IE5vdEVsZW1lbnQsXG5cdE5vdEVxdWFsOiBOb3RFcXVhbCxcblx0Tm90RXF1YWxUaWxkZTogTm90RXF1YWxUaWxkZSxcblx0Tm90RXhpc3RzOiBOb3RFeGlzdHMsXG5cdE5vdEdyZWF0ZXI6IE5vdEdyZWF0ZXIsXG5cdE5vdEdyZWF0ZXJFcXVhbDogTm90R3JlYXRlckVxdWFsLFxuXHROb3RHcmVhdGVyRnVsbEVxdWFsOiBOb3RHcmVhdGVyRnVsbEVxdWFsLFxuXHROb3RHcmVhdGVyR3JlYXRlcjogTm90R3JlYXRlckdyZWF0ZXIsXG5cdE5vdEdyZWF0ZXJMZXNzOiBOb3RHcmVhdGVyTGVzcyxcblx0Tm90R3JlYXRlclNsYW50RXF1YWw6IE5vdEdyZWF0ZXJTbGFudEVxdWFsLFxuXHROb3RHcmVhdGVyVGlsZGU6IE5vdEdyZWF0ZXJUaWxkZSxcblx0Tm90SHVtcERvd25IdW1wOiBOb3RIdW1wRG93bkh1bXAsXG5cdE5vdEh1bXBFcXVhbDogTm90SHVtcEVxdWFsLFxuXHRub3Rpbjogbm90aW4sXG5cdG5vdGluZG90OiBub3RpbmRvdCxcblx0bm90aW5FOiBub3RpbkUsXG5cdG5vdGludmE6IG5vdGludmEsXG5cdG5vdGludmI6IG5vdGludmIsXG5cdG5vdGludmM6IG5vdGludmMsXG5cdE5vdExlZnRUcmlhbmdsZUJhcjogTm90TGVmdFRyaWFuZ2xlQmFyLFxuXHROb3RMZWZ0VHJpYW5nbGU6IE5vdExlZnRUcmlhbmdsZSxcblx0Tm90TGVmdFRyaWFuZ2xlRXF1YWw6IE5vdExlZnRUcmlhbmdsZUVxdWFsLFxuXHROb3RMZXNzOiBOb3RMZXNzLFxuXHROb3RMZXNzRXF1YWw6IE5vdExlc3NFcXVhbCxcblx0Tm90TGVzc0dyZWF0ZXI6IE5vdExlc3NHcmVhdGVyLFxuXHROb3RMZXNzTGVzczogTm90TGVzc0xlc3MsXG5cdE5vdExlc3NTbGFudEVxdWFsOiBOb3RMZXNzU2xhbnRFcXVhbCxcblx0Tm90TGVzc1RpbGRlOiBOb3RMZXNzVGlsZGUsXG5cdE5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyOiBOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcixcblx0Tm90TmVzdGVkTGVzc0xlc3M6IE5vdE5lc3RlZExlc3NMZXNzLFxuXHRub3RuaTogbm90bmksXG5cdG5vdG5pdmE6IG5vdG5pdmEsXG5cdG5vdG5pdmI6IG5vdG5pdmIsXG5cdG5vdG5pdmM6IG5vdG5pdmMsXG5cdE5vdFByZWNlZGVzOiBOb3RQcmVjZWRlcyxcblx0Tm90UHJlY2VkZXNFcXVhbDogTm90UHJlY2VkZXNFcXVhbCxcblx0Tm90UHJlY2VkZXNTbGFudEVxdWFsOiBOb3RQcmVjZWRlc1NsYW50RXF1YWwsXG5cdE5vdFJldmVyc2VFbGVtZW50OiBOb3RSZXZlcnNlRWxlbWVudCxcblx0Tm90UmlnaHRUcmlhbmdsZUJhcjogTm90UmlnaHRUcmlhbmdsZUJhcixcblx0Tm90UmlnaHRUcmlhbmdsZTogTm90UmlnaHRUcmlhbmdsZSxcblx0Tm90UmlnaHRUcmlhbmdsZUVxdWFsOiBOb3RSaWdodFRyaWFuZ2xlRXF1YWwsXG5cdE5vdFNxdWFyZVN1YnNldDogTm90U3F1YXJlU3Vic2V0LFxuXHROb3RTcXVhcmVTdWJzZXRFcXVhbDogTm90U3F1YXJlU3Vic2V0RXF1YWwsXG5cdE5vdFNxdWFyZVN1cGVyc2V0OiBOb3RTcXVhcmVTdXBlcnNldCxcblx0Tm90U3F1YXJlU3VwZXJzZXRFcXVhbDogTm90U3F1YXJlU3VwZXJzZXRFcXVhbCxcblx0Tm90U3Vic2V0OiBOb3RTdWJzZXQsXG5cdE5vdFN1YnNldEVxdWFsOiBOb3RTdWJzZXRFcXVhbCxcblx0Tm90U3VjY2VlZHM6IE5vdFN1Y2NlZWRzLFxuXHROb3RTdWNjZWVkc0VxdWFsOiBOb3RTdWNjZWVkc0VxdWFsLFxuXHROb3RTdWNjZWVkc1NsYW50RXF1YWw6IE5vdFN1Y2NlZWRzU2xhbnRFcXVhbCxcblx0Tm90U3VjY2VlZHNUaWxkZTogTm90U3VjY2VlZHNUaWxkZSxcblx0Tm90U3VwZXJzZXQ6IE5vdFN1cGVyc2V0LFxuXHROb3RTdXBlcnNldEVxdWFsOiBOb3RTdXBlcnNldEVxdWFsLFxuXHROb3RUaWxkZTogTm90VGlsZGUsXG5cdE5vdFRpbGRlRXF1YWw6IE5vdFRpbGRlRXF1YWwsXG5cdE5vdFRpbGRlRnVsbEVxdWFsOiBOb3RUaWxkZUZ1bGxFcXVhbCxcblx0Tm90VGlsZGVUaWxkZTogTm90VGlsZGVUaWxkZSxcblx0Tm90VmVydGljYWxCYXI6IE5vdFZlcnRpY2FsQmFyLFxuXHRucGFyYWxsZWw6IG5wYXJhbGxlbCxcblx0bnBhcjogbnBhcixcblx0bnBhcnNsOiBucGFyc2wsXG5cdG5wYXJ0OiBucGFydCxcblx0bnBvbGludDogbnBvbGludCxcblx0bnByOiBucHIsXG5cdG5wcmN1ZTogbnByY3VlLFxuXHRucHJlYzogbnByZWMsXG5cdG5wcmVjZXE6IG5wcmVjZXEsXG5cdG5wcmU6IG5wcmUsXG5cdG5yYXJyYzogbnJhcnJjLFxuXHRucmFycjogbnJhcnIsXG5cdG5yQXJyOiBuckFycixcblx0bnJhcnJ3OiBucmFycncsXG5cdG5yaWdodGFycm93OiBucmlnaHRhcnJvdyxcblx0blJpZ2h0YXJyb3c6IG5SaWdodGFycm93LFxuXHRucnRyaTogbnJ0cmksXG5cdG5ydHJpZTogbnJ0cmllLFxuXHRuc2M6IG5zYyxcblx0bnNjY3VlOiBuc2NjdWUsXG5cdG5zY2U6IG5zY2UsXG5cdE5zY3I6IE5zY3IsXG5cdG5zY3I6IG5zY3IsXG5cdG5zaG9ydG1pZDogbnNob3J0bWlkLFxuXHRuc2hvcnRwYXJhbGxlbDogbnNob3J0cGFyYWxsZWwsXG5cdG5zaW06IG5zaW0sXG5cdG5zaW1lOiBuc2ltZSxcblx0bnNpbWVxOiBuc2ltZXEsXG5cdG5zbWlkOiBuc21pZCxcblx0bnNwYXI6IG5zcGFyLFxuXHRuc3FzdWJlOiBuc3FzdWJlLFxuXHRuc3FzdXBlOiBuc3FzdXBlLFxuXHRuc3ViOiBuc3ViLFxuXHRuc3ViRTogbnN1YkUsXG5cdG5zdWJlOiBuc3ViZSxcblx0bnN1YnNldDogbnN1YnNldCxcblx0bnN1YnNldGVxOiBuc3Vic2V0ZXEsXG5cdG5zdWJzZXRlcXE6IG5zdWJzZXRlcXEsXG5cdG5zdWNjOiBuc3VjYyxcblx0bnN1Y2NlcTogbnN1Y2NlcSxcblx0bnN1cDogbnN1cCxcblx0bnN1cEU6IG5zdXBFLFxuXHRuc3VwZTogbnN1cGUsXG5cdG5zdXBzZXQ6IG5zdXBzZXQsXG5cdG5zdXBzZXRlcTogbnN1cHNldGVxLFxuXHRuc3Vwc2V0ZXFxOiBuc3Vwc2V0ZXFxLFxuXHRudGdsOiBudGdsLFxuXHROdGlsZGU6IE50aWxkZSQxLFxuXHRudGlsZGU6IG50aWxkZSQxLFxuXHRudGxnOiBudGxnLFxuXHRudHJpYW5nbGVsZWZ0OiBudHJpYW5nbGVsZWZ0LFxuXHRudHJpYW5nbGVsZWZ0ZXE6IG50cmlhbmdsZWxlZnRlcSxcblx0bnRyaWFuZ2xlcmlnaHQ6IG50cmlhbmdsZXJpZ2h0LFxuXHRudHJpYW5nbGVyaWdodGVxOiBudHJpYW5nbGVyaWdodGVxLFxuXHROdTogTnUsXG5cdG51OiBudSxcblx0bnVtOiBudW0sXG5cdG51bWVybzogbnVtZXJvLFxuXHRudW1zcDogbnVtc3AsXG5cdG52YXA6IG52YXAsXG5cdG52ZGFzaDogbnZkYXNoLFxuXHRudkRhc2g6IG52RGFzaCxcblx0blZkYXNoOiBuVmRhc2gsXG5cdG5WRGFzaDogblZEYXNoLFxuXHRudmdlOiBudmdlLFxuXHRudmd0OiBudmd0LFxuXHRudkhhcnI6IG52SGFycixcblx0bnZpbmZpbjogbnZpbmZpbixcblx0bnZsQXJyOiBudmxBcnIsXG5cdG52bGU6IG52bGUsXG5cdG52bHQ6IG52bHQsXG5cdG52bHRyaWU6IG52bHRyaWUsXG5cdG52ckFycjogbnZyQXJyLFxuXHRudnJ0cmllOiBudnJ0cmllLFxuXHRudnNpbTogbnZzaW0sXG5cdG53YXJoazogbndhcmhrLFxuXHRud2FycjogbndhcnIsXG5cdG53QXJyOiBud0Fycixcblx0bndhcnJvdzogbndhcnJvdyxcblx0bnduZWFyOiBud25lYXIsXG5cdE9hY3V0ZTogT2FjdXRlJDEsXG5cdG9hY3V0ZTogb2FjdXRlJDEsXG5cdG9hc3Q6IG9hc3QsXG5cdE9jaXJjOiBPY2lyYyQxLFxuXHRvY2lyYzogb2NpcmMkMSxcblx0b2Npcjogb2Npcixcblx0T2N5OiBPY3ksXG5cdG9jeTogb2N5LFxuXHRvZGFzaDogb2Rhc2gsXG5cdE9kYmxhYzogT2RibGFjLFxuXHRvZGJsYWM6IG9kYmxhYyxcblx0b2Rpdjogb2Rpdixcblx0b2RvdDogb2RvdCxcblx0b2Rzb2xkOiBvZHNvbGQsXG5cdE9FbGlnOiBPRWxpZyxcblx0b2VsaWc6IG9lbGlnLFxuXHRvZmNpcjogb2ZjaXIsXG5cdE9mcjogT2ZyLFxuXHRvZnI6IG9mcixcblx0b2dvbjogb2dvbixcblx0T2dyYXZlOiBPZ3JhdmUkMSxcblx0b2dyYXZlOiBvZ3JhdmUkMSxcblx0b2d0OiBvZ3QsXG5cdG9oYmFyOiBvaGJhcixcblx0b2htOiBvaG0sXG5cdG9pbnQ6IG9pbnQsXG5cdG9sYXJyOiBvbGFycixcblx0b2xjaXI6IG9sY2lyLFxuXHRvbGNyb3NzOiBvbGNyb3NzLFxuXHRvbGluZTogb2xpbmUsXG5cdG9sdDogb2x0LFxuXHRPbWFjcjogT21hY3IsXG5cdG9tYWNyOiBvbWFjcixcblx0T21lZ2E6IE9tZWdhLFxuXHRvbWVnYTogb21lZ2EsXG5cdE9taWNyb246IE9taWNyb24sXG5cdG9taWNyb246IG9taWNyb24sXG5cdG9taWQ6IG9taWQsXG5cdG9taW51czogb21pbnVzLFxuXHRPb3BmOiBPb3BmLFxuXHRvb3BmOiBvb3BmLFxuXHRvcGFyOiBvcGFyLFxuXHRPcGVuQ3VybHlEb3VibGVRdW90ZTogT3BlbkN1cmx5RG91YmxlUXVvdGUsXG5cdE9wZW5DdXJseVF1b3RlOiBPcGVuQ3VybHlRdW90ZSxcblx0b3BlcnA6IG9wZXJwLFxuXHRvcGx1czogb3BsdXMsXG5cdG9yYXJyOiBvcmFycixcblx0T3I6IE9yLFxuXHRvcjogb3IsXG5cdG9yZDogb3JkLFxuXHRvcmRlcjogb3JkZXIsXG5cdG9yZGVyb2Y6IG9yZGVyb2YsXG5cdG9yZGY6IG9yZGYkMSxcblx0b3JkbTogb3JkbSQxLFxuXHRvcmlnb2Y6IG9yaWdvZixcblx0b3Jvcjogb3Jvcixcblx0b3JzbG9wZTogb3JzbG9wZSxcblx0b3J2OiBvcnYsXG5cdG9TOiBvUyxcblx0T3NjcjogT3Njcixcblx0b3Njcjogb3Njcixcblx0T3NsYXNoOiBPc2xhc2gkMSxcblx0b3NsYXNoOiBvc2xhc2gkMSxcblx0b3NvbDogb3NvbCxcblx0T3RpbGRlOiBPdGlsZGUkMSxcblx0b3RpbGRlOiBvdGlsZGUkMSxcblx0b3RpbWVzYXM6IG90aW1lc2FzLFxuXHRPdGltZXM6IE90aW1lcyxcblx0b3RpbWVzOiBvdGltZXMsXG5cdE91bWw6IE91bWwkMSxcblx0b3VtbDogb3VtbCQxLFxuXHRvdmJhcjogb3ZiYXIsXG5cdE92ZXJCYXI6IE92ZXJCYXIsXG5cdE92ZXJCcmFjZTogT3ZlckJyYWNlLFxuXHRPdmVyQnJhY2tldDogT3ZlckJyYWNrZXQsXG5cdE92ZXJQYXJlbnRoZXNpczogT3ZlclBhcmVudGhlc2lzLFxuXHRwYXJhOiBwYXJhJDEsXG5cdHBhcmFsbGVsOiBwYXJhbGxlbCxcblx0cGFyOiBwYXIsXG5cdHBhcnNpbTogcGFyc2ltLFxuXHRwYXJzbDogcGFyc2wsXG5cdHBhcnQ6IHBhcnQsXG5cdFBhcnRpYWxEOiBQYXJ0aWFsRCxcblx0UGN5OiBQY3ksXG5cdHBjeTogcGN5LFxuXHRwZXJjbnQ6IHBlcmNudCxcblx0cGVyaW9kOiBwZXJpb2QsXG5cdHBlcm1pbDogcGVybWlsLFxuXHRwZXJwOiBwZXJwLFxuXHRwZXJ0ZW5rOiBwZXJ0ZW5rLFxuXHRQZnI6IFBmcixcblx0cGZyOiBwZnIsXG5cdFBoaTogUGhpLFxuXHRwaGk6IHBoaSxcblx0cGhpdjogcGhpdixcblx0cGhtbWF0OiBwaG1tYXQsXG5cdHBob25lOiBwaG9uZSxcblx0UGk6IFBpLFxuXHRwaTogcGksXG5cdHBpdGNoZm9yazogcGl0Y2hmb3JrLFxuXHRwaXY6IHBpdixcblx0cGxhbmNrOiBwbGFuY2ssXG5cdHBsYW5ja2g6IHBsYW5ja2gsXG5cdHBsYW5rdjogcGxhbmt2LFxuXHRwbHVzYWNpcjogcGx1c2FjaXIsXG5cdHBsdXNiOiBwbHVzYixcblx0cGx1c2NpcjogcGx1c2Npcixcblx0cGx1czogcGx1cyxcblx0cGx1c2RvOiBwbHVzZG8sXG5cdHBsdXNkdTogcGx1c2R1LFxuXHRwbHVzZTogcGx1c2UsXG5cdFBsdXNNaW51czogUGx1c01pbnVzLFxuXHRwbHVzbW46IHBsdXNtbiQxLFxuXHRwbHVzc2ltOiBwbHVzc2ltLFxuXHRwbHVzdHdvOiBwbHVzdHdvLFxuXHRwbTogcG0sXG5cdFBvaW5jYXJlcGxhbmU6IFBvaW5jYXJlcGxhbmUsXG5cdHBvaW50aW50OiBwb2ludGludCxcblx0cG9wZjogcG9wZixcblx0UG9wZjogUG9wZixcblx0cG91bmQ6IHBvdW5kJDEsXG5cdHByYXA6IHByYXAsXG5cdFByOiBQcixcblx0cHI6IHByLFxuXHRwcmN1ZTogcHJjdWUsXG5cdHByZWNhcHByb3g6IHByZWNhcHByb3gsXG5cdHByZWM6IHByZWMsXG5cdHByZWNjdXJseWVxOiBwcmVjY3VybHllcSxcblx0UHJlY2VkZXM6IFByZWNlZGVzLFxuXHRQcmVjZWRlc0VxdWFsOiBQcmVjZWRlc0VxdWFsLFxuXHRQcmVjZWRlc1NsYW50RXF1YWw6IFByZWNlZGVzU2xhbnRFcXVhbCxcblx0UHJlY2VkZXNUaWxkZTogUHJlY2VkZXNUaWxkZSxcblx0cHJlY2VxOiBwcmVjZXEsXG5cdHByZWNuYXBwcm94OiBwcmVjbmFwcHJveCxcblx0cHJlY25lcXE6IHByZWNuZXFxLFxuXHRwcmVjbnNpbTogcHJlY25zaW0sXG5cdHByZTogcHJlLFxuXHRwckU6IHByRSxcblx0cHJlY3NpbTogcHJlY3NpbSxcblx0cHJpbWU6IHByaW1lLFxuXHRQcmltZTogUHJpbWUsXG5cdHByaW1lczogcHJpbWVzLFxuXHRwcm5hcDogcHJuYXAsXG5cdHBybkU6IHBybkUsXG5cdHBybnNpbTogcHJuc2ltLFxuXHRwcm9kOiBwcm9kLFxuXHRQcm9kdWN0OiBQcm9kdWN0LFxuXHRwcm9mYWxhcjogcHJvZmFsYXIsXG5cdHByb2ZsaW5lOiBwcm9mbGluZSxcblx0cHJvZnN1cmY6IHByb2ZzdXJmLFxuXHRwcm9wOiBwcm9wLFxuXHRQcm9wb3J0aW9uYWw6IFByb3BvcnRpb25hbCxcblx0UHJvcG9ydGlvbjogUHJvcG9ydGlvbixcblx0cHJvcHRvOiBwcm9wdG8sXG5cdHByc2ltOiBwcnNpbSxcblx0cHJ1cmVsOiBwcnVyZWwsXG5cdFBzY3I6IFBzY3IsXG5cdHBzY3I6IHBzY3IsXG5cdFBzaTogUHNpLFxuXHRwc2k6IHBzaSxcblx0cHVuY3NwOiBwdW5jc3AsXG5cdFFmcjogUWZyLFxuXHRxZnI6IHFmcixcblx0cWludDogcWludCxcblx0cW9wZjogcW9wZixcblx0UW9wZjogUW9wZixcblx0cXByaW1lOiBxcHJpbWUsXG5cdFFzY3I6IFFzY3IsXG5cdHFzY3I6IHFzY3IsXG5cdHF1YXRlcm5pb25zOiBxdWF0ZXJuaW9ucyxcblx0cXVhdGludDogcXVhdGludCxcblx0cXVlc3Q6IHF1ZXN0LFxuXHRxdWVzdGVxOiBxdWVzdGVxLFxuXHRxdW90OiBxdW90JDIsXG5cdFFVT1Q6IFFVT1QkMSxcblx0ckFhcnI6IHJBYXJyLFxuXHRyYWNlOiByYWNlLFxuXHRSYWN1dGU6IFJhY3V0ZSxcblx0cmFjdXRlOiByYWN1dGUsXG5cdHJhZGljOiByYWRpYyxcblx0cmFlbXB0eXY6IHJhZW1wdHl2LFxuXHRyYW5nOiByYW5nLFxuXHRSYW5nOiBSYW5nLFxuXHRyYW5nZDogcmFuZ2QsXG5cdHJhbmdlOiByYW5nZSxcblx0cmFuZ2xlOiByYW5nbGUsXG5cdHJhcXVvOiByYXF1byQxLFxuXHRyYXJyYXA6IHJhcnJhcCxcblx0cmFycmI6IHJhcnJiLFxuXHRyYXJyYmZzOiByYXJyYmZzLFxuXHRyYXJyYzogcmFycmMsXG5cdHJhcnI6IHJhcnIsXG5cdFJhcnI6IFJhcnIsXG5cdHJBcnI6IHJBcnIsXG5cdHJhcnJmczogcmFycmZzLFxuXHRyYXJyaGs6IHJhcnJoayxcblx0cmFycmxwOiByYXJybHAsXG5cdHJhcnJwbDogcmFycnBsLFxuXHRyYXJyc2ltOiByYXJyc2ltLFxuXHRSYXJydGw6IFJhcnJ0bCxcblx0cmFycnRsOiByYXJydGwsXG5cdHJhcnJ3OiByYXJydyxcblx0cmF0YWlsOiByYXRhaWwsXG5cdHJBdGFpbDogckF0YWlsLFxuXHRyYXRpbzogcmF0aW8sXG5cdHJhdGlvbmFsczogcmF0aW9uYWxzLFxuXHRyYmFycjogcmJhcnIsXG5cdHJCYXJyOiByQmFycixcblx0UkJhcnI6IFJCYXJyLFxuXHRyYmJyazogcmJicmssXG5cdHJicmFjZTogcmJyYWNlLFxuXHRyYnJhY2s6IHJicmFjayxcblx0cmJya2U6IHJicmtlLFxuXHRyYnJrc2xkOiByYnJrc2xkLFxuXHRyYnJrc2x1OiByYnJrc2x1LFxuXHRSY2Fyb246IFJjYXJvbixcblx0cmNhcm9uOiByY2Fyb24sXG5cdFJjZWRpbDogUmNlZGlsLFxuXHRyY2VkaWw6IHJjZWRpbCxcblx0cmNlaWw6IHJjZWlsLFxuXHRyY3ViOiByY3ViLFxuXHRSY3k6IFJjeSxcblx0cmN5OiByY3ksXG5cdHJkY2E6IHJkY2EsXG5cdHJkbGRoYXI6IHJkbGRoYXIsXG5cdHJkcXVvOiByZHF1byxcblx0cmRxdW9yOiByZHF1b3IsXG5cdHJkc2g6IHJkc2gsXG5cdHJlYWw6IHJlYWwsXG5cdHJlYWxpbmU6IHJlYWxpbmUsXG5cdHJlYWxwYXJ0OiByZWFscGFydCxcblx0cmVhbHM6IHJlYWxzLFxuXHRSZTogUmUsXG5cdHJlY3Q6IHJlY3QsXG5cdHJlZzogcmVnJDEsXG5cdFJFRzogUkVHJDEsXG5cdFJldmVyc2VFbGVtZW50OiBSZXZlcnNlRWxlbWVudCxcblx0UmV2ZXJzZUVxdWlsaWJyaXVtOiBSZXZlcnNlRXF1aWxpYnJpdW0sXG5cdFJldmVyc2VVcEVxdWlsaWJyaXVtOiBSZXZlcnNlVXBFcXVpbGlicml1bSxcblx0cmZpc2h0OiByZmlzaHQsXG5cdHJmbG9vcjogcmZsb29yLFxuXHRyZnI6IHJmcixcblx0UmZyOiBSZnIsXG5cdHJIYXI6IHJIYXIsXG5cdHJoYXJkOiByaGFyZCxcblx0cmhhcnU6IHJoYXJ1LFxuXHRyaGFydWw6IHJoYXJ1bCxcblx0UmhvOiBSaG8sXG5cdHJobzogcmhvLFxuXHRyaG92OiByaG92LFxuXHRSaWdodEFuZ2xlQnJhY2tldDogUmlnaHRBbmdsZUJyYWNrZXQsXG5cdFJpZ2h0QXJyb3dCYXI6IFJpZ2h0QXJyb3dCYXIsXG5cdHJpZ2h0YXJyb3c6IHJpZ2h0YXJyb3csXG5cdFJpZ2h0QXJyb3c6IFJpZ2h0QXJyb3csXG5cdFJpZ2h0YXJyb3c6IFJpZ2h0YXJyb3csXG5cdFJpZ2h0QXJyb3dMZWZ0QXJyb3c6IFJpZ2h0QXJyb3dMZWZ0QXJyb3csXG5cdHJpZ2h0YXJyb3d0YWlsOiByaWdodGFycm93dGFpbCxcblx0UmlnaHRDZWlsaW5nOiBSaWdodENlaWxpbmcsXG5cdFJpZ2h0RG91YmxlQnJhY2tldDogUmlnaHREb3VibGVCcmFja2V0LFxuXHRSaWdodERvd25UZWVWZWN0b3I6IFJpZ2h0RG93blRlZVZlY3Rvcixcblx0UmlnaHREb3duVmVjdG9yQmFyOiBSaWdodERvd25WZWN0b3JCYXIsXG5cdFJpZ2h0RG93blZlY3RvcjogUmlnaHREb3duVmVjdG9yLFxuXHRSaWdodEZsb29yOiBSaWdodEZsb29yLFxuXHRyaWdodGhhcnBvb25kb3duOiByaWdodGhhcnBvb25kb3duLFxuXHRyaWdodGhhcnBvb251cDogcmlnaHRoYXJwb29udXAsXG5cdHJpZ2h0bGVmdGFycm93czogcmlnaHRsZWZ0YXJyb3dzLFxuXHRyaWdodGxlZnRoYXJwb29uczogcmlnaHRsZWZ0aGFycG9vbnMsXG5cdHJpZ2h0cmlnaHRhcnJvd3M6IHJpZ2h0cmlnaHRhcnJvd3MsXG5cdHJpZ2h0c3F1aWdhcnJvdzogcmlnaHRzcXVpZ2Fycm93LFxuXHRSaWdodFRlZUFycm93OiBSaWdodFRlZUFycm93LFxuXHRSaWdodFRlZTogUmlnaHRUZWUsXG5cdFJpZ2h0VGVlVmVjdG9yOiBSaWdodFRlZVZlY3Rvcixcblx0cmlnaHR0aHJlZXRpbWVzOiByaWdodHRocmVldGltZXMsXG5cdFJpZ2h0VHJpYW5nbGVCYXI6IFJpZ2h0VHJpYW5nbGVCYXIsXG5cdFJpZ2h0VHJpYW5nbGU6IFJpZ2h0VHJpYW5nbGUsXG5cdFJpZ2h0VHJpYW5nbGVFcXVhbDogUmlnaHRUcmlhbmdsZUVxdWFsLFxuXHRSaWdodFVwRG93blZlY3RvcjogUmlnaHRVcERvd25WZWN0b3IsXG5cdFJpZ2h0VXBUZWVWZWN0b3I6IFJpZ2h0VXBUZWVWZWN0b3IsXG5cdFJpZ2h0VXBWZWN0b3JCYXI6IFJpZ2h0VXBWZWN0b3JCYXIsXG5cdFJpZ2h0VXBWZWN0b3I6IFJpZ2h0VXBWZWN0b3IsXG5cdFJpZ2h0VmVjdG9yQmFyOiBSaWdodFZlY3RvckJhcixcblx0UmlnaHRWZWN0b3I6IFJpZ2h0VmVjdG9yLFxuXHRyaW5nOiByaW5nLFxuXHRyaXNpbmdkb3RzZXE6IHJpc2luZ2RvdHNlcSxcblx0cmxhcnI6IHJsYXJyLFxuXHRybGhhcjogcmxoYXIsXG5cdHJsbTogcmxtLFxuXHRybW91c3RhY2hlOiBybW91c3RhY2hlLFxuXHRybW91c3Q6IHJtb3VzdCxcblx0cm5taWQ6IHJubWlkLFxuXHRyb2FuZzogcm9hbmcsXG5cdHJvYXJyOiByb2Fycixcblx0cm9icms6IHJvYnJrLFxuXHRyb3Bhcjogcm9wYXIsXG5cdHJvcGY6IHJvcGYsXG5cdFJvcGY6IFJvcGYsXG5cdHJvcGx1czogcm9wbHVzLFxuXHRyb3RpbWVzOiByb3RpbWVzLFxuXHRSb3VuZEltcGxpZXM6IFJvdW5kSW1wbGllcyxcblx0cnBhcjogcnBhcixcblx0cnBhcmd0OiBycGFyZ3QsXG5cdHJwcG9saW50OiBycHBvbGludCxcblx0cnJhcnI6IHJyYXJyLFxuXHRScmlnaHRhcnJvdzogUnJpZ2h0YXJyb3csXG5cdHJzYXF1bzogcnNhcXVvLFxuXHRyc2NyOiByc2NyLFxuXHRSc2NyOiBSc2NyLFxuXHRyc2g6IHJzaCxcblx0UnNoOiBSc2gsXG5cdHJzcWI6IHJzcWIsXG5cdHJzcXVvOiByc3F1byxcblx0cnNxdW9yOiByc3F1b3IsXG5cdHJ0aHJlZTogcnRocmVlLFxuXHRydGltZXM6IHJ0aW1lcyxcblx0cnRyaTogcnRyaSxcblx0cnRyaWU6IHJ0cmllLFxuXHRydHJpZjogcnRyaWYsXG5cdHJ0cmlsdHJpOiBydHJpbHRyaSxcblx0UnVsZURlbGF5ZWQ6IFJ1bGVEZWxheWVkLFxuXHRydWx1aGFyOiBydWx1aGFyLFxuXHRyeDogcngsXG5cdFNhY3V0ZTogU2FjdXRlLFxuXHRzYWN1dGU6IHNhY3V0ZSxcblx0c2JxdW86IHNicXVvLFxuXHRzY2FwOiBzY2FwLFxuXHRTY2Fyb246IFNjYXJvbixcblx0c2Nhcm9uOiBzY2Fyb24sXG5cdFNjOiBTYyxcblx0c2M6IHNjLFxuXHRzY2N1ZTogc2NjdWUsXG5cdHNjZTogc2NlLFxuXHRzY0U6IHNjRSxcblx0U2NlZGlsOiBTY2VkaWwsXG5cdHNjZWRpbDogc2NlZGlsLFxuXHRTY2lyYzogU2NpcmMsXG5cdHNjaXJjOiBzY2lyYyxcblx0c2NuYXA6IHNjbmFwLFxuXHRzY25FOiBzY25FLFxuXHRzY25zaW06IHNjbnNpbSxcblx0c2Nwb2xpbnQ6IHNjcG9saW50LFxuXHRzY3NpbTogc2NzaW0sXG5cdFNjeTogU2N5LFxuXHRzY3k6IHNjeSxcblx0c2RvdGI6IHNkb3RiLFxuXHRzZG90OiBzZG90LFxuXHRzZG90ZTogc2RvdGUsXG5cdHNlYXJoazogc2VhcmhrLFxuXHRzZWFycjogc2VhcnIsXG5cdHNlQXJyOiBzZUFycixcblx0c2VhcnJvdzogc2VhcnJvdyxcblx0c2VjdDogc2VjdCQxLFxuXHRzZW1pOiBzZW1pLFxuXHRzZXN3YXI6IHNlc3dhcixcblx0c2V0bWludXM6IHNldG1pbnVzLFxuXHRzZXRtbjogc2V0bW4sXG5cdHNleHQ6IHNleHQsXG5cdFNmcjogU2ZyLFxuXHRzZnI6IHNmcixcblx0c2Zyb3duOiBzZnJvd24sXG5cdHNoYXJwOiBzaGFycCxcblx0U0hDSGN5OiBTSENIY3ksXG5cdHNoY2hjeTogc2hjaGN5LFxuXHRTSGN5OiBTSGN5LFxuXHRzaGN5OiBzaGN5LFxuXHRTaG9ydERvd25BcnJvdzogU2hvcnREb3duQXJyb3csXG5cdFNob3J0TGVmdEFycm93OiBTaG9ydExlZnRBcnJvdyxcblx0c2hvcnRtaWQ6IHNob3J0bWlkLFxuXHRzaG9ydHBhcmFsbGVsOiBzaG9ydHBhcmFsbGVsLFxuXHRTaG9ydFJpZ2h0QXJyb3c6IFNob3J0UmlnaHRBcnJvdyxcblx0U2hvcnRVcEFycm93OiBTaG9ydFVwQXJyb3csXG5cdHNoeTogc2h5JDEsXG5cdFNpZ21hOiBTaWdtYSxcblx0c2lnbWE6IHNpZ21hLFxuXHRzaWdtYWY6IHNpZ21hZixcblx0c2lnbWF2OiBzaWdtYXYsXG5cdHNpbTogc2ltLFxuXHRzaW1kb3Q6IHNpbWRvdCxcblx0c2ltZTogc2ltZSxcblx0c2ltZXE6IHNpbWVxLFxuXHRzaW1nOiBzaW1nLFxuXHRzaW1nRTogc2ltZ0UsXG5cdHNpbWw6IHNpbWwsXG5cdHNpbWxFOiBzaW1sRSxcblx0c2ltbmU6IHNpbW5lLFxuXHRzaW1wbHVzOiBzaW1wbHVzLFxuXHRzaW1yYXJyOiBzaW1yYXJyLFxuXHRzbGFycjogc2xhcnIsXG5cdFNtYWxsQ2lyY2xlOiBTbWFsbENpcmNsZSxcblx0c21hbGxzZXRtaW51czogc21hbGxzZXRtaW51cyxcblx0c21hc2hwOiBzbWFzaHAsXG5cdHNtZXBhcnNsOiBzbWVwYXJzbCxcblx0c21pZDogc21pZCxcblx0c21pbGU6IHNtaWxlLFxuXHRzbXQ6IHNtdCxcblx0c210ZTogc210ZSxcblx0c210ZXM6IHNtdGVzLFxuXHRTT0ZUY3k6IFNPRlRjeSxcblx0c29mdGN5OiBzb2Z0Y3ksXG5cdHNvbGJhcjogc29sYmFyLFxuXHRzb2xiOiBzb2xiLFxuXHRzb2w6IHNvbCxcblx0U29wZjogU29wZixcblx0c29wZjogc29wZixcblx0c3BhZGVzOiBzcGFkZXMsXG5cdHNwYWRlc3VpdDogc3BhZGVzdWl0LFxuXHRzcGFyOiBzcGFyLFxuXHRzcWNhcDogc3FjYXAsXG5cdHNxY2Fwczogc3FjYXBzLFxuXHRzcWN1cDogc3FjdXAsXG5cdHNxY3Vwczogc3FjdXBzLFxuXHRTcXJ0OiBTcXJ0LFxuXHRzcXN1Yjogc3FzdWIsXG5cdHNxc3ViZTogc3FzdWJlLFxuXHRzcXN1YnNldDogc3FzdWJzZXQsXG5cdHNxc3Vic2V0ZXE6IHNxc3Vic2V0ZXEsXG5cdHNxc3VwOiBzcXN1cCxcblx0c3FzdXBlOiBzcXN1cGUsXG5cdHNxc3Vwc2V0OiBzcXN1cHNldCxcblx0c3FzdXBzZXRlcTogc3FzdXBzZXRlcSxcblx0c3F1YXJlOiBzcXVhcmUsXG5cdFNxdWFyZTogU3F1YXJlLFxuXHRTcXVhcmVJbnRlcnNlY3Rpb246IFNxdWFyZUludGVyc2VjdGlvbixcblx0U3F1YXJlU3Vic2V0OiBTcXVhcmVTdWJzZXQsXG5cdFNxdWFyZVN1YnNldEVxdWFsOiBTcXVhcmVTdWJzZXRFcXVhbCxcblx0U3F1YXJlU3VwZXJzZXQ6IFNxdWFyZVN1cGVyc2V0LFxuXHRTcXVhcmVTdXBlcnNldEVxdWFsOiBTcXVhcmVTdXBlcnNldEVxdWFsLFxuXHRTcXVhcmVVbmlvbjogU3F1YXJlVW5pb24sXG5cdHNxdWFyZjogc3F1YXJmLFxuXHRzcXU6IHNxdSxcblx0c3F1Zjogc3F1Zixcblx0c3JhcnI6IHNyYXJyLFxuXHRTc2NyOiBTc2NyLFxuXHRzc2NyOiBzc2NyLFxuXHRzc2V0bW46IHNzZXRtbixcblx0c3NtaWxlOiBzc21pbGUsXG5cdHNzdGFyZjogc3N0YXJmLFxuXHRTdGFyOiBTdGFyLFxuXHRzdGFyOiBzdGFyLFxuXHRzdGFyZjogc3RhcmYsXG5cdHN0cmFpZ2h0ZXBzaWxvbjogc3RyYWlnaHRlcHNpbG9uLFxuXHRzdHJhaWdodHBoaTogc3RyYWlnaHRwaGksXG5cdHN0cm5zOiBzdHJucyxcblx0c3ViOiBzdWIsXG5cdFN1YjogU3ViLFxuXHRzdWJkb3Q6IHN1YmRvdCxcblx0c3ViRTogc3ViRSxcblx0c3ViZTogc3ViZSxcblx0c3ViZWRvdDogc3ViZWRvdCxcblx0c3VibXVsdDogc3VibXVsdCxcblx0c3VibkU6IHN1Ym5FLFxuXHRzdWJuZTogc3VibmUsXG5cdHN1YnBsdXM6IHN1YnBsdXMsXG5cdHN1YnJhcnI6IHN1YnJhcnIsXG5cdHN1YnNldDogc3Vic2V0LFxuXHRTdWJzZXQ6IFN1YnNldCxcblx0c3Vic2V0ZXE6IHN1YnNldGVxLFxuXHRzdWJzZXRlcXE6IHN1YnNldGVxcSxcblx0U3Vic2V0RXF1YWw6IFN1YnNldEVxdWFsLFxuXHRzdWJzZXRuZXE6IHN1YnNldG5lcSxcblx0c3Vic2V0bmVxcTogc3Vic2V0bmVxcSxcblx0c3Vic2ltOiBzdWJzaW0sXG5cdHN1YnN1Yjogc3Vic3ViLFxuXHRzdWJzdXA6IHN1YnN1cCxcblx0c3VjY2FwcHJveDogc3VjY2FwcHJveCxcblx0c3VjYzogc3VjYyxcblx0c3VjY2N1cmx5ZXE6IHN1Y2NjdXJseWVxLFxuXHRTdWNjZWVkczogU3VjY2VlZHMsXG5cdFN1Y2NlZWRzRXF1YWw6IFN1Y2NlZWRzRXF1YWwsXG5cdFN1Y2NlZWRzU2xhbnRFcXVhbDogU3VjY2VlZHNTbGFudEVxdWFsLFxuXHRTdWNjZWVkc1RpbGRlOiBTdWNjZWVkc1RpbGRlLFxuXHRzdWNjZXE6IHN1Y2NlcSxcblx0c3VjY25hcHByb3g6IHN1Y2NuYXBwcm94LFxuXHRzdWNjbmVxcTogc3VjY25lcXEsXG5cdHN1Y2Nuc2ltOiBzdWNjbnNpbSxcblx0c3VjY3NpbTogc3VjY3NpbSxcblx0U3VjaFRoYXQ6IFN1Y2hUaGF0LFxuXHRzdW06IHN1bSxcblx0U3VtOiBTdW0sXG5cdHN1bmc6IHN1bmcsXG5cdHN1cDE6IHN1cDEkMSxcblx0c3VwMjogc3VwMiQxLFxuXHRzdXAzOiBzdXAzJDEsXG5cdHN1cDogc3VwLFxuXHRTdXA6IFN1cCxcblx0c3VwZG90OiBzdXBkb3QsXG5cdHN1cGRzdWI6IHN1cGRzdWIsXG5cdHN1cEU6IHN1cEUsXG5cdHN1cGU6IHN1cGUsXG5cdHN1cGVkb3Q6IHN1cGVkb3QsXG5cdFN1cGVyc2V0OiBTdXBlcnNldCxcblx0U3VwZXJzZXRFcXVhbDogU3VwZXJzZXRFcXVhbCxcblx0c3VwaHNvbDogc3VwaHNvbCxcblx0c3VwaHN1Yjogc3VwaHN1Yixcblx0c3VwbGFycjogc3VwbGFycixcblx0c3VwbXVsdDogc3VwbXVsdCxcblx0c3VwbkU6IHN1cG5FLFxuXHRzdXBuZTogc3VwbmUsXG5cdHN1cHBsdXM6IHN1cHBsdXMsXG5cdHN1cHNldDogc3Vwc2V0LFxuXHRTdXBzZXQ6IFN1cHNldCxcblx0c3Vwc2V0ZXE6IHN1cHNldGVxLFxuXHRzdXBzZXRlcXE6IHN1cHNldGVxcSxcblx0c3Vwc2V0bmVxOiBzdXBzZXRuZXEsXG5cdHN1cHNldG5lcXE6IHN1cHNldG5lcXEsXG5cdHN1cHNpbTogc3Vwc2ltLFxuXHRzdXBzdWI6IHN1cHN1Yixcblx0c3Vwc3VwOiBzdXBzdXAsXG5cdHN3YXJoazogc3dhcmhrLFxuXHRzd2Fycjogc3dhcnIsXG5cdHN3QXJyOiBzd0Fycixcblx0c3dhcnJvdzogc3dhcnJvdyxcblx0c3dud2FyOiBzd253YXIsXG5cdHN6bGlnOiBzemxpZyQxLFxuXHRUYWI6IFRhYixcblx0dGFyZ2V0OiB0YXJnZXQsXG5cdFRhdTogVGF1LFxuXHR0YXU6IHRhdSxcblx0dGJyazogdGJyayxcblx0VGNhcm9uOiBUY2Fyb24sXG5cdHRjYXJvbjogdGNhcm9uLFxuXHRUY2VkaWw6IFRjZWRpbCxcblx0dGNlZGlsOiB0Y2VkaWwsXG5cdFRjeTogVGN5LFxuXHR0Y3k6IHRjeSxcblx0dGRvdDogdGRvdCxcblx0dGVscmVjOiB0ZWxyZWMsXG5cdFRmcjogVGZyLFxuXHR0ZnI6IHRmcixcblx0dGhlcmU0OiB0aGVyZTQsXG5cdHRoZXJlZm9yZTogdGhlcmVmb3JlLFxuXHRUaGVyZWZvcmU6IFRoZXJlZm9yZSxcblx0VGhldGE6IFRoZXRhLFxuXHR0aGV0YTogdGhldGEsXG5cdHRoZXRhc3ltOiB0aGV0YXN5bSxcblx0dGhldGF2OiB0aGV0YXYsXG5cdHRoaWNrYXBwcm94OiB0aGlja2FwcHJveCxcblx0dGhpY2tzaW06IHRoaWNrc2ltLFxuXHRUaGlja1NwYWNlOiBUaGlja1NwYWNlLFxuXHRUaGluU3BhY2U6IFRoaW5TcGFjZSxcblx0dGhpbnNwOiB0aGluc3AsXG5cdHRoa2FwOiB0aGthcCxcblx0dGhrc2ltOiB0aGtzaW0sXG5cdFRIT1JOOiBUSE9STiQxLFxuXHR0aG9ybjogdGhvcm4kMSxcblx0dGlsZGU6IHRpbGRlLFxuXHRUaWxkZTogVGlsZGUsXG5cdFRpbGRlRXF1YWw6IFRpbGRlRXF1YWwsXG5cdFRpbGRlRnVsbEVxdWFsOiBUaWxkZUZ1bGxFcXVhbCxcblx0VGlsZGVUaWxkZTogVGlsZGVUaWxkZSxcblx0dGltZXNiYXI6IHRpbWVzYmFyLFxuXHR0aW1lc2I6IHRpbWVzYixcblx0dGltZXM6IHRpbWVzJDEsXG5cdHRpbWVzZDogdGltZXNkLFxuXHR0aW50OiB0aW50LFxuXHR0b2VhOiB0b2VhLFxuXHR0b3Bib3Q6IHRvcGJvdCxcblx0dG9wY2lyOiB0b3BjaXIsXG5cdHRvcDogdG9wLFxuXHRUb3BmOiBUb3BmLFxuXHR0b3BmOiB0b3BmLFxuXHR0b3Bmb3JrOiB0b3Bmb3JrLFxuXHR0b3NhOiB0b3NhLFxuXHR0cHJpbWU6IHRwcmltZSxcblx0dHJhZGU6IHRyYWRlLFxuXHRUUkFERTogVFJBREUsXG5cdHRyaWFuZ2xlOiB0cmlhbmdsZSxcblx0dHJpYW5nbGVkb3duOiB0cmlhbmdsZWRvd24sXG5cdHRyaWFuZ2xlbGVmdDogdHJpYW5nbGVsZWZ0LFxuXHR0cmlhbmdsZWxlZnRlcTogdHJpYW5nbGVsZWZ0ZXEsXG5cdHRyaWFuZ2xlcTogdHJpYW5nbGVxLFxuXHR0cmlhbmdsZXJpZ2h0OiB0cmlhbmdsZXJpZ2h0LFxuXHR0cmlhbmdsZXJpZ2h0ZXE6IHRyaWFuZ2xlcmlnaHRlcSxcblx0dHJpZG90OiB0cmlkb3QsXG5cdHRyaWU6IHRyaWUsXG5cdHRyaW1pbnVzOiB0cmltaW51cyxcblx0VHJpcGxlRG90OiBUcmlwbGVEb3QsXG5cdHRyaXBsdXM6IHRyaXBsdXMsXG5cdHRyaXNiOiB0cmlzYixcblx0dHJpdGltZTogdHJpdGltZSxcblx0dHJwZXppdW06IHRycGV6aXVtLFxuXHRUc2NyOiBUc2NyLFxuXHR0c2NyOiB0c2NyLFxuXHRUU2N5OiBUU2N5LFxuXHR0c2N5OiB0c2N5LFxuXHRUU0hjeTogVFNIY3ksXG5cdHRzaGN5OiB0c2hjeSxcblx0VHN0cm9rOiBUc3Ryb2ssXG5cdHRzdHJvazogdHN0cm9rLFxuXHR0d2l4dDogdHdpeHQsXG5cdHR3b2hlYWRsZWZ0YXJyb3c6IHR3b2hlYWRsZWZ0YXJyb3csXG5cdHR3b2hlYWRyaWdodGFycm93OiB0d29oZWFkcmlnaHRhcnJvdyxcblx0VWFjdXRlOiBVYWN1dGUkMSxcblx0dWFjdXRlOiB1YWN1dGUkMSxcblx0dWFycjogdWFycixcblx0VWFycjogVWFycixcblx0dUFycjogdUFycixcblx0VWFycm9jaXI6IFVhcnJvY2lyLFxuXHRVYnJjeTogVWJyY3ksXG5cdHVicmN5OiB1YnJjeSxcblx0VWJyZXZlOiBVYnJldmUsXG5cdHVicmV2ZTogdWJyZXZlLFxuXHRVY2lyYzogVWNpcmMkMSxcblx0dWNpcmM6IHVjaXJjJDEsXG5cdFVjeTogVWN5LFxuXHR1Y3k6IHVjeSxcblx0dWRhcnI6IHVkYXJyLFxuXHRVZGJsYWM6IFVkYmxhYyxcblx0dWRibGFjOiB1ZGJsYWMsXG5cdHVkaGFyOiB1ZGhhcixcblx0dWZpc2h0OiB1ZmlzaHQsXG5cdFVmcjogVWZyLFxuXHR1ZnI6IHVmcixcblx0VWdyYXZlOiBVZ3JhdmUkMSxcblx0dWdyYXZlOiB1Z3JhdmUkMSxcblx0dUhhcjogdUhhcixcblx0dWhhcmw6IHVoYXJsLFxuXHR1aGFycjogdWhhcnIsXG5cdHVoYmxrOiB1aGJsayxcblx0dWxjb3JuOiB1bGNvcm4sXG5cdHVsY29ybmVyOiB1bGNvcm5lcixcblx0dWxjcm9wOiB1bGNyb3AsXG5cdHVsdHJpOiB1bHRyaSxcblx0VW1hY3I6IFVtYWNyLFxuXHR1bWFjcjogdW1hY3IsXG5cdHVtbDogdW1sJDEsXG5cdFVuZGVyQmFyOiBVbmRlckJhcixcblx0VW5kZXJCcmFjZTogVW5kZXJCcmFjZSxcblx0VW5kZXJCcmFja2V0OiBVbmRlckJyYWNrZXQsXG5cdFVuZGVyUGFyZW50aGVzaXM6IFVuZGVyUGFyZW50aGVzaXMsXG5cdFVuaW9uOiBVbmlvbixcblx0VW5pb25QbHVzOiBVbmlvblBsdXMsXG5cdFVvZ29uOiBVb2dvbixcblx0dW9nb246IHVvZ29uLFxuXHRVb3BmOiBVb3BmLFxuXHR1b3BmOiB1b3BmLFxuXHRVcEFycm93QmFyOiBVcEFycm93QmFyLFxuXHR1cGFycm93OiB1cGFycm93LFxuXHRVcEFycm93OiBVcEFycm93LFxuXHRVcGFycm93OiBVcGFycm93LFxuXHRVcEFycm93RG93bkFycm93OiBVcEFycm93RG93bkFycm93LFxuXHR1cGRvd25hcnJvdzogdXBkb3duYXJyb3csXG5cdFVwRG93bkFycm93OiBVcERvd25BcnJvdyxcblx0VXBkb3duYXJyb3c6IFVwZG93bmFycm93LFxuXHRVcEVxdWlsaWJyaXVtOiBVcEVxdWlsaWJyaXVtLFxuXHR1cGhhcnBvb25sZWZ0OiB1cGhhcnBvb25sZWZ0LFxuXHR1cGhhcnBvb25yaWdodDogdXBoYXJwb29ucmlnaHQsXG5cdHVwbHVzOiB1cGx1cyxcblx0VXBwZXJMZWZ0QXJyb3c6IFVwcGVyTGVmdEFycm93LFxuXHRVcHBlclJpZ2h0QXJyb3c6IFVwcGVyUmlnaHRBcnJvdyxcblx0dXBzaTogdXBzaSxcblx0VXBzaTogVXBzaSxcblx0dXBzaWg6IHVwc2loLFxuXHRVcHNpbG9uOiBVcHNpbG9uLFxuXHR1cHNpbG9uOiB1cHNpbG9uLFxuXHRVcFRlZUFycm93OiBVcFRlZUFycm93LFxuXHRVcFRlZTogVXBUZWUsXG5cdHVwdXBhcnJvd3M6IHVwdXBhcnJvd3MsXG5cdHVyY29ybjogdXJjb3JuLFxuXHR1cmNvcm5lcjogdXJjb3JuZXIsXG5cdHVyY3JvcDogdXJjcm9wLFxuXHRVcmluZzogVXJpbmcsXG5cdHVyaW5nOiB1cmluZyxcblx0dXJ0cmk6IHVydHJpLFxuXHRVc2NyOiBVc2NyLFxuXHR1c2NyOiB1c2NyLFxuXHR1dGRvdDogdXRkb3QsXG5cdFV0aWxkZTogVXRpbGRlLFxuXHR1dGlsZGU6IHV0aWxkZSxcblx0dXRyaTogdXRyaSxcblx0dXRyaWY6IHV0cmlmLFxuXHR1dWFycjogdXVhcnIsXG5cdFV1bWw6IFV1bWwkMSxcblx0dXVtbDogdXVtbCQxLFxuXHR1d2FuZ2xlOiB1d2FuZ2xlLFxuXHR2YW5ncnQ6IHZhbmdydCxcblx0dmFyZXBzaWxvbjogdmFyZXBzaWxvbixcblx0dmFya2FwcGE6IHZhcmthcHBhLFxuXHR2YXJub3RoaW5nOiB2YXJub3RoaW5nLFxuXHR2YXJwaGk6IHZhcnBoaSxcblx0dmFycGk6IHZhcnBpLFxuXHR2YXJwcm9wdG86IHZhcnByb3B0byxcblx0dmFycjogdmFycixcblx0dkFycjogdkFycixcblx0dmFycmhvOiB2YXJyaG8sXG5cdHZhcnNpZ21hOiB2YXJzaWdtYSxcblx0dmFyc3Vic2V0bmVxOiB2YXJzdWJzZXRuZXEsXG5cdHZhcnN1YnNldG5lcXE6IHZhcnN1YnNldG5lcXEsXG5cdHZhcnN1cHNldG5lcTogdmFyc3Vwc2V0bmVxLFxuXHR2YXJzdXBzZXRuZXFxOiB2YXJzdXBzZXRuZXFxLFxuXHR2YXJ0aGV0YTogdmFydGhldGEsXG5cdHZhcnRyaWFuZ2xlbGVmdDogdmFydHJpYW5nbGVsZWZ0LFxuXHR2YXJ0cmlhbmdsZXJpZ2h0OiB2YXJ0cmlhbmdsZXJpZ2h0LFxuXHR2QmFyOiB2QmFyLFxuXHRWYmFyOiBWYmFyLFxuXHR2QmFydjogdkJhcnYsXG5cdFZjeTogVmN5LFxuXHR2Y3k6IHZjeSxcblx0dmRhc2g6IHZkYXNoLFxuXHR2RGFzaDogdkRhc2gsXG5cdFZkYXNoOiBWZGFzaCxcblx0VkRhc2g6IFZEYXNoLFxuXHRWZGFzaGw6IFZkYXNobCxcblx0dmVlYmFyOiB2ZWViYXIsXG5cdHZlZTogdmVlLFxuXHRWZWU6IFZlZSxcblx0dmVlZXE6IHZlZWVxLFxuXHR2ZWxsaXA6IHZlbGxpcCxcblx0dmVyYmFyOiB2ZXJiYXIsXG5cdFZlcmJhcjogVmVyYmFyLFxuXHR2ZXJ0OiB2ZXJ0LFxuXHRWZXJ0OiBWZXJ0LFxuXHRWZXJ0aWNhbEJhcjogVmVydGljYWxCYXIsXG5cdFZlcnRpY2FsTGluZTogVmVydGljYWxMaW5lLFxuXHRWZXJ0aWNhbFNlcGFyYXRvcjogVmVydGljYWxTZXBhcmF0b3IsXG5cdFZlcnRpY2FsVGlsZGU6IFZlcnRpY2FsVGlsZGUsXG5cdFZlcnlUaGluU3BhY2U6IFZlcnlUaGluU3BhY2UsXG5cdFZmcjogVmZyLFxuXHR2ZnI6IHZmcixcblx0dmx0cmk6IHZsdHJpLFxuXHR2bnN1Yjogdm5zdWIsXG5cdHZuc3VwOiB2bnN1cCxcblx0Vm9wZjogVm9wZixcblx0dm9wZjogdm9wZixcblx0dnByb3A6IHZwcm9wLFxuXHR2cnRyaTogdnJ0cmksXG5cdFZzY3I6IFZzY3IsXG5cdHZzY3I6IHZzY3IsXG5cdHZzdWJuRTogdnN1Ym5FLFxuXHR2c3VibmU6IHZzdWJuZSxcblx0dnN1cG5FOiB2c3VwbkUsXG5cdHZzdXBuZTogdnN1cG5lLFxuXHRWdmRhc2g6IFZ2ZGFzaCxcblx0dnppZ3phZzogdnppZ3phZyxcblx0V2NpcmM6IFdjaXJjLFxuXHR3Y2lyYzogd2NpcmMsXG5cdHdlZGJhcjogd2VkYmFyLFxuXHR3ZWRnZTogd2VkZ2UsXG5cdFdlZGdlOiBXZWRnZSxcblx0d2VkZ2VxOiB3ZWRnZXEsXG5cdHdlaWVycDogd2VpZXJwLFxuXHRXZnI6IFdmcixcblx0d2ZyOiB3ZnIsXG5cdFdvcGY6IFdvcGYsXG5cdHdvcGY6IHdvcGYsXG5cdHdwOiB3cCxcblx0d3I6IHdyLFxuXHR3cmVhdGg6IHdyZWF0aCxcblx0V3NjcjogV3Njcixcblx0d3Njcjogd3Njcixcblx0eGNhcDogeGNhcCxcblx0eGNpcmM6IHhjaXJjLFxuXHR4Y3VwOiB4Y3VwLFxuXHR4ZHRyaTogeGR0cmksXG5cdFhmcjogWGZyLFxuXHR4ZnI6IHhmcixcblx0eGhhcnI6IHhoYXJyLFxuXHR4aEFycjogeGhBcnIsXG5cdFhpOiBYaSxcblx0eGk6IHhpLFxuXHR4bGFycjogeGxhcnIsXG5cdHhsQXJyOiB4bEFycixcblx0eG1hcDogeG1hcCxcblx0eG5pczogeG5pcyxcblx0eG9kb3Q6IHhvZG90LFxuXHRYb3BmOiBYb3BmLFxuXHR4b3BmOiB4b3BmLFxuXHR4b3BsdXM6IHhvcGx1cyxcblx0eG90aW1lOiB4b3RpbWUsXG5cdHhyYXJyOiB4cmFycixcblx0eHJBcnI6IHhyQXJyLFxuXHRYc2NyOiBYc2NyLFxuXHR4c2NyOiB4c2NyLFxuXHR4c3FjdXA6IHhzcWN1cCxcblx0eHVwbHVzOiB4dXBsdXMsXG5cdHh1dHJpOiB4dXRyaSxcblx0eHZlZTogeHZlZSxcblx0eHdlZGdlOiB4d2VkZ2UsXG5cdFlhY3V0ZTogWWFjdXRlJDEsXG5cdHlhY3V0ZTogeWFjdXRlJDEsXG5cdFlBY3k6IFlBY3ksXG5cdHlhY3k6IHlhY3ksXG5cdFljaXJjOiBZY2lyYyxcblx0eWNpcmM6IHljaXJjLFxuXHRZY3k6IFljeSxcblx0eWN5OiB5Y3ksXG5cdHllbjogeWVuJDEsXG5cdFlmcjogWWZyLFxuXHR5ZnI6IHlmcixcblx0WUljeTogWUljeSxcblx0eWljeTogeWljeSxcblx0WW9wZjogWW9wZixcblx0eW9wZjogeW9wZixcblx0WXNjcjogWXNjcixcblx0eXNjcjogeXNjcixcblx0WVVjeTogWVVjeSxcblx0eXVjeTogeXVjeSxcblx0eXVtbDogeXVtbCQxLFxuXHRZdW1sOiBZdW1sLFxuXHRaYWN1dGU6IFphY3V0ZSxcblx0emFjdXRlOiB6YWN1dGUsXG5cdFpjYXJvbjogWmNhcm9uLFxuXHR6Y2Fyb246IHpjYXJvbixcblx0WmN5OiBaY3ksXG5cdHpjeTogemN5LFxuXHRaZG90OiBaZG90LFxuXHR6ZG90OiB6ZG90LFxuXHR6ZWV0cmY6IHplZXRyZixcblx0WmVyb1dpZHRoU3BhY2U6IFplcm9XaWR0aFNwYWNlLFxuXHRaZXRhOiBaZXRhLFxuXHR6ZXRhOiB6ZXRhLFxuXHR6ZnI6IHpmcixcblx0WmZyOiBaZnIsXG5cdFpIY3k6IFpIY3ksXG5cdHpoY3k6IHpoY3ksXG5cdHppZ3JhcnI6IHppZ3JhcnIsXG5cdHpvcGY6IHpvcGYsXG5cdFpvcGY6IFpvcGYsXG5cdFpzY3I6IFpzY3IsXG5cdHpzY3I6IHpzY3IsXG5cdHp3ajogendqLFxuXHR6d25qOiB6d25qXG59O1xuXG52YXIgQWFjdXRlID0gXCLDgVwiO1xudmFyIGFhY3V0ZSA9IFwiw6FcIjtcbnZhciBBY2lyYyA9IFwiw4JcIjtcbnZhciBhY2lyYyA9IFwiw6JcIjtcbnZhciBhY3V0ZSA9IFwiwrRcIjtcbnZhciBBRWxpZyA9IFwiw4ZcIjtcbnZhciBhZWxpZyA9IFwiw6ZcIjtcbnZhciBBZ3JhdmUgPSBcIsOAXCI7XG52YXIgYWdyYXZlID0gXCLDoFwiO1xudmFyIGFtcCQxID0gXCImXCI7XG52YXIgQU1QID0gXCImXCI7XG52YXIgQXJpbmcgPSBcIsOFXCI7XG52YXIgYXJpbmcgPSBcIsOlXCI7XG52YXIgQXRpbGRlID0gXCLDg1wiO1xudmFyIGF0aWxkZSA9IFwiw6NcIjtcbnZhciBBdW1sID0gXCLDhFwiO1xudmFyIGF1bWwgPSBcIsOkXCI7XG52YXIgYnJ2YmFyID0gXCLCplwiO1xudmFyIENjZWRpbCA9IFwiw4dcIjtcbnZhciBjY2VkaWwgPSBcIsOnXCI7XG52YXIgY2VkaWwgPSBcIsK4XCI7XG52YXIgY2VudCA9IFwiwqJcIjtcbnZhciBjb3B5ID0gXCLCqVwiO1xudmFyIENPUFkgPSBcIsKpXCI7XG52YXIgY3VycmVuID0gXCLCpFwiO1xudmFyIGRlZyA9IFwiwrBcIjtcbnZhciBkaXZpZGUgPSBcIsO3XCI7XG52YXIgRWFjdXRlID0gXCLDiVwiO1xudmFyIGVhY3V0ZSA9IFwiw6lcIjtcbnZhciBFY2lyYyA9IFwiw4pcIjtcbnZhciBlY2lyYyA9IFwiw6pcIjtcbnZhciBFZ3JhdmUgPSBcIsOIXCI7XG52YXIgZWdyYXZlID0gXCLDqFwiO1xudmFyIEVUSCA9IFwiw5BcIjtcbnZhciBldGggPSBcIsOwXCI7XG52YXIgRXVtbCA9IFwiw4tcIjtcbnZhciBldW1sID0gXCLDq1wiO1xudmFyIGZyYWMxMiA9IFwiwr1cIjtcbnZhciBmcmFjMTQgPSBcIsK8XCI7XG52YXIgZnJhYzM0ID0gXCLCvlwiO1xudmFyIGd0JDEgPSBcIj5cIjtcbnZhciBHVCA9IFwiPlwiO1xudmFyIElhY3V0ZSA9IFwiw41cIjtcbnZhciBpYWN1dGUgPSBcIsOtXCI7XG52YXIgSWNpcmMgPSBcIsOOXCI7XG52YXIgaWNpcmMgPSBcIsOuXCI7XG52YXIgaWV4Y2wgPSBcIsKhXCI7XG52YXIgSWdyYXZlID0gXCLDjFwiO1xudmFyIGlncmF2ZSA9IFwiw6xcIjtcbnZhciBpcXVlc3QgPSBcIsK/XCI7XG52YXIgSXVtbCA9IFwiw49cIjtcbnZhciBpdW1sID0gXCLDr1wiO1xudmFyIGxhcXVvID0gXCLCq1wiO1xudmFyIGx0JDEgPSBcIjxcIjtcbnZhciBMVCA9IFwiPFwiO1xudmFyIG1hY3IgPSBcIsKvXCI7XG52YXIgbWljcm8gPSBcIsK1XCI7XG52YXIgbWlkZG90ID0gXCLCt1wiO1xudmFyIG5ic3AgPSBcIsKgXCI7XG52YXIgbm90ID0gXCLCrFwiO1xudmFyIE50aWxkZSA9IFwiw5FcIjtcbnZhciBudGlsZGUgPSBcIsOxXCI7XG52YXIgT2FjdXRlID0gXCLDk1wiO1xudmFyIG9hY3V0ZSA9IFwiw7NcIjtcbnZhciBPY2lyYyA9IFwiw5RcIjtcbnZhciBvY2lyYyA9IFwiw7RcIjtcbnZhciBPZ3JhdmUgPSBcIsOSXCI7XG52YXIgb2dyYXZlID0gXCLDslwiO1xudmFyIG9yZGYgPSBcIsKqXCI7XG52YXIgb3JkbSA9IFwiwrpcIjtcbnZhciBPc2xhc2ggPSBcIsOYXCI7XG52YXIgb3NsYXNoID0gXCLDuFwiO1xudmFyIE90aWxkZSA9IFwiw5VcIjtcbnZhciBvdGlsZGUgPSBcIsO1XCI7XG52YXIgT3VtbCA9IFwiw5ZcIjtcbnZhciBvdW1sID0gXCLDtlwiO1xudmFyIHBhcmEgPSBcIsK2XCI7XG52YXIgcGx1c21uID0gXCLCsVwiO1xudmFyIHBvdW5kID0gXCLCo1wiO1xudmFyIHF1b3QkMSA9IFwiXFxcIlwiO1xudmFyIFFVT1QgPSBcIlxcXCJcIjtcbnZhciByYXF1byA9IFwiwrtcIjtcbnZhciByZWcgPSBcIsKuXCI7XG52YXIgUkVHID0gXCLCrlwiO1xudmFyIHNlY3QgPSBcIsKnXCI7XG52YXIgc2h5ID0gXCLCrVwiO1xudmFyIHN1cDEgPSBcIsK5XCI7XG52YXIgc3VwMiA9IFwiwrJcIjtcbnZhciBzdXAzID0gXCLCs1wiO1xudmFyIHN6bGlnID0gXCLDn1wiO1xudmFyIFRIT1JOID0gXCLDnlwiO1xudmFyIHRob3JuID0gXCLDvlwiO1xudmFyIHRpbWVzID0gXCLDl1wiO1xudmFyIFVhY3V0ZSA9IFwiw5pcIjtcbnZhciB1YWN1dGUgPSBcIsO6XCI7XG52YXIgVWNpcmMgPSBcIsObXCI7XG52YXIgdWNpcmMgPSBcIsO7XCI7XG52YXIgVWdyYXZlID0gXCLDmVwiO1xudmFyIHVncmF2ZSA9IFwiw7lcIjtcbnZhciB1bWwgPSBcIsKoXCI7XG52YXIgVXVtbCA9IFwiw5xcIjtcbnZhciB1dW1sID0gXCLDvFwiO1xudmFyIFlhY3V0ZSA9IFwiw51cIjtcbnZhciB5YWN1dGUgPSBcIsO9XCI7XG52YXIgeWVuID0gXCLCpVwiO1xudmFyIHl1bWwgPSBcIsO/XCI7XG52YXIgcmVxdWlyZSQkMSA9IHtcblx0QWFjdXRlOiBBYWN1dGUsXG5cdGFhY3V0ZTogYWFjdXRlLFxuXHRBY2lyYzogQWNpcmMsXG5cdGFjaXJjOiBhY2lyYyxcblx0YWN1dGU6IGFjdXRlLFxuXHRBRWxpZzogQUVsaWcsXG5cdGFlbGlnOiBhZWxpZyxcblx0QWdyYXZlOiBBZ3JhdmUsXG5cdGFncmF2ZTogYWdyYXZlLFxuXHRhbXA6IGFtcCQxLFxuXHRBTVA6IEFNUCxcblx0QXJpbmc6IEFyaW5nLFxuXHRhcmluZzogYXJpbmcsXG5cdEF0aWxkZTogQXRpbGRlLFxuXHRhdGlsZGU6IGF0aWxkZSxcblx0QXVtbDogQXVtbCxcblx0YXVtbDogYXVtbCxcblx0YnJ2YmFyOiBicnZiYXIsXG5cdENjZWRpbDogQ2NlZGlsLFxuXHRjY2VkaWw6IGNjZWRpbCxcblx0Y2VkaWw6IGNlZGlsLFxuXHRjZW50OiBjZW50LFxuXHRjb3B5OiBjb3B5LFxuXHRDT1BZOiBDT1BZLFxuXHRjdXJyZW46IGN1cnJlbixcblx0ZGVnOiBkZWcsXG5cdGRpdmlkZTogZGl2aWRlLFxuXHRFYWN1dGU6IEVhY3V0ZSxcblx0ZWFjdXRlOiBlYWN1dGUsXG5cdEVjaXJjOiBFY2lyYyxcblx0ZWNpcmM6IGVjaXJjLFxuXHRFZ3JhdmU6IEVncmF2ZSxcblx0ZWdyYXZlOiBlZ3JhdmUsXG5cdEVUSDogRVRILFxuXHRldGg6IGV0aCxcblx0RXVtbDogRXVtbCxcblx0ZXVtbDogZXVtbCxcblx0ZnJhYzEyOiBmcmFjMTIsXG5cdGZyYWMxNDogZnJhYzE0LFxuXHRmcmFjMzQ6IGZyYWMzNCxcblx0Z3Q6IGd0JDEsXG5cdEdUOiBHVCxcblx0SWFjdXRlOiBJYWN1dGUsXG5cdGlhY3V0ZTogaWFjdXRlLFxuXHRJY2lyYzogSWNpcmMsXG5cdGljaXJjOiBpY2lyYyxcblx0aWV4Y2w6IGlleGNsLFxuXHRJZ3JhdmU6IElncmF2ZSxcblx0aWdyYXZlOiBpZ3JhdmUsXG5cdGlxdWVzdDogaXF1ZXN0LFxuXHRJdW1sOiBJdW1sLFxuXHRpdW1sOiBpdW1sLFxuXHRsYXF1bzogbGFxdW8sXG5cdGx0OiBsdCQxLFxuXHRMVDogTFQsXG5cdG1hY3I6IG1hY3IsXG5cdG1pY3JvOiBtaWNybyxcblx0bWlkZG90OiBtaWRkb3QsXG5cdG5ic3A6IG5ic3AsXG5cdG5vdDogbm90LFxuXHROdGlsZGU6IE50aWxkZSxcblx0bnRpbGRlOiBudGlsZGUsXG5cdE9hY3V0ZTogT2FjdXRlLFxuXHRvYWN1dGU6IG9hY3V0ZSxcblx0T2NpcmM6IE9jaXJjLFxuXHRvY2lyYzogb2NpcmMsXG5cdE9ncmF2ZTogT2dyYXZlLFxuXHRvZ3JhdmU6IG9ncmF2ZSxcblx0b3JkZjogb3JkZixcblx0b3JkbTogb3JkbSxcblx0T3NsYXNoOiBPc2xhc2gsXG5cdG9zbGFzaDogb3NsYXNoLFxuXHRPdGlsZGU6IE90aWxkZSxcblx0b3RpbGRlOiBvdGlsZGUsXG5cdE91bWw6IE91bWwsXG5cdG91bWw6IG91bWwsXG5cdHBhcmE6IHBhcmEsXG5cdHBsdXNtbjogcGx1c21uLFxuXHRwb3VuZDogcG91bmQsXG5cdHF1b3Q6IHF1b3QkMSxcblx0UVVPVDogUVVPVCxcblx0cmFxdW86IHJhcXVvLFxuXHRyZWc6IHJlZyxcblx0UkVHOiBSRUcsXG5cdHNlY3Q6IHNlY3QsXG5cdHNoeTogc2h5LFxuXHRzdXAxOiBzdXAxLFxuXHRzdXAyOiBzdXAyLFxuXHRzdXAzOiBzdXAzLFxuXHRzemxpZzogc3psaWcsXG5cdFRIT1JOOiBUSE9STixcblx0dGhvcm46IHRob3JuLFxuXHR0aW1lczogdGltZXMsXG5cdFVhY3V0ZTogVWFjdXRlLFxuXHR1YWN1dGU6IHVhY3V0ZSxcblx0VWNpcmM6IFVjaXJjLFxuXHR1Y2lyYzogdWNpcmMsXG5cdFVncmF2ZTogVWdyYXZlLFxuXHR1Z3JhdmU6IHVncmF2ZSxcblx0dW1sOiB1bWwsXG5cdFV1bWw6IFV1bWwsXG5cdHV1bWw6IHV1bWwsXG5cdFlhY3V0ZTogWWFjdXRlLFxuXHR5YWN1dGU6IHlhY3V0ZSxcblx0eWVuOiB5ZW4sXG5cdHl1bWw6IHl1bWxcbn07XG5cbnZhciBhbXAgPSBcIiZcIjtcbnZhciBhcG9zID0gXCInXCI7XG52YXIgZ3QgPSBcIj5cIjtcbnZhciBsdCA9IFwiPFwiO1xudmFyIHF1b3QgPSBcIlxcXCJcIjtcbnZhciByZXF1aXJlJCQwJDEgPSB7XG5cdGFtcDogYW1wLFxuXHRhcG9zOiBhcG9zLFxuXHRndDogZ3QsXG5cdGx0OiBsdCxcblx0cXVvdDogcXVvdFxufTtcblxudmFyIGRlY29kZV9jb2RlcG9pbnQgPSB7fTtcblxudmFyIHJlcXVpcmUkJDAgPSB7XG5cdFwiMFwiOiA2NTUzMyxcblx0XCIxMjhcIjogODM2NCxcblx0XCIxMzBcIjogODIxOCxcblx0XCIxMzFcIjogNDAyLFxuXHRcIjEzMlwiOiA4MjIyLFxuXHRcIjEzM1wiOiA4MjMwLFxuXHRcIjEzNFwiOiA4MjI0LFxuXHRcIjEzNVwiOiA4MjI1LFxuXHRcIjEzNlwiOiA3MTAsXG5cdFwiMTM3XCI6IDgyNDAsXG5cdFwiMTM4XCI6IDM1Mixcblx0XCIxMzlcIjogODI0OSxcblx0XCIxNDBcIjogMzM4LFxuXHRcIjE0MlwiOiAzODEsXG5cdFwiMTQ1XCI6IDgyMTYsXG5cdFwiMTQ2XCI6IDgyMTcsXG5cdFwiMTQ3XCI6IDgyMjAsXG5cdFwiMTQ4XCI6IDgyMjEsXG5cdFwiMTQ5XCI6IDgyMjYsXG5cdFwiMTUwXCI6IDgyMTEsXG5cdFwiMTUxXCI6IDgyMTIsXG5cdFwiMTUyXCI6IDczMixcblx0XCIxNTNcIjogODQ4Mixcblx0XCIxNTRcIjogMzUzLFxuXHRcIjE1NVwiOiA4MjUwLFxuXHRcIjE1NlwiOiAzMzksXG5cdFwiMTU4XCI6IDM4Mixcblx0XCIxNTlcIjogMzc2XG59O1xuXG52YXIgX19pbXBvcnREZWZhdWx0JDIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlY29kZV9jb2RlcG9pbnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlY29kZV9qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQkMihyZXF1aXJlJCQwKTtcbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9oZS9ibG9iL21hc3Rlci9zcmMvaGUuanMjTDk0LUwxMTlcbnZhciBmcm9tQ29kZVBvaW50JDIgPSBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG5TdHJpbmcuZnJvbUNvZGVQb2ludCB8fFxuICAgIGZ1bmN0aW9uIChjb2RlUG9pbnQpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IFwiXCI7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweGZmZmYpIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4+IDEwKSAmIDB4M2ZmKSB8IDB4ZDgwMCk7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSAweGRjMDAgfCAoY29kZVBvaW50ICYgMHgzZmYpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcbiAgICBpZiAoKGNvZGVQb2ludCA+PSAweGQ4MDAgJiYgY29kZVBvaW50IDw9IDB4ZGZmZikgfHwgY29kZVBvaW50ID4gMHgxMGZmZmYpIHtcbiAgICAgICAgcmV0dXJuIFwiXFx1RkZGRFwiO1xuICAgIH1cbiAgICBpZiAoY29kZVBvaW50IGluIGRlY29kZV9qc29uXzEuZGVmYXVsdCkge1xuICAgICAgICBjb2RlUG9pbnQgPSBkZWNvZGVfanNvbl8xLmRlZmF1bHRbY29kZVBvaW50XTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21Db2RlUG9pbnQkMihjb2RlUG9pbnQpO1xufVxuZGVjb2RlX2NvZGVwb2ludC5kZWZhdWx0ID0gZGVjb2RlQ29kZVBvaW50O1xuXG52YXIgX19pbXBvcnREZWZhdWx0JDEgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlY29kZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5kZWNvZGUuZGVjb2RlSFRNTCA9IGRlY29kZS5kZWNvZGVIVE1MU3RyaWN0ID0gZGVjb2RlLmRlY29kZVhNTCA9IHZvaWQgMDtcbnZhciBlbnRpdGllc19qc29uXzEkMSA9IF9faW1wb3J0RGVmYXVsdCQxKHJlcXVpcmUkJDEkMSk7XG52YXIgbGVnYWN5X2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdCQxKHJlcXVpcmUkJDEpO1xudmFyIHhtbF9qc29uXzEkMSA9IF9faW1wb3J0RGVmYXVsdCQxKHJlcXVpcmUkJDAkMSk7XG52YXIgZGVjb2RlX2NvZGVwb2ludF8xID0gX19pbXBvcnREZWZhdWx0JDEoZGVjb2RlX2NvZGVwb2ludCk7XG52YXIgc3RyaWN0RW50aXR5UmUgPSAvJig/OlthLXpBLVowLTldK3wjW3hYXVtcXGRhLWZBLUZdK3wjXFxkKyk7L2c7XG5kZWNvZGUuZGVjb2RlWE1MID0gZ2V0U3RyaWN0RGVjb2Rlcih4bWxfanNvbl8xJDEuZGVmYXVsdCk7XG5kZWNvZGUuZGVjb2RlSFRNTFN0cmljdCA9IGdldFN0cmljdERlY29kZXIoZW50aXRpZXNfanNvbl8xJDEuZGVmYXVsdCk7XG5mdW5jdGlvbiBnZXRTdHJpY3REZWNvZGVyKG1hcCkge1xuICAgIHZhciByZXBsYWNlID0gZ2V0UmVwbGFjZXIobWFwKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZShzdHJpY3RFbnRpdHlSZSwgcmVwbGFjZSk7IH07XG59XG52YXIgc29ydGVyID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChhIDwgYiA/IDEgOiAtMSk7IH07XG5kZWNvZGUuZGVjb2RlSFRNTCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlZ2FjeSA9IE9iamVjdC5rZXlzKGxlZ2FjeV9qc29uXzEuZGVmYXVsdCkuc29ydChzb3J0ZXIpO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZW50aXRpZXNfanNvbl8xJDEuZGVmYXVsdCkuc29ydChzb3J0ZXIpO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxlZ2FjeVtqXSA9PT0ga2V5c1tpXSkge1xuICAgICAgICAgICAga2V5c1tpXSArPSBcIjs/XCI7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrZXlzW2ldICs9IFwiO1wiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoXCImKD86XCIgKyBrZXlzLmpvaW4oXCJ8XCIpICsgXCJ8I1t4WF1bXFxcXGRhLWZBLUZdKzs/fCNcXFxcZCs7PylcIiwgXCJnXCIpO1xuICAgIHZhciByZXBsYWNlID0gZ2V0UmVwbGFjZXIoZW50aXRpZXNfanNvbl8xJDEuZGVmYXVsdCk7XG4gICAgZnVuY3Rpb24gcmVwbGFjZXIoc3RyKSB7XG4gICAgICAgIGlmIChzdHIuc3Vic3RyKC0xKSAhPT0gXCI7XCIpXG4gICAgICAgICAgICBzdHIgKz0gXCI7XCI7XG4gICAgICAgIHJldHVybiByZXBsYWNlKHN0cik7XG4gICAgfVxuICAgIC8vIFRPRE8gY29uc2lkZXIgY3JlYXRpbmcgYSBtZXJnZWQgbWFwXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UocmUsIHJlcGxhY2VyKTsgfTtcbn0pKCk7XG5mdW5jdGlvbiBnZXRSZXBsYWNlcihtYXApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShzdHIpIHtcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoMSkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICB2YXIgc2Vjb25kQ2hhciA9IHN0ci5jaGFyQXQoMik7XG4gICAgICAgICAgICBpZiAoc2Vjb25kQ2hhciA9PT0gXCJYXCIgfHwgc2Vjb25kQ2hhciA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlX2NvZGVwb2ludF8xLmRlZmF1bHQocGFyc2VJbnQoc3RyLnN1YnN0cigzKSwgMTYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVfY29kZXBvaW50XzEuZGVmYXVsdChwYXJzZUludChzdHIuc3Vic3RyKDIpLCAxMCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW51bGxpc2gtY29hbGVzY2luZ1xuICAgICAgICByZXR1cm4gbWFwW3N0ci5zbGljZSgxLCAtMSldIHx8IHN0cjtcbiAgICB9O1xufVxuXG52YXIgZW5jb2RlID0ge307XG5cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGVuY29kZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5lbmNvZGUuZXNjYXBlVVRGOCA9IGVuY29kZS5lc2NhcGUgPSBlbmNvZGUuZW5jb2RlTm9uQXNjaWlIVE1MID0gZW5jb2RlLmVuY29kZUhUTUwgPSBlbmNvZGUuZW5jb2RlWE1MID0gdm9pZCAwO1xudmFyIHhtbF9qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZSQkMCQxKTtcbnZhciBpbnZlcnNlWE1MID0gZ2V0SW52ZXJzZU9iaih4bWxfanNvbl8xLmRlZmF1bHQpO1xudmFyIHhtbFJlcGxhY2VyID0gZ2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2VYTUwpO1xuLyoqXG4gKiBFbmNvZGVzIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycywgYXMgd2VsbCBhcyBjaGFyYWN0ZXJzIG5vdCB2YWxpZCBpbiBYTUxcbiAqIGRvY3VtZW50cyB1c2luZyBYTUwgZW50aXRpZXMuXG4gKlxuICogSWYgYSBjaGFyYWN0ZXIgaGFzIG5vIGVxdWl2YWxlbnQgZW50aXR5LCBhXG4gKiBudW1lcmljIGhleGFkZWNpbWFsIHJlZmVyZW5jZSAoZWcuIGAmI3hmYztgKSB3aWxsIGJlIHVzZWQuXG4gKi9cbmVuY29kZS5lbmNvZGVYTUwgPSBnZXRBU0NJSUVuY29kZXIoaW52ZXJzZVhNTCk7XG52YXIgZW50aXRpZXNfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUkJDEkMSk7XG52YXIgaW52ZXJzZUhUTUwgPSBnZXRJbnZlcnNlT2JqKGVudGl0aWVzX2pzb25fMS5kZWZhdWx0KTtcbnZhciBodG1sUmVwbGFjZXIgPSBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZUhUTUwpO1xuLyoqXG4gKiBFbmNvZGVzIGFsbCBlbnRpdGllcyBhbmQgbm9uLUFTQ0lJIGNoYXJhY3RlcnMgaW4gdGhlIGlucHV0LlxuICpcbiAqIFRoaXMgaW5jbHVkZXMgY2hhcmFjdGVycyB0aGF0IGFyZSB2YWxpZCBBU0NJSSBjaGFyYWN0ZXJzIGluIEhUTUwgZG9jdW1lbnRzLlxuICogRm9yIGV4YW1wbGUgYCNgIHdpbGwgYmUgZW5jb2RlZCBhcyBgJm51bTtgLiBUbyBnZXQgYSBtb3JlIGNvbXBhY3Qgb3V0cHV0LFxuICogY29uc2lkZXIgdXNpbmcgdGhlIGBlbmNvZGVOb25Bc2NpaUhUTUxgIGZ1bmN0aW9uLlxuICpcbiAqIElmIGEgY2hhcmFjdGVyIGhhcyBubyBlcXVpdmFsZW50IGVudGl0eSwgYVxuICogbnVtZXJpYyBoZXhhZGVjaW1hbCByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkgd2lsbCBiZSB1c2VkLlxuICovXG5lbmNvZGUuZW5jb2RlSFRNTCA9IGdldEludmVyc2UoaW52ZXJzZUhUTUwsIGh0bWxSZXBsYWNlcik7XG4vKipcbiAqIEVuY29kZXMgYWxsIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBhcyB3ZWxsIGFzIGNoYXJhY3RlcnMgbm90IHZhbGlkIGluIEhUTUxcbiAqIGRvY3VtZW50cyB1c2luZyBIVE1MIGVudGl0aWVzLlxuICpcbiAqIElmIGEgY2hhcmFjdGVyIGhhcyBubyBlcXVpdmFsZW50IGVudGl0eSwgYVxuICogbnVtZXJpYyBoZXhhZGVjaW1hbCByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkgd2lsbCBiZSB1c2VkLlxuICovXG5lbmNvZGUuZW5jb2RlTm9uQXNjaWlIVE1MID0gZ2V0QVNDSUlFbmNvZGVyKGludmVyc2VIVE1MKTtcbmZ1bmN0aW9uIGdldEludmVyc2VPYmoob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgLnNvcnQoKVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChpbnZlcnNlLCBuYW1lKSB7XG4gICAgICAgIGludmVyc2Vbb2JqW25hbWVdXSA9IFwiJlwiICsgbmFtZSArIFwiO1wiO1xuICAgICAgICByZXR1cm4gaW52ZXJzZTtcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZSkge1xuICAgIHZhciBzaW5nbGUgPSBbXTtcbiAgICB2YXIgbXVsdGlwbGUgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMoaW52ZXJzZSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBrID0gX2FbX2ldO1xuICAgICAgICBpZiAoay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIEFkZCB2YWx1ZSB0byBzaW5nbGUgYXJyYXlcbiAgICAgICAgICAgIHNpbmdsZS5wdXNoKFwiXFxcXFwiICsgayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBBZGQgdmFsdWUgdG8gbXVsdGlwbGUgYXJyYXlcbiAgICAgICAgICAgIG11bHRpcGxlLnB1c2goayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIHJhbmdlcyB0byBzaW5nbGUgY2hhcmFjdGVycy5cbiAgICBzaW5nbGUuc29ydCgpO1xuICAgIGZvciAodmFyIHN0YXJ0ID0gMDsgc3RhcnQgPCBzaW5nbGUubGVuZ3RoIC0gMTsgc3RhcnQrKykge1xuICAgICAgICAvLyBGaW5kIHRoZSBlbmQgb2YgYSBydW4gb2YgY2hhcmFjdGVyc1xuICAgICAgICB2YXIgZW5kID0gc3RhcnQ7XG4gICAgICAgIHdoaWxlIChlbmQgPCBzaW5nbGUubGVuZ3RoIC0gMSAmJlxuICAgICAgICAgICAgc2luZ2xlW2VuZF0uY2hhckNvZGVBdCgxKSArIDEgPT09IHNpbmdsZVtlbmQgKyAxXS5jaGFyQ29kZUF0KDEpKSB7XG4gICAgICAgICAgICBlbmQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY291bnQgPSAxICsgZW5kIC0gc3RhcnQ7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gcmVwbGFjZSBhdCBsZWFzdCB0aHJlZSBjaGFyYWN0ZXJzXG4gICAgICAgIGlmIChjb3VudCA8IDMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgc2luZ2xlLnNwbGljZShzdGFydCwgY291bnQsIHNpbmdsZVtzdGFydF0gKyBcIi1cIiArIHNpbmdsZVtlbmRdKTtcbiAgICB9XG4gICAgbXVsdGlwbGUudW5zaGlmdChcIltcIiArIHNpbmdsZS5qb2luKFwiXCIpICsgXCJdXCIpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKG11bHRpcGxlLmpvaW4oXCJ8XCIpLCBcImdcIik7XG59XG4vLyAvW15cXDAtXFx4N0ZdL2d1XG52YXIgcmVOb25BU0NJSSA9IC8oPzpbXFx4ODAtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkvZztcbnZhciBnZXRDb2RlUG9pbnQgPSBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG5TdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0ICE9IG51bGxcbiAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ci5jb2RlUG9pbnRBdCgwKTsgfVxuICAgIDogLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiAoYy5jaGFyQ29kZUF0KDApIC0gMHhkODAwKSAqIDB4NDAwICtcbiAgICAgICAgICAgICAgICBjLmNoYXJDb2RlQXQoMSkgLVxuICAgICAgICAgICAgICAgIDB4ZGMwMCArXG4gICAgICAgICAgICAgICAgMHgxMDAwMDtcbiAgICAgICAgfTtcbmZ1bmN0aW9uIHNpbmdsZUNoYXJSZXBsYWNlcihjKSB7XG4gICAgcmV0dXJuIFwiJiN4XCIgKyAoYy5sZW5ndGggPiAxID8gZ2V0Q29kZVBvaW50KGMpIDogYy5jaGFyQ29kZUF0KDApKVxuICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgIC50b1VwcGVyQ2FzZSgpICsgXCI7XCI7XG59XG5mdW5jdGlvbiBnZXRJbnZlcnNlKGludmVyc2UsIHJlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgICAgICAgICAucmVwbGFjZShyZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGludmVyc2VbbmFtZV07IH0pXG4gICAgICAgICAgICAucmVwbGFjZShyZU5vbkFTQ0lJLCBzaW5nbGVDaGFyUmVwbGFjZXIpO1xuICAgIH07XG59XG52YXIgcmVFc2NhcGVDaGFycyA9IG5ldyBSZWdFeHAoeG1sUmVwbGFjZXIuc291cmNlICsgXCJ8XCIgKyByZU5vbkFTQ0lJLnNvdXJjZSwgXCJnXCIpO1xuLyoqXG4gKiBFbmNvZGVzIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycywgYXMgd2VsbCBhcyBjaGFyYWN0ZXJzIG5vdCB2YWxpZCBpbiBYTUxcbiAqIGRvY3VtZW50cyB1c2luZyBudW1lcmljIGhleGFkZWNpbWFsIHJlZmVyZW5jZSAoZWcuIGAmI3hmYztgKS5cbiAqXG4gKiBIYXZlIGEgbG9vayBhdCBgZXNjYXBlVVRGOGAgaWYgeW91IHdhbnQgYSBtb3JlIGNvbmNpc2Ugb3V0cHV0IGF0IHRoZSBleHBlbnNlXG4gKiBvZiByZWR1Y2VkIHRyYW5zcG9ydGFiaWxpdHkuXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGVzY2FwZS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5yZXBsYWNlKHJlRXNjYXBlQ2hhcnMsIHNpbmdsZUNoYXJSZXBsYWNlcik7XG59XG5lbmNvZGUuZXNjYXBlID0gZXNjYXBlO1xuLyoqXG4gKiBFbmNvZGVzIGFsbCBjaGFyYWN0ZXJzIG5vdCB2YWxpZCBpbiBYTUwgZG9jdW1lbnRzIHVzaW5nIG51bWVyaWMgaGV4YWRlY2ltYWxcbiAqIHJlZmVyZW5jZSAoZWcuIGAmI3hmYztgKS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIG91dHB1dCB3aWxsIGJlIGNoYXJhY3Rlci1zZXQgZGVwZW5kZW50LlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBlc2NhcGUuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVVURjgoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnJlcGxhY2UoeG1sUmVwbGFjZXIsIHNpbmdsZUNoYXJSZXBsYWNlcik7XG59XG5lbmNvZGUuZXNjYXBlVVRGOCA9IGVzY2FwZVVURjg7XG5mdW5jdGlvbiBnZXRBU0NJSUVuY29kZXIob2JqKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnJlcGxhY2UocmVFc2NhcGVDaGFycywgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG9ialtjXSB8fCBzaW5nbGVDaGFyUmVwbGFjZXIoYyk7IH0pO1xuICAgIH07XG59XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVYTUxTdHJpY3QgPSBleHBvcnRzLmRlY29kZUhUTUw1U3RyaWN0ID0gZXhwb3J0cy5kZWNvZGVIVE1MNFN0cmljdCA9IGV4cG9ydHMuZGVjb2RlSFRNTDUgPSBleHBvcnRzLmRlY29kZUhUTUw0ID0gZXhwb3J0cy5kZWNvZGVIVE1MU3RyaWN0ID0gZXhwb3J0cy5kZWNvZGVIVE1MID0gZXhwb3J0cy5kZWNvZGVYTUwgPSBleHBvcnRzLmVuY29kZUhUTUw1ID0gZXhwb3J0cy5lbmNvZGVIVE1MNCA9IGV4cG9ydHMuZXNjYXBlVVRGOCA9IGV4cG9ydHMuZXNjYXBlID0gZXhwb3J0cy5lbmNvZGVOb25Bc2NpaUhUTUwgPSBleHBvcnRzLmVuY29kZUhUTUwgPSBleHBvcnRzLmVuY29kZVhNTCA9IGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5kZWNvZGVTdHJpY3QgPSBleHBvcnRzLmRlY29kZSA9IHZvaWQgMDtcbnZhciBkZWNvZGVfMSA9IGRlY29kZTtcbnZhciBlbmNvZGVfMSA9IGVuY29kZTtcbi8qKlxuICogRGVjb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0gbGV2ZWwgT3B0aW9uYWwgbGV2ZWwgdG8gZGVjb2RlIGF0LiAwID0gWE1MLCAxID0gSFRNTC4gRGVmYXVsdCBpcyAwLlxuICogQGRlcHJlY2F0ZWQgVXNlIGBkZWNvZGVYTUxgIG9yIGBkZWNvZGVIVE1MYCBkaXJlY3RseS5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlJDEoZGF0YSwgbGV2ZWwpIHtcbiAgICByZXR1cm4gKCFsZXZlbCB8fCBsZXZlbCA8PSAwID8gZGVjb2RlXzEuZGVjb2RlWE1MIDogZGVjb2RlXzEuZGVjb2RlSFRNTCkoZGF0YSk7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZSQxO1xuLyoqXG4gKiBEZWNvZGVzIGEgc3RyaW5nIHdpdGggZW50aXRpZXMuIERvZXMgbm90IGFsbG93IG1pc3NpbmcgdHJhaWxpbmcgc2VtaWNvbG9ucyBmb3IgZW50aXRpZXMuXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBsZXZlbCBPcHRpb25hbCBsZXZlbCB0byBkZWNvZGUgYXQuIDAgPSBYTUwsIDEgPSBIVE1MLiBEZWZhdWx0IGlzIDAuXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGRlY29kZUhUTUxTdHJpY3RgIG9yIGBkZWNvZGVYTUxgIGRpcmVjdGx5LlxuICovXG5mdW5jdGlvbiBkZWNvZGVTdHJpY3QoZGF0YSwgbGV2ZWwpIHtcbiAgICByZXR1cm4gKCFsZXZlbCB8fCBsZXZlbCA8PSAwID8gZGVjb2RlXzEuZGVjb2RlWE1MIDogZGVjb2RlXzEuZGVjb2RlSFRNTFN0cmljdCkoZGF0YSk7XG59XG5leHBvcnRzLmRlY29kZVN0cmljdCA9IGRlY29kZVN0cmljdDtcbi8qKlxuICogRW5jb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gbGV2ZWwgT3B0aW9uYWwgbGV2ZWwgdG8gZW5jb2RlIGF0LiAwID0gWE1MLCAxID0gSFRNTC4gRGVmYXVsdCBpcyAwLlxuICogQGRlcHJlY2F0ZWQgVXNlIGBlbmNvZGVIVE1MYCwgYGVuY29kZVhNTGAgb3IgYGVuY29kZU5vbkFzY2lpSFRNTGAgZGlyZWN0bHkuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZSQxKGRhdGEsIGxldmVsKSB7XG4gICAgcmV0dXJuICghbGV2ZWwgfHwgbGV2ZWwgPD0gMCA/IGVuY29kZV8xLmVuY29kZVhNTCA6IGVuY29kZV8xLmVuY29kZUhUTUwpKGRhdGEpO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGUkMTtcbnZhciBlbmNvZGVfMiA9IGVuY29kZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZVhNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlWE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlSFRNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlSFRNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZU5vbkFzY2lpSFRNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlTm9uQXNjaWlIVE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lc2NhcGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlc2NhcGVVVEY4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lc2NhcGVVVEY4OyB9IH0pO1xuLy8gTGVnYWN5IGFsaWFzZXMgKGRlcHJlY2F0ZWQpXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVIVE1MNFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlSFRNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUhUTUw1XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lbmNvZGVIVE1MOyB9IH0pO1xudmFyIGRlY29kZV8yID0gZGVjb2RlO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlWE1MXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVYTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTFN0cmljdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlSFRNTFN0cmljdDsgfSB9KTtcbi8vIExlZ2FjeSBhbGlhc2VzIChkZXByZWNhdGVkKVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTDRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MNVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlSFRNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw0U3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MU3RyaWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTDVTdHJpY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUxTdHJpY3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVYTUxTdHJpY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZVhNTDsgfSB9KTtcbn0obGliKSk7XG5cbnZhciBFTlRJVFkgPSAnJig/OiN4W2EtZjAtOV17MSw2fXwjWzAtOV17MSw3fXxbYS16XVthLXowLTldezEsMzF9KTsnO1xudmFyIENfQkFDS1NMQVNIJDEgPSA5MjtcbnZhciByZUJhY2tzbGFzaE9yQW1wID0gL1tcXFxcJl0vO1xudmFyIEVTQ0FQQUJMRSA9ICdbIVwiIyQlJlxcJygpKissLi86Ozw9Pj9AW1xcXFxcXFxcXFxcXF1eX2B7fH1+LV0nO1xudmFyIHJlRW50aXR5T3JFc2NhcGVkQ2hhciA9IG5ldyBSZWdFeHAoXCJcXFxcXFxcXFwiICsgRVNDQVBBQkxFICsgXCJ8XCIgKyBFTlRJVFksICdnaScpO1xudmFyIFhNTFNQRUNJQUwgPSAnWyY8PlwiXSc7XG52YXIgcmVYbWxTcGVjaWFsID0gbmV3IFJlZ0V4cChYTUxTUEVDSUFMLCAnZycpO1xudmFyIHVuZXNjYXBlQ2hhciA9IGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMuY2hhckNvZGVBdCgwKSA9PT0gQ19CQUNLU0xBU0gkMSkge1xuICAgICAgICByZXR1cm4gcy5jaGFyQXQoMSk7XG4gICAgfVxuICAgIHJldHVybiBsaWIuZGVjb2RlSFRNTChzKTtcbn07XG4vLyBSZXBsYWNlIGVudGl0aWVzIGFuZCBiYWNrc2xhc2ggZXNjYXBlcyB3aXRoIGxpdGVyYWwgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHVuZXNjYXBlU3RyaW5nKHMpIHtcbiAgICBpZiAocmVCYWNrc2xhc2hPckFtcC50ZXN0KHMpKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UocmVFbnRpdHlPckVzY2FwZWRDaGFyLCB1bmVzY2FwZUNoYXIpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVSSSh1cmkpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZW5jb2RlXzEodXJpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gdXJpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2VVbnNhZmVDaGFyKHMpIHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICByZXR1cm4gJyZhbXA7JztcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICByZXR1cm4gJyZsdDsnO1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHJldHVybiAnJmd0Oyc7XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHJldHVybiAnJnF1b3Q7JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVzY2FwZVhtbChzKSB7XG4gICAgaWYgKHJlWG1sU3BlY2lhbC50ZXN0KHMpKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UocmVYbWxTcGVjaWFsLCByZXBsYWNlVW5zYWZlQ2hhcik7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgY291bnQpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGFyci5wdXNoKHN0cik7XG4gICAgfVxuICAgIHJldHVybiBhcnIuam9pbignJyk7XG59XG5mdW5jdGlvbiBpc0VtcHR5KHN0cikge1xuICAgIGlmICghc3RyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gIS9bXiBcXHRdKy8udGVzdChzdHIpO1xufVxuXG52YXIgTm9kZVdhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlV2Fsa2VyKHJvb3QpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gcm9vdDtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5lbnRlcmluZyA9IHRydWU7XG4gICAgfVxuICAgIE5vZGVXYWxrZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXIgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IHRoaXMuZW50ZXJpbmc7XG4gICAgICAgIGlmIChjdXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250YWluZXIgPSBpc0NvbnRhaW5lciQxKGN1cik7XG4gICAgICAgIGlmIChlbnRlcmluZyAmJiBjb250YWluZXIpIHtcbiAgICAgICAgICAgIGlmIChjdXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGN1ci5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc3RheSBvbiBub2RlIGJ1dCBleGl0XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ciA9PT0gdGhpcy5yb290KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5uZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXIucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5lbnRlcmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VyLm5leHQ7XG4gICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBlbnRlcmluZzogZW50ZXJpbmcsIG5vZGU6IGN1ciB9O1xuICAgIH07XG4gICAgTm9kZVdhbGtlci5wcm90b3R5cGUucmVzdW1lQXQgPSBmdW5jdGlvbiAobm9kZSwgZW50ZXJpbmcpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgdGhpcy5lbnRlcmluZyA9IGVudGVyaW5nID09PSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIE5vZGVXYWxrZXI7XG59KCkpO1xuXG5mdW5jdGlvbiBpc0NvbnRhaW5lciQxKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgIGNhc2UgJ2Jsb2NrUXVvdGUnOlxuICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgY2FzZSAnaXRlbSc6XG4gICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6XG4gICAgICAgIGNhc2UgJ2hlYWRpbmcnOlxuICAgICAgICBjYXNlICdlbXBoJzpcbiAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgY2FzZSAnc3RyaWtlJzpcbiAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICBjYXNlICd0YWJsZUhlYWQnOlxuICAgICAgICBjYXNlICd0YWJsZUJvZHknOlxuICAgICAgICBjYXNlICd0YWJsZVJvdyc6XG4gICAgICAgIGNhc2UgJ3RhYmxlQ2VsbCc6XG4gICAgICAgIGNhc2UgJ3RhYmxlRGVsaW1Sb3cnOlxuICAgICAgICBjYXNlICdjdXN0b21JbmxpbmUnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxudmFyIGxhc3ROb2RlSWQgPSAxO1xudmFyIG5vZGVNYXAgPSB7fTtcbmZ1bmN0aW9uIGdldE5vZGVCeUlkKGlkKSB7XG4gICAgcmV0dXJuIG5vZGVNYXBbaWRdO1xufVxuZnVuY3Rpb24gcmVtb3ZlTm9kZUJ5SWQoaWQpIHtcbiAgICBkZWxldGUgbm9kZU1hcFtpZF07XG59XG5mdW5jdGlvbiByZW1vdmVBbGxOb2RlKCkge1xuICAgIG5vZGVNYXAgPSB7fTtcbn1cbnZhciBOb2RlJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZShub2RlVHlwZSwgc291cmNlcG9zKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgLy8gb25seSBmb3IgY29udGFpbmVyIG5vZGVcbiAgICAgICAgdGhpcy5maXJzdENoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBudWxsO1xuICAgICAgICAvLyBvbmx5IGZvciBsZWFmIG5vZGVcbiAgICAgICAgdGhpcy5saXRlcmFsID0gbnVsbDtcbiAgICAgICAgaWYgKG5vZGVUeXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gbGFzdE5vZGVJZCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGVUeXBlO1xuICAgICAgICB0aGlzLnNvdXJjZXBvcyA9IHNvdXJjZXBvcztcbiAgICAgICAgbm9kZU1hcFt0aGlzLmlkXSA9IHRoaXM7XG4gICAgfVxuICAgIE5vZGUucHJvdG90eXBlLmlzQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaXNDb250YWluZXIkMSh0aGlzKTtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJldikge1xuICAgICAgICAgICAgdGhpcy5wcmV2Lm5leHQgPSB0aGlzLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmZpcnN0Q2hpbGQgPSB0aGlzLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LnByZXYgPSB0aGlzLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Lmxhc3RDaGlsZCA9IHRoaXMucHJldjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5yZXBsYWNlV2l0aCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICB0aGlzLnVubGluaygpO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoc2libGluZykge1xuICAgICAgICBzaWJsaW5nLnVubGluaygpO1xuICAgICAgICBzaWJsaW5nLm5leHQgPSB0aGlzLm5leHQ7XG4gICAgICAgIGlmIChzaWJsaW5nLm5leHQpIHtcbiAgICAgICAgICAgIHNpYmxpbmcubmV4dC5wcmV2ID0gc2libGluZztcbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nLnByZXYgPSB0aGlzO1xuICAgICAgICB0aGlzLm5leHQgPSBzaWJsaW5nO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXNpYmxpbmcubmV4dCkge1xuICAgICAgICAgICAgICAgIHNpYmxpbmcucGFyZW50Lmxhc3RDaGlsZCA9IHNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChzaWJsaW5nKSB7XG4gICAgICAgIHNpYmxpbmcudW5saW5rKCk7XG4gICAgICAgIHNpYmxpbmcucHJldiA9IHRoaXMucHJldjtcbiAgICAgICAgaWYgKHNpYmxpbmcucHJldikge1xuICAgICAgICAgICAgc2libGluZy5wcmV2Lm5leHQgPSBzaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIHNpYmxpbmcubmV4dCA9IHRoaXM7XG4gICAgICAgIHRoaXMucHJldiA9IHNpYmxpbmc7XG4gICAgICAgIHNpYmxpbmcucGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGlmICghc2libGluZy5wcmV2KSB7XG4gICAgICAgICAgICBzaWJsaW5nLnBhcmVudC5maXJzdENoaWxkID0gc2libGluZztcbiAgICAgICAgfVxuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQudW5saW5rKCk7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q2hpbGQubmV4dCA9IGNoaWxkO1xuICAgICAgICAgICAgY2hpbGQucHJldiA9IHRoaXMubGFzdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUucHJlcGVuZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnVubGluaygpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0Q2hpbGQucHJldiA9IGNoaWxkO1xuICAgICAgICAgICAgY2hpbGQubmV4dCA9IHRoaXMuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maXJzdENoaWxkID0gY2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmxhc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS53YWxrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVdhbGtlcih0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBOb2RlO1xufSgpKTtcbnZhciBCbG9ja05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9ja05vZGUobm9kZVR5cGUsIHNvdXJjZXBvcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBub2RlVHlwZSwgc291cmNlcG9zKSB8fCB0aGlzO1xuICAgICAgICAvLyB0ZW1wb3JhbCBkYXRhIChmb3IgcGFyc2luZylcbiAgICAgICAgX3RoaXMub3BlbiA9IHRydWU7XG4gICAgICAgIF90aGlzLmxpbmVPZmZzZXRzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuc3RyaW5nQ29udGVudCA9IG51bGw7XG4gICAgICAgIF90aGlzLmxhc3RMaW5lQmxhbmsgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubGFzdExpbmVDaGVja2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnR5cGUgPSBub2RlVHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQmxvY2tOb2RlO1xufShOb2RlJDEpKTtcbnZhciBMaXN0Tm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGlzdE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGlzdE5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5saXN0RGF0YSA9IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExpc3ROb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBIZWFkaW5nTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGVhZGluZ05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVhZGluZ05vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZXZlbCA9IDA7XG4gICAgICAgIF90aGlzLmhlYWRpbmdUeXBlID0gJ2F0eCc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEhlYWRpbmdOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBDb2RlQmxvY2tOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb2RlQmxvY2tOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvZGVCbG9ja05vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pc0ZlbmNlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5mZW5jZUNoYXIgPSBudWxsO1xuICAgICAgICBfdGhpcy5mZW5jZUxlbmd0aCA9IDA7XG4gICAgICAgIF90aGlzLmZlbmNlT2Zmc2V0ID0gLTE7XG4gICAgICAgIF90aGlzLmluZm8gPSBudWxsO1xuICAgICAgICBfdGhpcy5pbmZvUGFkZGluZyA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvZGVCbG9ja05vZGU7XG59KEJsb2NrTm9kZSkpO1xudmFyIFRhYmxlTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbHVtbnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFibGVOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBUYWJsZUNlbGxOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZUNlbGxOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlQ2VsbE5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGFydElkeCA9IDA7XG4gICAgICAgIF90aGlzLmVuZElkeCA9IDA7XG4gICAgICAgIF90aGlzLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgICAgX3RoaXMucGFkZGluZ1JpZ2h0ID0gMDtcbiAgICAgICAgX3RoaXMuaWdub3JlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUYWJsZUNlbGxOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBSZWZEZWZOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWZEZWZOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZkRlZk5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50aXRsZSA9ICcnO1xuICAgICAgICBfdGhpcy5kZXN0ID0gJyc7XG4gICAgICAgIF90aGlzLmxhYmVsID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlZkRlZk5vZGU7XG59KEJsb2NrTm9kZSkpO1xudmFyIEN1c3RvbUJsb2NrTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ3VzdG9tQmxvY2tOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1c3RvbUJsb2NrTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN5bnRheExlbmd0aCA9IDA7XG4gICAgICAgIF90aGlzLm9mZnNldCA9IC0xO1xuICAgICAgICBfdGhpcy5pbmZvID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEN1c3RvbUJsb2NrTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgSHRtbEJsb2NrTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSHRtbEJsb2NrTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIdG1sQmxvY2tOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaHRtbEJsb2NrVHlwZSA9IC0xO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIdG1sQmxvY2tOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBMaW5rTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGlua05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGlua05vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgIF90aGlzLnRpdGxlID0gbnVsbDtcbiAgICAgICAgX3RoaXMuZXh0ZW5kZWRBdXRvbGluayA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBMaW5rTm9kZTtcbn0oTm9kZSQxKSk7XG52YXIgQ29kZU5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvZGVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvZGVOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGlja0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29kZU5vZGU7XG59KE5vZGUkMSkpO1xudmFyIEN1c3RvbUlubGluZU5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEN1c3RvbUlubGluZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3VzdG9tSW5saW5lTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmluZm8gPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ3VzdG9tSW5saW5lTm9kZTtcbn0oTm9kZSQxKSk7XG5mdW5jdGlvbiBjcmVhdGVOb2RlJDEodHlwZSwgc291cmNlcG9zKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2hlYWRpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWFkaW5nTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgY2FzZSAnaXRlbSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3ROb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpbmtOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2NvZGVCbG9jayc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvZGVCbG9ja05vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAnaHRtbEJsb2NrJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSHRtbEJsb2NrTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRhYmxlTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICd0YWJsZUNlbGwnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYWJsZUNlbGxOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgY2FzZSAncGFyYWdyYXBoJzpcbiAgICAgICAgY2FzZSAnYmxvY2tRdW90ZSc6XG4gICAgICAgIGNhc2UgJ3RoZW1hdGljQnJlYWsnOlxuICAgICAgICBjYXNlICd0YWJsZVJvdyc6XG4gICAgICAgIGNhc2UgJ3RhYmxlQm9keSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlSGVhZCc6XG4gICAgICAgIGNhc2UgJ2Zyb250TWF0dGVyJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2NvZGUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2RlTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdyZWZEZWYnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWZEZWZOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2N1c3RvbUJsb2NrJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tQmxvY2tOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2N1c3RvbUlubGluZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUlubGluZU5vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZSQxKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNDb2RlQmxvY2sobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdjb2RlQmxvY2snO1xufVxuZnVuY3Rpb24gaXNIdG1sQmxvY2sobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdodG1sQmxvY2snO1xufVxuZnVuY3Rpb24gaXNIZWFkaW5nKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAnaGVhZGluZyc7XG59XG5mdW5jdGlvbiBpc0xpc3Qobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdsaXN0Jztcbn1cbmZ1bmN0aW9uIGlzVGFibGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICd0YWJsZSc7XG59XG5mdW5jdGlvbiBpc1JlZkRlZihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ3JlZkRlZic7XG59XG5mdW5jdGlvbiBpc0N1c3RvbUJsb2NrKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAnY3VzdG9tQmxvY2snO1xufVxuZnVuY3Rpb24gaXNDdXN0b21JbmxpbmUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdjdXN0b21JbmxpbmUnO1xufVxuZnVuY3Rpb24gdGV4dCQxKHMsIHNvdXJjZXBvcykge1xuICAgIHZhciBub2RlID0gY3JlYXRlTm9kZSQxKCd0ZXh0Jywgc291cmNlcG9zKTtcbiAgICBub2RlLmxpdGVyYWwgPSBzO1xuICAgIHJldHVybiBub2RlO1xufVxuXG52YXIgVEFHTkFNRSA9ICdbQS1aYS16XVtBLVphLXowLTktXSonO1xudmFyIEFUVFJJQlVURU5BTUUgPSAnW2EtekEtWl86XVthLXpBLVowLTk6Ll8tXSonO1xudmFyIFVOUVVPVEVEVkFMVUUgPSAnW15cIlxcJz08PmBcXFxceDAwLVxcXFx4MjBdKyc7XG52YXIgU0lOR0xFUVVPVEVEVkFMVUUgPSBcIidbXiddKidcIjtcbnZhciBET1VCTEVRVU9URURWQUxVRSA9ICdcIlteXCJdKlwiJztcbnZhciBBVFRSSUJVVEVWQUxVRSA9IFwiKD86XCIgKyBVTlFVT1RFRFZBTFVFICsgXCJ8XCIgKyBTSU5HTEVRVU9URURWQUxVRSArIFwifFwiICsgRE9VQkxFUVVPVEVEVkFMVUUgKyBcIilcIjtcbnZhciBBVFRSSUJVVEVWQUxVRVNQRUMgPSBcIlwiICsgJyg/OlxcXFxzKj1cXFxccyonICsgQVRUUklCVVRFVkFMVUUgKyBcIilcIjtcbnZhciBBVFRSSUJVVEUgPSBcIlwiICsgJyg/OlxcXFxzKycgKyBBVFRSSUJVVEVOQU1FICsgQVRUUklCVVRFVkFMVUVTUEVDICsgXCI/KVwiO1xudmFyIE9QRU5UQUcgPSBcIjxcIiArIFRBR05BTUUgKyBBVFRSSUJVVEUgKyBcIipcXFxccyovPz5cIjtcbnZhciBDTE9TRVRBRyA9IFwiPC9cIiArIFRBR05BTUUgKyBcIlxcXFxzKls+XVwiO1xudmFyIEhUTUxDT01NRU5UID0gJzwhLS0tLT58PCEtLSg/Oi0/W14+LV0pKD86LT9bXi1dKSotLT4nO1xudmFyIFBST0NFU1NJTkdJTlNUUlVDVElPTiA9ICdbPF1bP10uKj9bP11bPl0nO1xudmFyIERFQ0xBUkFUSU9OID0gJzwhW0EtWl0rXFxcXHMrW14+XSo+JztcbnZhciBDREFUQSA9ICc8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nO1xudmFyIEhUTUxUQUcgPSBcIig/OlwiICsgT1BFTlRBRyArIFwifFwiICsgQ0xPU0VUQUcgKyBcInxcIiArIEhUTUxDT01NRU5UICsgXCJ8XCIgKyBQUk9DRVNTSU5HSU5TVFJVQ1RJT04gKyBcInxcIiArIERFQ0xBUkFUSU9OICsgXCJ8XCIgKyBDREFUQSArIFwiKVwiO1xudmFyIHJlSHRtbFRhZyA9IG5ldyBSZWdFeHAoXCJeXCIgKyBIVE1MVEFHLCAnaScpO1xuXG4vLyBkZXJpdmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLmZyb21Db2RlUG9pbnRcbi8qISBodHRwOi8vbXRocy5iZS9mcm9tY29kZXBvaW50IHYwLjIuMSBieSBAbWF0aGlhcyAqL1xudmFyIGZyb21Db2RlUG9pbnQ7XG5pZiAoU3RyaW5nLmZyb21Db2RlUG9pbnQpIHtcbiAgICBmcm9tQ29kZVBvaW50ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChfKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSYW5nZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmZmZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZWxzZSB7XG4gICAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZV8xID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgICB2YXIgZmxvb3JfMSA9IE1hdGguZmxvb3I7XG4gICAgZnJvbUNvZGVQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgTUFYX1NJWkUgPSAweDQwMDA7XG4gICAgICAgIHZhciBjb2RlVW5pdHMgPSBbXTtcbiAgICAgICAgdmFyIGhpZ2hTdXJyb2dhdGU7XG4gICAgICAgIHZhciBsb3dTdXJyb2dhdGU7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IE51bWJlcihhcmdzW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAoIWlzRmluaXRlKGNvZGVQb2ludCkgfHwgLy8gYE5hTmAsIGArSW5maW5pdHlgLCBvciBgLUluZmluaXR5YFxuICAgICAgICAgICAgICAgIGNvZGVQb2ludCA8IDAgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgICAgICAgY29kZVBvaW50ID4gMHgxMGZmZmYgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgICAgICAgZmxvb3JfMShjb2RlUG9pbnQpICE9PSBjb2RlUG9pbnQgLy8gbm90IGFuIGludGVnZXJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZmZmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgICAgIC8vIEJNUCBjb2RlIHBvaW50XG4gICAgICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goY29kZVBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFzdHJhbCBjb2RlIHBvaW50OyBzcGxpdCBpbiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgICAgICBoaWdoU3Vycm9nYXRlID0gKGNvZGVQb2ludCA+PiAxMCkgKyAweGQ4MDA7XG4gICAgICAgICAgICAgICAgbG93U3Vycm9nYXRlID0gKGNvZGVQb2ludCAlIDB4NDAwKSArIDB4ZGMwMDtcbiAgICAgICAgICAgICAgICBjb2RlVW5pdHMucHVzaChoaWdoU3Vycm9nYXRlLCBsb3dTdXJyb2dhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ICsgMSA9PT0gbGVuZ3RoIHx8IGNvZGVVbml0cy5sZW5ndGggPiBNQVhfU0laRSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmdGcm9tQ2hhckNvZGVfMS5hcHBseSh2b2lkIDAsIGNvZGVVbml0cyk7XG4gICAgICAgICAgICAgICAgY29kZVVuaXRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxudmFyIGZyb21Db2RlUG9pbnQkMSA9IGZyb21Db2RlUG9pbnQ7XG5cbnZhciBET01BSU4gPSAnKD86W3ctXSsuKSpbQS1aYS16MC05LV0rLltBLVphLXowLTktXSsnO1xudmFyIFBBVEggPSAnW148XFxcXHNdKltePD8hLiw6Kl8/flxcXFxzXSc7XG52YXIgRU1BSUwgPSAnW1xcXFx3ListXStAKD86W1xcXFx3LV0rXFxcXC4pK1tcXFxcdy1dKyc7XG5mdW5jdGlvbiB0cmltVW5tYXRjaGVkVHJhaWxpbmdQYXJlbnMoc291cmNlKSB7XG4gICAgdmFyIHRyYWlsaW5nUGFyZW4gPSAvXFwpKyQvLmV4ZWMoc291cmNlKTtcbiAgICBpZiAodHJhaWxpbmdQYXJlbikge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNvdXJjZV8xID0gc291cmNlOyBfaSA8IHNvdXJjZV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNoID0gc291cmNlXzFbX2ldO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICcpJykge1xuICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAgICAgdmFyIHRyaW1Db3VudCA9IE1hdGgubWluKC1jb3VudCwgdHJhaWxpbmdQYXJlblswXS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzdHJpbmcoMCwgc291cmNlLmxlbmd0aCAtIHRyaW1Db3VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbn1cbmZ1bmN0aW9uIHRyaW1UcmFpbGluZ0VudGl0eShzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLnJlcGxhY2UoLyZbQS1aYS16MC05XSs7JC8sICcnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRW1haWxMaW5rKHNvdXJjZSkge1xuICAgIHZhciByZUVtYWlsTGluayA9IG5ldyBSZWdFeHAoRU1BSUwsICdnJyk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBtO1xuICAgIHdoaWxlICgobSA9IHJlRW1haWxMaW5rLmV4ZWMoc291cmNlKSkpIHtcbiAgICAgICAgdmFyIHRleHRfMSA9IG1bMF07XG4gICAgICAgIGlmICghL1tfLV0rJC8udGVzdCh0ZXh0XzEpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dF8xLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbbS5pbmRleCwgbS5pbmRleCArIHRleHRfMS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICB1cmw6IFwibWFpbHRvOlwiICsgdGV4dF8xLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlVXJsTGluayhzb3VyY2UpIHtcbiAgICB2YXIgcmVXd3dBdXRvbGluayA9IG5ldyBSZWdFeHAoXCIod3d3fGh0dHBzPzovLykuXCIgKyBET01BSU4gKyBQQVRILCAnZycpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgbTtcbiAgICB3aGlsZSAoKG0gPSByZVd3d0F1dG9saW5rLmV4ZWMoc291cmNlKSkpIHtcbiAgICAgICAgdmFyIHRleHRfMiA9IHRyaW1UcmFpbGluZ0VudGl0eSh0cmltVW5tYXRjaGVkVHJhaWxpbmdQYXJlbnMobVswXSkpO1xuICAgICAgICB2YXIgc2NoZW1lID0gbVsxXSA9PT0gJ3d3dycgPyAnaHR0cDovLycgOiAnJztcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgdGV4dDogdGV4dF8yLFxuICAgICAgICAgICAgcmFuZ2U6IFttLmluZGV4LCBtLmluZGV4ICsgdGV4dF8yLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgdXJsOiBcIlwiICsgc2NoZW1lICsgdGV4dF8yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGJhc2VBdXRvbGlua1BhcnNlcihzb3VyY2UpIHtcbiAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBwYXJzZVVybExpbmsoc291cmNlKSksIHBhcnNlRW1haWxMaW5rKHNvdXJjZSkpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEucmFuZ2VbMF0gLSBiLnJhbmdlWzBdOyB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRFeHRBdXRvTGlua3Mod2Fsa2VyLCBhdXRvbGlua1BhcnNlcikge1xuICAgIGlmICh0eXBlb2YgYXV0b2xpbmtQYXJzZXIgPT09ICdib29sZWFuJykge1xuICAgICAgICBhdXRvbGlua1BhcnNlciA9IGJhc2VBdXRvbGlua1BhcnNlcjtcbiAgICB9XG4gICAgdmFyIGV2ZW50O1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZywgbm9kZSA9IGV2ZW50Lm5vZGU7XG4gICAgICAgIGlmIChlbnRlcmluZyAmJiBub2RlLnR5cGUgPT09ICd0ZXh0JyAmJiBub2RlLnBhcmVudC50eXBlICE9PSAnbGluaycpIHtcbiAgICAgICAgICAgIHZhciBsaXRlcmFsID0gbm9kZS5saXRlcmFsO1xuICAgICAgICAgICAgdmFyIGxpbmtJbmZvcyA9IGF1dG9saW5rUGFyc2VyKGxpdGVyYWwpO1xuICAgICAgICAgICAgaWYgKCFsaW5rSW5mb3MgfHwgIWxpbmtJbmZvcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxhc3RJZHggPSAwO1xuICAgICAgICAgICAgdmFyIF9hID0gbm9kZS5zb3VyY2Vwb3NbMF0sIGxpbmVOdW1fMSA9IF9hWzBdLCBjaFBvc18xID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgc291cmNlcG9zID0gZnVuY3Rpb24gKHN0YXJ0SWR4LCBlbmRJZHgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBbbGluZU51bV8xLCBjaFBvc18xICsgc3RhcnRJZHhdLFxuICAgICAgICAgICAgICAgIFtsaW5lTnVtXzEsIGNoUG9zXzEgKyBlbmRJZHhdLFxuICAgICAgICAgICAgXTsgfTtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBsaW5rSW5mb3NfMSA9IGxpbmtJbmZvczsgX2kgPCBsaW5rSW5mb3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBsaW5rSW5mb3NfMVtfaV0sIHJhbmdlID0gX2IucmFuZ2UsIHVybCA9IF9iLnVybCwgbGlua1RleHQgPSBfYi50ZXh0O1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZVswXSA+IGxhc3RJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZXMucHVzaCh0ZXh0JDEobGl0ZXJhbC5zdWJzdHJpbmcobGFzdElkeCwgcmFuZ2VbMF0pLCBzb3VyY2Vwb3MobGFzdElkeCwgcmFuZ2VbMF0gLSAxKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGlua05vZGUgPSBjcmVhdGVOb2RlJDEoJ2xpbmsnLCBzb3VyY2Vwb3MuYXBwbHkodm9pZCAwLCByYW5nZSkpO1xuICAgICAgICAgICAgICAgIGxpbmtOb2RlLmFwcGVuZENoaWxkKHRleHQkMShsaW5rVGV4dCwgc291cmNlcG9zLmFwcGx5KHZvaWQgMCwgcmFuZ2UpKSk7XG4gICAgICAgICAgICAgICAgbGlua05vZGUuZGVzdGluYXRpb24gPSB1cmw7XG4gICAgICAgICAgICAgICAgbGlua05vZGUuZXh0ZW5kZWRBdXRvbGluayA9IHRydWU7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZXMucHVzaChsaW5rTm9kZSk7XG4gICAgICAgICAgICAgICAgbGFzdElkeCA9IHJhbmdlWzFdICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0SWR4IDwgbGl0ZXJhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuZXdOb2Rlcy5wdXNoKHRleHQkMShsaXRlcmFsLnN1YnN0cmluZyhsYXN0SWR4KSwgc291cmNlcG9zKGxhc3RJZHgsIGxpdGVyYWwubGVuZ3RoIC0gMSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9jID0gMCwgbmV3Tm9kZXNfMSA9IG5ld05vZGVzOyBfYyA8IG5ld05vZGVzXzEubGVuZ3RoOyBfYysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld05vZGUgPSBuZXdOb2Rlc18xW19jXTtcbiAgICAgICAgICAgICAgICBub2RlLmluc2VydEJlZm9yZShuZXdOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUudW5saW5rKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICBfbG9vcF8xKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBsYXN0KGFycikge1xuICAgIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xufVxuLy8gbm9ybWFsaXplIGEgcmVmZXJlbmNlIGluIHJlZmVyZW5jZSBsaW5rIChyZW1vdmUgW11zLCB0cmltLFxuLy8gY29sbGFwc2UgaW50ZXJuYWwgc3BhY2UsIHVuaWNvZGUgY2FzZSBmb2xkLlxuLy8gU2VlIGNvbW1vbm1hcmsvY29tbW9ubWFyay5qcyMxNjguXG5mdW5jdGlvbiBub3JtYWxpemVSZWZlcmVuY2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0clxuICAgICAgICAuc2xpY2UoMSwgc3RyLmxlbmd0aCAtIDEpXG4gICAgICAgIC50cmltKClcbiAgICAgICAgLnJlcGxhY2UoL1sgXFx0XFxyXFxuXSsvLCAnICcpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIC50b1VwcGVyQ2FzZSgpO1xufVxuZnVuY3Rpb24gaXRlcmF0ZU9iamVjdChvYmosIGl0ZXJhdGVlKSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaXRlcmF0ZWUoa2V5LCBvYmpba2V5XSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBvbWl0KG9iaikge1xuICAgIHZhciBwcm9wTmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBwcm9wTmFtZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciByZXN1bHRNYXAgPSBfX2Fzc2lnbih7fSwgb2JqKTtcbiAgICBwcm9wTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSByZXN1bHRNYXBba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0TWFwO1xufVxuZnVuY3Rpb24gaXNFbXB0eU9iaihvYmopIHtcbiAgICByZXR1cm4gIU9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xufVxuZnVuY3Rpb24gY2xlYXJPYmoob2JqKSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgIH0pO1xufVxuXG52YXIgQ19ORVdMSU5FID0gMTA7XG52YXIgQ19BU1RFUklTSyA9IDQyO1xudmFyIENfVU5ERVJTQ09SRSA9IDk1O1xudmFyIENfQkFDS1RJQ0sgPSA5NjtcbnZhciBDX09QRU5fQlJBQ0tFVCQxID0gOTE7XG52YXIgQ19DTE9TRV9CUkFDS0VUID0gOTM7XG52YXIgQ19USUxERSA9IDEyNjtcbnZhciBDX0xFU1NUSEFOJDEgPSA2MDtcbnZhciBDX0JBTkcgPSAzMztcbnZhciBDX0JBQ0tTTEFTSCA9IDkyO1xudmFyIENfQU1QRVJTQU5EID0gMzg7XG52YXIgQ19PUEVOX1BBUkVOID0gNDA7XG52YXIgQ19DTE9TRV9QQVJFTiA9IDQxO1xudmFyIENfQ09MT04gPSA1ODtcbnZhciBDX1NJTkdMRVFVT1RFID0gMzk7XG52YXIgQ19ET1VCTEVRVU9URSA9IDM0O1xudmFyIENfRE9MTEFSID0gMzY7XG4vLyBTb21lIHJlZ2V4cHMgdXNlZCBpbiBpbmxpbmUgcGFyc2VyOlxudmFyIEVTQ0FQRURfQ0hBUiA9IFwiXFxcXFxcXFxcIiArIEVTQ0FQQUJMRTtcbnZhciByZVB1bmN0dWF0aW9uID0gbmV3IFJlZ0V4cCgvWyFcIiMkJSYnKCkqKyxcXC0uLzo7PD0+P0BcXFtcXF1cXFxcXl9ge3x9flxceEExXFx4QTdcXHhBQlxceEI2XFx4QjdcXHhCQlxceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFNDJcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QThGQ1xcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdURGOUZcXHVERkQwXXxcXHVEODAxXFx1REQ2RnxcXHVEODAyW1xcdURDNTdcXHVERDFGXFx1REQzRlxcdURFNTAtXFx1REU1OFxcdURFN0ZcXHVERUYwLVxcdURFRjZcXHVERjM5LVxcdURGM0ZcXHVERjk5LVxcdURGOUNdfFxcdUQ4MDRbXFx1REM0Ny1cXHVEQzREXFx1RENCQlxcdURDQkNcXHVEQ0JFLVxcdURDQzFcXHVERDQwLVxcdURENDNcXHVERDc0XFx1REQ3NVxcdUREQzUtXFx1RERDOVxcdUREQ0RcXHVERERCXFx1RERERC1cXHVERERGXFx1REUzOC1cXHVERTNEXFx1REVBOV18XFx1RDgwNVtcXHVEQ0M2XFx1RERDMS1cXHVEREQ3XFx1REU0MS1cXHVERTQzXFx1REYzQy1cXHVERjNFXXxcXHVEODA5W1xcdURDNzAtXFx1REM3NF18XFx1RDgxQVtcXHVERTZFXFx1REU2RlxcdURFRjVcXHVERjM3LVxcdURGM0JcXHVERjQ0XXxcXHVEODJGXFx1REM5RnxcXHVEODM2W1xcdURFODctXFx1REU4Ql0vKTtcbnZhciByZUxpbmtUaXRsZSA9IG5ldyBSZWdFeHAoXCJeKD86XFxcIihcIiArIEVTQ0FQRURfQ0hBUiArIFwifFteXFxcIlxcXFx4MDBdKSpcXFwiXCIgK1xuICAgIFwifFwiICtcbiAgICAoXCInKFwiICsgRVNDQVBFRF9DSEFSICsgXCJ8W14nXFxcXHgwMF0pKidcIikgK1xuICAgIFwifFwiICtcbiAgICAoXCJcXFxcKChcIiArIEVTQ0FQRURfQ0hBUiArIFwifFteKClcXFxceDAwXSkqXFxcXCkpXCIpKTtcbnZhciByZUxpbmtEZXN0aW5hdGlvbkJyYWNlcyA9IC9eKD86PCg/OltePD5cXG5cXFxcXFx4MDBdfFxcXFwuKSo+KS87XG52YXIgcmVFc2NhcGFibGUgPSBuZXcgUmVnRXhwKFwiXlwiICsgRVNDQVBBQkxFKTtcbnZhciByZUVudGl0eUhlcmUgPSBuZXcgUmVnRXhwKFwiXlwiICsgRU5USVRZLCAnaScpO1xudmFyIHJlVGlja3MgPSAvYCsvO1xudmFyIHJlVGlja3NIZXJlID0gL15gKy87XG52YXIgcmVFbGxpcHNlcyA9IC9cXC5cXC5cXC4vZztcbnZhciByZURhc2ggPSAvLS0rL2c7XG52YXIgcmVFbWFpbEF1dG9saW5rID0gL148KFthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSopPi87XG52YXIgcmVBdXRvbGluayA9IC9ePFtBLVphLXpdW0EtWmEtejAtOS4rLV17MSwzMX06W148PlxceDAwLVxceDIwXSo+L2k7XG52YXIgcmVTcG5sID0gL14gKig/OlxcbiAqKT8vO1xudmFyIHJlV2hpdGVzcGFjZUNoYXIgPSAvXlsgXFx0XFxuXFx4MGJcXHgwY1xceDBkXS87XG52YXIgcmVVbmljb2RlV2hpdGVzcGFjZUNoYXIgPSAvXlxccy87XG52YXIgcmVGaW5hbFNwYWNlID0gLyAqJC87XG52YXIgcmVJbml0aWFsU3BhY2UgPSAvXiAqLztcbnZhciByZVNwYWNlQXRFbmRPZkxpbmUgPSAvXiAqKD86XFxufCQpLztcbnZhciByZUxpbmtMYWJlbCA9IC9eXFxbKD86W15cXFxcXFxbXFxdXXxcXFxcLil7MCwxMDAwfVxcXS87XG4vLyBNYXRjaGVzIGEgc3RyaW5nIG9mIG5vbi1zcGVjaWFsIGNoYXJhY3RlcnMuXG52YXIgcmVNYWluID0gL15bXlxcbmBcXFtcXF1cXFxcITwmKl8nXCJ+JF0rL207XG52YXIgSW5saW5lUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElubGluZVBhcnNlcihvcHRpb25zKSB7XG4gICAgICAgIC8vIEFuIElubGluZVBhcnNlciBrZWVwcyB0cmFjayBvZiBhIHN1YmplY3QgKGEgc3RyaW5nIHRvIGJlIHBhcnNlZClcbiAgICAgICAgLy8gYW5kIGEgcG9zaXRpb24gaW4gdGhhdCBzdWJqZWN0LlxuICAgICAgICB0aGlzLnN1YmplY3QgPSAnJztcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gbnVsbDsgLy8gdXNlZCBieSBoYW5kbGVEZWxpbSBtZXRob2RcbiAgICAgICAgdGhpcy5icmFja2V0cyA9IG51bGw7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5saW5lU3RhcnROdW0gPSAwO1xuICAgICAgICB0aGlzLmxpbmVJZHggPSAwO1xuICAgICAgICB0aGlzLmxpbmVPZmZzZXRzID0gWzBdO1xuICAgICAgICB0aGlzLmxpbmVQb3NPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLnJlZk1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5zb3VyY2Vwb3MgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgbGluZVBvc09mZnNldCA9IHRoaXMubGluZVBvc09mZnNldCArIHRoaXMubGluZU9mZnNldHNbdGhpcy5saW5lSWR4XTtcbiAgICAgICAgdmFyIGxpbmVOdW0gPSB0aGlzLmxpbmVTdGFydE51bSArIHRoaXMubGluZUlkeDtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gW2xpbmVOdW0sIHN0YXJ0ICsgbGluZVBvc09mZnNldF07XG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIFtzdGFydHBvcywgW2xpbmVOdW0sIGVuZCArIGxpbmVQb3NPZmZzZXRdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnRwb3M7XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLm5leHRMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxpbmVJZHggKz0gMTtcbiAgICAgICAgdGhpcy5saW5lUG9zT2Zmc2V0ID0gLXRoaXMucG9zO1xuICAgIH07XG4gICAgLy8gSWYgcmUgbWF0Y2hlcyBhdCBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBzdWJqZWN0LCBhZHZhbmNlXG4gICAgLy8gcG9zaXRpb24gaW4gc3ViamVjdCBhbmQgcmV0dXJuIHRoZSBtYXRjaDsgb3RoZXJ3aXNlIHJldHVybiBudWxsLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAocmUpIHtcbiAgICAgICAgdmFyIG0gPSByZS5leGVjKHRoaXMuc3ViamVjdC5zbGljZSh0aGlzLnBvcykpO1xuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gbS5pbmRleCArIG1bMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbVswXTtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgdGhlIGNvZGUgZm9yIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIGN1cnJlbnQgc3ViamVjdCBwb3NpdGlvbiwgb3IgLTFcbiAgICAvLyB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdWJqZWN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViamVjdC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICAvLyBQYXJzZSB6ZXJvIG9yIG1vcmUgc3BhY2UgY2hhcmFjdGVycywgaW5jbHVkaW5nIGF0IG1vc3Qgb25lIG5ld2xpbmVcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnNwbmwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWF0Y2gocmVTcG5sKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBBbGwgb2YgdGhlIHBhcnNlcnMgYmVsb3cgdHJ5IHRvIG1hdGNoIHNvbWV0aGluZyBhdCB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgIC8vIGluIHRoZSBzdWJqZWN0LiAgSWYgdGhleSBzdWNjZWVkIGluIG1hdGNoaW5nIGFueXRoaW5nLCB0aGV5XG4gICAgLy8gcmV0dXJuIHRoZSBpbmxpbmUgbWF0Y2hlZCwgYWR2YW5jaW5nIHRoZSBzdWJqZWN0LlxuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYmFja3RpY2tzLCBhZGRpbmcgZWl0aGVyIGEgYmFja3RpY2sgY29kZSBzcGFuIG9yIGFcbiAgICAvLyBsaXRlcmFsIHNlcXVlbmNlIG9mIGJhY2t0aWNrcy5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlQmFja3RpY2tzID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgdmFyIHRpY2tzID0gdGhpcy5tYXRjaChyZVRpY2tzSGVyZSk7XG4gICAgICAgIGlmICh0aWNrcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZnRlck9wZW5UaWNrcyA9IHRoaXMucG9zO1xuICAgICAgICB2YXIgbWF0Y2hlZDtcbiAgICAgICAgd2hpbGUgKChtYXRjaGVkID0gdGhpcy5tYXRjaChyZVRpY2tzKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaGVkID09PSB0aWNrcykge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IHRoaXMuc3ViamVjdC5zbGljZShhZnRlck9wZW5UaWNrcywgdGhpcy5wb3MgLSB0aWNrcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2Vwb3MgPSB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IGNvbnRlbnRzLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdExpbmUgPSBsYXN0KGxpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lSWR4ICs9IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVBvc09mZnNldCA9IC0odGhpcy5wb3MgLSBsYXN0TGluZS5sZW5ndGggLSB0aWNrcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2Vwb3NbMV0gPSB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gbGluZXMuam9pbignICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUkMSgnY29kZScsIHNvdXJjZXBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMubWF0Y2goL1teIF0vKSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBjb250ZW50c1swXSA9PSAnICcgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHNbY29udGVudHMubGVuZ3RoIC0gMV0gPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGl0ZXJhbCA9IGNvbnRlbnRzLnNsaWNlKDEsIGNvbnRlbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5saXRlcmFsID0gY29udGVudHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUudGlja0NvdW50ID0gdGlja3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGdvdCBoZXJlLCB3ZSBkaWRuJ3QgbWF0Y2ggYSBjbG9zaW5nIGJhY2t0aWNrIHNlcXVlbmNlLlxuICAgICAgICB0aGlzLnBvcyA9IGFmdGVyT3BlblRpY2tzO1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0JDEodGlja3MsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcyAtIDEpKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gUGFyc2UgYSBiYWNrc2xhc2gtZXNjYXBlZCBzcGVjaWFsIGNoYXJhY3RlciwgYWRkaW5nIGVpdGhlciB0aGUgZXNjYXBlZFxuICAgIC8vIGNoYXJhY3RlciwgYSBoYXJkIGxpbmUgYnJlYWsgKGlmIHRoZSBiYWNrc2xhc2ggaXMgZm9sbG93ZWQgYnkgYSBuZXdsaW5lKSxcbiAgICAvLyBvciBhIGxpdGVyYWwgYmFja3NsYXNoIHRvIHRoZSBibG9jaydzIGNoaWxkcmVuLiAgQXNzdW1lcyBjdXJyZW50IGNoYXJhY3RlclxuICAgIC8vIGlzIGEgYmFja3NsYXNoLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VCYWNrc2xhc2ggPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIHN1YmogPSB0aGlzLnN1YmplY3Q7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSBDX05FV0xJTkUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICBub2RlID0gY3JlYXRlTm9kZSQxKCdsaW5lYnJlYWsnLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcyAtIDEsIHRoaXMucG9zKSk7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZUVzY2FwYWJsZS50ZXN0KHN1YmouY2hhckF0KHRoaXMucG9zKSkpIHtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKHRleHQkMShzdWJqLmNoYXJBdCh0aGlzLnBvcyksIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0JDEoJ1xcXFwnLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgc3RhcnRwb3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGFuIGF1dG9saW5rIChVUkwgb3IgZW1haWwgaW4gcG9pbnR5IGJyYWNrZXRzKS5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlQXV0b2xpbmsgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIG07XG4gICAgICAgIHZhciBkZXN0O1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICBpZiAoKG0gPSB0aGlzLm1hdGNoKHJlRW1haWxBdXRvbGluaykpKSB7XG4gICAgICAgICAgICBkZXN0ID0gbS5zbGljZSgxLCBtLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUkMSgnbGluaycsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgbm9kZS5kZXN0aW5hdGlvbiA9IG5vcm1hbGl6ZVVSSShcIm1haWx0bzpcIiArIGRlc3QpO1xuICAgICAgICAgICAgbm9kZS50aXRsZSA9ICcnO1xuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0ZXh0JDEoZGVzdCwgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MgKyAxLCB0aGlzLnBvcyAtIDEpKSk7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgobSA9IHRoaXMubWF0Y2gocmVBdXRvbGluaykpKSB7XG4gICAgICAgICAgICBkZXN0ID0gbS5zbGljZSgxLCBtLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUkMSgnbGluaycsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgbm9kZS5kZXN0aW5hdGlvbiA9IG5vcm1hbGl6ZVVSSShkZXN0KTtcbiAgICAgICAgICAgIG5vZGUudGl0bGUgPSAnJztcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGV4dCQxKGRlc3QsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zICsgMSwgdGhpcy5wb3MgLSAxKSkpO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGEgcmF3IEhUTUwgdGFnLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VIdG1sVGFnID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKHJlSHRtbFRhZyk7XG4gICAgICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVOb2RlJDEoJ2h0bWxJbmxpbmUnLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgbm9kZS5saXRlcmFsID0gbTtcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gU2NhbiBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgd2l0aCBjb2RlIGNjLCBhbmQgcmV0dXJuIGluZm9ybWF0aW9uIGFib3V0XG4gICAgLy8gdGhlIG51bWJlciBvZiBkZWxpbWl0ZXJzIGFuZCB3aGV0aGVyIHRoZXkgYXJlIHBvc2l0aW9uZWQgc3VjaCB0aGF0XG4gICAgLy8gdGhleSBjYW4gb3BlbiBhbmQvb3IgY2xvc2UgZW1waGFzaXMgb3Igc3Ryb25nIGVtcGhhc2lzLiAgQSB1dGlsaXR5XG4gICAgLy8gZnVuY3Rpb24gZm9yIHN0cm9uZy9lbXBoIHBhcnNpbmcuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5zY2FuRGVsaW1zID0gZnVuY3Rpb24gKGNjKSB7XG4gICAgICAgIHZhciBudW1kZWxpbXMgPSAwO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgaWYgKGNjID09PSBDX1NJTkdMRVFVT1RFIHx8IGNjID09PSBDX0RPVUJMRVFVT1RFKSB7XG4gICAgICAgICAgICBudW1kZWxpbXMrKztcbiAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wZWVrKCkgPT09IGNjKSB7XG4gICAgICAgICAgICAgICAgbnVtZGVsaW1zKys7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtZGVsaW1zID09PSAwIHx8IChudW1kZWxpbXMgPCAyICYmIChjYyA9PT0gQ19USUxERSB8fCBjYyA9PT0gQ19ET0xMQVIpKSkge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFyQmVmb3JlID0gc3RhcnRwb3MgPT09IDAgPyAnXFxuJyA6IHRoaXMuc3ViamVjdC5jaGFyQXQoc3RhcnRwb3MgLSAxKTtcbiAgICAgICAgdmFyIGNjQWZ0ZXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgdmFyIGNoYXJBZnRlcjtcbiAgICAgICAgaWYgKGNjQWZ0ZXIgPT09IC0xKSB7XG4gICAgICAgICAgICBjaGFyQWZ0ZXIgPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYXJBZnRlciA9IGZyb21Db2RlUG9pbnQkMShjY0FmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWZ0ZXJJc1doaXRlc3BhY2UgPSByZVVuaWNvZGVXaGl0ZXNwYWNlQ2hhci50ZXN0KGNoYXJBZnRlcik7XG4gICAgICAgIHZhciBhZnRlcklzUHVuY3R1YXRpb24gPSByZVB1bmN0dWF0aW9uLnRlc3QoY2hhckFmdGVyKTtcbiAgICAgICAgdmFyIGJlZm9yZUlzV2hpdGVzcGFjZSA9IHJlVW5pY29kZVdoaXRlc3BhY2VDaGFyLnRlc3QoY2hhckJlZm9yZSk7XG4gICAgICAgIHZhciBiZWZvcmVJc1B1bmN0dWF0aW9uID0gcmVQdW5jdHVhdGlvbi50ZXN0KGNoYXJCZWZvcmUpO1xuICAgICAgICB2YXIgbGVmdEZsYW5raW5nID0gIWFmdGVySXNXaGl0ZXNwYWNlICYmICghYWZ0ZXJJc1B1bmN0dWF0aW9uIHx8IGJlZm9yZUlzV2hpdGVzcGFjZSB8fCBiZWZvcmVJc1B1bmN0dWF0aW9uKTtcbiAgICAgICAgdmFyIHJpZ2h0RmxhbmtpbmcgPSAhYmVmb3JlSXNXaGl0ZXNwYWNlICYmICghYmVmb3JlSXNQdW5jdHVhdGlvbiB8fCBhZnRlcklzV2hpdGVzcGFjZSB8fCBhZnRlcklzUHVuY3R1YXRpb24pO1xuICAgICAgICB2YXIgY2FuT3BlbjtcbiAgICAgICAgdmFyIGNhbkNsb3NlO1xuICAgICAgICBpZiAoY2MgPT09IENfVU5ERVJTQ09SRSkge1xuICAgICAgICAgICAgY2FuT3BlbiA9IGxlZnRGbGFua2luZyAmJiAoIXJpZ2h0RmxhbmtpbmcgfHwgYmVmb3JlSXNQdW5jdHVhdGlvbik7XG4gICAgICAgICAgICBjYW5DbG9zZSA9IHJpZ2h0RmxhbmtpbmcgJiYgKCFsZWZ0RmxhbmtpbmcgfHwgYWZ0ZXJJc1B1bmN0dWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYyA9PT0gQ19TSU5HTEVRVU9URSB8fCBjYyA9PT0gQ19ET1VCTEVRVU9URSkge1xuICAgICAgICAgICAgY2FuT3BlbiA9IGxlZnRGbGFua2luZyAmJiAhcmlnaHRGbGFua2luZztcbiAgICAgICAgICAgIGNhbkNsb3NlID0gcmlnaHRGbGFua2luZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYyA9PT0gQ19ET0xMQVIpIHtcbiAgICAgICAgICAgIGNhbk9wZW4gPSAhYWZ0ZXJJc1doaXRlc3BhY2U7XG4gICAgICAgICAgICBjYW5DbG9zZSA9ICFiZWZvcmVJc1doaXRlc3BhY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYW5PcGVuID0gbGVmdEZsYW5raW5nO1xuICAgICAgICAgICAgY2FuQ2xvc2UgPSByaWdodEZsYW5raW5nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgIHJldHVybiB7IG51bWRlbGltczogbnVtZGVsaW1zLCBjYW5PcGVuOiBjYW5PcGVuLCBjYW5DbG9zZTogY2FuQ2xvc2UgfTtcbiAgICB9O1xuICAgIC8vIEhhbmRsZSBhIGRlbGltaXRlciBtYXJrZXIgZm9yIGVtcGhhc2lzIG9yIGEgcXVvdGUuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5oYW5kbGVEZWxpbSA9IGZ1bmN0aW9uIChjYywgYmxvY2spIHtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuc2NhbkRlbGltcyhjYyk7XG4gICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG51bWRlbGltcyA9IHJlcy5udW1kZWxpbXM7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgdmFyIGNvbnRlbnRzO1xuICAgICAgICB0aGlzLnBvcyArPSBudW1kZWxpbXM7XG4gICAgICAgIGlmIChjYyA9PT0gQ19TSU5HTEVRVU9URSkge1xuICAgICAgICAgICAgY29udGVudHMgPSAnXFx1MjAxOSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2MgPT09IENfRE9VQkxFUVVPVEUpIHtcbiAgICAgICAgICAgIGNvbnRlbnRzID0gJ1xcdTIwMUMnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGVudHMgPSB0aGlzLnN1YmplY3Quc2xpY2Uoc3RhcnRwb3MgLSAxLCB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSB0ZXh0JDEoY29udGVudHMsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpO1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgLy8gQWRkIGVudHJ5IHRvIHN0YWNrIGZvciB0aGlzIG9wZW5lclxuICAgICAgICBpZiAoKHJlcy5jYW5PcGVuIHx8IHJlcy5jYW5DbG9zZSkgJiZcbiAgICAgICAgICAgICh0aGlzLm9wdGlvbnMuc21hcnQgfHwgKGNjICE9PSBDX1NJTkdMRVFVT1RFICYmIGNjICE9PSBDX0RPVUJMRVFVT1RFKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVycyA9IHtcbiAgICAgICAgICAgICAgICBjYzogY2MsXG4gICAgICAgICAgICAgICAgbnVtZGVsaW1zOiBudW1kZWxpbXMsXG4gICAgICAgICAgICAgICAgb3JpZ2RlbGltczogbnVtZGVsaW1zLFxuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IHRoaXMuZGVsaW1pdGVycyxcbiAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIGNhbk9wZW46IHJlcy5jYW5PcGVuLFxuICAgICAgICAgICAgICAgIGNhbkNsb3NlOiByZXMuY2FuQ2xvc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVsaW1pdGVycy5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVycy5wcmV2aW91cy5uZXh0ID0gdGhpcy5kZWxpbWl0ZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5yZW1vdmVEZWxpbWl0ZXIgPSBmdW5jdGlvbiAoZGVsaW0pIHtcbiAgICAgICAgaWYgKGRlbGltLnByZXZpb3VzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxpbS5wcmV2aW91cy5uZXh0ID0gZGVsaW0ubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsaW0ubmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gdG9wIG9mIHN0YWNrXG4gICAgICAgICAgICB0aGlzLmRlbGltaXRlcnMgPSBkZWxpbS5wcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGltLm5leHQucHJldmlvdXMgPSBkZWxpbS5wcmV2aW91cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5yZW1vdmVEZWxpbWl0ZXJzQmV0d2VlbiA9IGZ1bmN0aW9uIChib3R0b20sIHRvcCkge1xuICAgICAgICBpZiAoYm90dG9tLm5leHQgIT09IHRvcCkge1xuICAgICAgICAgICAgYm90dG9tLm5leHQgPSB0b3A7XG4gICAgICAgICAgICB0b3AucHJldmlvdXMgPSBib3R0b207XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYWxsIGRlbGltaXRlcnMgLSBlbXBoYXNpcywgc3Ryb25nIGVtcGhhc2lzLCBzdHJpa2V0aHJvdWdoKGdmbSlcbiAgICAgKiBJZiB0aGUgc21hcnQgcHVuY3R1YXRpb24gb3B0aW9ucyBpcyB0cnVlLFxuICAgICAqIGNvbnZlcnQgc2luZ2xlL2RvdWJsZSBxdW90ZXMgdG8gY29ycmVzcG9uZGluZyB1bmljb2RlIGNoYXJhY3RlcnMuXG4gICAgICoqL1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucHJvY2Vzc0VtcGhhc2lzID0gZnVuY3Rpb24gKHN0YWNrQm90dG9tKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIG9wZW5lcjtcbiAgICAgICAgdmFyIGNsb3NlcjtcbiAgICAgICAgdmFyIG9sZENsb3NlcjtcbiAgICAgICAgdmFyIG9wZW5lcklubCwgY2xvc2VySW5sO1xuICAgICAgICB2YXIgb3BlbmVyRm91bmQ7XG4gICAgICAgIHZhciBvZGRNYXRjaCA9IGZhbHNlO1xuICAgICAgICB2YXIgb3BlbmVyc0JvdHRvbSA9IChfYSA9IHt9LFxuICAgICAgICAgICAgX2FbQ19VTkRFUlNDT1JFXSA9IFtzdGFja0JvdHRvbSwgc3RhY2tCb3R0b20sIHN0YWNrQm90dG9tXSxcbiAgICAgICAgICAgIF9hW0NfQVNURVJJU0tdID0gW3N0YWNrQm90dG9tLCBzdGFja0JvdHRvbSwgc3RhY2tCb3R0b21dLFxuICAgICAgICAgICAgX2FbQ19TSU5HTEVRVU9URV0gPSBbc3RhY2tCb3R0b21dLFxuICAgICAgICAgICAgX2FbQ19ET1VCTEVRVU9URV0gPSBbc3RhY2tCb3R0b21dLFxuICAgICAgICAgICAgX2FbQ19USUxERV0gPSBbc3RhY2tCb3R0b21dLFxuICAgICAgICAgICAgX2FbQ19ET0xMQVJdID0gW3N0YWNrQm90dG9tXSxcbiAgICAgICAgICAgIF9hKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBjbG9zZXIgYWJvdmUgc3RhY2tCb3R0b206XG4gICAgICAgIGNsb3NlciA9IHRoaXMuZGVsaW1pdGVycztcbiAgICAgICAgd2hpbGUgKGNsb3NlciAhPT0gbnVsbCAmJiBjbG9zZXIucHJldmlvdXMgIT09IHN0YWNrQm90dG9tKSB7XG4gICAgICAgICAgICBjbG9zZXIgPSBjbG9zZXIucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbW92ZSBmb3J3YXJkLCBsb29raW5nIGZvciBjbG9zZXJzLCBhbmQgaGFuZGxpbmcgZWFjaFxuICAgICAgICB3aGlsZSAoY2xvc2VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgY2xvc2VyY2MgPSBjbG9zZXIuY2M7XG4gICAgICAgICAgICB2YXIgY2xvc2VyRW1waCA9IGNsb3NlcmNjID09PSBDX1VOREVSU0NPUkUgfHwgY2xvc2VyY2MgPT09IENfQVNURVJJU0s7XG4gICAgICAgICAgICBpZiAoIWNsb3Nlci5jYW5DbG9zZSkge1xuICAgICAgICAgICAgICAgIGNsb3NlciA9IGNsb3Nlci5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm91bmQgZW1waGFzaXMgY2xvc2VyLiBub3cgbG9vayBiYWNrIGZvciBmaXJzdCBtYXRjaGluZyBvcGVuZXI6XG4gICAgICAgICAgICAgICAgb3BlbmVyID0gY2xvc2VyLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIG9wZW5lckZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG9wZW5lciAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBvcGVuZXIgIT09IHN0YWNrQm90dG9tICYmXG4gICAgICAgICAgICAgICAgICAgIG9wZW5lciAhPT0gb3BlbmVyc0JvdHRvbVtjbG9zZXJjY11bY2xvc2VyRW1waCA/IGNsb3Nlci5vcmlnZGVsaW1zICUgMyA6IDBdKSB7XG4gICAgICAgICAgICAgICAgICAgIG9kZE1hdGNoID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlckVtcGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xvc2VyLmNhbk9wZW4gfHwgb3BlbmVyLmNhbkNsb3NlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlci5vcmlnZGVsaW1zICUgMyAhPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvcGVuZXIub3JpZ2RlbGltcyArIGNsb3Nlci5vcmlnZGVsaW1zKSAlIDMgPT09IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuZXIuY2MgPT09IGNsb3Nlci5jYyAmJiBvcGVuZXIuY2FuT3BlbiAmJiAhb2RkTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wZW5lciA9IG9wZW5lci5wcmV2aW91cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2xkQ2xvc2VyID0gY2xvc2VyO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXJFbXBoIHx8IGNsb3NlcmNjID09PSBDX1RJTERFIHx8IGNsb3NlcmNjID09PSBDX0RPTExBUikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wZW5lckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXIgPSBjbG9zZXIubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChudWxsIG9wZW5lciBjaGVjayBmb3IgdHlwZSBuYXJyb3dpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgYWN0dWFsIG51bWJlciBvZiBkZWxpbWl0ZXJzIHVzZWQgZnJvbSBjbG9zZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1c2VEZWxpbXMgPSBjbG9zZXIubnVtZGVsaW1zID49IDIgJiYgb3BlbmVyLm51bWRlbGltcyA+PSAyID8gMiA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW1wdHlEZWxpbXMgPSBjbG9zZXJFbXBoID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJJbmwgPSBvcGVuZXIubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlcklubCA9IGNsb3Nlci5ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnVpbGQgY29udGVudHMgZm9yIG5ldyBlbXBoIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlVHlwZSA9IGNsb3NlckVtcGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHVzZURlbGltcyA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdlbXBoJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdzdHJvbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnc3RyaWtlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXJjYyA9PT0gQ19ET0xMQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlVHlwZSA9ICdjdXN0b21JbmxpbmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld05vZGUgPSBjcmVhdGVOb2RlJDEobm9kZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5lckVuZFBvcyA9IG9wZW5lcklubC5zb3VyY2Vwb3NbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VyU3RhcnRQb3MgPSBjbG9zZXJJbmwuc291cmNlcG9zWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5zb3VyY2Vwb3MgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wZW5lckVuZFBvc1swXSwgb3BlbmVyRW5kUG9zWzFdIC0gdXNlRGVsaW1zICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Nsb3NlclN0YXJ0UG9zWzBdLCBjbG9zZXJTdGFydFBvc1sxXSArIHVzZURlbGltcyAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lcklubC5zb3VyY2Vwb3NbMV1bMV0gLT0gdXNlRGVsaW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VySW5sLnNvdXJjZXBvc1swXVsxXSArPSB1c2VEZWxpbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJJbmwubGl0ZXJhbCA9IG9wZW5lcklubC5saXRlcmFsLnNsaWNlKHVzZURlbGltcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXJJbmwubGl0ZXJhbCA9IGNsb3NlcklubC5saXRlcmFsLnNsaWNlKHVzZURlbGltcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXIubnVtZGVsaW1zIC09IHVzZURlbGltcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlci5udW1kZWxpbXMgLT0gdXNlRGVsaW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHVzZWQgZGVsaW1pdGVycyBmcm9tIHN0YWNrIGVsdHMgYW5kIGlubGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBvcGVuZXJJbmwubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRtcCAmJiB0bXAgIT09IGNsb3NlcklubCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSB0bXAubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAudW5saW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5hcHBlbmRDaGlsZCh0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidWlsZCBjdXN0b20gaW5saW5lIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXJjYyA9PT0gQ19ET0xMQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBuZXdOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpdGVyYWwgPSB0ZXh0Tm9kZS5saXRlcmFsIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZvID0gbGl0ZXJhbC5zcGxpdCgvXFxzLylbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5pbmZvID0gaW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGl0ZXJhbC5sZW5ndGggPD0gaW5mby5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUudW5saW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZS5zb3VyY2Vwb3NbMF1bMV0gKz0gaW5mby5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHROb2RlLmxpdGVyYWwgPSBsaXRlcmFsLnJlcGxhY2UoaW5mbyArIFwiIFwiLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVySW5sLmluc2VydEFmdGVyKG5ld05vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGVsdHMgYmV0d2VlbiBvcGVuZXIgYW5kIGNsb3NlciBpbiBkZWxpbWl0ZXJzIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURlbGltaXRlcnNCZXR3ZWVuKG9wZW5lciwgY2xvc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG9wZW5lciBoYXMgMCBkZWxpbXMsIHJlbW92ZSBpdCBhbmQgdGhlIGlubGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgb3BlbmVyIGhhcyAxIGRlbGltcyBhbmQgY2hhcmFjdGVyIGlzIHRpbGRlLCByZW1vdmUgZGVsaW1pdGVyIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVuZXIubnVtZGVsaW1zIDw9IGVtcHR5RGVsaW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lci5udW1kZWxpbXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVySW5sLnVubGluaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURlbGltaXRlcihvcGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY2xvc2VyIGhhcyAwIGRlbGltcywgcmVtb3ZlIGl0IGFuZCB0aGUgaW5saW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBjbG9zZXIgaGFzIDEgZGVsaW1zIGFuZCBjaGFyYWN0ZXIgaXMgdGlsZGUsIHJlbW92ZSBkZWxpbWl0ZXIgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlci5udW1kZWxpbXMgPD0gZW1wdHlEZWxpbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VyLm51bWRlbGltcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXJJbmwudW5saW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wc3RhY2sgPSBjbG9zZXIubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURlbGltaXRlcihjbG9zZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlciA9IHRlbXBzdGFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbG9zZXJjYyA9PT0gQ19TSU5HTEVRVU9URSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXIubm9kZS5saXRlcmFsID0gJ1xcdTIwMTknO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbmVyRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lci5ub2RlLmxpdGVyYWwgPSAnXFx1MjAxOCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsb3NlcmNjID09PSBDX0RPVUJMRVFVT1RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlci5ub2RlLmxpdGVyYWwgPSAnXFx1MjAxRCc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuZXJGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyLm5vZGUubGl0ZXJhbCA9ICdcXHUyMDFDJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbG9zZXIgPSBjbG9zZXIubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcGVuZXJGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgbG93ZXIgYm91bmQgZm9yIGZ1dHVyZSBzZWFyY2hlcyBmb3Igb3BlbmVyczpcbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyc0JvdHRvbVtjbG9zZXJjY11bY2xvc2VyRW1waCA/IG9sZENsb3Nlci5vcmlnZGVsaW1zICUgMyA6IDBdID0gb2xkQ2xvc2VyLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZENsb3Nlci5jYW5PcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gcmVtb3ZlIGEgY2xvc2VyIHRoYXQgY2FuJ3QgYmUgYW4gb3BlbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25jZSB3ZSd2ZSBzZWVuIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgb3BlbmVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEZWxpbWl0ZXIob2xkQ2xvc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgYWxsIGRlbGltaXRlcnNcbiAgICAgICAgd2hpbGUgKHRoaXMuZGVsaW1pdGVycyAhPT0gbnVsbCAmJiB0aGlzLmRlbGltaXRlcnMgIT09IHN0YWNrQm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZURlbGltaXRlcih0aGlzLmRlbGltaXRlcnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGxpbmsgdGl0bGUgKHNhbnMgcXVvdGVzKSwgcmV0dXJuaW5nIHRoZSBzdHJpbmdcbiAgICAvLyBvciBudWxsIGlmIG5vIG1hdGNoLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VMaW5rVGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMubWF0Y2gocmVMaW5rVGl0bGUpO1xuICAgICAgICBpZiAodGl0bGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNob3Agb2ZmIHF1b3RlcyBmcm9tIHRpdGxlIGFuZCB1bmVzY2FwZTpcbiAgICAgICAgcmV0dXJuIHVuZXNjYXBlU3RyaW5nKHRpdGxlLnN1YnN0cigxLCB0aXRsZS5sZW5ndGggLSAyKSk7XG4gICAgfTtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGxpbmsgZGVzdGluYXRpb24sIHJldHVybmluZyB0aGUgc3RyaW5nIG9yIG51bGwgaWYgbm8gbWF0Y2guXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpbmtEZXN0aW5hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMubWF0Y2gocmVMaW5rRGVzdGluYXRpb25CcmFjZXMpO1xuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09IENfTEVTU1RIQU4kMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQFRPRE8gaGFuZHJvbGxlZCBwYXJzZXI7IHJlcyBzaG91bGQgYmUgbnVsbCBvciB0aGUgc3RyaW5nXG4gICAgICAgICAgICB2YXIgc2F2ZXBvcyA9IHRoaXMucG9zO1xuICAgICAgICAgICAgdmFyIG9wZW5wYXJlbnMgPSAwO1xuICAgICAgICAgICAgdmFyIGMgPSB2b2lkIDA7XG4gICAgICAgICAgICB3aGlsZSAoKGMgPSB0aGlzLnBlZWsoKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IENfQkFDS1NMQVNIICYmIHJlRXNjYXBhYmxlLnRlc3QodGhpcy5zdWJqZWN0LmNoYXJBdCh0aGlzLnBvcyArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZWVrKCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IENfT1BFTl9QQVJFTikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBvcGVucGFyZW5zICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IENfQ0xPU0VfUEFSRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5wYXJlbnMgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVucGFyZW5zIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVXaGl0ZXNwYWNlQ2hhci5leGVjKGZyb21Db2RlUG9pbnQkMShjKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gc2F2ZXBvcyAmJiBjICE9PSBDX0NMT1NFX1BBUkVOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3BlbnBhcmVucyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gdGhpcy5zdWJqZWN0LnN1YnN0cihzYXZlcG9zLCB0aGlzLnBvcyAtIHNhdmVwb3MpO1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVVSSSh1bmVzY2FwZVN0cmluZyhyZXMpKTtcbiAgICAgICAgfSAvLyBjaG9wIG9mZiBzdXJyb3VuZGluZyA8Li4+OlxuICAgICAgICByZXR1cm4gbm9ybWFsaXplVVJJKHVuZXNjYXBlU3RyaW5nKHJlcy5zdWJzdHIoMSwgcmVzLmxlbmd0aCAtIDIpKSk7XG4gICAgfTtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGEgbGluayBsYWJlbCwgcmV0dXJuaW5nIG51bWJlciBvZiBjaGFyYWN0ZXJzIHBhcnNlZC5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlTGlua0xhYmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMubWF0Y2gocmVMaW5rTGFiZWwpO1xuICAgICAgICBpZiAobSA9PT0gbnVsbCB8fCBtLmxlbmd0aCA+IDEwMDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLmxlbmd0aDtcbiAgICB9O1xuICAgIC8vIEFkZCBvcGVuIGJyYWNrZXQgdG8gZGVsaW1pdGVyIHN0YWNrIGFuZCBhZGQgYSB0ZXh0IG5vZGUgdG8gYmxvY2sncyBjaGlsZHJlbi5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlT3BlbkJyYWNrZXQgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgIHZhciBub2RlID0gdGV4dCQxKCdbJywgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MsIHRoaXMucG9zKSk7XG4gICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAvLyBBZGQgZW50cnkgdG8gc3RhY2sgZm9yIHRoaXMgb3BlbmVyXG4gICAgICAgIHRoaXMuYWRkQnJhY2tldChub2RlLCBzdGFydHBvcywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIElGIG5leHQgY2hhcmFjdGVyIGlzIFssIGFuZCAhIGRlbGltaXRlciB0byBkZWxpbWl0ZXIgc3RhY2sgYW5kXG4gICAgLy8gYWRkIGEgdGV4dCBub2RlIHRvIGJsb2NrJ3MgY2hpbGRyZW4uICBPdGhlcndpc2UganVzdCBhZGQgYSB0ZXh0IG5vZGUuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJhbmcgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gQ19PUEVOX0JSQUNLRVQkMSkge1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGV4dCQxKCchWycsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zIC0gMSwgdGhpcy5wb3MpKTtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgLy8gQWRkIGVudHJ5IHRvIHN0YWNrIGZvciB0aGlzIG9wZW5lclxuICAgICAgICAgICAgdGhpcy5hZGRCcmFja2V0KG5vZGUsIHN0YXJ0cG9zICsgMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRleHQkMSgnIScsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBUcnkgdG8gbWF0Y2ggY2xvc2UgYnJhY2tldCBhZ2FpbnN0IGFuIG9wZW5pbmcgaW4gdGhlIGRlbGltaXRlclxuICAgIC8vIHN0YWNrLiAgQWRkIGVpdGhlciBhIGxpbmsgb3IgaW1hZ2UsIG9yIGEgcGxhaW4gWyBjaGFyYWN0ZXIsXG4gICAgLy8gdG8gYmxvY2sncyBjaGlsZHJlbi4gIElmIHRoZXJlIGlzIGEgbWF0Y2hpbmcgZGVsaW1pdGVyLFxuICAgIC8vIHJlbW92ZSBpdCBmcm9tIHRoZSBkZWxpbWl0ZXIgc3RhY2suXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsb3NlQnJhY2tldCA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgZGVzdCA9IG51bGw7XG4gICAgICAgIHZhciB0aXRsZSA9IG51bGw7XG4gICAgICAgIHZhciBtYXRjaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zO1xuICAgICAgICAvLyBnZXQgbGFzdCBbIG9yICFbXG4gICAgICAgIHZhciBvcGVuZXIgPSB0aGlzLmJyYWNrZXRzO1xuICAgICAgICBpZiAob3BlbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBubyBtYXRjaGVkIG9wZW5lciwganVzdCByZXR1cm4gYSBsaXRlcmFsXG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0JDEoJ10nLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgc3RhcnRwb3MpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wZW5lci5hY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIG5vIG1hdGNoZWQgb3BlbmVyLCBqdXN0IHJldHVybiBhIGxpdGVyYWxcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKHRleHQkMSgnXScsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCBzdGFydHBvcykpKTtcbiAgICAgICAgICAgIC8vIHRha2Ugb3BlbmVyIG9mZiBicmFja2V0cyBzdGFja1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVCcmFja2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgb3BlbiBpcyBhIHBvdGVudGlhbCBvcGVuZXJcbiAgICAgICAgdmFyIGlzSW1hZ2UgPSBvcGVuZXIuaW1hZ2U7XG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgbGluay9pbWFnZVxuICAgICAgICB2YXIgc2F2ZXBvcyA9IHRoaXMucG9zO1xuICAgICAgICAvLyBJbmxpbmUgbGluaz9cbiAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSBDX09QRU5fUEFSRU4pIHtcbiAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgICAgICBpZiAodGhpcy5zcG5sKCkgJiZcbiAgICAgICAgICAgICAgICAoZGVzdCA9IHRoaXMucGFyc2VMaW5rRGVzdGluYXRpb24oKSkgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNwbmwoKSAmJlxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSdzIGEgc3BhY2UgYmVmb3JlIHRoZSB0aXRsZTpcbiAgICAgICAgICAgICAgICAoKHJlV2hpdGVzcGFjZUNoYXIudGVzdCh0aGlzLnN1YmplY3QuY2hhckF0KHRoaXMucG9zIC0gMSkpICYmXG4gICAgICAgICAgICAgICAgICAgICh0aXRsZSA9IHRoaXMucGFyc2VMaW5rVGl0bGUoKSkpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRydWUpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zcG5sKCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnBlZWsoKSA9PT0gQ19DTE9TRV9QQVJFTikge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IHNhdmVwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZkxhYmVsID0gJyc7XG4gICAgICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgICAgICAgLy8gTmV4dCwgc2VlIGlmIHRoZXJlJ3MgYSBsaW5rIGxhYmVsXG4gICAgICAgICAgICB2YXIgYmVmb3JlbGFiZWwgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5wYXJzZUxpbmtMYWJlbCgpO1xuICAgICAgICAgICAgaWYgKG4gPiAyKSB7XG4gICAgICAgICAgICAgICAgcmVmTGFiZWwgPSB0aGlzLnN1YmplY3Quc2xpY2UoYmVmb3JlbGFiZWwsIGJlZm9yZWxhYmVsICsgbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghb3BlbmVyLmJyYWNrZXRBZnRlcikge1xuICAgICAgICAgICAgICAgIC8vIEVtcHR5IG9yIG1pc3Npbmcgc2Vjb25kIGxhYmVsIG1lYW5zIHRvIHVzZSB0aGUgZmlyc3QgbGFiZWwgYXMgdGhlIHJlZmVyZW5jZS5cbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVmZXJlbmNlIG11c3Qgbm90IGNvbnRhaW4gYSBicmFja2V0LiBJZiB3ZSBrbm93IHRoZXJlJ3MgYSBicmFja2V0LCB3ZSBkb24ndCBldmVuIGJvdGhlciBjaGVja2luZyBpdC5cbiAgICAgICAgICAgICAgICByZWZMYWJlbCA9IHRoaXMuc3ViamVjdC5zbGljZShvcGVuZXIuaW5kZXgsIHN0YXJ0cG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmssIHJld2luZCBiZWZvcmUgc3BhY2VzIHdlIHNraXBwZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBzYXZlcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlZkxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmVmTGFiZWwgPSBub3JtYWxpemVSZWZlcmVuY2UocmVmTGFiZWwpO1xuICAgICAgICAgICAgICAgIC8vIGxvb2t1cCByYXdsYWJlbCBpbiByZWZNYXBcbiAgICAgICAgICAgICAgICB2YXIgbGluayA9IHRoaXMucmVmTWFwW3JlZkxhYmVsXTtcbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICBkZXN0ID0gbGluay5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBsaW5rLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gY3JlYXRlTm9kZSQxKGlzSW1hZ2UgPyAnaW1hZ2UnIDogJ2xpbmsnKTtcbiAgICAgICAgICAgIG5vZGUuZGVzdGluYXRpb24gPSBkZXN0O1xuICAgICAgICAgICAgbm9kZS50aXRsZSA9IHRpdGxlIHx8ICcnO1xuICAgICAgICAgICAgbm9kZS5zb3VyY2Vwb3MgPSBbb3BlbmVyLnN0YXJ0cG9zLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcyldO1xuICAgICAgICAgICAgdmFyIHRtcCA9IG9wZW5lci5ub2RlLm5leHQ7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHdoaWxlICh0bXApIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gdG1wLm5leHQ7XG4gICAgICAgICAgICAgICAgdG1wLnVubGluaygpO1xuICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodG1wKTtcbiAgICAgICAgICAgICAgICB0bXAgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NFbXBoYXNpcyhvcGVuZXIucHJldmlvdXNEZWxpbWl0ZXIpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVCcmFja2V0KCk7XG4gICAgICAgICAgICBvcGVuZXIubm9kZS51bmxpbmsoKTtcbiAgICAgICAgICAgIC8vIFdlIHJlbW92ZSB0aGlzIGJyYWNrZXQgYW5kIHByb2Nlc3NFbXBoYXNpcyB3aWxsIHJlbW92ZSBsYXRlciBkZWxpbWl0ZXJzLlxuICAgICAgICAgICAgLy8gTm93LCBmb3IgYSBsaW5rLCB3ZSBhbHNvIGRlYWN0aXZhdGUgZWFybGllciBsaW5rIG9wZW5lcnMuXG4gICAgICAgICAgICAvLyAobm8gbGlua3MgaW4gbGlua3MpXG4gICAgICAgICAgICBpZiAoIWlzSW1hZ2UpIHtcbiAgICAgICAgICAgICAgICBvcGVuZXIgPSB0aGlzLmJyYWNrZXRzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChvcGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcGVuZXIuaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lci5hY3RpdmUgPSBmYWxzZTsgLy8gZGVhY3RpdmF0ZSB0aGlzIG9wZW5lclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wZW5lciA9IG9wZW5lci5wcmV2aW91cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlZmVyZW5jZURlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXBbYmxvY2suaWRdID0geyBub2RlOiBibG9jaywgcmVmTGFiZWw6IHJlZkxhYmVsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBubyBtYXRjaFxuICAgICAgICB0aGlzLnJlbW92ZUJyYWNrZXQoKTsgLy8gcmVtb3ZlIHRoaXMgb3BlbmVyIGZyb20gc3RhY2tcbiAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCQxKCddJywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHN0YXJ0cG9zKSkpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlZmVyZW5jZURlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcFtibG9jay5pZF0gPSB7IG5vZGU6IGJsb2NrLCByZWZMYWJlbDogcmVmTGFiZWwgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUuYWRkQnJhY2tldCA9IGZ1bmN0aW9uIChub2RlLCBpbmRleCwgaW1hZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuYnJhY2tldHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYnJhY2tldHMuYnJhY2tldEFmdGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJyYWNrZXRzID0ge1xuICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgIHN0YXJ0cG9zOiB0aGlzLnNvdXJjZXBvcyhpbmRleCArIChpbWFnZSA/IDAgOiAxKSksXG4gICAgICAgICAgICBwcmV2aW91czogdGhpcy5icmFja2V0cyxcbiAgICAgICAgICAgIHByZXZpb3VzRGVsaW1pdGVyOiB0aGlzLmRlbGltaXRlcnMsXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnJlbW92ZUJyYWNrZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJyYWNrZXRzKSB7XG4gICAgICAgICAgICB0aGlzLmJyYWNrZXRzID0gdGhpcy5icmFja2V0cy5wcmV2aW91cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBhbiBlbnRpdHkuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUVudGl0eSA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICBpZiAoKG0gPSB0aGlzLm1hdGNoKHJlRW50aXR5SGVyZSkpKSB7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0JDEobGliLmRlY29kZUhUTUwobSksIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIGEgcnVuIG9mIG9yZGluYXJ5IGNoYXJhY3RlcnMsIG9yIGEgc2luZ2xlIGNoYXJhY3RlciB3aXRoXG4gICAgLy8gYSBzcGVjaWFsIG1lYW5pbmcgaW4gbWFya2Rvd24sIGFzIGEgcGxhaW4gc3RyaW5nLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJpbmcgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIG07XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgaWYgKChtID0gdGhpcy5tYXRjaChyZU1haW4pKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbWFydCkge1xuICAgICAgICAgICAgICAgIHZhciBsaXQgPSBtLnJlcGxhY2UocmVFbGxpcHNlcywgJ1xcdTIwMjYnKS5yZXBsYWNlKHJlRGFzaCwgZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbkNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVtQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnMubGVuZ3RoICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNpYmxlIGJ5IDMsIHVzZSBhbGwgZW0gZGFzaGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBlbUNvdW50ID0gY2hhcnMubGVuZ3RoIC8gMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFycy5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc2libGUgYnkgMiwgdXNlIGFsbCBlbiBkYXNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuQ291bnQgPSBjaGFycy5sZW5ndGggLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJzLmxlbmd0aCAlIDMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIDIgZXh0cmEgZGFzaGVzLCB1c2UgZW4gZGFzaCBmb3IgbGFzdCAyOyBlbSBkYXNoZXMgZm9yIHJlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1Db3VudCA9IChjaGFycy5sZW5ndGggLSAyKSAvIDM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgZW4gZGFzaGVzIGZvciBsYXN0IDQgaHlwaGVuczsgZW0gZGFzaGVzIGZvciByZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBlbkNvdW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtQ291bnQgPSAoY2hhcnMubGVuZ3RoIC0gNCkgLyAzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBlYXQoJ1xcdTIwMTQnLCBlbUNvdW50KSArIHJlcGVhdCgnXFx1MjAxMycsIGVuQ291bnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKHRleHQkMShsaXQsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGV4dCQxKG0sIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLy8gUGFyc2UgYSBuZXdsaW5lLiAgSWYgaXQgd2FzIHByZWNlZGVkIGJ5IHR3byBzcGFjZXMsIHJldHVybiBhIGhhcmRcbiAgICAvLyBsaW5lIGJyZWFrOyBvdGhlcndpc2UgYSBzb2Z0IGxpbmUgYnJlYWsuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZU5ld2xpbmUgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdGhpcy5wb3MgKz0gMTsgLy8gYXNzdW1lIHdlJ3JlIGF0IGEgXFxuXG4gICAgICAgIC8vIGNoZWNrIHByZXZpb3VzIG5vZGUgZm9yIHRyYWlsaW5nIHNwYWNlc1xuICAgICAgICB2YXIgbGFzdGMgPSBibG9jay5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmIChsYXN0YyAmJiBsYXN0Yy50eXBlID09PSAndGV4dCcgJiYgbGFzdGMubGl0ZXJhbFtsYXN0Yy5saXRlcmFsLmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgIHZhciBoYXJkYnJlYWsgPSBsYXN0Yy5saXRlcmFsW2xhc3RjLmxpdGVyYWwubGVuZ3RoIC0gMl0gPT09ICcgJztcbiAgICAgICAgICAgIHZhciBsaXRMZW4gPSBsYXN0Yy5saXRlcmFsLmxlbmd0aDtcbiAgICAgICAgICAgIGxhc3RjLmxpdGVyYWwgPSBsYXN0Yy5saXRlcmFsLnJlcGxhY2UocmVGaW5hbFNwYWNlLCAnJyk7XG4gICAgICAgICAgICB2YXIgZmluYWxTcGFjZUxlbiA9IGxpdExlbiAtIGxhc3RjLmxpdGVyYWwubGVuZ3RoO1xuICAgICAgICAgICAgbGFzdGMuc291cmNlcG9zWzFdWzFdIC09IGZpbmFsU3BhY2VMZW47XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChjcmVhdGVOb2RlJDEoaGFyZGJyZWFrID8gJ2xpbmVicmVhaycgOiAnc29mdGJyZWFrJywgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MgLSBmaW5hbFNwYWNlTGVuLCB0aGlzLnBvcykpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKGNyZWF0ZU5vZGUkMSgnc29mdGJyZWFrJywgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MsIHRoaXMucG9zKSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgdGhpcy5tYXRjaChyZUluaXRpYWxTcGFjZSk7IC8vIGdvYmJsZSBsZWFkaW5nIHNwYWNlcyBpbiBuZXh0IGxpbmVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGEgbGluayByZWZlcmVuY2UsIG1vZGlmeWluZyByZWZtYXAuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJlZmVyZW5jZSA9IGZ1bmN0aW9uIChibG9jaywgcmVmTWFwKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnJlZmVyZW5jZURlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQ7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdmFyIHRpdGxlID0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgICAgIC8vIGxhYmVsOlxuICAgICAgICB2YXIgbWF0Y2hDaGFycyA9IHRoaXMucGFyc2VMaW5rTGFiZWwoKTtcbiAgICAgICAgaWYgKG1hdGNoQ2hhcnMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYXdsYWJlbCA9IHRoaXMuc3ViamVjdC5zdWJzdHIoMCwgbWF0Y2hDaGFycyk7XG4gICAgICAgIC8vIGNvbG9uOlxuICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09IENfQ09MT04pIHtcbiAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gIGxpbmsgdXJsXG4gICAgICAgIHRoaXMuc3BubCgpO1xuICAgICAgICB2YXIgZGVzdCA9IHRoaXMucGFyc2VMaW5rRGVzdGluYXRpb24oKTtcbiAgICAgICAgaWYgKGRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmVmb3JldGl0bGUgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5zcG5sKCk7XG4gICAgICAgIGlmICh0aGlzLnBvcyAhPT0gYmVmb3JldGl0bGUpIHtcbiAgICAgICAgICAgIHRpdGxlID0gdGhpcy5wYXJzZUxpbmtUaXRsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aXRsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGl0bGUgPSAnJztcbiAgICAgICAgICAgIC8vIHJld2luZCBiZWZvcmUgc3BhY2VzXG4gICAgICAgICAgICB0aGlzLnBvcyA9IGJlZm9yZXRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSdyZSBhdCBsaW5lIGVuZDpcbiAgICAgICAgdmFyIGF0TGluZUVuZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKHJlU3BhY2VBdEVuZE9mTGluZSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aXRsZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBhdExpbmVFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBwb3RlbnRpYWwgdGl0bGUgd2UgZm91bmQgaXMgbm90IGF0IHRoZSBsaW5lIGVuZCxcbiAgICAgICAgICAgICAgICAvLyBidXQgaXQgY291bGQgc3RpbGwgYmUgYSBsZWdhbCBsaW5rIHJlZmVyZW5jZSBpZiB3ZVxuICAgICAgICAgICAgICAgIC8vIGRpc2NhcmQgdGhlIHRpdGxlXG4gICAgICAgICAgICAgICAgdGl0bGUgPSAnJztcbiAgICAgICAgICAgICAgICAvLyByZXdpbmQgYmVmb3JlIHNwYWNlc1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gYmVmb3JldGl0bGU7XG4gICAgICAgICAgICAgICAgLy8gYW5kIGluc3RlYWQgY2hlY2sgaWYgdGhlIGxpbmsgVVJMIGlzIGF0IHRoZSBsaW5lIGVuZFxuICAgICAgICAgICAgICAgIGF0TGluZUVuZCA9IHRoaXMubWF0Y2gocmVTcGFjZUF0RW5kT2ZMaW5lKSAhPT0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWF0TGluZUVuZCkge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub3JtYWxMYWJlbCA9IG5vcm1hbGl6ZVJlZmVyZW5jZShyYXdsYWJlbCk7XG4gICAgICAgIGlmIChub3JtYWxMYWJlbCA9PT0gJycpIHtcbiAgICAgICAgICAgIC8vIGxhYmVsIG11c3QgY29udGFpbiBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZXBvcyA9IHRoaXMuZ2V0UmVmZXJlbmNlRGVmU291cmNlcG9zKGJsb2NrKTtcbiAgICAgICAgYmxvY2suc291cmNlcG9zWzBdWzBdID0gc291cmNlcG9zWzFdWzBdICsgMTtcbiAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVOb2RlJDEoJ3JlZkRlZicsIHNvdXJjZXBvcyk7XG4gICAgICAgIG5vZGUudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgbm9kZS5kZXN0ID0gZGVzdDtcbiAgICAgICAgbm9kZS5sYWJlbCA9IG5vcm1hbExhYmVsO1xuICAgICAgICBibG9jay5pbnNlcnRCZWZvcmUobm9kZSk7XG4gICAgICAgIGlmICghcmVmTWFwW25vcm1hbExhYmVsXSkge1xuICAgICAgICAgICAgcmVmTWFwW25vcm1hbExhYmVsXSA9IGNyZWF0ZVJlZkRlZlN0YXRlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXBbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyAtIHN0YXJ0cG9zO1xuICAgIH07XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5tZXJnZVRleHROb2RlcyA9IGZ1bmN0aW9uICh3YWxrZXIpIHtcbiAgICAgICAgdmFyIGV2ZW50O1xuICAgICAgICB2YXIgdGV4dE5vZGVzID0gW107XG4gICAgICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICAgICAgdmFyIGVudGVyaW5nID0gZXZlbnQuZW50ZXJpbmcsIG5vZGUgPSBldmVudC5ub2RlO1xuICAgICAgICAgICAgaWYgKGVudGVyaW5nICYmIG5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgdGV4dE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ZXh0Tm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGV4dE5vZGVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ZXh0Tm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdE5vZGUgPSB0ZXh0Tm9kZXNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGxhc3ROb2RlID0gdGV4dE5vZGVzW3RleHROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb2RlLnNvdXJjZXBvcyAmJiBsYXN0Tm9kZS5zb3VyY2Vwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb2RlLnNvdXJjZXBvc1sxXSA9IGxhc3ROb2RlLnNvdXJjZXBvc1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlyc3ROb2RlLm5leHQgPSBsYXN0Tm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdE5vZGUubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vZGUubmV4dC5wcmV2ID0gZmlyc3ROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRleHROb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vZGUubGl0ZXJhbCArPSB0ZXh0Tm9kZXNbaV0ubGl0ZXJhbDtcbiAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGVzW2ldLnVubGluaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXh0Tm9kZXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5nZXRSZWZlcmVuY2VEZWZTb3VyY2Vwb3MgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIGxpbmVzID0gYmxvY2suc3RyaW5nQ29udGVudC5zcGxpdCgvXFxufFxcclxcbi8pO1xuICAgICAgICB2YXIgcGFzc2VkVXJsTGluZSA9IGZhbHNlO1xuICAgICAgICB2YXIgcXVvdGF0aW9uQ291bnQgPSAwO1xuICAgICAgICB2YXIgbGFzdExpbmVPZmZzZXQgPSB7IGxpbmU6IDAsIGNoOiAwIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgICAgICAgICBpZiAocmVXaGl0ZXNwYWNlQ2hhci50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL1xcOi8udGVzdChsaW5lKSAmJiBxdW90YXRpb25Db3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXNzZWRVcmxMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGluZU9mZnNldCA9IGxpbmUuaW5kZXhPZignOicpID09PSBsaW5lLmxlbmd0aCAtIDEgPyBpICsgMSA6IGk7XG4gICAgICAgICAgICAgICAgbGFzdExpbmVPZmZzZXQgPSB7IGxpbmU6IGxpbmVPZmZzZXQsIGNoOiBsaW5lc1tsaW5lT2Zmc2V0XS5sZW5ndGggfTtcbiAgICAgICAgICAgICAgICBwYXNzZWRVcmxMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNob3VsZCBjb25zaWRlciBleHRlbmRhYmxlIHRpdGxlXG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IGxpbmUubWF0Y2goLyd8XCIvZyk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIHF1b3RhdGlvbkNvdW50ICs9IG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHF1b3RhdGlvbkNvdW50ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgbGFzdExpbmVPZmZzZXQgPSB7IGxpbmU6IGksIGNoOiBsaW5lLmxlbmd0aCB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbYmxvY2suc291cmNlcG9zWzBdWzBdLCBibG9jay5zb3VyY2Vwb3NbMF1bMV1dLFxuICAgICAgICAgICAgW2Jsb2NrLnNvdXJjZXBvc1swXVswXSArIGxhc3RMaW5lT2Zmc2V0LmxpbmUsIGxhc3RMaW5lT2Zmc2V0LmNoXSxcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIHRoZSBuZXh0IGlubGluZSBlbGVtZW50IGluIHN1YmplY3QsIGFkdmFuY2luZyBzdWJqZWN0IHBvc2l0aW9uLlxuICAgIC8vIE9uIHN1Y2Nlc3MsIGFkZCB0aGUgcmVzdWx0IHRvIGJsb2NrJ3MgY2hpbGRyZW4gYW5kIHJldHVybiB0cnVlLlxuICAgIC8vIE9uIGZhaWx1cmUsIHJldHVybiBmYWxzZS5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlSW5saW5lID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHJlcyA9IGZhbHNlO1xuICAgICAgICB2YXIgYyA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAoYyA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgIGNhc2UgQ19ORVdMSU5FOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VOZXdsaW5lKGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19CQUNLU0xBU0g6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZUJhY2tzbGFzaChibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfQkFDS1RJQ0s6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZUJhY2t0aWNrcyhibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfQVNURVJJU0s6XG4gICAgICAgICAgICBjYXNlIENfVU5ERVJTQ09SRTpcbiAgICAgICAgICAgIGNhc2UgQ19USUxERTpcbiAgICAgICAgICAgIGNhc2UgQ19ET0xMQVI6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5oYW5kbGVEZWxpbShjLCBibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfU0lOR0xFUVVPVEU6XG4gICAgICAgICAgICBjYXNlIENfRE9VQkxFUVVPVEU6XG4gICAgICAgICAgICAgICAgcmVzID0gISEoKF9hID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc21hcnQpICYmIHRoaXMuaGFuZGxlRGVsaW0oYywgYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX09QRU5fQlJBQ0tFVCQxOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VPcGVuQnJhY2tldChibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfQkFORzpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlQmFuZyhibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfQ0xPU0VfQlJBQ0tFVDpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlQ2xvc2VCcmFja2V0KGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19MRVNTVEhBTiQxOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VBdXRvbGluayhibG9jaykgfHwgdGhpcy5wYXJzZUh0bWxUYWcoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0FNUEVSU0FORDpcbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrLmRpc2FibGVkRW50aXR5UGFyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZUVudGl0eShibG9jayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlU3RyaW5nKGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKHRleHQkMShmcm9tQ29kZVBvaW50JDEoYyksIHRoaXMuc291cmNlcG9zKHRoaXMucG9zLCB0aGlzLnBvcyArIDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBQYXJzZSBzdHJpbmcgY29udGVudCBpbiBibG9jayBpbnRvIGlubGluZSBjaGlsZHJlbixcbiAgICAvLyB1c2luZyByZWZtYXAgdG8gcmVzb2x2ZSByZWZlcmVuY2VzLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gYmxvY2suc3RyaW5nQ29udGVudC50cmltKCk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmFja2V0cyA9IG51bGw7XG4gICAgICAgIHRoaXMubGluZU9mZnNldHMgPSBibG9jay5saW5lT2Zmc2V0cyB8fCBbMF07XG4gICAgICAgIHRoaXMubGluZUlkeCA9IDA7XG4gICAgICAgIHRoaXMubGluZVBvc09mZnNldCA9IDA7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0TnVtID0gYmxvY2suc291cmNlcG9zWzBdWzBdO1xuICAgICAgICBpZiAoaXNIZWFkaW5nKGJsb2NrKSkge1xuICAgICAgICAgICAgdGhpcy5saW5lT2Zmc2V0c1swXSArPSBibG9jay5sZXZlbCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMucGFyc2VJbmxpbmUoYmxvY2spKSB7IH1cbiAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IG51bGw7IC8vIGFsbG93IHJhdyBzdHJpbmcgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICAgICAgdGhpcy5wcm9jZXNzRW1waGFzaXMobnVsbCk7XG4gICAgICAgIHRoaXMubWVyZ2VUZXh0Tm9kZXMoYmxvY2sud2Fsa2VyKCkpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIGV4dGVuZGVkQXV0b2xpbmtzID0gX2EuZXh0ZW5kZWRBdXRvbGlua3MsIGN1c3RvbVBhcnNlciA9IF9hLmN1c3RvbVBhcnNlcjtcbiAgICAgICAgaWYgKGV4dGVuZGVkQXV0b2xpbmtzKSB7XG4gICAgICAgICAgICBjb252ZXJ0RXh0QXV0b0xpbmtzKGJsb2NrLndhbGtlcigpLCBleHRlbmRlZEF1dG9saW5rcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1c3RvbVBhcnNlciAmJiBibG9jay5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMTtcbiAgICAgICAgICAgIHZhciB3YWxrZXIgPSBibG9jay5maXJzdENoaWxkLndhbGtlcigpO1xuICAgICAgICAgICAgd2hpbGUgKChldmVudF8xID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGV2ZW50XzEubm9kZSwgZW50ZXJpbmcgPSBldmVudF8xLmVudGVyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21QYXJzZXJbbm9kZS50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21QYXJzZXJbbm9kZS50eXBlXShub2RlLCB7IGVudGVyaW5nOiBlbnRlcmluZywgb3B0aW9uczogdGhpcy5vcHRpb25zIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIElubGluZVBhcnNlcjtcbn0oKSk7XG5cbnZhciByZVRhc2tMaXN0SXRlbU1hcmtlciA9IC9eXFxbKFsgXFx0eFhdKVxcXVsgXFx0XSsvO1xuLy8gZmluYWxpemUgZm9yIGJsb2NrIGhhbmRsZXJcbmZ1bmN0aW9uIHRhc2tMaXN0SXRlbUZpbmFsaXplKF8sIGJsb2NrKSB7XG4gICAgaWYgKGJsb2NrLmZpcnN0Q2hpbGQgJiYgYmxvY2suZmlyc3RDaGlsZC50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICB2YXIgcCA9IGJsb2NrLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBtID0gcC5zdHJpbmdDb250ZW50Lm1hdGNoKHJlVGFza0xpc3RJdGVtTWFya2VyKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHZhciBtTGVuID0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICBwLnN0cmluZ0NvbnRlbnQgPSBwLnN0cmluZ0NvbnRlbnQuc3Vic3RyaW5nKG1MZW4gLSAxKTtcbiAgICAgICAgICAgIHAuc291cmNlcG9zWzBdWzFdICs9IG1MZW47XG4gICAgICAgICAgICBwLmxpbmVPZmZzZXRzWzBdICs9IG1MZW47XG4gICAgICAgICAgICBibG9jay5saXN0RGF0YS50YXNrID0gdHJ1ZTtcbiAgICAgICAgICAgIGJsb2NrLmxpc3REYXRhLmNoZWNrZWQgPSAvW3hYXS8udGVzdChtWzFdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHRhYmxlID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gJ3RhYmxlSGVhZCcgfHwgdCA9PT0gJ3RhYmxlQm9keSc7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciB0YWJsZUJvZHkkMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09ICd0YWJsZVJvdyc7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciB0YWJsZUhlYWQkMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gJ3RhYmxlUm93JyB8fCB0ID09PSAndGFibGVEZWxpbVJvdyc7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciB0YWJsZURlbGltUm93ID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAndGFibGVEZWxpbUNlbGwnO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVEZWxpbUNlbGwgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciB0YWJsZVJvdyA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gJ3RhYmxlQ2VsbCc7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciB0YWJsZUNlbGwgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcblxudmFyIENPREVfSU5ERU5UID0gNDtcbnZhciBDX1RBQiA9IDk7XG52YXIgQ19HUkVBVEVSVEhBTiA9IDYyO1xudmFyIENfTEVTU1RIQU4gPSA2MDtcbnZhciBDX1NQQUNFID0gMzI7XG52YXIgQ19PUEVOX0JSQUNLRVQgPSA5MTtcbnZhciByZU5vblNwYWNlID0gL1teIFxcdFxcZlxcdlxcclxcbl0vO1xudmFyIHJlQ2xvc2luZ0NvZGVGZW5jZSA9IC9eKD86YHszLH18fnszLH0pKD89ICokKS87XG4vLyBSZXR1cm5zIHRydWUgaWYgYmxvY2sgZW5kcyB3aXRoIGEgYmxhbmsgbGluZSwgZGVzY2VuZGluZyBpZiBuZWVkZWRcbi8vIGludG8gbGlzdHMgYW5kIHN1Ymxpc3RzLlxuZnVuY3Rpb24gZW5kc1dpdGhCbGFua0xpbmUoYmxvY2spIHtcbiAgICB2YXIgY3VyQmxvY2sgPSBibG9jaztcbiAgICB3aGlsZSAoY3VyQmxvY2spIHtcbiAgICAgICAgaWYgKGN1ckJsb2NrLmxhc3RMaW5lQmxhbmspIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ID0gY3VyQmxvY2sudHlwZTtcbiAgICAgICAgaWYgKCFjdXJCbG9jay5sYXN0TGluZUNoZWNrZWQgJiYgKHQgPT09ICdsaXN0JyB8fCB0ID09PSAnaXRlbScpKSB7XG4gICAgICAgICAgICBjdXJCbG9jay5sYXN0TGluZUNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgY3VyQmxvY2sgPSBjdXJCbG9jay5sYXN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJCbG9jay5sYXN0TGluZUNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGVlayhsbiwgcG9zKSB7XG4gICAgaWYgKHBvcyA8IGxuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbG4uY2hhckNvZGVBdChwb3MpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vLyBSZXR1cm5zIHRydWUgaWYgc3RyaW5nIGNvbnRhaW5zIG9ubHkgc3BhY2UgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIGlzQmxhbmsocykge1xuICAgIHJldHVybiAhcmVOb25TcGFjZS50ZXN0KHMpO1xufVxuZnVuY3Rpb24gaXNTcGFjZU9yVGFiKGMpIHtcbiAgICByZXR1cm4gYyA9PT0gQ19TUEFDRSB8fCBjID09PSBDX1RBQjtcbn1cblxudmFyIHJlQ2xvc2luZ0N1c3RvbUJsb2NrID0gL15cXCRcXCQkLztcbnZhciBjdXN0b21CbG9jayQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBwYXJzZXIuY3VycmVudExpbmU7XG4gICAgICAgIHZhciBtYXRjaCA9IGxpbmUubWF0Y2gocmVDbG9zaW5nQ3VzdG9tQmxvY2spO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIGNsb3NpbmcgY3VzdG9tIGJsb2NrXG4gICAgICAgICAgICBwYXJzZXIubGFzdExpbmVMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICBwYXJzZXIuZmluYWxpemUoY29udGFpbmVyLCBwYXJzZXIubGluZU51bWJlcik7XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBGaW5pc2hlZCAqLztcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIG9wdGlvbmFsIHNwYWNlcyBvZiBjdXN0b20gYmxvY2sgb2Zmc2V0XG4gICAgICAgIHZhciBpID0gY29udGFpbmVyLm9mZnNldDtcbiAgICAgICAgd2hpbGUgKGkgPiAwICYmIGlzU3BhY2VPclRhYihwZWVrKGxpbmUsIHBhcnNlci5vZmZzZXQpKSkge1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKF8sIGJsb2NrKSB7XG4gICAgICAgIGlmIChibG9jay5zdHJpbmdDb250ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlyc3QgbGluZSBiZWNvbWVzIGluZm8gc3RyaW5nXG4gICAgICAgIHZhciBjb250ZW50ID0gYmxvY2suc3RyaW5nQ29udGVudDtcbiAgICAgICAgdmFyIG5ld2xpbmVQb3MgPSBjb250ZW50LmluZGV4T2YoJ1xcbicpO1xuICAgICAgICB2YXIgZmlyc3RMaW5lID0gY29udGVudC5zbGljZSgwLCBuZXdsaW5lUG9zKTtcbiAgICAgICAgdmFyIHJlc3QgPSBjb250ZW50LnNsaWNlKG5ld2xpbmVQb3MgKyAxKTtcbiAgICAgICAgdmFyIGluZm9TdHJpbmcgPSBmaXJzdExpbmUubWF0Y2goL14oXFxzKikoLiopLyk7XG4gICAgICAgIGJsb2NrLmluZm8gPSB1bmVzY2FwZVN0cmluZyhpbmZvU3RyaW5nWzJdLnRyaW0oKSk7XG4gICAgICAgIGJsb2NrLmxpdGVyYWwgPSByZXN0O1xuICAgICAgICBibG9jay5zdHJpbmdDb250ZW50ID0gbnVsbDtcbiAgICB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiB0cnVlLFxufTtcblxudmFyIG5vb3AgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IHRydWUsXG59O1xudmFyIGRvY3VtZW50JDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ICE9PSAnaXRlbSc7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciBsaXN0ID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uIChfLCBibG9jaykge1xuICAgICAgICB2YXIgaXRlbSA9IGJsb2NrLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChpdGVtKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3Igbm9uLWZpbmFsIGxpc3QgaXRlbSBlbmRpbmcgd2l0aCBibGFuayBsaW5lOlxuICAgICAgICAgICAgaWYgKGVuZHNXaXRoQmxhbmtMaW5lKGl0ZW0pICYmIGl0ZW0ubmV4dCkge1xuICAgICAgICAgICAgICAgIGJsb2NrLmxpc3REYXRhLnRpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWN1cnNlIGludG8gY2hpbGRyZW4gb2YgbGlzdCBpdGVtLCB0byBzZWUgaWYgdGhlcmUgYXJlXG4gICAgICAgICAgICAvLyBzcGFjZXMgYmV0d2VlbiBhbnkgb2YgdGhlbTpcbiAgICAgICAgICAgIHZhciBzdWJpdGVtID0gaXRlbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKHN1Yml0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kc1dpdGhCbGFua0xpbmUoc3ViaXRlbSkgJiYgKGl0ZW0ubmV4dCB8fCBzdWJpdGVtLm5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmxpc3REYXRhLnRpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJpdGVtID0gc3ViaXRlbS5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbSA9IGl0ZW0ubmV4dDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09ICdpdGVtJztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIGJsb2NrUXVvdGUkMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlcikge1xuICAgICAgICB2YXIgbG4gPSBwYXJzZXIuY3VycmVudExpbmU7XG4gICAgICAgIGlmICghcGFyc2VyLmluZGVudGVkICYmIHBlZWsobG4sIHBhcnNlci5uZXh0Tm9uc3BhY2UpID09PSBDX0dSRUFURVJUSEFOKSB7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGlzU3BhY2VPclRhYihwZWVrKGxuLCBwYXJzZXIub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldCgxLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ICE9PSAnaXRlbSc7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciBpdGVtID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICAgICAgaWYgKHBhcnNlci5ibGFuaykge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5maXJzdENoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gQmxhbmsgbGluZSBhZnRlciBlbXB0eSBsaXN0IGl0ZW1cbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJzZXIuaW5kZW50ID49IGNvbnRhaW5lci5saXN0RGF0YS5tYXJrZXJPZmZzZXQgKyBjb250YWluZXIubGlzdERhdGEucGFkZGluZykge1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoY29udGFpbmVyLmxpc3REYXRhLm1hcmtlck9mZnNldCArIGNvbnRhaW5lci5saXN0RGF0YS5wYWRkaW5nLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogdGFza0xpc3RJdGVtRmluYWxpemUsXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgIT09ICdpdGVtJztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIGhlYWRpbmcgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gYSBoZWFkaW5nIGNhbiBuZXZlciBjb250YWluZXIgPiAxIGxpbmUsIHNvIGZhaWwgdG8gbWF0Y2g6XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGhlbWF0aWNCcmVhayQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGEgdGhlbWF0aWMgYnJlYWsgY2FuIG5ldmVyIGNvbnRhaW5lciA+IDEgbGluZSwgc28gZmFpbCB0byBtYXRjaDpcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciBjb2RlQmxvY2sgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgbG4gPSBwYXJzZXIuY3VycmVudExpbmU7XG4gICAgICAgIHZhciBpbmRlbnQgPSBwYXJzZXIuaW5kZW50O1xuICAgICAgICBpZiAoY29udGFpbmVyLmlzRmVuY2VkKSB7XG4gICAgICAgICAgICAvLyBmZW5jZWRcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGluZGVudCA8PSAzICYmXG4gICAgICAgICAgICAgICAgbG4uY2hhckF0KHBhcnNlci5uZXh0Tm9uc3BhY2UpID09PSBjb250YWluZXIuZmVuY2VDaGFyICYmXG4gICAgICAgICAgICAgICAgbG4uc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSkubWF0Y2gocmVDbG9zaW5nQ29kZUZlbmNlKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFswXS5sZW5ndGggPj0gY29udGFpbmVyLmZlbmNlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xvc2luZyBmZW5jZSAtIHdlJ3JlIGF0IGVuZCBvZiBsaW5lLCBzbyB3ZSBjYW4gcmV0dXJuXG4gICAgICAgICAgICAgICAgcGFyc2VyLmxhc3RMaW5lTGVuZ3RoID0gcGFyc2VyLm9mZnNldCArIGluZGVudCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBwYXJzZXIuZmluYWxpemUoY29udGFpbmVyLCBwYXJzZXIubGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogRmluaXNoZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBza2lwIG9wdGlvbmFsIHNwYWNlcyBvZiBmZW5jZSBvZmZzZXRcbiAgICAgICAgICAgIHZhciBpID0gY29udGFpbmVyLmZlbmNlT2Zmc2V0O1xuICAgICAgICAgICAgd2hpbGUgKGkgPiAwICYmIGlzU3BhY2VPclRhYihwZWVrKGxuLCBwYXJzZXIub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldCgxLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbmRlbnRlZFxuICAgICAgICAgICAgaWYgKGluZGVudCA+PSBDT0RFX0lOREVOVCkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KENPREVfSU5ERU5ULCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlci5ibGFuaykge1xuICAgICAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uIChfLCBibG9jaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChibG9jay5zdHJpbmdDb250ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrLmlzRmVuY2VkKSB7XG4gICAgICAgICAgICAvLyBmZW5jZWRcbiAgICAgICAgICAgIC8vIGZpcnN0IGxpbmUgYmVjb21lcyBpbmZvIHN0cmluZ1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBibG9jay5zdHJpbmdDb250ZW50O1xuICAgICAgICAgICAgdmFyIG5ld2xpbmVQb3MgPSBjb250ZW50LmluZGV4T2YoJ1xcbicpO1xuICAgICAgICAgICAgdmFyIGZpcnN0TGluZSA9IGNvbnRlbnQuc2xpY2UoMCwgbmV3bGluZVBvcyk7XG4gICAgICAgICAgICB2YXIgcmVzdCA9IGNvbnRlbnQuc2xpY2UobmV3bGluZVBvcyArIDEpO1xuICAgICAgICAgICAgdmFyIGluZm9TdHJpbmcgPSBmaXJzdExpbmUubWF0Y2goL14oXFxzKikoLiopLyk7XG4gICAgICAgICAgICBibG9jay5pbmZvUGFkZGluZyA9IGluZm9TdHJpbmdbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgYmxvY2suaW5mbyA9IHVuZXNjYXBlU3RyaW5nKGluZm9TdHJpbmdbMl0udHJpbSgpKTtcbiAgICAgICAgICAgIGJsb2NrLmxpdGVyYWwgPSByZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5kZW50ZWRcbiAgICAgICAgICAgIGJsb2NrLmxpdGVyYWwgPSAoX2EgPSBibG9jay5zdHJpbmdDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZSgvKFxcbiAqKSskLywgJ1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrLnN0cmluZ0NvbnRlbnQgPSBudWxsOyAvLyBhbGxvdyBHQ1xuICAgIH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IHRydWUsXG59O1xudmFyIGh0bWxCbG9jayQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5ibGFuayAmJiAoY29udGFpbmVyLmh0bWxCbG9ja1R5cGUgPT09IDYgfHwgY29udGFpbmVyLmh0bWxCbG9ja1R5cGUgPT09IDcpXG4gICAgICAgICAgICA/IDEgLyogU3RvcCAqL1xuICAgICAgICAgICAgOiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uIChfLCBibG9jaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGJsb2NrLmxpdGVyYWwgPSAoKF9hID0gYmxvY2suc3RyaW5nQ29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2UoLyhcXG4gKikrJC8sICcnKSkgfHwgbnVsbDtcbiAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IG51bGw7IC8vIGFsbG93IEdDXG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG52YXIgcGFyYWdyYXBoID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgICAgIHJldHVybiBwYXJzZXIuYmxhbmsgPyAxIC8qIFN0b3AgKi8gOiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uIChwYXJzZXIsIGJsb2NrKSB7XG4gICAgICAgIGlmIChibG9jay5zdHJpbmdDb250ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvcztcbiAgICAgICAgdmFyIGhhc1JlZmVyZW5jZURlZnMgPSBmYWxzZTtcbiAgICAgICAgLy8gdHJ5IHBhcnNpbmcgdGhlIGJlZ2lubmluZyBhcyBsaW5rIHJlZmVyZW5jZSBkZWZpbml0aW9uczpcbiAgICAgICAgd2hpbGUgKHBlZWsoYmxvY2suc3RyaW5nQ29udGVudCwgMCkgPT09IENfT1BFTl9CUkFDS0VUICYmXG4gICAgICAgICAgICAocG9zID0gcGFyc2VyLmlubGluZVBhcnNlci5wYXJzZVJlZmVyZW5jZShibG9jaywgcGFyc2VyLnJlZk1hcCkpKSB7XG4gICAgICAgICAgICBibG9jay5zdHJpbmdDb250ZW50ID0gYmxvY2suc3RyaW5nQ29udGVudC5zbGljZShwb3MpO1xuICAgICAgICAgICAgaGFzUmVmZXJlbmNlRGVmcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1JlZmVyZW5jZURlZnMgJiYgaXNCbGFuayhibG9jay5zdHJpbmdDb250ZW50KSkge1xuICAgICAgICAgICAgYmxvY2sudW5saW5rKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiB0cnVlLFxufTtcbnZhciByZWZEZWYgPSBub29wO1xudmFyIGZyb250TWF0dGVyJDIgPSBub29wO1xudmFyIGJsb2NrSGFuZGxlcnMgPSB7XG4gICAgZG9jdW1lbnQ6IGRvY3VtZW50JDEsXG4gICAgbGlzdDogbGlzdCxcbiAgICBibG9ja1F1b3RlOiBibG9ja1F1b3RlJDEsXG4gICAgaXRlbTogaXRlbSxcbiAgICBoZWFkaW5nOiBoZWFkaW5nLFxuICAgIHRoZW1hdGljQnJlYWs6IHRoZW1hdGljQnJlYWskMSxcbiAgICBjb2RlQmxvY2s6IGNvZGVCbG9jayxcbiAgICBodG1sQmxvY2s6IGh0bWxCbG9jayQxLFxuICAgIHBhcmFncmFwaDogcGFyYWdyYXBoLFxuICAgIHRhYmxlOiB0YWJsZSxcbiAgICB0YWJsZUJvZHk6IHRhYmxlQm9keSQxLFxuICAgIHRhYmxlSGVhZDogdGFibGVIZWFkJDEsXG4gICAgdGFibGVSb3c6IHRhYmxlUm93LFxuICAgIHRhYmxlQ2VsbDogdGFibGVDZWxsLFxuICAgIHRhYmxlRGVsaW1Sb3c6IHRhYmxlRGVsaW1Sb3csXG4gICAgdGFibGVEZWxpbUNlbGw6IHRhYmxlRGVsaW1DZWxsLFxuICAgIHJlZkRlZjogcmVmRGVmLFxuICAgIGN1c3RvbUJsb2NrOiBjdXN0b21CbG9jayQxLFxuICAgIGZyb250TWF0dGVyOiBmcm9udE1hdHRlciQyLFxufTtcblxuZnVuY3Rpb24gcGFyc2VSb3dDb250ZW50KGNvbnRlbnQpIHtcbiAgICB2YXIgc3RhcnRJZHggPSAwO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBjZWxscyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoY29udGVudFtpXSA9PT0gJ3wnICYmIGNvbnRlbnRbaSAtIDFdICE9PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gY29udGVudC5zdWJzdHJpbmcoc3RhcnRJZHgsIGkpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0SWR4ID09PSAwICYmIGlzRW1wdHkoY2VsbCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goY2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydElkeCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFydElkeCA8IGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjZWxsID0gY29udGVudC5zdWJzdHJpbmcoc3RhcnRJZHgsIGNvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFpc0VtcHR5KGNlbGwpKSB7XG4gICAgICAgICAgICBjZWxscy5wdXNoKGNlbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbb2Zmc2V0LCBjZWxsc107XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVRhYmxlQ2VsbHMoY2VsbFR5cGUsIGNvbnRlbnRzLCBsaW5lTnVtLCBjaFBvcykge1xuICAgIHZhciBjZWxscyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgY29udGVudHNfMSA9IGNvbnRlbnRzOyBfaSA8IGNvbnRlbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gY29udGVudHNfMVtfaV07XG4gICAgICAgIHZhciBwcmVTcGFjZXMgPSBjb250ZW50Lm1hdGNoKC9eWyBcXHRdKy8pO1xuICAgICAgICB2YXIgcGFkZGluZ0xlZnQgPSBwcmVTcGFjZXMgPyBwcmVTcGFjZXNbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgdmFyIHBhZGRpbmdSaWdodCA9IHZvaWQgMCwgdHJpbW1lZCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHBhZGRpbmdMZWZ0ID09PSBjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgcGFkZGluZ0xlZnQgPSAwO1xuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gMDtcbiAgICAgICAgICAgIHRyaW1tZWQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb3N0U3BhY2VzID0gY29udGVudC5tYXRjaCgvWyBcXHRdKyQvKTtcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodCA9IHBvc3RTcGFjZXMgPyBwb3N0U3BhY2VzWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICB0cmltbWVkID0gY29udGVudC5zbGljZShwYWRkaW5nTGVmdCwgY29udGVudC5sZW5ndGggLSBwYWRkaW5nUmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaFBvc1N0YXJ0ID0gY2hQb3MgKyBwYWRkaW5nTGVmdDtcbiAgICAgICAgdmFyIHRhYmxlQ2VsbCA9IGNyZWF0ZU5vZGUkMShjZWxsVHlwZSwgW1xuICAgICAgICAgICAgW2xpbmVOdW0sIGNoUG9zXSxcbiAgICAgICAgICAgIFtsaW5lTnVtLCBjaFBvcyArIGNvbnRlbnQubGVuZ3RoIC0gMV0sXG4gICAgICAgIF0pO1xuICAgICAgICB0YWJsZUNlbGwuc3RyaW5nQ29udGVudCA9IHRyaW1tZWQucmVwbGFjZSgvXFxcXFxcfC9nLCAnfCcpOyAvLyByZXBsYWNlIGVzYWNwZWQgcGlwZShcXHwpXG4gICAgICAgIHRhYmxlQ2VsbC5zdGFydElkeCA9IGNlbGxzLmxlbmd0aDtcbiAgICAgICAgdGFibGVDZWxsLmVuZElkeCA9IGNlbGxzLmxlbmd0aDtcbiAgICAgICAgdGFibGVDZWxsLmxpbmVPZmZzZXRzID0gW2NoUG9zU3RhcnQgLSAxXTtcbiAgICAgICAgdGFibGVDZWxsLnBhZGRpbmdMZWZ0ID0gcGFkZGluZ0xlZnQ7XG4gICAgICAgIHRhYmxlQ2VsbC5wYWRkaW5nUmlnaHQgPSBwYWRkaW5nUmlnaHQ7XG4gICAgICAgIGNlbGxzLnB1c2godGFibGVDZWxsKTtcbiAgICAgICAgY2hQb3MgKz0gY29udGVudC5sZW5ndGggKyAxO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbHM7XG59XG5mdW5jdGlvbiBnZXRDb2x1bW5Gcm9tRGVsaW1DZWxsKGNlbGxOb2RlKSB7XG4gICAgdmFyIGFsaWduID0gbnVsbDtcbiAgICB2YXIgY29udGVudCA9IGNlbGxOb2RlLnN0cmluZ0NvbnRlbnQ7XG4gICAgdmFyIGZpcnN0Q2ggPSBjb250ZW50WzBdO1xuICAgIHZhciBsYXN0Q2ggPSBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RDaCA9PT0gJzonKSB7XG4gICAgICAgIGFsaWduID0gZmlyc3RDaCA9PT0gJzonID8gJ2NlbnRlcicgOiAncmlnaHQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdENoID09PSAnOicpIHtcbiAgICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgfVxuICAgIHJldHVybiB7IGFsaWduOiBhbGlnbiB9O1xufVxudmFyIHRhYmxlSGVhZCA9IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIHZhciBzdHJpbmdDb250ZW50ID0gY29udGFpbmVyLnN0cmluZ0NvbnRlbnQ7XG4gICAgaWYgKGNvbnRhaW5lci50eXBlID09PSAncGFyYWdyYXBoJyAmJiAhcGFyc2VyLmluZGVudGVkICYmICFwYXJzZXIuYmxhbmspIHtcbiAgICAgICAgdmFyIGxhc3ROZXdMaW5lSWR4ID0gc3RyaW5nQ29udGVudC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgbGFzdExpbmVTdGFydElkeCA9IHN0cmluZ0NvbnRlbnQubGFzdEluZGV4T2YoJ1xcbicsIGxhc3ROZXdMaW5lSWR4IC0gMSkgKyAxO1xuICAgICAgICB2YXIgaGVhZGVyQ29udGVudCA9IHN0cmluZ0NvbnRlbnQuc2xpY2UobGFzdExpbmVTdGFydElkeCwgbGFzdE5ld0xpbmVJZHgpO1xuICAgICAgICB2YXIgZGVsaW1Db250ZW50ID0gcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICB2YXIgX2EgPSBwYXJzZVJvd0NvbnRlbnQoaGVhZGVyQ29udGVudCksIGhlYWRlck9mZnNldCA9IF9hWzBdLCBoZWFkZXJDZWxscyA9IF9hWzFdO1xuICAgICAgICB2YXIgX2IgPSBwYXJzZVJvd0NvbnRlbnQoZGVsaW1Db250ZW50KSwgZGVsaW1PZmZzZXQgPSBfYlswXSwgZGVsaW1DZWxscyA9IF9iWzFdO1xuICAgICAgICB2YXIgcmVWYWxpZERlbGltQ2VsbF8xID0gL15bIFxcdF0qOj8tKzo/WyBcXHRdKiQvO1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBjaGVja2luZyBpZiB0aGUgbnVtYmVyIG9mIGhlYWRlciBjZWxscyBhbmQgZGVsaW1pdGVyIGNlbGxzIGFyZSB0aGUgc2FtZVxuICAgICAgICAvLyB0byBjb25zaWRlciB0aGUgY2FzZSBvZiBtZXJnZWQtY29sdW1uICh2aWEgcGx1Z2luKVxuICAgICAgICAhaGVhZGVyQ2VsbHMubGVuZ3RoIHx8XG4gICAgICAgICAgICAhZGVsaW1DZWxscy5sZW5ndGggfHxcbiAgICAgICAgICAgIGRlbGltQ2VsbHMuc29tZShmdW5jdGlvbiAoY2VsbCkgeyByZXR1cm4gIXJlVmFsaWREZWxpbUNlbGxfMS50ZXN0KGNlbGwpOyB9KSB8fFxuICAgICAgICAgICAgLy8gdG8gcHJldmVudCB0byByZWdhcmQgc2V0VGV4dEhlYWRpbmcgYXMgdGFiZWwgZGVsaW0gY2VsbCB3aXRoICdkaXNhbGxvd0RlZXBIZWFkaW5nJyBvcHRpb25cbiAgICAgICAgICAgIChkZWxpbUNlbGxzLmxlbmd0aCA9PT0gMSAmJiBkZWxpbUNvbnRlbnQuaW5kZXhPZignfCcpICE9PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZU9mZnNldHMgPSBjb250YWluZXIubGluZU9mZnNldHM7XG4gICAgICAgIHZhciBmaXJzdExpbmVOdW0gPSBwYXJzZXIubGluZU51bWJlciAtIDE7XG4gICAgICAgIHZhciBmaXJzdExpbmVTdGFydCA9IGxhc3QobGluZU9mZnNldHMpICsgMTtcbiAgICAgICAgdmFyIHRhYmxlID0gY3JlYXRlTm9kZSQxKCd0YWJsZScsIFtcbiAgICAgICAgICAgIFtmaXJzdExpbmVOdW0sIGZpcnN0TGluZVN0YXJ0XSxcbiAgICAgICAgICAgIFtwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLm9mZnNldF0sXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyb3ctYm9keS1zdHlsZVxuICAgICAgICB0YWJsZS5jb2x1bW5zID0gZGVsaW1DZWxscy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgYWxpZ246IG51bGwgfSk7IH0pO1xuICAgICAgICBjb250YWluZXIuaW5zZXJ0QWZ0ZXIodGFibGUpO1xuICAgICAgICBpZiAobGluZU9mZnNldHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb250YWluZXIudW5saW5rKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXIuc3RyaW5nQ29udGVudCA9IHN0cmluZ0NvbnRlbnQuc2xpY2UoMCwgbGFzdExpbmVTdGFydElkeCk7XG4gICAgICAgICAgICB2YXIgcGFyYUxhc3RMaW5lU3RhcnRJZHggPSBzdHJpbmdDb250ZW50Lmxhc3RJbmRleE9mKCdcXG4nLCBsYXN0TGluZVN0YXJ0SWR4IC0gMikgKyAxO1xuICAgICAgICAgICAgdmFyIHBhcmFMYXN0TGluZUxlbiA9IGxhc3RMaW5lU3RhcnRJZHggLSBwYXJhTGFzdExpbmVTdGFydElkeCAtIDE7XG4gICAgICAgICAgICBwYXJzZXIubGFzdExpbmVMZW5ndGggPSBsaW5lT2Zmc2V0c1tsaW5lT2Zmc2V0cy5sZW5ndGggLSAyXSArIHBhcmFMYXN0TGluZUxlbjtcbiAgICAgICAgICAgIHBhcnNlci5maW5hbGl6ZShjb250YWluZXIsIGZpcnN0TGluZU51bSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KHBhcnNlci5jdXJyZW50TGluZS5sZW5ndGggLSBwYXJzZXIub2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIHZhciB0YWJsZUhlYWRfMSA9IGNyZWF0ZU5vZGUkMSgndGFibGVIZWFkJywgW1xuICAgICAgICAgICAgW2ZpcnN0TGluZU51bSwgZmlyc3RMaW5lU3RhcnRdLFxuICAgICAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIub2Zmc2V0XSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHRhYmxlSGVhZF8xKTtcbiAgICAgICAgdmFyIHRhYmxlSGVhZFJvd18xID0gY3JlYXRlTm9kZSQxKCd0YWJsZVJvdycsIFtcbiAgICAgICAgICAgIFtmaXJzdExpbmVOdW0sIGZpcnN0TGluZVN0YXJ0XSxcbiAgICAgICAgICAgIFtmaXJzdExpbmVOdW0sIGZpcnN0TGluZVN0YXJ0ICsgaGVhZGVyQ29udGVudC5sZW5ndGggLSAxXSxcbiAgICAgICAgXSk7XG4gICAgICAgIHZhciB0YWJsZURlbGltUm93XzEgPSBjcmVhdGVOb2RlJDEoJ3RhYmxlRGVsaW1Sb3cnLCBbXG4gICAgICAgICAgICBbcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5uZXh0Tm9uc3BhY2UgKyAxXSxcbiAgICAgICAgICAgIFtwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLm9mZnNldF0sXG4gICAgICAgIF0pO1xuICAgICAgICB0YWJsZUhlYWRfMS5hcHBlbmRDaGlsZCh0YWJsZUhlYWRSb3dfMSk7XG4gICAgICAgIHRhYmxlSGVhZF8xLmFwcGVuZENoaWxkKHRhYmxlRGVsaW1Sb3dfMSk7XG4gICAgICAgIGdlbmVyYXRlVGFibGVDZWxscygndGFibGVDZWxsJywgaGVhZGVyQ2VsbHMsIGZpcnN0TGluZU51bSwgZmlyc3RMaW5lU3RhcnQgKyBoZWFkZXJPZmZzZXQpLmZvckVhY2goZnVuY3Rpb24gKGNlbGxOb2RlKSB7XG4gICAgICAgICAgICB0YWJsZUhlYWRSb3dfMS5hcHBlbmRDaGlsZChjZWxsTm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGVsaW1DZWxsTm9kZXMgPSBnZW5lcmF0ZVRhYmxlQ2VsbHMoJ3RhYmxlRGVsaW1DZWxsJywgZGVsaW1DZWxscywgcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5uZXh0Tm9uc3BhY2UgKyAxICsgZGVsaW1PZmZzZXQpO1xuICAgICAgICBkZWxpbUNlbGxOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsTm9kZSkge1xuICAgICAgICAgICAgdGFibGVEZWxpbVJvd18xLmFwcGVuZENoaWxkKGNlbGxOb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRhYmxlLmNvbHVtbnMgPSBkZWxpbUNlbGxOb2Rlcy5tYXAoZ2V0Q29sdW1uRnJvbURlbGltQ2VsbCk7XG4gICAgICAgIHBhcnNlci50aXAgPSB0YWJsZTtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgdGFibGVCb2R5ID0gZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgaWYgKChjb250YWluZXIudHlwZSAhPT0gJ3RhYmxlJyAmJiBjb250YWluZXIudHlwZSAhPT0gJ3RhYmxlQm9keScpIHx8XG4gICAgICAgICghcGFyc2VyLmJsYW5rICYmIHBhcnNlci5jdXJyZW50TGluZS5pbmRleE9mKCd8JykgPT09IC0xKSkge1xuICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgIH1cbiAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChwYXJzZXIuY3VycmVudExpbmUubGVuZ3RoIC0gcGFyc2VyLm9mZnNldCwgZmFsc2UpO1xuICAgIGlmIChwYXJzZXIuYmxhbmspIHtcbiAgICAgICAgdmFyIHRhYmxlXzEgPSBjb250YWluZXI7XG4gICAgICAgIGlmIChjb250YWluZXIudHlwZSA9PT0gJ3RhYmxlQm9keScpIHtcbiAgICAgICAgICAgIHRhYmxlXzEgPSBjb250YWluZXIucGFyZW50O1xuICAgICAgICAgICAgcGFyc2VyLmZpbmFsaXplKGNvbnRhaW5lciwgcGFyc2VyLmxpbmVOdW1iZXIgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuZmluYWxpemUodGFibGVfMSwgcGFyc2VyLmxpbmVOdW1iZXIgLSAxKTtcbiAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICB9XG4gICAgdmFyIHRhYmxlQm9keSA9IGNvbnRhaW5lcjtcbiAgICBpZiAoY29udGFpbmVyLnR5cGUgPT09ICd0YWJsZScpIHtcbiAgICAgICAgdGFibGVCb2R5ID0gcGFyc2VyLmFkZENoaWxkKCd0YWJsZUJvZHknLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgdGFibGVCb2R5LnN0cmluZ0NvbnRlbnQgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgdGFibGVSb3cgPSBjcmVhdGVOb2RlJDEoJ3RhYmxlUm93JywgW1xuICAgICAgICBbcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5uZXh0Tm9uc3BhY2UgKyAxXSxcbiAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIuY3VycmVudExpbmUubGVuZ3RoXSxcbiAgICBdKTtcbiAgICB0YWJsZUJvZHkuYXBwZW5kQ2hpbGQodGFibGVSb3cpO1xuICAgIHZhciB0YWJsZSA9IHRhYmxlQm9keS5wYXJlbnQ7XG4gICAgdmFyIGNvbnRlbnQgPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgdmFyIF9hID0gcGFyc2VSb3dDb250ZW50KGNvbnRlbnQpLCBvZmZzZXQgPSBfYVswXSwgY2VsbENvbnRlbnRzID0gX2FbMV07XG4gICAgZ2VuZXJhdGVUYWJsZUNlbGxzKCd0YWJsZUNlbGwnLCBjZWxsQ29udGVudHMsIHBhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIubmV4dE5vbnNwYWNlICsgMSArIG9mZnNldCkuZm9yRWFjaChmdW5jdGlvbiAoY2VsbE5vZGUsIGlkeCkge1xuICAgICAgICBpZiAoaWR4ID49IHRhYmxlLmNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjZWxsTm9kZS5pZ25vcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZVJvdy5hcHBlbmRDaGlsZChjZWxsTm9kZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbn07XG5cbnZhciByZUN1c3RvbUJsb2NrID0gL14oXFwkXFwkKShcXHMqW2EtekEtWl0pKy87XG52YXIgcmVDYW5CZUN1c3RvbUlubGluZSA9IC9eKFxcJFxcJCkoXFxzKlthLXpBLVpdKSsuKihcXCRcXCQpLztcbnZhciBjdXN0b21CbG9jayA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICB2YXIgbWF0Y2g7XG4gICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiZcbiAgICAgICAgIXJlQ2FuQmVDdXN0b21JbmxpbmUudGVzdChwYXJzZXIuY3VycmVudExpbmUpICYmXG4gICAgICAgIChtYXRjaCA9IHBhcnNlci5jdXJyZW50TGluZS5tYXRjaChyZUN1c3RvbUJsb2NrKSkpIHtcbiAgICAgICAgdmFyIHN5bnRheExlbmd0aCA9IG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBwYXJzZXIuYWRkQ2hpbGQoJ2N1c3RvbUJsb2NrJywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIGNvbnRhaW5lci5zeW50YXhMZW5ndGggPSBzeW50YXhMZW5ndGg7XG4gICAgICAgIGNvbnRhaW5lci5vZmZzZXQgPSBwYXJzZXIuaW5kZW50O1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChzeW50YXhMZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG5cbnZhciByZUNvZGVGZW5jZSA9IC9eYHszLH0oPyEuKmApfF5+ezMsfS87XG52YXIgcmVIdG1sQmxvY2tPcGVuID0gW1xuICAgIC8uLyxcbiAgICAvXjwoPzpzY3JpcHR8cHJlfHN0eWxlKSg/Olxcc3w+fCQpL2ksXG4gICAgL148IS0tLyxcbiAgICAvXjxbP10vLFxuICAgIC9ePCFbQS1aXS8sXG4gICAgL148IVxcW0NEQVRBXFxbLyxcbiAgICAvXjxbL10/KD86YWRkcmVzc3xhcnRpY2xlfGFzaWRlfGJhc2V8YmFzZWZvbnR8YmxvY2txdW90ZXxib2R5fGNhcHRpb258Y2VudGVyfGNvbHxjb2xncm91cHxkZHxkZXRhaWxzfGRpYWxvZ3xkaXJ8ZGl2fGRsfGR0fGZpZWxkc2V0fGZpZ2NhcHRpb258ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMTIzNDU2XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZXxsZWdlbmR8bGl8bGlua3xtYWlufG1lbnV8bWVudWl0ZW18bmF2fG5vZnJhbWVzfG9sfG9wdGdyb3VwfG9wdGlvbnxwfHBhcmFtfHNlY3Rpb258c291cmNlfHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGV8dHJ8dHJhY2t8dWwpKD86XFxzfFsvXT9bPl18JCkvaSxcbiAgICBuZXcgUmVnRXhwKFwiXig/OlwiICsgT1BFTlRBRyArIFwifFwiICsgQ0xPU0VUQUcgKyBcIilcXFxccyokXCIsICdpJyksXG5dO1xudmFyIHJlU2V0ZXh0SGVhZGluZ0xpbmUgPSAvXig/Oj0rfC0rKVsgXFx0XSokLztcbnZhciByZUFUWEhlYWRpbmdNYXJrZXIgPSAvXiN7MSw2fSg/OlsgXFx0XSt8JCkvO1xudmFyIHJlVGhlbWF0aWNCcmVhayA9IC9eKD86KD86XFwqWyBcXHRdKil7Myx9fCg/Ol9bIFxcdF0qKXszLH18KD86LVsgXFx0XSopezMsfSlbIFxcdF0qJC87XG52YXIgcmVCdWxsZXRMaXN0TWFya2VyID0gL15bKistXS87XG52YXIgcmVPcmRlcmVkTGlzdE1hcmtlciA9IC9eKFxcZHsxLDl9KShbLildKS87XG4vLyBQYXJzZSBhIGxpc3QgbWFya2VyIGFuZCByZXR1cm4gZGF0YSBvbiB0aGUgbWFya2VyICh0eXBlLFxuLy8gc3RhcnQsIGRlbGltaXRlciwgYnVsbGV0IGNoYXJhY3RlciwgcGFkZGluZykgb3IgbnVsbC5cbmZ1bmN0aW9uIHBhcnNlTGlzdE1hcmtlcihwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIHZhciByZXN0ID0gcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgIHZhciBtYXRjaDtcbiAgICB2YXIgbmV4dGM7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIHR5cGU6ICdidWxsZXQnLFxuICAgICAgICB0aWdodDogdHJ1ZSxcbiAgICAgICAgYnVsbGV0Q2hhcjogJycsXG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBkZWxpbWl0ZXI6ICcnLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBtYXJrZXJPZmZzZXQ6IHBhcnNlci5pbmRlbnQsXG4gICAgICAgIC8vIEdGTTogVGFzayBMaXN0IEl0ZW1cbiAgICAgICAgdGFzazogZmFsc2UsXG4gICAgICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgIH07XG4gICAgaWYgKHBhcnNlci5pbmRlbnQgPj0gNCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IHJlc3QubWF0Y2gocmVCdWxsZXRMaXN0TWFya2VyKSkpIHtcbiAgICAgICAgZGF0YS50eXBlID0gJ2J1bGxldCc7XG4gICAgICAgIGRhdGEuYnVsbGV0Q2hhciA9IG1hdGNoWzBdWzBdO1xuICAgIH1cbiAgICBlbHNlIGlmICgobWF0Y2ggPSByZXN0Lm1hdGNoKHJlT3JkZXJlZExpc3RNYXJrZXIpKSAmJlxuICAgICAgICAoY29udGFpbmVyLnR5cGUgIT09ICdwYXJhZ3JhcGgnIHx8IG1hdGNoWzFdID09PSAnMScpKSB7XG4gICAgICAgIGRhdGEudHlwZSA9ICdvcmRlcmVkJztcbiAgICAgICAgZGF0YS5zdGFydCA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgIGRhdGEuZGVsaW1pdGVyID0gbWF0Y2hbMl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHdlIGhhdmUgc3BhY2VzIGFmdGVyXG4gICAgbmV4dGMgPSBwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm5leHROb25zcGFjZSArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgaWYgKCEobmV4dGMgPT09IC0xIHx8IG5leHRjID09PSBDX1RBQiB8fCBuZXh0YyA9PT0gQ19TUEFDRSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIGlmIGl0IGludGVycnVwdHMgcGFyYWdyYXBoLCBtYWtlIHN1cmUgZmlyc3QgbGluZSBpc24ndCBibGFua1xuICAgIGlmIChjb250YWluZXIudHlwZSA9PT0gJ3BhcmFncmFwaCcgJiZcbiAgICAgICAgIXBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlICsgbWF0Y2hbMF0ubGVuZ3RoKS5tYXRjaChyZU5vblNwYWNlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gd2UndmUgZ290IGEgbWF0Y2ghIGFkdmFuY2Ugb2Zmc2V0IGFuZCBjYWxjdWxhdGUgcGFkZGluZ1xuICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7IC8vIHRvIHN0YXJ0IG9mIG1hcmtlclxuICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KG1hdGNoWzBdLmxlbmd0aCwgdHJ1ZSk7IC8vIHRvIGVuZCBvZiBtYXJrZXJcbiAgICB2YXIgc3BhY2VzU3RhcnRDb2wgPSBwYXJzZXIuY29sdW1uO1xuICAgIHZhciBzcGFjZXNTdGFydE9mZnNldCA9IHBhcnNlci5vZmZzZXQ7XG4gICAgZG8ge1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldCgxLCB0cnVlKTtcbiAgICAgICAgbmV4dGMgPSBwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm9mZnNldCk7XG4gICAgfSB3aGlsZSAocGFyc2VyLmNvbHVtbiAtIHNwYWNlc1N0YXJ0Q29sIDwgNSAmJiBpc1NwYWNlT3JUYWIobmV4dGMpKTtcbiAgICB2YXIgYmxhbmtJdGVtID0gcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5vZmZzZXQpID09PSAtMTtcbiAgICB2YXIgc3BhY2VzQWZ0ZXJNYXJrZXIgPSBwYXJzZXIuY29sdW1uIC0gc3BhY2VzU3RhcnRDb2w7XG4gICAgaWYgKHNwYWNlc0FmdGVyTWFya2VyID49IDUgfHwgc3BhY2VzQWZ0ZXJNYXJrZXIgPCAxIHx8IGJsYW5rSXRlbSkge1xuICAgICAgICBkYXRhLnBhZGRpbmcgPSBtYXRjaFswXS5sZW5ndGggKyAxO1xuICAgICAgICBwYXJzZXIuY29sdW1uID0gc3BhY2VzU3RhcnRDb2w7XG4gICAgICAgIHBhcnNlci5vZmZzZXQgPSBzcGFjZXNTdGFydE9mZnNldDtcbiAgICAgICAgaWYgKGlzU3BhY2VPclRhYihwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm9mZnNldCkpKSB7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldCgxLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGF0YS5wYWRkaW5nID0gbWF0Y2hbMF0ubGVuZ3RoICsgc3BhY2VzQWZ0ZXJNYXJrZXI7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuLy8gUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gbGlzdCBpdGVtcyBhcmUgb2YgdGhlIHNhbWUgdHlwZSxcbi8vIHdpdGggdGhlIHNhbWUgZGVsaW1pdGVyIGFuZCBidWxsZXQgY2hhcmFjdGVyLiAgVGhpcyBpcyB1c2VkXG4vLyBpbiBhZ2dsb21lcmF0aW5nIGxpc3QgaXRlbXMgaW50byBsaXN0cy5cbmZ1bmN0aW9uIGxpc3RzTWF0Y2gobGlzdERhdGEsIGl0ZW1EYXRhKSB7XG4gICAgcmV0dXJuIChsaXN0RGF0YS50eXBlID09PSBpdGVtRGF0YS50eXBlICYmXG4gICAgICAgIGxpc3REYXRhLmRlbGltaXRlciA9PT0gaXRlbURhdGEuZGVsaW1pdGVyICYmXG4gICAgICAgIGxpc3REYXRhLmJ1bGxldENoYXIgPT09IGl0ZW1EYXRhLmJ1bGxldENoYXIpO1xufVxuZnVuY3Rpb24gaXNEaXNhbGxvd2VkRGVlcEhlYWRpbmcocGFyc2VyLCBub2RlKSB7XG4gICAgcmV0dXJuIHBhcnNlci5vcHRpb25zLmRpc2FsbG93RGVlcEhlYWRpbmcgJiYgKG5vZGUudHlwZSA9PT0gJ2Jsb2NrUXVvdGUnIHx8IG5vZGUudHlwZSA9PT0gJ2l0ZW0nKTtcbn1cbnZhciBibG9ja1F1b3RlID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICAgIGlmICghcGFyc2VyLmluZGVudGVkICYmIHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIubmV4dE5vbnNwYWNlKSA9PT0gQ19HUkVBVEVSVEhBTikge1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldCgxLCBmYWxzZSk7XG4gICAgICAgIC8vIG9wdGlvbmFsIGZvbGxvd2luZyBzcGFjZVxuICAgICAgICBpZiAoaXNTcGFjZU9yVGFiKHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICBwYXJzZXIuYWRkQ2hpbGQoJ2Jsb2NrUXVvdGUnLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgcmV0dXJuIDEgLyogQ29udGFpbmVyICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBhdHhIZWFkaW5nID0gZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIGlmICghcGFyc2VyLmluZGVudGVkICYmXG4gICAgICAgIC8vIFRoZSBuZXN0ZWQgSGVhZGluZyBpcyBkaXNhbGxvd2VkIGluIGxpc3QgYW5kIGJsb2NrcXVvdGUgd2l0aCAnZGlzYWxsb3dEZWVwSGVhZGluZycgb3B0aW9uXG4gICAgICAgICFpc0Rpc2FsbG93ZWREZWVwSGVhZGluZyhwYXJzZXIsIGNvbnRhaW5lcikgJiZcbiAgICAgICAgKG1hdGNoID0gcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpLm1hdGNoKHJlQVRYSGVhZGluZ01hcmtlcikpKSB7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KG1hdGNoWzBdLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgdmFyIGhlYWRpbmcgPSBwYXJzZXIuYWRkQ2hpbGQoJ2hlYWRpbmcnLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgaGVhZGluZy5sZXZlbCA9IG1hdGNoWzBdLnRyaW0oKS5sZW5ndGg7IC8vIG51bWJlciBvZiAjc1xuICAgICAgICBoZWFkaW5nLmhlYWRpbmdUeXBlID0gJ2F0eCc7XG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyAjIyNzOlxuICAgICAgICBoZWFkaW5nLnN0cmluZ0NvbnRlbnQgPSBwYXJzZXIuY3VycmVudExpbmVcbiAgICAgICAgICAgIC5zbGljZShwYXJzZXIub2Zmc2V0KVxuICAgICAgICAgICAgLnJlcGxhY2UoL15bIFxcdF0qIytbIFxcdF0qJC8sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1sgXFx0XSsjK1sgXFx0XSokLywgJycpO1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChwYXJzZXIuY3VycmVudExpbmUubGVuZ3RoIC0gcGFyc2VyLm9mZnNldCk7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIGZlbmNlZENvZGVCbG9jayA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICB2YXIgbWF0Y2g7XG4gICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiZcbiAgICAgICAgKG1hdGNoID0gcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpLm1hdGNoKHJlQ29kZUZlbmNlKSkpIHtcbiAgICAgICAgdmFyIGZlbmNlTGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHBhcnNlci5hZGRDaGlsZCgnY29kZUJsb2NrJywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIGNvbnRhaW5lci5pc0ZlbmNlZCA9IHRydWU7XG4gICAgICAgIGNvbnRhaW5lci5mZW5jZUxlbmd0aCA9IGZlbmNlTGVuZ3RoO1xuICAgICAgICBjb250YWluZXIuZmVuY2VDaGFyID0gbWF0Y2hbMF1bMF07XG4gICAgICAgIGNvbnRhaW5lci5mZW5jZU9mZnNldCA9IHBhcnNlci5pbmRlbnQ7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KGZlbmNlTGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIGh0bWxCbG9jayA9IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIGlmICghcGFyc2VyLmluZGVudGVkICYmIHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIubmV4dE5vbnNwYWNlKSA9PT0gQ19MRVNTVEhBTikge1xuICAgICAgICB2YXIgcyA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgdmFyIGRpc2FsbG93ZWRUYWdzID0gcGFyc2VyLm9wdGlvbnMuZGlzYWxsb3dlZEh0bWxCbG9ja1RhZ3M7XG4gICAgICAgIHZhciBibG9ja1R5cGUgPSB2b2lkIDA7XG4gICAgICAgIGZvciAoYmxvY2tUeXBlID0gMTsgYmxvY2tUeXBlIDw9IDc7IGJsb2NrVHlwZSsrKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IHMubWF0Y2gocmVIdG1sQmxvY2tPcGVuW2Jsb2NrVHlwZV0pO1xuICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tUeXBlID09PSA3KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIudHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc2FsbG93ZWRUYWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZURpc2FsbG93ZWRUYWdzID0gbmV3IFJlZ0V4cChcIjwvPyg/OlwiICsgZGlzYWxsb3dlZFRhZ3Muam9pbignfCcpICsgXCIpXCIsICdpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVEaXNhbGxvd2VkVGFncy50ZXN0KG1hdGNoZWRbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBhZGp1c3QgcGFyc2VyLm9mZnNldDtcbiAgICAgICAgICAgICAgICAvLyBzcGFjZXMgYXJlIHBhcnQgb2YgdGhlIEhUTUwgYmxvY2s6XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBwYXJzZXIuYWRkQ2hpbGQoJ2h0bWxCbG9jaycsIHBhcnNlci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGIuaHRtbEJsb2NrVHlwZSA9IGJsb2NrVHlwZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIHNlVGV4dEhlYWRpbmcgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgbWF0Y2g7XG4gICAgaWYgKGNvbnRhaW5lci5zdHJpbmdDb250ZW50ICE9PSBudWxsICYmXG4gICAgICAgICFwYXJzZXIuaW5kZW50ZWQgJiZcbiAgICAgICAgY29udGFpbmVyLnR5cGUgPT09ICdwYXJhZ3JhcGgnICYmXG4gICAgICAgIC8vIFRoZSBuZXN0ZWQgSGVhZGluZyBpcyBkaXNhbGxvd2VkIGluIGxpc3QgYW5kIGJsb2NrcXVvdGUgd2l0aCAnZGlzYWxsb3dEZWVwSGVhZGluZycgb3B0aW9uXG4gICAgICAgICFpc0Rpc2FsbG93ZWREZWVwSGVhZGluZyhwYXJzZXIsIGNvbnRhaW5lci5wYXJlbnQpICYmXG4gICAgICAgIChtYXRjaCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKS5tYXRjaChyZVNldGV4dEhlYWRpbmdMaW5lKSkpIHtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIC8vIHJlc29sdmUgcmVmZXJlbmNlIGxpbmsgZGVmaW5pdGlvbnNcbiAgICAgICAgdmFyIHBvcyA9IHZvaWQgMDtcbiAgICAgICAgd2hpbGUgKHBlZWsoY29udGFpbmVyLnN0cmluZ0NvbnRlbnQsIDApID09PSBDX09QRU5fQlJBQ0tFVCAmJlxuICAgICAgICAgICAgKHBvcyA9IHBhcnNlci5pbmxpbmVQYXJzZXIucGFyc2VSZWZlcmVuY2UoY29udGFpbmVyLCBwYXJzZXIucmVmTWFwKSkpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHJpbmdDb250ZW50ID0gY29udGFpbmVyLnN0cmluZ0NvbnRlbnQuc2xpY2UocG9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyLnN0cmluZ0NvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGhlYWRpbmcgPSBjcmVhdGVOb2RlJDEoJ2hlYWRpbmcnLCBjb250YWluZXIuc291cmNlcG9zKTtcbiAgICAgICAgICAgIGhlYWRpbmcubGV2ZWwgPSBtYXRjaFswXVswXSA9PT0gJz0nID8gMSA6IDI7XG4gICAgICAgICAgICBoZWFkaW5nLmhlYWRpbmdUeXBlID0gJ3NldGV4dCc7XG4gICAgICAgICAgICBoZWFkaW5nLnN0cmluZ0NvbnRlbnQgPSBjb250YWluZXIuc3RyaW5nQ29udGVudDtcbiAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRBZnRlcihoZWFkaW5nKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci51bmxpbmsoKTtcbiAgICAgICAgICAgIHBhcnNlci50aXAgPSBoZWFkaW5nO1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQocGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aCAtIHBhcnNlci5vZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgdGhlbWF0aWNCcmVhayA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJiByZVRoZW1hdGljQnJlYWsudGVzdChwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSkpKSB7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICBwYXJzZXIuYWRkQ2hpbGQoJ3RoZW1hdGljQnJlYWsnLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQocGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aCAtIHBhcnNlci5vZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgbGlzdEl0ZW0gPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgY3Vyck5vZGUgPSBjb250YWluZXI7XG4gICAgaWYgKCghcGFyc2VyLmluZGVudGVkIHx8IGNvbnRhaW5lci50eXBlID09PSAnbGlzdCcpICYmXG4gICAgICAgIChkYXRhID0gcGFyc2VMaXN0TWFya2VyKHBhcnNlciwgY3Vyck5vZGUpKSkge1xuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgLy8gYWRkIHRoZSBsaXN0IGlmIG5lZWRlZFxuICAgICAgICBpZiAocGFyc2VyLnRpcC50eXBlICE9PSAnbGlzdCcgfHwgIWxpc3RzTWF0Y2goY3Vyck5vZGUubGlzdERhdGEsIGRhdGEpKSB7XG4gICAgICAgICAgICBjdXJyTm9kZSA9IHBhcnNlci5hZGRDaGlsZCgnbGlzdCcsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICAgICAgY3Vyck5vZGUubGlzdERhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgbGlzdCBpdGVtXG4gICAgICAgIGN1cnJOb2RlID0gcGFyc2VyLmFkZENoaWxkKCdpdGVtJywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIGN1cnJOb2RlLmxpc3REYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIDEgLyogQ29udGFpbmVyICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbi8vIGluZGVudGVkIGNvZGUgYmxvY2tcbnZhciBpbmRlbnRlZENvZGVCbG9jayA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICBpZiAocGFyc2VyLmluZGVudGVkICYmIHBhcnNlci50aXAudHlwZSAhPT0gJ3BhcmFncmFwaCcgJiYgIXBhcnNlci5ibGFuaykge1xuICAgICAgICAvLyBpbmRlbnRlZCBjb2RlXG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KENPREVfSU5ERU5ULCB0cnVlKTtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHBhcnNlci5hZGRDaGlsZCgnY29kZUJsb2NrJywgcGFyc2VyLm9mZnNldCk7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIGJsb2NrU3RhcnRzID0gW1xuICAgIGJsb2NrUXVvdGUsXG4gICAgYXR4SGVhZGluZyxcbiAgICBmZW5jZWRDb2RlQmxvY2ssXG4gICAgaHRtbEJsb2NrLFxuICAgIHNlVGV4dEhlYWRpbmcsXG4gICAgdGhlbWF0aWNCcmVhayxcbiAgICBsaXN0SXRlbSxcbiAgICBpbmRlbnRlZENvZGVCbG9jayxcbiAgICB0YWJsZUhlYWQsXG4gICAgdGFibGVCb2R5LFxuICAgIGN1c3RvbUJsb2NrLFxuXTtcblxuLy8gYC0tLWAgZm9yIFlBTUwsIGArKytgIGZvciBUT01MLCBgOzs7YCBmb3IgSlNPTlxudmFyIHJlRnJvbnRNYXR0ZXIgPSAvXigtezN9fFxcK3szfXw7ezN9KSQvO1xudmFyIGZyb250TWF0dGVyJDEgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgY3VycmVudExpbmUgPSBwYXJzZXIuY3VycmVudExpbmUsIGxpbmVOdW1iZXIgPSBwYXJzZXIubGluZU51bWJlciwgaW5kZW50ZWQgPSBwYXJzZXIuaW5kZW50ZWQ7XG4gICAgaWYgKGxpbmVOdW1iZXIgPT09IDEgJiZcbiAgICAgICAgIWluZGVudGVkICYmXG4gICAgICAgIGNvbnRhaW5lci50eXBlID09PSAnZG9jdW1lbnQnICYmXG4gICAgICAgIHJlRnJvbnRNYXR0ZXIudGVzdChjdXJyZW50TGluZSkpIHtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHZhciBmcm9udE1hdHRlcl8xID0gcGFyc2VyLmFkZENoaWxkKCdmcm9udE1hdHRlcicsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBmcm9udE1hdHRlcl8xLnN0cmluZ0NvbnRlbnQgPSBjdXJyZW50TGluZTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoY3VycmVudExpbmUubGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xuXG52YXIgZnJvbnRNYXR0ZXIgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgbGluZSA9IHBhcnNlci5jdXJyZW50TGluZTtcbiAgICAgICAgdmFyIG1hdGNoID0gbGluZS5tYXRjaChyZUZyb250TWF0dGVyKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lci50eXBlID09PSAnZnJvbnRNYXR0ZXInICYmIG1hdGNoKSB7XG4gICAgICAgICAgICBjb250YWluZXIuc3RyaW5nQ29udGVudCArPSBsaW5lO1xuICAgICAgICAgICAgcGFyc2VyLmxhc3RMaW5lTGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcGFyc2VyLmZpbmFsaXplKGNvbnRhaW5lciwgcGFyc2VyLmxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgcmV0dXJuIDIgLyogRmluaXNoZWQgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKF8sIGJsb2NrKSB7XG4gICAgICAgIGlmIChibG9jay5zdHJpbmdDb250ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2subGl0ZXJhbCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQ7XG4gICAgICAgIGJsb2NrLnN0cmluZ0NvbnRlbnQgPSBudWxsO1xuICAgIH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IHRydWUsXG59O1xuXG52YXIgcmVIdG1sQmxvY2tDbG9zZSA9IFtcbiAgICAvLi8sXG4gICAgLzxcXC8oPzpzY3JpcHR8cHJlfHN0eWxlKT4vaSxcbiAgICAvLS0+LyxcbiAgICAvXFw/Pi8sXG4gICAgLz4vLFxuICAgIC9cXF1cXF0+Lyxcbl07XG52YXIgcmVNYXliZVNwZWNpYWwgPSAvXlsjYH4qK189PD4wLTktOyRdLztcbnZhciByZUxpbmVFbmRpbmckMSA9IC9cXHJcXG58XFxufFxcci87XG5mdW5jdGlvbiBkb2N1bWVudCQyKCkge1xuICAgIHJldHVybiBjcmVhdGVOb2RlJDEoJ2RvY3VtZW50JywgW1xuICAgICAgICBbMSwgMV0sXG4gICAgICAgIFswLCAwXSxcbiAgICBdKTtcbn1cbnZhciBkZWZhdWx0T3B0aW9ucyQxID0ge1xuICAgIHNtYXJ0OiBmYWxzZSxcbiAgICB0YWdGaWx0ZXI6IGZhbHNlLFxuICAgIGV4dGVuZGVkQXV0b2xpbmtzOiBmYWxzZSxcbiAgICBkaXNhbGxvd2VkSHRtbEJsb2NrVGFnczogW10sXG4gICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogZmFsc2UsXG4gICAgZGlzYWxsb3dEZWVwSGVhZGluZzogZmFsc2UsXG4gICAgY3VzdG9tUGFyc2VyOiBudWxsLFxuICAgIGZyb250TWF0dGVyOiBmYWxzZSxcbn07XG52YXIgUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyQxKSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jdW1lbnQkMigpO1xuICAgICAgICB0aGlzLnRpcCA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLm9sZHRpcCA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSAwO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgICAgdGhpcy5uZXh0Tm9uc3BhY2UgPSAwO1xuICAgICAgICB0aGlzLm5leHROb25zcGFjZUNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9ICcnO1xuICAgICAgICB0aGlzLmluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmxhbmsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbENsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5yZWZNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwID0ge307XG4gICAgICAgIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwID0ge307XG4gICAgICAgIHRoaXMubGFzdExpbmVMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmxpbmVzID0gW107XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZnJvbnRNYXR0ZXIpIHtcbiAgICAgICAgICAgIGJsb2NrSGFuZGxlcnMuZnJvbnRNYXR0ZXIgPSBmcm9udE1hdHRlcjtcbiAgICAgICAgICAgIGJsb2NrU3RhcnRzLnVuc2hpZnQoZnJvbnRNYXR0ZXIkMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXIgPSBuZXcgSW5saW5lUGFyc2VyKHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIFBhcnNlci5wcm90b3R5cGUuYWR2YW5jZU9mZnNldCA9IGZ1bmN0aW9uIChjb3VudCwgY29sdW1ucykge1xuICAgICAgICBpZiAoY29sdW1ucyA9PT0gdm9pZCAwKSB7IGNvbHVtbnMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgY3VycmVudExpbmUgPSB0aGlzLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgY2hhcnNUb1RhYiwgY2hhcnNUb0FkdmFuY2U7XG4gICAgICAgIHZhciBjO1xuICAgICAgICB3aGlsZSAoY291bnQgPiAwICYmIChjID0gY3VycmVudExpbmVbdGhpcy5vZmZzZXRdKSkge1xuICAgICAgICAgICAgaWYgKGMgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNUb1RhYiA9IDQgLSAodGhpcy5jb2x1bW4gJSA0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID0gY2hhcnNUb1RhYiA+IGNvdW50O1xuICAgICAgICAgICAgICAgICAgICBjaGFyc1RvQWR2YW5jZSA9IGNoYXJzVG9UYWIgPiBjb3VudCA/IGNvdW50IDogY2hhcnNUb1RhYjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4gKz0gY2hhcnNUb0FkdmFuY2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgLT0gY2hhcnNUb0FkdmFuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uICs9IGNoYXJzVG9UYWI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4gKz0gMTsgLy8gYXNzdW1lIGFzY2lpOyBibG9jayBzdGFydHMgYXJlIGFzY2lpXG4gICAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5hZHZhbmNlTmV4dE5vbnNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMubmV4dE5vbnNwYWNlO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IHRoaXMubmV4dE5vbnNwYWNlQ29sdW1uO1xuICAgICAgICB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID0gZmFsc2U7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLmZpbmROZXh0Tm9uc3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50TGluZSA9IHRoaXMuY3VycmVudExpbmU7XG4gICAgICAgIHZhciBpID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHZhciBjb2xzID0gdGhpcy5jb2x1bW47XG4gICAgICAgIHZhciBjO1xuICAgICAgICB3aGlsZSAoKGMgPSBjdXJyZW50TGluZS5jaGFyQXQoaSkpICE9PSAnJykge1xuICAgICAgICAgICAgaWYgKGMgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb2xzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb2xzICs9IDQgLSAoY29scyAlIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ibGFuayA9IGMgPT09ICdcXG4nIHx8IGMgPT09ICdcXHInIHx8IGMgPT09ICcnO1xuICAgICAgICB0aGlzLm5leHROb25zcGFjZSA9IGk7XG4gICAgICAgIHRoaXMubmV4dE5vbnNwYWNlQ29sdW1uID0gY29scztcbiAgICAgICAgdGhpcy5pbmRlbnQgPSB0aGlzLm5leHROb25zcGFjZUNvbHVtbiAtIHRoaXMuY29sdW1uO1xuICAgICAgICB0aGlzLmluZGVudGVkID0gdGhpcy5pbmRlbnQgPj0gQ09ERV9JTkRFTlQ7XG4gICAgfTtcbiAgICAvLyBBZGQgYSBsaW5lIHRvIHRoZSBibG9jayBhdCB0aGUgdGlwLiAgV2UgYXNzdW1lIHRoZSB0aXBcbiAgICAvLyBjYW4gYWNjZXB0IGxpbmVzIC0tIHRoYXQgY2hlY2sgc2hvdWxkIGJlIGRvbmUgYmVmb3JlIGNhbGxpbmcgdGhpcy5cbiAgICBQYXJzZXIucHJvdG90eXBlLmFkZExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCArPSAxOyAvLyBza2lwIG92ZXIgdGFiXG4gICAgICAgICAgICAvLyBhZGQgc3BhY2UgY2hhcmFjdGVyczpcbiAgICAgICAgICAgIHZhciBjaGFyc1RvVGFiID0gNCAtICh0aGlzLmNvbHVtbiAlIDQpO1xuICAgICAgICAgICAgdGhpcy50aXAuc3RyaW5nQ29udGVudCArPSByZXBlYXQoJyAnLCBjaGFyc1RvVGFiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aXAubGluZU9mZnNldHMpIHtcbiAgICAgICAgICAgIHRoaXMudGlwLmxpbmVPZmZzZXRzLnB1c2godGhpcy5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50aXAubGluZU9mZnNldHMgPSBbdGhpcy5vZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlwLnN0cmluZ0NvbnRlbnQgKz0gdGhpcy5jdXJyZW50TGluZS5zbGljZSh0aGlzLm9mZnNldCkgKyBcIlxcblwiO1xuICAgIH07XG4gICAgLy8gQWRkIGJsb2NrIG9mIHR5cGUgdGFnIGFzIGEgY2hpbGQgb2YgdGhlIHRpcC4gIElmIHRoZSB0aXAgY2FuJ3RcbiAgICAvLyBhY2NlcHQgY2hpbGRyZW4sIGNsb3NlIGFuZCBmaW5hbGl6ZSBpdCBhbmQgdHJ5IGl0cyBwYXJlbnQsXG4gICAgLy8gYW5kIHNvIG9uIHRpbCB3ZSBmaW5kIGEgYmxvY2sgdGhhdCBjYW4gYWNjZXB0IGNoaWxkcmVuLlxuICAgIFBhcnNlci5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAodGFnLCBvZmZzZXQpIHtcbiAgICAgICAgd2hpbGUgKCFibG9ja0hhbmRsZXJzW3RoaXMudGlwLnR5cGVdLmNhbkNvbnRhaW4odGFnKSkge1xuICAgICAgICAgICAgdGhpcy5maW5hbGl6ZSh0aGlzLnRpcCwgdGhpcy5saW5lTnVtYmVyIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IG9mZnNldCArIDE7IC8vIG9mZnNldCAwID0gY29sdW1uIDFcbiAgICAgICAgdmFyIG5ld0Jsb2NrID0gY3JlYXRlTm9kZSQxKHRhZywgW1xuICAgICAgICAgICAgW3RoaXMubGluZU51bWJlciwgY29sdW1uTnVtYmVyXSxcbiAgICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgXSk7XG4gICAgICAgIG5ld0Jsb2NrLnN0cmluZ0NvbnRlbnQgPSAnJztcbiAgICAgICAgdGhpcy50aXAuYXBwZW5kQ2hpbGQobmV3QmxvY2spO1xuICAgICAgICB0aGlzLnRpcCA9IG5ld0Jsb2NrO1xuICAgICAgICByZXR1cm4gbmV3QmxvY2s7XG4gICAgfTtcbiAgICAvLyBGaW5hbGl6ZSBhbmQgY2xvc2UgYW55IHVubWF0Y2hlZCBibG9ja3MuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5jbG9zZVVubWF0Y2hlZEJsb2NrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbENsb3NlZCkge1xuICAgICAgICAgICAgLy8gZmluYWxpemUgYW55IGJsb2NrcyBub3QgbWF0Y2hlZFxuICAgICAgICAgICAgd2hpbGUgKHRoaXMub2xkdGlwICE9PSB0aGlzLmxhc3RNYXRjaGVkQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gdGhpcy5vbGR0aXAucGFyZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuZmluYWxpemUodGhpcy5vbGR0aXAsIHRoaXMubGluZU51bWJlciAtIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMub2xkdGlwID0gcGFyZW50XzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFsbENsb3NlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEZpbmFsaXplIGEgYmxvY2suICBDbG9zZSBpdCBhbmQgZG8gYW55IG5lY2Vzc2FyeSBwb3N0cHJvY2Vzc2luZyxcbiAgICAvLyBlLmcuIGNyZWF0aW5nIHN0cmluZ0NvbnRlbnQgZnJvbSBzdHJpbmdzLCBzZXR0aW5nIHRoZSAndGlnaHQnXG4gICAgLy8gb3IgJ2xvb3NlJyBzdGF0dXMgb2YgYSBsaXN0LCBhbmQgcGFyc2luZyB0aGUgYmVnaW5uaW5nc1xuICAgIC8vIG9mIHBhcmFncmFwaHMgZm9yIHJlZmVyZW5jZSBkZWZpbml0aW9ucy4gIFJlc2V0IHRoZSB0aXAgdG8gdGhlXG4gICAgLy8gcGFyZW50IG9mIHRoZSBjbG9zZWQgYmxvY2suXG4gICAgUGFyc2VyLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChibG9jaywgbGluZU51bWJlcikge1xuICAgICAgICB2YXIgYWJvdmUgPSBibG9jay5wYXJlbnQ7XG4gICAgICAgIGJsb2NrLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgYmxvY2suc291cmNlcG9zWzFdID0gW2xpbmVOdW1iZXIsIHRoaXMubGFzdExpbmVMZW5ndGhdO1xuICAgICAgICBibG9ja0hhbmRsZXJzW2Jsb2NrLnR5cGVdLmZpbmFsaXplKHRoaXMsIGJsb2NrKTtcbiAgICAgICAgdGhpcy50aXAgPSBhYm92ZTtcbiAgICB9O1xuICAgIC8vIFdhbGsgdGhyb3VnaCBhIGJsb2NrICYgY2hpbGRyZW4gcmVjdXJzaXZlbHksIHBhcnNpbmcgc3RyaW5nIGNvbnRlbnRcbiAgICAvLyBpbnRvIGlubGluZSBjb250ZW50IHdoZXJlIGFwcHJvcHJpYXRlLlxuICAgIFBhcnNlci5wcm90b3R5cGUucHJvY2Vzc0lubGluZXMgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIGV2ZW50O1xuICAgICAgICB2YXIgY3VzdG9tUGFyc2VyID0gdGhpcy5vcHRpb25zLmN1c3RvbVBhcnNlcjtcbiAgICAgICAgdmFyIHdhbGtlciA9IGJsb2NrLndhbGtlcigpO1xuICAgICAgICB0aGlzLmlubGluZVBhcnNlci5yZWZNYXAgPSB0aGlzLnJlZk1hcDtcbiAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXIucmVmTGlua0NhbmRpZGF0ZU1hcCA9IHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcDtcbiAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXIucmVmRGVmQ2FuZGlkYXRlTWFwID0gdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXA7XG4gICAgICAgIHRoaXMuaW5saW5lUGFyc2VyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBldmVudC5ub2RlLCBlbnRlcmluZyA9IGV2ZW50LmVudGVyaW5nO1xuICAgICAgICAgICAgdmFyIHQgPSBub2RlLnR5cGU7XG4gICAgICAgICAgICBpZiAoY3VzdG9tUGFyc2VyICYmIGN1c3RvbVBhcnNlclt0XSkge1xuICAgICAgICAgICAgICAgIGN1c3RvbVBhcnNlclt0XShub2RlLCB7IGVudGVyaW5nOiBlbnRlcmluZywgb3B0aW9uczogdGhpcy5vcHRpb25zIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlbnRlcmluZyAmJlxuICAgICAgICAgICAgICAgICh0ID09PSAncGFyYWdyYXBoJyB8fFxuICAgICAgICAgICAgICAgICAgICB0ID09PSAnaGVhZGluZycgfHxcbiAgICAgICAgICAgICAgICAgICAgKHQgPT09ICd0YWJsZUNlbGwnICYmICFub2RlLmlnbm9yZWQpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUGFyc2VyLnBhcnNlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBBbmFseXplIGEgbGluZSBvZiB0ZXh0IGFuZCB1cGRhdGUgdGhlIGRvY3VtZW50IGFwcHJvcHJpYXRlbHkuXG4gICAgLy8gV2UgcGFyc2UgbWFya2Rvd24gdGV4dCBieSBjYWxsaW5nIHRoaXMgb24gZWFjaCBsaW5lIG9mIGlucHV0LFxuICAgIC8vIHRoZW4gZmluYWxpemluZyB0aGUgZG9jdW1lbnQuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5pbmNvcnBvcmF0ZUxpbmUgPSBmdW5jdGlvbiAobG4pIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLm9sZHRpcCA9IHRoaXMudGlwO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgICAgdGhpcy5ibGFuayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGluZU51bWJlciArPSAxO1xuICAgICAgICAvLyByZXBsYWNlIE5VTCBjaGFyYWN0ZXJzIGZvciBzZWN1cml0eVxuICAgICAgICBpZiAobG4uaW5kZXhPZignXFx1MDAwMCcpICE9PSAtMSkge1xuICAgICAgICAgICAgbG4gPSBsbi5yZXBsYWNlKC9cXDAvZywgJ1xcdUZGRkQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRMaW5lID0gbG47XG4gICAgICAgIC8vIEZvciBlYWNoIGNvbnRhaW5pbmcgYmxvY2ssIHRyeSB0byBwYXJzZSB0aGUgYXNzb2NpYXRlZCBsaW5lIHN0YXJ0LlxuICAgICAgICAvLyBCYWlsIG91dCBvbiBmYWlsdXJlOiBjb250YWluZXIgd2lsbCBwb2ludCB0byB0aGUgbGFzdCBtYXRjaGluZyBibG9jay5cbiAgICAgICAgLy8gU2V0IGFsbE1hdGNoZWQgdG8gZmFsc2UgaWYgbm90IGFsbCBjb250YWluZXJzIG1hdGNoLlxuICAgICAgICB2YXIgYWxsTWF0Y2hlZCA9IHRydWU7XG4gICAgICAgIHZhciBsYXN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlICgobGFzdENoaWxkID0gY29udGFpbmVyLmxhc3RDaGlsZCkgJiYgbGFzdENoaWxkLm9wZW4pIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGxhc3RDaGlsZDtcbiAgICAgICAgICAgIHRoaXMuZmluZE5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChibG9ja0hhbmRsZXJzW2NvbnRhaW5lci50eXBlXVsnY29udGludWUnXSh0aGlzLCBjb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIEdvICovOiAvLyB3ZSd2ZSBtYXRjaGVkLCBrZWVwIGdvaW5nXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBTdG9wICovOiAvLyB3ZSd2ZSBmYWlsZWQgdG8gbWF0Y2ggYSBibG9ja1xuICAgICAgICAgICAgICAgICAgICBhbGxNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBGaW5pc2hlZCAqLzogLy8gd2UndmUgaGl0IGVuZCBvZiBsaW5lIGZvciBmZW5jZWQgY29kZSBjbG9zZSBhbmQgY2FuIHJldHVyblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gbG4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb250aW51ZSByZXR1cm5lZCBpbGxlZ2FsIHZhbHVlLCBtdXN0IGJlIDAsIDEsIG9yIDInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWxsTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnQ7IC8vIGJhY2sgdXAgdG8gbGFzdCBtYXRjaGluZyBibG9ja1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsQ2xvc2VkID0gY29udGFpbmVyID09PSB0aGlzLm9sZHRpcDtcbiAgICAgICAgdGhpcy5sYXN0TWF0Y2hlZENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdmFyIG1hdGNoZWRMZWFmID0gY29udGFpbmVyLnR5cGUgIT09ICdwYXJhZ3JhcGgnICYmIGJsb2NrSGFuZGxlcnNbY29udGFpbmVyLnR5cGVdLmFjY2VwdHNMaW5lcztcbiAgICAgICAgdmFyIGJsb2NrU3RhcnRzTGVuID0gYmxvY2tTdGFydHMubGVuZ3RoO1xuICAgICAgICAvLyBVbmxlc3MgbGFzdCBtYXRjaGVkIGNvbnRhaW5lciBpcyBhIGNvZGUgYmxvY2ssIHRyeSBuZXcgY29udGFpbmVyIHN0YXJ0cyxcbiAgICAgICAgLy8gYWRkaW5nIGNoaWxkcmVuIHRvIHRoZSBsYXN0IG1hdGNoZWQgY29udGFpbmVyOlxuICAgICAgICB3aGlsZSAoIW1hdGNoZWRMZWFmKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmROZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBsaXR0bGUgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOlxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci50eXBlICE9PSAndGFibGUnICYmXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnR5cGUgIT09ICd0YWJsZUJvZHknICYmXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnR5cGUgIT09ICdwYXJhZ3JhcGgnICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaW5kZW50ZWQgJiZcbiAgICAgICAgICAgICAgICAhcmVNYXliZVNwZWNpYWwudGVzdChsbi5zbGljZSh0aGlzLm5leHROb25zcGFjZSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGJsb2NrU3RhcnRzTGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGJsb2NrU3RhcnRzW2ldKHRoaXMsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgaWYgKHJlcyA9PT0gMSAvKiBDb250YWluZXIgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy50aXA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXMgPT09IDIgLyogTGVhZiAqLykge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLnRpcDtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZExlYWYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gYmxvY2tTdGFydHNMZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBub3RoaW5nIG1hdGNoZWRcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXaGF0IHJlbWFpbnMgYXQgdGhlIG9mZnNldCBpcyBhIHRleHQgbGluZS4gIEFkZCB0aGUgdGV4dCB0byB0aGVcbiAgICAgICAgLy8gYXBwcm9wcmlhdGUgY29udGFpbmVyLlxuICAgICAgICAvLyBGaXJzdCBjaGVjayBmb3IgYSBsYXp5IHBhcmFncmFwaCBjb250aW51YXRpb246XG4gICAgICAgIGlmICghdGhpcy5hbGxDbG9zZWQgJiYgIXRoaXMuYmxhbmsgJiYgdGhpcy50aXAudHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgIC8vIGxhenkgcGFyYWdyYXBoIGNvbnRpbnVhdGlvblxuICAgICAgICAgICAgdGhpcy5hZGRMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBub3QgYSBsYXp5IGNvbnRpbnVhdGlvblxuICAgICAgICAgICAgLy8gZmluYWxpemUgYW55IGJsb2NrcyBub3QgbWF0Y2hlZFxuICAgICAgICAgICAgdGhpcy5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmxhbmsgJiYgY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5sYXN0Q2hpbGQubGFzdExpbmVCbGFuayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdCA9IGNvbnRhaW5lci50eXBlO1xuICAgICAgICAgICAgLy8gQmxvY2sgcXVvdGUgbGluZXMgYXJlIG5ldmVyIGJsYW5rIGFzIHRoZXkgc3RhcnQgd2l0aCA+XG4gICAgICAgICAgICAvLyBhbmQgd2UgZG9uJ3QgY291bnQgYmxhbmtzIGluIGZlbmNlZCBjb2RlIGZvciBwdXJwb3NlcyBvZiB0aWdodC9sb29zZVxuICAgICAgICAgICAgLy8gbGlzdHMgb3IgYnJlYWtpbmcgb3V0IG9mIGxpc3RzLiBXZSBhbHNvIGRvbid0IHNldCBfbGFzdExpbmVCbGFua1xuICAgICAgICAgICAgLy8gb24gYW4gZW1wdHkgbGlzdCBpdGVtLCBvciBpZiB3ZSBqdXN0IGNsb3NlZCBhIGZlbmNlZCBibG9jay5cbiAgICAgICAgICAgIHZhciBsYXN0TGluZUJsYW5rID0gdGhpcy5ibGFuayAmJlxuICAgICAgICAgICAgICAgICEodCA9PT0gJ2Jsb2NrUXVvdGUnIHx8XG4gICAgICAgICAgICAgICAgICAgIChpc0NvZGVCbG9jayhjb250YWluZXIpICYmIGNvbnRhaW5lci5pc0ZlbmNlZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHQgPT09ICdpdGVtJyAmJiAhY29udGFpbmVyLmZpcnN0Q2hpbGQgJiYgY29udGFpbmVyLnNvdXJjZXBvc1swXVswXSA9PT0gdGhpcy5saW5lTnVtYmVyKSk7XG4gICAgICAgICAgICAvLyBwcm9wYWdhdGUgbGFzdExpbmVCbGFuayB1cCB0aHJvdWdoIHBhcmVudHM6XG4gICAgICAgICAgICB2YXIgY29udCA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgIHdoaWxlIChjb250KSB7XG4gICAgICAgICAgICAgICAgY29udC5sYXN0TGluZUJsYW5rID0gbGFzdExpbmVCbGFuaztcbiAgICAgICAgICAgICAgICBjb250ID0gY29udC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2tIYW5kbGVyc1t0XS5hY2NlcHRzTGluZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExpbmUoKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBIdG1sQmxvY2ssIGNoZWNrIGZvciBlbmQgY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGlzSHRtbEJsb2NrKGNvbnRhaW5lcikgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmh0bWxCbG9ja1R5cGUgPj0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuaHRtbEJsb2NrVHlwZSA8PSA1ICYmXG4gICAgICAgICAgICAgICAgICAgIHJlSHRtbEJsb2NrQ2xvc2VbY29udGFpbmVyLmh0bWxCbG9ja1R5cGVdLnRlc3QodGhpcy5jdXJyZW50TGluZS5zbGljZSh0aGlzLm9mZnNldCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdExpbmVMZW5ndGggPSBsbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluYWxpemUoY29udGFpbmVyLCB0aGlzLmxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub2Zmc2V0IDwgbG4ubGVuZ3RoICYmICF0aGlzLmJsYW5rKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHBhcmFncmFwaCBjb250YWluZXIgZm9yIGxpbmVcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLmFkZENoaWxkKCdwYXJhZ3JhcGgnLCB0aGlzLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0TGluZUxlbmd0aCA9IGxuLmxlbmd0aDtcbiAgICB9O1xuICAgIC8vIFRoZSBtYWluIHBhcnNpbmcgZnVuY3Rpb24uICBSZXR1cm5zIGEgcGFyc2VkIGRvY3VtZW50IEFTVC5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGlucHV0LCBsaW5lVGV4dHMpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2N1bWVudCQyKCk7XG4gICAgICAgIHRoaXMudGlwID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMubGluZU51bWJlciA9IDA7XG4gICAgICAgIHRoaXMubGFzdExpbmVMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgICAgdGhpcy5sYXN0TWF0Y2hlZENvbnRhaW5lciA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLmN1cnJlbnRMaW5lID0gJyc7XG4gICAgICAgIHZhciBsaW5lcyA9IGlucHV0LnNwbGl0KHJlTGluZUVuZGluZyQxKTtcbiAgICAgICAgdmFyIGxlbiA9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVUZXh0cyA/IGxpbmVUZXh0cyA6IGxpbmVzO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlZmVyZW5jZURlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJSZWZNYXBzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgPT09IENfTkVXTElORSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIGxhc3QgYmxhbmsgbGluZSBjcmVhdGVkIGJ5IGZpbmFsIG5ld2xpbmVcbiAgICAgICAgICAgIGxlbiAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5jb3Jwb3JhdGVMaW5lKGxpbmVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy50aXApIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemUodGhpcy50aXAsIGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9jZXNzSW5saW5lcyh0aGlzLmRvYyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYztcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFydGlhbFBhcnNlU3RhcnQgPSBmdW5jdGlvbiAobGluZU51bWJlciwgbGluZXMpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2N1bWVudCQyKCk7XG4gICAgICAgIHRoaXMudGlwID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMubGluZU51bWJlciA9IGxpbmVOdW1iZXIgLSAxO1xuICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9ICcnO1xuICAgICAgICB2YXIgbGVuID0gbGluZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmluY29ycG9yYXRlTGluZShsaW5lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJ0aWFsUGFyc2VFeHRlbmRzID0gZnVuY3Rpb24gKGxpbmVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5jb3Jwb3JhdGVMaW5lKGxpbmVzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJ0aWFsUGFyc2VGaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnRpcCkge1xuICAgICAgICAgICAgdGhpcy5maW5hbGl6ZSh0aGlzLnRpcCwgdGhpcy5saW5lTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2Nlc3NJbmxpbmVzKHRoaXMuZG9jKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuc2V0UmVmTWFwcyA9IGZ1bmN0aW9uIChyZWZNYXAsIHJlZkxpbmtDYW5kaWRhdGVNYXAsIHJlZkRlZkNhbmRpZGF0ZU1hcCkge1xuICAgICAgICB0aGlzLnJlZk1hcCA9IHJlZk1hcDtcbiAgICAgICAgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwID0gcmVmTGlua0NhbmRpZGF0ZU1hcDtcbiAgICAgICAgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXAgPSByZWZEZWZDYW5kaWRhdGVNYXA7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLmNsZWFyUmVmTWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgW3RoaXMucmVmTWFwLCB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAsIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwXS5mb3JFYWNoKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIGNsZWFyT2JqKG1hcCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlcjtcbn0oKSk7XG5cbmZ1bmN0aW9uIGNvbXBhcmVQb3MocDEsIHAyKSB7XG4gICAgaWYgKHAxWzBdIDwgcDJbMF0pIHtcbiAgICAgICAgcmV0dXJuIDEgLyogTFQgKi87XG4gICAgfVxuICAgIGlmIChwMVswXSA+IHAyWzBdKSB7XG4gICAgICAgIHJldHVybiAtMSAvKiBHVCAqLztcbiAgICB9XG4gICAgaWYgKHAxWzFdIDwgcDJbMV0pIHtcbiAgICAgICAgcmV0dXJuIDEgLyogTFQgKi87XG4gICAgfVxuICAgIGlmIChwMVsxXSA+IHAyWzFdKSB7XG4gICAgICAgIHJldHVybiAtMSAvKiBHVCAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogRVEgKi87XG59XG5mdW5jdGlvbiBjb21wYXJlUmFuZ2VBbmRQb3MoX2EsIHBvcykge1xuICAgIHZhciBzdGFydFBvcyA9IF9hWzBdLCBlbmRQb3MgPSBfYVsxXTtcbiAgICBpZiAoY29tcGFyZVBvcyhlbmRQb3MsIHBvcykgPT09IDEgLyogTFQgKi8pIHtcbiAgICAgICAgcmV0dXJuIDEgLyogTFQgKi87XG4gICAgfVxuICAgIGlmIChjb21wYXJlUG9zKHN0YXJ0UG9zLCBwb3MpID09PSAtMSAvKiBHVCAqLykge1xuICAgICAgICByZXR1cm4gLTEgLyogR1QgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIEVRICovO1xufVxuZnVuY3Rpb24gcmVtb3ZlTmV4dFVudGlsKG5vZGUsIGxhc3QpIHtcbiAgICBpZiAobm9kZS5wYXJlbnQgIT09IGxhc3QucGFyZW50IHx8IG5vZGUgPT09IGxhc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IG5vZGUubmV4dDtcbiAgICB3aGlsZSAobmV4dCAmJiBuZXh0ICE9PSBsYXN0KSB7XG4gICAgICAgIHZhciB0ZW1wID0gbmV4dC5uZXh0O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gWydwYXJlbnQnLCAncHJldicsICduZXh0J107IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChuZXh0W3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZUJ5SWQobmV4dFt0eXBlXS5pZCk7XG4gICAgICAgICAgICAgICAgbmV4dFt0eXBlXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCA9IHRlbXA7XG4gICAgfVxuICAgIG5vZGUubmV4dCA9IGxhc3QubmV4dDtcbiAgICBpZiAobGFzdC5uZXh0KSB7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gbm9kZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUucGFyZW50Lmxhc3RDaGlsZCA9IG5vZGU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGROb2RlcyhwYXJlbnQpIHtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgY3VyciA9IHBhcmVudC5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjdXJyKSB7XG4gICAgICAgIG5vZGVzLnB1c2goY3Vycik7XG4gICAgICAgIGN1cnIgPSBjdXJyLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIGluc2VydE5vZGVzQmVmb3JlKHRhcmdldCwgbm9kZXMpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIG5vZGVzXzEgPSBub2RlczsgX2kgPCBub2Rlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzXzFbX2ldO1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByZXBlbmRDaGlsZE5vZGVzKHBhcmVudCwgbm9kZXMpIHtcbiAgICBmb3IgKHZhciBpID0gbm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgcGFyZW50LnByZXBlbmRDaGlsZChub2Rlc1tpXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlTmV4dExpbmVOdW1iZXJzKGJhc2UsIGRpZmYpIHtcbiAgICBpZiAoIWJhc2UgfHwgIWJhc2UucGFyZW50IHx8IGRpZmYgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2Fsa2VyID0gYmFzZS5wYXJlbnQud2Fsa2VyKCk7XG4gICAgd2Fsa2VyLnJlc3VtZUF0KGJhc2UsIHRydWUpO1xuICAgIHZhciBldmVudDtcbiAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBldmVudC5ub2RlLCBlbnRlcmluZyA9IGV2ZW50LmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIG5vZGUuc291cmNlcG9zWzBdWzBdICs9IGRpZmY7XG4gICAgICAgICAgICBub2RlLnNvdXJjZXBvc1sxXVswXSArPSBkaWZmO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZVJhbmdlQW5kTGluZShfYSwgbGluZSkge1xuICAgIHZhciBzdGFydFBvcyA9IF9hWzBdLCBlbmRQb3MgPSBfYVsxXTtcbiAgICBpZiAoZW5kUG9zWzBdIDwgbGluZSkge1xuICAgICAgICByZXR1cm4gMSAvKiBMVCAqLztcbiAgICB9XG4gICAgaWYgKHN0YXJ0UG9zWzBdID4gbGluZSkge1xuICAgICAgICByZXR1cm4gLTEgLyogR1QgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIEVRICovO1xufVxuZnVuY3Rpb24gZmluZENoaWxkTm9kZUF0TGluZShwYXJlbnQsIGxpbmUpIHtcbiAgICB2YXIgbm9kZSA9IHBhcmVudC5maXJzdENoaWxkO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIHZhciBjb21wID0gY29tcGFyZVJhbmdlQW5kTGluZShub2RlLnNvdXJjZXBvcywgbGluZSk7XG4gICAgICAgIGlmIChjb21wID09PSAwIC8qIEVRICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcCA9PT0gLTEgLyogR1QgKi8pIHtcbiAgICAgICAgICAgIC8vIFRvIGNvbnNpZGVyIHRoYXQgdG9wIGxpbmUgaXMgYmxhbmsgbGluZVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUucHJldiB8fCBub2RlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnQubGFzdENoaWxkO1xufVxuZnVuY3Rpb24gbGFzdExlYWZOb2RlKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHNhbWVMaW5lVG9wQW5jZXN0b3Iobm9kZSkge1xuICAgIHdoaWxlIChub2RlLnBhcmVudCAmJlxuICAgICAgICBub2RlLnBhcmVudC50eXBlICE9PSAnZG9jdW1lbnQnICYmXG4gICAgICAgIG5vZGUucGFyZW50LnNvdXJjZXBvc1swXVswXSA9PT0gbm9kZS5zb3VyY2Vwb3NbMF1bMF0pIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGZpbmRGaXJzdE5vZGVBdExpbmUocGFyZW50LCBsaW5lKSB7XG4gICAgdmFyIG5vZGUgPSBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICB2YXIgcHJldiA9IG51bGw7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgdmFyIGNvbXAgPSBjb21wYXJlUmFuZ2VBbmRMaW5lKG5vZGUuc291cmNlcG9zLCBsaW5lKTtcbiAgICAgICAgaWYgKGNvbXAgPT09IDAgLyogRVEgKi8pIHtcbiAgICAgICAgICAgIGlmIChub2RlLnNvdXJjZXBvc1swXVswXSA9PT0gbGluZSB8fCAhbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcCA9PT0gLTEgLyogR1QgKi8pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2KSB7XG4gICAgICAgIHJldHVybiBzYW1lTGluZVRvcEFuY2VzdG9yKGxhc3RMZWFmTm9kZShwcmV2KSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZE5vZGVBdFBvc2l0aW9uKHBhcmVudCwgcG9zKSB7XG4gICAgdmFyIG5vZGUgPSBwYXJlbnQ7XG4gICAgdmFyIHByZXYgPSBudWxsO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIHZhciBjb21wID0gY29tcGFyZVJhbmdlQW5kUG9zKG5vZGUuc291cmNlcG9zLCBwb3MpO1xuICAgICAgICBpZiAoY29tcCA9PT0gMCAvKiBFUSAqLykge1xuICAgICAgICAgICAgaWYgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wID09PSAtMSAvKiBHVCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5uZXh0KSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBmaW5kTm9kZUJ5SWQoaWQpIHtcbiAgICByZXR1cm4gZ2V0Tm9kZUJ5SWQoaWQpIHx8IG51bGw7XG59XG5mdW5jdGlvbiBpbnZva2VOZXh0VW50aWwoY2FsbGJhY2ssIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gbnVsbDsgfVxuICAgIGlmIChzdGFydCkge1xuICAgICAgICB2YXIgd2Fsa2VyID0gc3RhcnQud2Fsa2VyKCk7XG4gICAgICAgIHdoaWxlIChzdGFydCAmJiBzdGFydCAhPT0gZW5kKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhzdGFydCk7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHdhbGtlci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbmV4dC5ub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1VubGlua2VkKGlkKSB7XG4gICAgdmFyIG5vZGUgPSBmaW5kTm9kZUJ5SWQoaWQpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZS50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgICAgaWYgKCFub2RlLnBhcmVudCAmJiAhbm9kZS5wcmV2ICYmICFub2RlLm5leHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgcmVMaW5lRW5kaW5nID0gL1xcclxcbnxcXG58XFxyLztcbmZ1bmN0aW9uIGNhbkJlQ29udGludWVkTGlzdEl0ZW0obGluZVRleHQpIHtcbiAgICB2YXIgc3BhY2VNYXRjaCA9IGxpbmVUZXh0Lm1hdGNoKC9eWyBcXHRdKy8pO1xuICAgIGlmIChzcGFjZU1hdGNoICYmIChzcGFjZU1hdGNoWzBdLmxlbmd0aCA+PSAyIHx8IC9cXHQvLnRlc3Qoc3BhY2VNYXRjaFswXSkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgbGVmdFRyaW1tZWQgPSBzcGFjZU1hdGNoID8gbGluZVRleHQuc2xpY2Uoc3BhY2VNYXRjaC5sZW5ndGgpIDogbGluZVRleHQ7XG4gICAgcmV0dXJuIHJlQnVsbGV0TGlzdE1hcmtlci50ZXN0KGxlZnRUcmltbWVkKSB8fCByZU9yZGVyZWRMaXN0TWFya2VyLnRlc3QobGVmdFRyaW1tZWQpO1xufVxuZnVuY3Rpb24gY2FuQmVDb250aW51ZWRUYWJsZUJvZHkobGluZVRleHQpIHtcbiAgICByZXR1cm4gIWlzQmxhbmsobGluZVRleHQpICYmIGxpbmVUZXh0LmluZGV4T2YoJ3wnKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWZEZWZTdGF0ZShub2RlKSB7XG4gICAgdmFyIGlkID0gbm9kZS5pZCwgdGl0bGUgPSBub2RlLnRpdGxlLCBzb3VyY2Vwb3MgPSBub2RlLnNvdXJjZXBvcywgZGVzdCA9IG5vZGUuZGVzdDtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgc291cmNlcG9zOiBzb3VyY2Vwb3MsXG4gICAgICAgIHVubGlua2VkOiBmYWxzZSxcbiAgICAgICAgZGVzdGluYXRpb246IGRlc3QsXG4gICAgfTtcbn1cbnZhciBUb2FzdE1hcmsgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9hc3RNYXJrKGNvbnRlbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVmTWFwID0ge307XG4gICAgICAgIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZmVyZW5jZURlZmluaXRpb24gPSAhIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVmZXJlbmNlRGVmaW5pdGlvbik7XG4gICAgICAgIHRoaXMucGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wYXJzZXIuc2V0UmVmTWFwcyh0aGlzLnJlZk1hcCwgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwLCB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCk7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyTWFwID0geyBjaGFuZ2U6IFtdIH07XG4gICAgICAgIGNvbnRlbnRzID0gY29udGVudHMgfHwgJyc7XG4gICAgICAgIHRoaXMubGluZVRleHRzID0gY29udGVudHMuc3BsaXQocmVMaW5lRW5kaW5nKTtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5wYXJzZXIucGFyc2UoY29udGVudHMsIHRoaXMubGluZVRleHRzKTtcbiAgICB9XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS51cGRhdGVMaW5lVGV4dHMgPSBmdW5jdGlvbiAoc3RhcnRQb3MsIGVuZFBvcywgbmV3VGV4dCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBzdGFydExpbmUgPSBzdGFydFBvc1swXSwgc3RhcnRDb2wgPSBzdGFydFBvc1sxXTtcbiAgICAgICAgdmFyIGVuZExpbmUgPSBlbmRQb3NbMF0sIGVuZENvbCA9IGVuZFBvc1sxXTtcbiAgICAgICAgdmFyIG5ld0xpbmVzID0gbmV3VGV4dC5zcGxpdChyZUxpbmVFbmRpbmcpO1xuICAgICAgICB2YXIgbmV3TGluZUxlbiA9IG5ld0xpbmVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHN0YXJ0TGluZVRleHQgPSB0aGlzLmxpbmVUZXh0c1tzdGFydExpbmUgLSAxXTtcbiAgICAgICAgdmFyIGVuZExpbmVUZXh0ID0gdGhpcy5saW5lVGV4dHNbZW5kTGluZSAtIDFdO1xuICAgICAgICBuZXdMaW5lc1swXSA9IHN0YXJ0TGluZVRleHQuc2xpY2UoMCwgc3RhcnRDb2wgLSAxKSArIG5ld0xpbmVzWzBdO1xuICAgICAgICBuZXdMaW5lc1tuZXdMaW5lTGVuIC0gMV0gPSBuZXdMaW5lc1tuZXdMaW5lTGVuIC0gMV0gKyBlbmRMaW5lVGV4dC5zbGljZShlbmRDb2wgLSAxKTtcbiAgICAgICAgdmFyIHJlbW92ZWRMaW5lTGVuID0gZW5kTGluZSAtIHN0YXJ0TGluZSArIDE7XG4gICAgICAgIChfYSA9IHRoaXMubGluZVRleHRzKS5zcGxpY2UuYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW3N0YXJ0TGluZSAtIDEsIHJlbW92ZWRMaW5lTGVuXSwgbmV3TGluZXMpKTtcbiAgICAgICAgcmV0dXJuIG5ld0xpbmVMZW4gLSByZW1vdmVkTGluZUxlbjtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUudXBkYXRlUm9vdE5vZGVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVRleHRzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmxpbmVUZXh0c1swXSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5sYXN0TGluZUJsYW5rID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5zb3VyY2Vwb3MgPSBbXG4gICAgICAgICAgICAgICAgWzEsIDFdLFxuICAgICAgICAgICAgICAgIFsxLCAwXSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucm9vdC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5sYXN0TGluZUJsYW5rID0gdGhpcy5yb290Lmxhc3RDaGlsZC5sYXN0TGluZUJsYW5rO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lVGV4dHMgPSB0aGlzLmxpbmVUZXh0cztcbiAgICAgICAgdmFyIGlkeCA9IGxpbmVUZXh0cy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAobGluZVRleHRzW2lkeF0gPT09ICcnKSB7XG4gICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVRleHRzLmxlbmd0aCAtIDIgPiBpZHgpIHtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdC5zb3VyY2Vwb3NbMV0gPSBbaWR4ICsgMSwgbGluZVRleHRzW2lkeF0ubGVuZ3RoXTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucmVwbGFjZVJhbmdlTm9kZXMgPSBmdW5jdGlvbiAoc3RhcnROb2RlLCBlbmROb2RlLCBuZXdOb2Rlcykge1xuICAgICAgICBpZiAoIXN0YXJ0Tm9kZSkge1xuICAgICAgICAgICAgaWYgKGVuZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnROb2Rlc0JlZm9yZShlbmROb2RlLCBuZXdOb2Rlcyk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZUJ5SWQoZW5kTm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgZW5kTm9kZS51bmxpbmsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXBlbmRDaGlsZE5vZGVzKHRoaXMucm9vdCwgbmV3Tm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zZXJ0Tm9kZXNCZWZvcmUoc3RhcnROb2RlLCBuZXdOb2Rlcyk7XG4gICAgICAgICAgICByZW1vdmVOZXh0VW50aWwoc3RhcnROb2RlLCBlbmROb2RlKTtcbiAgICAgICAgICAgIFtzdGFydE5vZGUuaWQsIGVuZE5vZGUuaWRdLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiByZW1vdmVOb2RlQnlJZChpZCk7IH0pO1xuICAgICAgICAgICAgc3RhcnROb2RlLnVubGluaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmdldE5vZGVSYW5nZSA9IGZ1bmN0aW9uIChzdGFydFBvcywgZW5kUG9zKSB7XG4gICAgICAgIHZhciBzdGFydE5vZGUgPSBmaW5kQ2hpbGROb2RlQXRMaW5lKHRoaXMucm9vdCwgc3RhcnRQb3NbMF0pO1xuICAgICAgICB2YXIgZW5kTm9kZSA9IGZpbmRDaGlsZE5vZGVBdExpbmUodGhpcy5yb290LCBlbmRQb3NbMF0pO1xuICAgICAgICAvLyBleHRlbmQgbm9kZSByYW5nZSB0byBpbmNsdWRlIGEgZm9sbG93aW5nIGJsb2NrIHdoaWNoIGRvZXNuJ3QgaGF2ZSBwcmVjZWRpbmcgYmxhbmsgbGluZVxuICAgICAgICBpZiAoZW5kTm9kZSAmJiBlbmROb2RlLm5leHQgJiYgZW5kUG9zWzBdICsgMSA9PT0gZW5kTm9kZS5uZXh0LnNvdXJjZXBvc1swXVswXSkge1xuICAgICAgICAgICAgZW5kTm9kZSA9IGVuZE5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3N0YXJ0Tm9kZSwgZW5kTm9kZV07XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBwYXJhbSkge1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlck1hcFtldmVudE5hbWVdLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIocGFyYW0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZXh0ZW5kRW5kTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmxpbmVUZXh0c1tsaW5lXSA9PT0gJycpIHtcbiAgICAgICAgICAgIGxpbmUgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucGFyc2VSYW5nZSA9IGZ1bmN0aW9uIChzdGFydE5vZGUsIGVuZE5vZGUsIHN0YXJ0TGluZSwgZW5kTGluZSkge1xuICAgICAgICAvLyBleHRlbmRzIHN0YXJ0aW5nIHJhbmdlIGlmIHRoZSBmaXJzdCBub2RlIGNhbiBiZSBhIGNvbnRpbnVlZCBsaXN0IGl0ZW1cbiAgICAgICAgaWYgKHN0YXJ0Tm9kZSAmJlxuICAgICAgICAgICAgc3RhcnROb2RlLnByZXYgJiZcbiAgICAgICAgICAgICgoaXNMaXN0KHN0YXJ0Tm9kZS5wcmV2KSAmJiBjYW5CZUNvbnRpbnVlZExpc3RJdGVtKHRoaXMubGluZVRleHRzW3N0YXJ0TGluZSAtIDFdKSkgfHxcbiAgICAgICAgICAgICAgICAoaXNUYWJsZShzdGFydE5vZGUucHJldikgJiYgY2FuQmVDb250aW51ZWRUYWJsZUJvZHkodGhpcy5saW5lVGV4dHNbc3RhcnRMaW5lIC0gMV0pKSkpIHtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZS5wcmV2O1xuICAgICAgICAgICAgc3RhcnRMaW5lID0gc3RhcnROb2RlLnNvdXJjZXBvc1swXVswXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWRpdGVkTGluZXMgPSB0aGlzLmxpbmVUZXh0cy5zbGljZShzdGFydExpbmUgLSAxLCBlbmRMaW5lKTtcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnBhcnNlci5wYXJ0aWFsUGFyc2VTdGFydChzdGFydExpbmUsIGVkaXRlZExpbmVzKTtcbiAgICAgICAgLy8gZXh0ZW5kcyBlbmRpbmcgcmFuZ2UgaWYgdGhlIGZvbGxvd2luZyBub2RlIGNhbiBiZSBhIGZlbmNlZCBjb2RlIGJsb2NrIG9yIGEgY29udGludWVkIGxpc3QgaXRlbVxuICAgICAgICB2YXIgbmV4dE5vZGUgPSBlbmROb2RlID8gZW5kTm9kZS5uZXh0IDogdGhpcy5yb290LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBsYXN0Q2hpbGQgPSByb290Lmxhc3RDaGlsZDtcbiAgICAgICAgdmFyIGlzT3BlbmVkTGFzdENoaWxkQ29kZUJsb2NrID0gbGFzdENoaWxkICYmIGlzQ29kZUJsb2NrKGxhc3RDaGlsZCkgJiYgbGFzdENoaWxkLm9wZW47XG4gICAgICAgIHZhciBpc09wZW5lZExhc3RDaGlsZEN1c3RvbUJsb2NrID0gbGFzdENoaWxkICYmIGlzQ3VzdG9tQmxvY2sobGFzdENoaWxkKSAmJiBsYXN0Q2hpbGQub3BlbjtcbiAgICAgICAgdmFyIGlzTGFzdENoaWxkTGlzdCA9IGxhc3RDaGlsZCAmJiBpc0xpc3QobGFzdENoaWxkKTtcbiAgICAgICAgd2hpbGUgKCgoaXNPcGVuZWRMYXN0Q2hpbGRDb2RlQmxvY2sgfHwgaXNPcGVuZWRMYXN0Q2hpbGRDdXN0b21CbG9jaykgJiYgbmV4dE5vZGUpIHx8XG4gICAgICAgICAgICAoaXNMYXN0Q2hpbGRMaXN0ICYmIG5leHROb2RlICYmIChuZXh0Tm9kZS50eXBlID09PSAnbGlzdCcgfHwgbmV4dE5vZGUuc291cmNlcG9zWzBdWzFdID49IDIpKSkge1xuICAgICAgICAgICAgdmFyIG5ld0VuZExpbmUgPSB0aGlzLmV4dGVuZEVuZExpbmUobmV4dE5vZGUuc291cmNlcG9zWzFdWzBdKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLnBhcnRpYWxQYXJzZUV4dGVuZHModGhpcy5saW5lVGV4dHMuc2xpY2UoZW5kTGluZSwgbmV3RW5kTGluZSkpO1xuICAgICAgICAgICAgaWYgKCFzdGFydE5vZGUpIHtcbiAgICAgICAgICAgICAgICBzdGFydE5vZGUgPSBlbmROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kTm9kZSA9IG5leHROb2RlO1xuICAgICAgICAgICAgZW5kTGluZSA9IG5ld0VuZExpbmU7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHROb2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZXIucGFydGlhbFBhcnNlRmluaXNoKCk7XG4gICAgICAgIHZhciBuZXdOb2RlcyA9IGdldENoaWxkTm9kZXMocm9vdCk7XG4gICAgICAgIHJldHVybiB7IG5ld05vZGVzOiBuZXdOb2RlcywgZXh0U3RhcnROb2RlOiBzdGFydE5vZGUsIGV4dEVuZE5vZGU6IGVuZE5vZGUgfTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZ2V0UmVtb3ZlZE5vZGVSYW5nZSA9IGZ1bmN0aW9uIChleHRTdGFydE5vZGUsIGV4dEVuZE5vZGUpIHtcbiAgICAgICAgaWYgKCFleHRTdGFydE5vZGUgfHxcbiAgICAgICAgICAgIChleHRTdGFydE5vZGUgJiYgaXNSZWZEZWYoZXh0U3RhcnROb2RlKSkgfHxcbiAgICAgICAgICAgIChleHRFbmROb2RlICYmIGlzUmVmRGVmKGV4dEVuZE5vZGUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBbZXh0U3RhcnROb2RlLmlkLCBleHRFbmROb2RlLmlkXSxcbiAgICAgICAgICAgIGxpbmU6IFtleHRTdGFydE5vZGUuc291cmNlcG9zWzBdWzBdIC0gMSwgZXh0RW5kTm9kZS5zb3VyY2Vwb3NbMV1bMF0gLSAxXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUubWFya0RlbGV0ZWRSZWZNYXAgPSBmdW5jdGlvbiAoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghaXNFbXB0eU9iaih0aGlzLnJlZk1hcCkpIHtcbiAgICAgICAgICAgIHZhciBtYXJrRGVsZXRlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVmRGVmKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWZEZWZTdGF0ZSA9IF90aGlzLnJlZk1hcFtub2RlLmxhYmVsXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZkRlZlN0YXRlICYmIG5vZGUuaWQgPT09IHJlZkRlZlN0YXRlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZEZWZTdGF0ZS51bmxpbmtlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGV4dFN0YXJ0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGludm9rZU5leHRVbnRpbChtYXJrRGVsZXRlZCwgZXh0U3RhcnROb2RlLnBhcmVudCwgZXh0RW5kTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0RW5kTm9kZSkge1xuICAgICAgICAgICAgICAgIGludm9rZU5leHRVbnRpbChtYXJrRGVsZXRlZCwgZXh0RW5kTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucmVwbGFjZVdpdGhOZXdSZWZEZWZTdGF0ZSA9IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmoodGhpcy5yZWZNYXApKSB7XG4gICAgICAgICAgICB2YXIgcmVwbGFjZVdpdGhfMSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVmRGVmKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IG5vZGUubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWZEZWZTdGF0ZSA9IF90aGlzLnJlZk1hcFtsYWJlbF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVmRGVmU3RhdGUgfHwgcmVmRGVmU3RhdGUudW5saW5rZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZk1hcFtsYWJlbF0gPSBjcmVhdGVSZWZEZWZTdGF0ZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlTmV4dFVudGlsKHJlcGxhY2VXaXRoXzEsIG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucmVwbGFjZVdpdGhSZWZEZWZDYW5kaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghaXNFbXB0eU9iaih0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVPYmplY3QodGhpcy5yZWZEZWZDYW5kaWRhdGVNYXAsIGZ1bmN0aW9uIChfLCBjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBjYW5kaWRhdGUubGFiZWwsIHNvdXJjZXBvcyA9IGNhbmRpZGF0ZS5zb3VyY2Vwb3M7XG4gICAgICAgICAgICAgICAgdmFyIHJlZkRlZlN0YXRlID0gX3RoaXMucmVmTWFwW2xhYmVsXTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZkRlZlN0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlZkRlZlN0YXRlLnVubGlua2VkIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlZkRlZlN0YXRlLnNvdXJjZXBvc1swXVswXSA+IHNvdXJjZXBvc1swXVswXSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWZNYXBbbGFiZWxdID0gY3JlYXRlUmVmRGVmU3RhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5nZXRSYW5nZVdpdGhSZWZEZWYgPSBmdW5jdGlvbiAoc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydE5vZGUsIGVuZE5vZGUsIGxpbmVEaWZmKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZURlZmluaXRpb24gJiYgIWlzRW1wdHlPYmoodGhpcy5yZWZNYXApKSB7XG4gICAgICAgICAgICB2YXIgcHJldk5vZGUgPSBmaW5kQ2hpbGROb2RlQXRMaW5lKHRoaXMucm9vdCwgc3RhcnRMaW5lIC0gMSk7XG4gICAgICAgICAgICB2YXIgbmV4dE5vZGUgPSBmaW5kQ2hpbGROb2RlQXRMaW5lKHRoaXMucm9vdCwgZW5kTGluZSArIDEpO1xuICAgICAgICAgICAgaWYgKHByZXZOb2RlICYmIGlzUmVmRGVmKHByZXZOb2RlKSAmJiBwcmV2Tm9kZSAhPT0gc3RhcnROb2RlICYmIHByZXZOb2RlICE9PSBlbmROb2RlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnROb2RlID0gcHJldk5vZGU7XG4gICAgICAgICAgICAgICAgc3RhcnRMaW5lID0gc3RhcnROb2RlLnNvdXJjZXBvc1swXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZSAmJiBpc1JlZkRlZihuZXh0Tm9kZSkgJiYgbmV4dE5vZGUgIT09IHN0YXJ0Tm9kZSAmJiBuZXh0Tm9kZSAhPT0gZW5kTm9kZSkge1xuICAgICAgICAgICAgICAgIGVuZE5vZGUgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICBlbmRMaW5lID0gdGhpcy5leHRlbmRFbmRMaW5lKGVuZE5vZGUuc291cmNlcG9zWzFdWzBdICsgbGluZURpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3RhcnROb2RlLCBlbmROb2RlLCBzdGFydExpbmUsIGVuZExpbmVdO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzdGFydFBvcywgZW5kUG9zLCBsaW5lRGlmZikge1xuICAgICAgICBpZiAobGluZURpZmYgPT09IHZvaWQgMCkgeyBsaW5lRGlmZiA9IDA7IH1cbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXROb2RlUmFuZ2Uoc3RhcnRQb3MsIGVuZFBvcyk7XG4gICAgICAgIHZhciBzdGFydE5vZGUgPSByYW5nZVswXSwgZW5kTm9kZSA9IHJhbmdlWzFdO1xuICAgICAgICB2YXIgc3RhcnRMaW5lID0gc3RhcnROb2RlID8gTWF0aC5taW4oc3RhcnROb2RlLnNvdXJjZXBvc1swXVswXSwgc3RhcnRQb3NbMF0pIDogc3RhcnRQb3NbMF07XG4gICAgICAgIHZhciBlbmRMaW5lID0gdGhpcy5leHRlbmRFbmRMaW5lKChlbmROb2RlID8gTWF0aC5tYXgoZW5kTm9kZS5zb3VyY2Vwb3NbMV1bMF0sIGVuZFBvc1swXSkgOiBlbmRQb3NbMF0pICsgbGluZURpZmYpO1xuICAgICAgICB2YXIgcGFyc2VSZXN1bHQgPSB0aGlzLnBhcnNlUmFuZ2UuYXBwbHkodGhpcywgdGhpcy5nZXRSYW5nZVdpdGhSZWZEZWYoc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydE5vZGUsIGVuZE5vZGUsIGxpbmVEaWZmKSk7XG4gICAgICAgIHZhciBuZXdOb2RlcyA9IHBhcnNlUmVzdWx0Lm5ld05vZGVzLCBleHRTdGFydE5vZGUgPSBwYXJzZVJlc3VsdC5leHRTdGFydE5vZGUsIGV4dEVuZE5vZGUgPSBwYXJzZVJlc3VsdC5leHRFbmROb2RlO1xuICAgICAgICB2YXIgcmVtb3ZlZE5vZGVSYW5nZSA9IHRoaXMuZ2V0UmVtb3ZlZE5vZGVSYW5nZShleHRTdGFydE5vZGUsIGV4dEVuZE5vZGUpO1xuICAgICAgICB2YXIgbmV4dE5vZGUgPSBleHRFbmROb2RlID8gZXh0RW5kTm9kZS5uZXh0IDogdGhpcy5yb290LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZURlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWFya0RlbGV0ZWRSZWZNYXAoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlKTtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVJhbmdlTm9kZXMoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlLCBuZXdOb2Rlcyk7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VXaXRoTmV3UmVmRGVmU3RhdGUobmV3Tm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUmFuZ2VOb2RlcyhleHRTdGFydE5vZGUsIGV4dEVuZE5vZGUsIG5ld05vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBub2RlczogbmV3Tm9kZXMsIHJlbW92ZWROb2RlUmFuZ2U6IHJlbW92ZWROb2RlUmFuZ2UsIG5leHROb2RlOiBuZXh0Tm9kZSB9O1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5wYXJzZVJlZkxpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKCFpc0VtcHR5T2JqKHRoaXMucmVmTWFwKSkge1xuICAgICAgICAgICAgaXRlcmF0ZU9iamVjdCh0aGlzLnJlZk1hcCwgZnVuY3Rpb24gKGxhYmVsLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS51bmxpbmtlZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMucmVmTWFwW2xhYmVsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlcmF0ZU9iamVjdChfdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwLCBmdW5jdGlvbiAoXywgY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gY2FuZGlkYXRlLm5vZGUsIHJlZkxhYmVsID0gY2FuZGlkYXRlLnJlZkxhYmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmTGFiZWwgPT09IGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChfdGhpcy5wYXJzZShub2RlLnNvdXJjZXBvc1swXSwgbm9kZS5zb3VyY2Vwb3NbMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucmVtb3ZlVW5saW5rZWRDYW5kaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNFbXB0eU9iaih0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCkpIHtcbiAgICAgICAgICAgIFt0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAsIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwXS5mb3JFYWNoKGZ1bmN0aW9uIChjYW5kaWRhdGVNYXApIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRlT2JqZWN0KGNhbmRpZGF0ZU1hcCwgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1VubGlua2VkKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhbmRpZGF0ZU1hcFtpZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmVkaXRNYXJrZG93biA9IGZ1bmN0aW9uIChzdGFydFBvcywgZW5kUG9zLCBuZXdUZXh0KSB7XG4gICAgICAgIHZhciBsaW5lRGlmZiA9IHRoaXMudXBkYXRlTGluZVRleHRzKHN0YXJ0UG9zLCBlbmRQb3MsIG5ld1RleHQpO1xuICAgICAgICB2YXIgcGFyc2VSZXN1bHQgPSB0aGlzLnBhcnNlKHN0YXJ0UG9zLCBlbmRQb3MsIGxpbmVEaWZmKTtcbiAgICAgICAgdmFyIGVkaXRSZXN1bHQgPSBvbWl0KHBhcnNlUmVzdWx0LCAnbmV4dE5vZGUnKTtcbiAgICAgICAgdXBkYXRlTmV4dExpbmVOdW1iZXJzKHBhcnNlUmVzdWx0Lm5leHROb2RlLCBsaW5lRGlmZik7XG4gICAgICAgIHRoaXMudXBkYXRlUm9vdE5vZGVTdGF0ZSgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW2VkaXRSZXN1bHRdO1xuICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVVubGlua2VkQ2FuZGlkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VXaXRoUmVmRGVmQ2FuZGlkYXRlKCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMucGFyc2VSZWZMaW5rKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJywgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZ2V0TGluZVRleHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lVGV4dHM7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmdldFJvb3ROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290O1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5maW5kTm9kZUF0UG9zaXRpb24gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHZhciBub2RlID0gZmluZE5vZGVBdFBvc2l0aW9uKHRoaXMucm9vdCwgcG9zKTtcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUgPT09IHRoaXMucm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmZpbmRGaXJzdE5vZGVBdExpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICByZXR1cm4gZmluZEZpcnN0Tm9kZUF0TGluZSh0aGlzLnJvb3QsIGxpbmUpO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyTWFwW2V2ZW50TmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuZXZlbnRIYW5kbGVyTWFwW2V2ZW50TmFtZV07XG4gICAgICAgIHZhciBpZHggPSBoYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmZpbmROb2RlQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gZmluZE5vZGVCeUlkKGlkKTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucmVtb3ZlQWxsTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlQWxsTm9kZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRvYXN0TWFyaztcbn0oKSk7XG5cbnZhciBkaXNhbGxvd2VkVGFncyA9IFtcbiAgICAndGl0bGUnLFxuICAgICd0ZXh0YXJlYScsXG4gICAgJ3N0eWxlJyxcbiAgICAneG1wJyxcbiAgICAnaWZyYW1lJyxcbiAgICAnbm9lbWJlZCcsXG4gICAgJ25vZnJhbWVzJyxcbiAgICAnc2NyaXB0JyxcbiAgICAncGxhaW50ZXh0Jyxcbl07XG52YXIgcmVEaXNhbGxvd2VkVGFnID0gbmV3IFJlZ0V4cChcIjwoLz8oPzpcIiArIGRpc2FsbG93ZWRUYWdzLmpvaW4oJ3wnKSArIFwiKVtePl0qPilcIiwgJ2lnJyk7XG5mdW5jdGlvbiBmaWx0ZXJEaXNhbGxvd2VkVGFncyhzdHIpIHtcbiAgICBpZiAocmVEaXNhbGxvd2VkVGFnLnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVEaXNhbGxvd2VkVGFnLCBmdW5jdGlvbiAoXywgZ3JvdXApIHsgcmV0dXJuIFwiJmx0O1wiICsgZ3JvdXA7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuXG52YXIgYmFzZUNvbnZlcnRvcnMkMSA9IHtcbiAgICBoZWFkaW5nOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiBcImhcIiArIG5vZGUubGV2ZWwsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0ZXh0OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgY29udGVudDogbm9kZS5saXRlcmFsLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgc29mdGJyZWFrOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgY29udGVudDogb3B0aW9ucy5zb2Z0YnJlYWssXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBsaW5lYnJlYWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICc8YnIgLz5cXG4nLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZW1waDogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2VtJyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHN0cm9uZzogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3N0cm9uZycsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwYXJhZ3JhcGg6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICB2YXIgZ3JhbmRwYXJlbnQgPSAoX2IgPSBub2RlLnBhcmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcmVudDtcbiAgICAgICAgaWYgKGdyYW5kcGFyZW50ICYmIGdyYW5kcGFyZW50LnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgaWYgKGdyYW5kcGFyZW50Lmxpc3REYXRhLnRpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdwJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRoZW1hdGljQnJlYWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdocicsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICBzZWxmQ2xvc2U6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBibG9ja1F1b3RlOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnYmxvY2txdW90ZScsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICBpbm5lck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBsaXN0OiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHZhciBfYiA9IG5vZGUubGlzdERhdGEsIHR5cGUgPSBfYi50eXBlLCBzdGFydCA9IF9iLnN0YXJ0O1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHR5cGUgPT09ICdidWxsZXQnID8gJ3VsJyA6ICdvbCc7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnb2wnICYmIHN0YXJ0ICE9PSBudWxsICYmIHN0YXJ0ICE9PSAxKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnN0YXJ0ID0gc3RhcnQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBpdGVtOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnbGknLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgaHRtbElubGluZTogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBvcHRpb25zLnRhZ0ZpbHRlciA/IGZpbHRlckRpc2FsbG93ZWRUYWdzKG5vZGUubGl0ZXJhbCkgOiBub2RlLmxpdGVyYWw7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdodG1sJywgY29udGVudDogY29udGVudCB9O1xuICAgIH0sXG4gICAgaHRtbEJsb2NrOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICB2YXIgY29udGVudCA9IG9wdGlvbnMudGFnRmlsdGVyID8gZmlsdGVyRGlzYWxsb3dlZFRhZ3Mobm9kZS5saXRlcmFsKSA6IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgaWYgKG9wdGlvbnMubm9kZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnZGl2Jywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnaHRtbCcsIGNvbnRlbnQ6IGNvbnRlbnQgfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdkaXYnLCBvdXRlck5ld0xpbmU6IHRydWUgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2h0bWwnLCBjb250ZW50OiBjb250ZW50LCBvdXRlck5ld0xpbmU6IHRydWUgfTtcbiAgICB9LFxuICAgIGNvZGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2NvZGUnIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogbm9kZS5saXRlcmFsIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdjb2RlJyB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgY29kZUJsb2NrOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgaW5mb1N0ciA9IG5vZGUuaW5mbztcbiAgICAgICAgdmFyIGluZm9Xb3JkcyA9IGluZm9TdHIgPyBpbmZvU3RyLnNwbGl0KC9cXHMrLykgOiBbXTtcbiAgICAgICAgdmFyIGNvZGVDbGFzc05hbWVzID0gW107XG4gICAgICAgIGlmIChpbmZvV29yZHMubGVuZ3RoID4gMCAmJiBpbmZvV29yZHNbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29kZUNsYXNzTmFtZXMucHVzaChcImxhbmd1YWdlLVwiICsgZXNjYXBlWG1sKGluZm9Xb3Jkc1swXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ3ByZScsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdjb2RlJywgY2xhc3NOYW1lczogY29kZUNsYXNzTmFtZXMgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmxpdGVyYWwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2NvZGUnIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdwcmUnLCBvdXRlck5ld0xpbmU6IHRydWUgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBub2RlLCB0aXRsZSA9IF9iLnRpdGxlLCBkZXN0aW5hdGlvbiA9IF9iLmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2EnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IF9fYXNzaWduKHsgaHJlZjogZXNjYXBlWG1sKGRlc3RpbmF0aW9uKSB9LCAodGl0bGUgJiYgeyB0aXRsZTogZXNjYXBlWG1sKHRpdGxlKSB9KSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdhJyB9O1xuICAgIH0sXG4gICAgaW1hZ2U6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZ2V0Q2hpbGRyZW5UZXh0ID0gX2EuZ2V0Q2hpbGRyZW5UZXh0LCBza2lwQ2hpbGRyZW4gPSBfYS5za2lwQ2hpbGRyZW47XG4gICAgICAgIHZhciBfYiA9IG5vZGUsIHRpdGxlID0gX2IudGl0bGUsIGRlc3RpbmF0aW9uID0gX2IuZGVzdGluYXRpb247XG4gICAgICAgIHNraXBDaGlsZHJlbigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2ltZycsXG4gICAgICAgICAgICBzZWxmQ2xvc2U6IHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBfX2Fzc2lnbih7IHNyYzogZXNjYXBlWG1sKGRlc3RpbmF0aW9uKSwgYWx0OiBnZXRDaGlsZHJlblRleHQobm9kZSkgfSwgKHRpdGxlICYmIHsgdGl0bGU6IGVzY2FwZVhtbCh0aXRsZSkgfSkpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY3VzdG9tQmxvY2s6IGZ1bmN0aW9uIChub2RlLCBjb250ZXh0LCBjb252ZXJ0b3JzKSB7XG4gICAgICAgIHZhciBpbmZvID0gbm9kZS5pbmZvLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgY3VzdG9tQ29udmVydG9yID0gY29udmVydG9yc1tpbmZvXTtcbiAgICAgICAgaWYgKGN1c3RvbUNvbnZlcnRvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tQ29udmVydG9yKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbQHRvYXN0LXVpL2VkaXRvcl0gLSBUaGUgZXJyb3Igb2NjdXJyZWQgd2hlbiBcIiArIGluZm8gKyBcIiBibG9jayBub2RlIHdhcyBwYXJzZWQgaW4gbWFya2Rvd24gcmVuZGVyZXI6IFwiICsgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnZGl2Jywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogbm9kZS5saXRlcmFsIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdkaXYnLCBvdXRlck5ld0xpbmU6IHRydWUgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGZyb250TWF0dGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAnZGl2JyxcbiAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBmcm9udCBtYXR0ZXIgaXMgbWV0YWRhdGEsIGl0IHNob3VsZCBub3QgYmUgcmVuZGVyLlxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHsgc3R5bGU6ICd3aGl0ZS1zcGFjZTogcHJlOyBkaXNwbGF5OiBub25lOycgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogbm9kZS5saXRlcmFsIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdkaXYnLCBvdXRlck5ld0xpbmU6IHRydWUgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGN1c3RvbUlubGluZTogZnVuY3Rpb24gKG5vZGUsIGNvbnRleHQsIGNvbnZlcnRvcnMpIHtcbiAgICAgICAgdmFyIF9hID0gbm9kZSwgaW5mbyA9IF9hLmluZm8sIGZpcnN0Q2hpbGQgPSBfYS5maXJzdENoaWxkO1xuICAgICAgICB2YXIgbm9tYWxpemVkSW5mbyA9IGluZm8udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBjdXN0b21Db252ZXJ0b3IgPSBjb252ZXJ0b3JzW25vbWFsaXplZEluZm9dO1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBjb250ZXh0LmVudGVyaW5nO1xuICAgICAgICBpZiAoY3VzdG9tQ29udmVydG9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21Db252ZXJ0b3Iobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltAdG9hc3QtdWkvZWRpdG9yXSAtIFRoZSBlcnJvciBvY2N1cnJlZCB3aGVuIFwiICsgbm9tYWxpemVkSW5mbyArIFwiIGlubGluZSBub2RlIHdhcyBwYXJzZWQgaW4gbWFya2Rvd24gcmVuZGVyZXI6IFwiICsgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudGVyaW5nXG4gICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ3NwYW4nIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IFwiJCRcIiArIGluZm8gKyAoZmlyc3RDaGlsZCA/ICcgJyA6ICcnKSB9LFxuICAgICAgICAgICAgXVxuICAgICAgICAgICAgOiBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6ICckJCcgfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdzcGFuJyB9LFxuICAgICAgICAgICAgXTtcbiAgICB9LFxufTtcblxudmFyIGdmbUNvbnZlcnRvcnMgPSB7XG4gICAgc3RyaWtlOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnZGVsJyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGl0ZW06IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgdmFyIF9iID0gbm9kZS5saXN0RGF0YSwgY2hlY2tlZCA9IF9iLmNoZWNrZWQsIHRhc2sgPSBfYi50YXNrO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBpdGVtVGFnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAnbGknLFxuICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1UYWcsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmQ2xvc2U6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKGNoZWNrZWQgJiYgeyBjaGVja2VkOiAnJyB9KSksIHsgZGlzYWJsZWQ6ICcnLCB0eXBlOiAnY2hlY2tib3gnIH0pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnICcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtVGFnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2xpJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAndGFibGUnLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGFibGVIZWFkOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAndGhlYWQnLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGFibGVCb2R5OiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAndGJvZHknLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGFibGVSb3c6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAndHInLFxuICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW5MZW4gPSBub2RlLnBhcmVudC5wYXJlbnQuY29sdW1ucy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbGFzdENvbElkeCA9IG5vZGUubGFzdENoaWxkLmVuZElkeDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsYXN0Q29sSWR4ICsgMTsgaSA8IGNvbHVtbkxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6ICd0ZCcsXG4gICAgICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6ICd0ZCcsXG4gICAgICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3RyJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICB0YWJsZUNlbGw6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKG5vZGUuaWdub3JlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YWJsZVBhcnQgPSBub2RlLnBhcmVudC5wYXJlbnQ7XG4gICAgICAgIHZhciB0YWdOYW1lID0gdGFibGVQYXJ0LnR5cGUgPT09ICd0YWJsZUhlYWQnID8gJ3RoJyA6ICd0ZCc7XG4gICAgICAgIHZhciB0YWJsZSA9IHRhYmxlUGFydC5wYXJlbnQ7XG4gICAgICAgIHZhciBjb2x1bW5JbmZvID0gdGFibGUuY29sdW1uc1tub2RlLnN0YXJ0SWR4XTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSAoY29sdW1uSW5mbyA9PT0gbnVsbCB8fCBjb2x1bW5JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2x1bW5JbmZvLmFsaWduKSA/IHsgYWxpZ246IGNvbHVtbkluZm8uYWxpZ24gfSA6IG51bGw7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiB0YWdOYW1lLCBvdXRlck5ld0xpbmU6IHRydWUgfSwgKGF0dHJpYnV0ZXMgJiYgeyBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBzb2Z0YnJlYWs6ICdcXG4nLFxuICAgIGdmbTogZmFsc2UsXG4gICAgdGFnRmlsdGVyOiBmYWxzZSxcbiAgICBub2RlSWQ6IGZhbHNlLFxufTtcbmZ1bmN0aW9uIGdldENoaWxkcmVuVGV4dChub2RlKSB7XG4gICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgIHZhciB3YWxrZXIgPSBub2RlLndhbGtlcigpO1xuICAgIHZhciBldmVudCA9IG51bGw7XG4gICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgIHZhciBub2RlXzEgPSBldmVudC5ub2RlO1xuICAgICAgICBpZiAobm9kZV8xLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgYnVmZmVyLnB1c2gobm9kZV8xLmxpdGVyYWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbignJyk7XG59XG52YXIgUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVuZGVyZXIoY3VzdG9tT3B0aW9ucykge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMpLCBjdXN0b21PcHRpb25zKTtcbiAgICAgICAgdGhpcy5jb252ZXJ0b3JzID0gdGhpcy5jcmVhdGVDb252ZXJ0b3JzKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuY29udmVydG9ycztcbiAgICB9XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNvbnZlcnRvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb252ZXJ0b3JzID0gX19hc3NpZ24oe30sIGJhc2VDb252ZXJ0b3JzJDEpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgICAgY29udmVydG9ycyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb252ZXJ0b3JzKSwgZ2ZtQ29udmVydG9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb252ZXJ0b3JzKSB7XG4gICAgICAgICAgICB2YXIgY3VzdG9tQ29udmVydG9yc18xID0gdGhpcy5vcHRpb25zLmNvbnZlcnRvcnM7XG4gICAgICAgICAgICB2YXIgbm9kZVR5cGVzID0gT2JqZWN0LmtleXMoY3VzdG9tQ29udmVydG9yc18xKTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Q29udmVydG9yc18xID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGJhc2VDb252ZXJ0b3JzJDEpLCBnZm1Db252ZXJ0b3JzKTtcbiAgICAgICAgICAgIG5vZGVUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBvcmdDb252ZXJ0b3IgPSBjb252ZXJ0b3JzW25vZGVUeXBlXTtcbiAgICAgICAgICAgICAgICB2YXIgY29udmVydG9yID0gY3VzdG9tQ29udmVydG9yc18xW25vZGVUeXBlXTtcbiAgICAgICAgICAgICAgICB2YXIgY29udmVydG9yVHlwZSA9IE9iamVjdC5rZXlzKGRlZmF1bHRDb252ZXJ0b3JzXzEpLmluZGV4T2Yobm9kZVR5cGUpID09PSAtMVxuICAgICAgICAgICAgICAgICAgICA/IG5vZGVUeXBlLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgOiBub2RlVHlwZTtcbiAgICAgICAgICAgICAgICBpZiAob3JnQ29udmVydG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRvcnNbY29udmVydG9yVHlwZV0gPSBmdW5jdGlvbiAobm9kZSwgY29udGV4dCwgY29udmVydG9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vcmlnaW4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmdDb252ZXJ0b3Iobm9kZSwgY29udGV4dCwgY29udmVydG9ycyk7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydG9yKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udmVydG9yc1tjb252ZXJ0b3JUeXBlXSA9IGNvbnZlcnRvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydG9ycztcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5nZXRDb252ZXJ0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0b3JzO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmdldE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHJvb3ROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHZhciB3YWxrZXIgPSByb290Tm9kZS53YWxrZXIoKTtcbiAgICAgICAgdmFyIGV2ZW50ID0gbnVsbDtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGV2ZW50Lm5vZGUsIGVudGVyaW5nID0gZXZlbnQuZW50ZXJpbmc7XG4gICAgICAgICAgICB2YXIgY29udmVydG9yID0gdGhpc18xLmNvbnZlcnRvcnNbbm9kZS50eXBlXTtcbiAgICAgICAgICAgIGlmICghY29udmVydG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBza2lwcGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICBlbnRlcmluZzogZW50ZXJpbmcsXG4gICAgICAgICAgICAgICAgbGVhZjogIWlzQ29udGFpbmVyJDEobm9kZSksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogdGhpc18xLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgZ2V0Q2hpbGRyZW5UZXh0OiBnZXRDaGlsZHJlblRleHQsXG4gICAgICAgICAgICAgICAgc2tpcENoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGNvbnZlcnRlZCA9IGlzQ3VzdG9tQmxvY2sobm9kZSkgfHwgaXNDdXN0b21JbmxpbmUobm9kZSlcbiAgICAgICAgICAgICAgICA/IGNvbnZlcnRvcihub2RlLCBjb250ZXh0LCB0aGlzXzEuY29udmVydG9ycylcbiAgICAgICAgICAgICAgICA6IGNvbnZlcnRvcihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChjb252ZXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaHRtbE5vZGVzID0gQXJyYXkuaXNBcnJheShjb252ZXJ0ZWQpID8gY29udmVydGVkIDogW2NvbnZlcnRlZF07XG4gICAgICAgICAgICAgICAgaHRtbE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGh0bWxOb2RlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHRtbE5vZGUudHlwZSA9PT0gJ29wZW5UYWcnICYmIF90aGlzLm9wdGlvbnMubm9kZUlkICYmIGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWh0bWxOb2RlLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sTm9kZS5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sTm9kZS5hdHRyaWJ1dGVzWydkYXRhLW5vZGVpZCddID0gU3RyaW5nKG5vZGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckhUTUxOb2RlKGh0bWxOb2RlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICB3YWxrZXIucmVzdW1lQXQobm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICAgICAgX2xvb3BfMSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkTmV3TGluZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuam9pbignJyk7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVySFRNTE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnb3BlblRhZyc6XG4gICAgICAgICAgICBjYXNlICdjbG9zZVRhZyc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFbGVtZW50Tm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGV4dE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclJhd0h0bWxOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gbm8tZGVmYXVsdC1jYXNlXG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5nZW5lcmF0ZU9wZW5UYWdTdHJpbmcgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdGFnTmFtZSA9IG5vZGUudGFnTmFtZSwgY2xhc3NOYW1lcyA9IG5vZGUuY2xhc3NOYW1lcywgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChcIjxcIiArIHRhZ05hbWUpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lcyAmJiBjbGFzc05hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCIgY2xhc3M9XFxcIlwiICsgY2xhc3NOYW1lcy5qb2luKCcgJykgKyBcIlxcXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IGF0dHJpYnV0ZXNbYXR0ck5hbWVdO1xuICAgICAgICAgICAgICAgIF90aGlzLmJ1ZmZlci5wdXNoKFwiIFwiICsgYXR0ck5hbWUgKyBcIj1cXFwiXCIgKyBhdHRyVmFsdWUgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5zZWxmQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goJyAvJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIucHVzaCgnPicpO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmdlbmVyYXRlQ2xvc2VUYWdTdHJpbmcgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBfYS50YWdOYW1lO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiPC9cIiArIHRhZ05hbWUgKyBcIj5cIik7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuYWRkTmV3TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCAmJiBsYXN0KGxhc3QodGhpcy5idWZmZXIpKSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goJ1xcbicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuYWRkT3V0ZXJOZXdMaW5lID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUub3V0ZXJOZXdMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE5ld0xpbmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmFkZElubmVyTmV3TGluZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmlubmVyTmV3TGluZSkge1xuICAgICAgICAgICAgdGhpcy5hZGROZXdMaW5lKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUZXh0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goZXNjYXBlWG1sKG5vZGUuY29udGVudCkpO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclJhd0h0bWxOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5hZGRPdXRlck5ld0xpbmUobm9kZSk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2gobm9kZS5jb250ZW50KTtcbiAgICAgICAgdGhpcy5hZGRPdXRlck5ld0xpbmUobm9kZSk7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRWxlbWVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnb3BlblRhZycpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0ZXJOZXdMaW5lKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZU9wZW5UYWdTdHJpbmcobm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5zZWxmQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE91dGVyTmV3TGluZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5uZXJOZXdMaW5lKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRJbm5lck5ld0xpbmUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlQ2xvc2VUYWdTdHJpbmcobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmFkZE91dGVyTmV3TGluZShub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlbmRlcmVyO1xufSgpKTtcblxuLyohIEBsaWNlbnNlIERPTVB1cmlmeSAyLjMuMyB8IChjKSBDdXJlNTMgYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyB8IFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgbGljZW5zZSAyLjAgYW5kIE1vemlsbGEgUHVibGljIExpY2Vuc2UgMi4wIHwgZ2l0aHViLmNvbS9jdXJlNTMvRE9NUHVyaWZ5L2Jsb2IvMi4zLjMvTElDRU5TRSAqL1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0Lmhhc093blByb3BlcnR5LFxuICAgIHNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mLFxuICAgIGlzRnJvemVuID0gT2JqZWN0LmlzRnJvemVuLFxuICAgIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZnJlZXplID0gT2JqZWN0LmZyZWV6ZSxcbiAgICBzZWFsID0gT2JqZWN0LnNlYWwsXG4gICAgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbXBvcnQvbm8tbXV0YWJsZS1leHBvcnRzXG5cbnZhciBfcmVmID0gdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3QsXG4gICAgYXBwbHkgPSBfcmVmLmFwcGx5LFxuICAgIGNvbnN0cnVjdCA9IF9yZWYuY29uc3RydWN0O1xuXG5pZiAoIWFwcGx5KSB7XG4gIGFwcGx5ID0gZnVuY3Rpb24gYXBwbHkoZnVuLCB0aGlzVmFsdWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gZnVuLmFwcGx5KHRoaXNWYWx1ZSwgYXJncyk7XG4gIH07XG59XG5cbmlmICghZnJlZXplKSB7XG4gIGZyZWV6ZSA9IGZ1bmN0aW9uIGZyZWV6ZSh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbmlmICghc2VhbCkge1xuICBzZWFsID0gZnVuY3Rpb24gc2VhbCh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbmlmICghY29uc3RydWN0KSB7XG4gIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIGNvbnN0cnVjdChGdW5jLCBhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoRnVuYywgW251bGxdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYXJncykpKSkoKTtcbiAgfTtcbn1cblxudmFyIGFycmF5Rm9yRWFjaCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLmZvckVhY2gpO1xudmFyIGFycmF5UG9wID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUucG9wKTtcbnZhciBhcnJheVB1c2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wdXNoKTtcblxudmFyIHN0cmluZ1RvTG93ZXJDYXNlID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlKTtcbnZhciBzdHJpbmdNYXRjaCA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5tYXRjaCk7XG52YXIgc3RyaW5nUmVwbGFjZSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciBzdHJpbmdJbmRleE9mID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLmluZGV4T2YpO1xudmFyIHN0cmluZ1RyaW0gPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudHJpbSk7XG5cbnZhciByZWdFeHBUZXN0ID0gdW5hcHBseShSZWdFeHAucHJvdG90eXBlLnRlc3QpO1xuXG52YXIgdHlwZUVycm9yQ3JlYXRlID0gdW5jb25zdHJ1Y3QoVHlwZUVycm9yKTtcblxuZnVuY3Rpb24gdW5hcHBseShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhpc0FyZykge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1bmNvbnN0cnVjdChmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uc3RydWN0KGZ1bmMsIGFyZ3MpO1xuICB9O1xufVxuXG4vKiBBZGQgcHJvcGVydGllcyB0byBhIGxvb2t1cCB0YWJsZSAqL1xuZnVuY3Rpb24gYWRkVG9TZXQoc2V0LCBhcnJheSkge1xuICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAvLyBNYWtlICdpbicgYW5kIHRydXRoeSBjaGVja3MgbGlrZSBCb29sZWFuKHNldC5jb25zdHJ1Y3RvcilcbiAgICAvLyBpbmRlcGVuZGVudCBvZiBhbnkgcHJvcGVydGllcyBkZWZpbmVkIG9uIE9iamVjdC5wcm90b3R5cGUuXG4gICAgLy8gUHJldmVudCBwcm90b3R5cGUgc2V0dGVycyBmcm9tIGludGVyY2VwdGluZyBzZXQgYXMgYSB0aGlzIHZhbHVlLlxuICAgIHNldFByb3RvdHlwZU9mKHNldCwgbnVsbCk7XG4gIH1cblxuICB2YXIgbCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGwtLSkge1xuICAgIHZhciBlbGVtZW50ID0gYXJyYXlbbF07XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGxjRWxlbWVudCA9IHN0cmluZ1RvTG93ZXJDYXNlKGVsZW1lbnQpO1xuICAgICAgaWYgKGxjRWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgICAgICAvLyBDb25maWcgcHJlc2V0cyAoZS5nLiB0YWdzLmpzLCBhdHRycy5qcykgYXJlIGltbXV0YWJsZS5cbiAgICAgICAgaWYgKCFpc0Zyb3plbihhcnJheSkpIHtcbiAgICAgICAgICBhcnJheVtsXSA9IGxjRWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQgPSBsY0VsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0W2VsZW1lbnRdID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBzZXQ7XG59XG5cbi8qIFNoYWxsb3cgY2xvbmUgYW4gb2JqZWN0ICovXG5mdW5jdGlvbiBjbG9uZShvYmplY3QpIHtcbiAgdmFyIG5ld09iamVjdCA9IGNyZWF0ZShudWxsKTtcblxuICB2YXIgcHJvcGVydHkgPSB2b2lkIDA7XG4gIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKGFwcGx5KGhhc093blByb3BlcnR5LCBvYmplY3QsIFtwcm9wZXJ0eV0pKSB7XG4gICAgICBuZXdPYmplY3RbcHJvcGVydHldID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3T2JqZWN0O1xufVxuXG4vKiBJRTEwIGRvZXNuJ3Qgc3VwcG9ydCBfX2xvb2t1cEdldHRlcl9fIHNvIGxldHMnXG4gKiBzaW11bGF0ZSBpdC4gSXQgYWxzbyBhdXRvbWF0aWNhbGx5IGNoZWNrc1xuICogaWYgdGhlIHByb3AgaXMgZnVuY3Rpb24gb3IgZ2V0dGVyIGFuZCBiZWhhdmVzXG4gKiBhY2NvcmRpbmdseS4gKi9cbmZ1bmN0aW9uIGxvb2t1cEdldHRlcihvYmplY3QsIHByb3ApIHtcbiAgd2hpbGUgKG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcCk7XG4gICAgaWYgKGRlc2MpIHtcbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLmdldCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGVzYy52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmFsbGJhY2tWYWx1ZShlbGVtZW50KSB7XG4gICAgY29uc29sZS53YXJuKCdmYWxsYmFjayB2YWx1ZSBmb3InLCBlbGVtZW50KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBmYWxsYmFja1ZhbHVlO1xufVxuXG52YXIgaHRtbCQyID0gZnJlZXplKFsnYScsICdhYmJyJywgJ2Fjcm9ueW0nLCAnYWRkcmVzcycsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYXVkaW8nLCAnYicsICdiZGknLCAnYmRvJywgJ2JpZycsICdibGluaycsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhbnZhcycsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjaXRlJywgJ2NvZGUnLCAnY29sJywgJ2NvbGdyb3VwJywgJ2NvbnRlbnQnLCAnZGF0YScsICdkYXRhbGlzdCcsICdkZCcsICdkZWNvcmF0b3InLCAnZGVsJywgJ2RldGFpbHMnLCAnZGZuJywgJ2RpYWxvZycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VsZW1lbnQnLCAnZW0nLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9udCcsICdmb290ZXInLCAnZm9ybScsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpJywgJ2ltZycsICdpbnB1dCcsICdpbnMnLCAna2JkJywgJ2xhYmVsJywgJ2xlZ2VuZCcsICdsaScsICdtYWluJywgJ21hcCcsICdtYXJrJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRlcicsICduYXYnLCAnbm9icicsICdvbCcsICdvcHRncm91cCcsICdvcHRpb24nLCAnb3V0cHV0JywgJ3AnLCAncGljdHVyZScsICdwcmUnLCAncHJvZ3Jlc3MnLCAncScsICdycCcsICdydCcsICdydWJ5JywgJ3MnLCAnc2FtcCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzaGFkb3cnLCAnc21hbGwnLCAnc291cmNlJywgJ3NwYWNlcicsICdzcGFuJywgJ3N0cmlrZScsICdzdHJvbmcnLCAnc3R5bGUnLCAnc3ViJywgJ3N1bW1hcnknLCAnc3VwJywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpbWUnLCAndHInLCAndHJhY2snLCAndHQnLCAndScsICd1bCcsICd2YXInLCAndmlkZW8nLCAnd2JyJ10pO1xuXG4vLyBTVkdcbnZhciBzdmcgPSBmcmVlemUoWydzdmcnLCAnYScsICdhbHRnbHlwaCcsICdhbHRnbHlwaGRlZicsICdhbHRnbHlwaGl0ZW0nLCAnYW5pbWF0ZWNvbG9yJywgJ2FuaW1hdGVtb3Rpb24nLCAnYW5pbWF0ZXRyYW5zZm9ybScsICdjaXJjbGUnLCAnY2xpcHBhdGgnLCAnZGVmcycsICdkZXNjJywgJ2VsbGlwc2UnLCAnZmlsdGVyJywgJ2ZvbnQnLCAnZycsICdnbHlwaCcsICdnbHlwaHJlZicsICdoa2VybicsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhcmdyYWRpZW50JywgJ21hcmtlcicsICdtYXNrJywgJ21ldGFkYXRhJywgJ21wYXRoJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbGdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICdzdHlsZScsICdzd2l0Y2gnLCAnc3ltYm9sJywgJ3RleHQnLCAndGV4dHBhdGgnLCAndGl0bGUnLCAndHJlZicsICd0c3BhbicsICd2aWV3JywgJ3ZrZXJuJ10pO1xuXG52YXIgc3ZnRmlsdGVycyA9IGZyZWV6ZShbJ2ZlQmxlbmQnLCAnZmVDb2xvck1hdHJpeCcsICdmZUNvbXBvbmVudFRyYW5zZmVyJywgJ2ZlQ29tcG9zaXRlJywgJ2ZlQ29udm9sdmVNYXRyaXgnLCAnZmVEaWZmdXNlTGlnaHRpbmcnLCAnZmVEaXNwbGFjZW1lbnRNYXAnLCAnZmVEaXN0YW50TGlnaHQnLCAnZmVGbG9vZCcsICdmZUZ1bmNBJywgJ2ZlRnVuY0InLCAnZmVGdW5jRycsICdmZUZ1bmNSJywgJ2ZlR2F1c3NpYW5CbHVyJywgJ2ZlTWVyZ2UnLCAnZmVNZXJnZU5vZGUnLCAnZmVNb3JwaG9sb2d5JywgJ2ZlT2Zmc2V0JywgJ2ZlUG9pbnRMaWdodCcsICdmZVNwZWN1bGFyTGlnaHRpbmcnLCAnZmVTcG90TGlnaHQnLCAnZmVUaWxlJywgJ2ZlVHVyYnVsZW5jZSddKTtcblxuLy8gTGlzdCBvZiBTVkcgZWxlbWVudHMgdGhhdCBhcmUgZGlzYWxsb3dlZCBieSBkZWZhdWx0LlxuLy8gV2Ugc3RpbGwgbmVlZCB0byBrbm93IHRoZW0gc28gdGhhdCB3ZSBjYW4gZG8gbmFtZXNwYWNlXG4vLyBjaGVja3MgcHJvcGVybHkgaW4gY2FzZSBvbmUgd2FudHMgdG8gYWRkIHRoZW0gdG9cbi8vIGFsbG93LWxpc3QuXG52YXIgc3ZnRGlzYWxsb3dlZCA9IGZyZWV6ZShbJ2FuaW1hdGUnLCAnY29sb3ItcHJvZmlsZScsICdjdXJzb3InLCAnZGlzY2FyZCcsICdmZWRyb3BzaGFkb3cnLCAnZmVpbWFnZScsICdmb250LWZhY2UnLCAnZm9udC1mYWNlLWZvcm1hdCcsICdmb250LWZhY2UtbmFtZScsICdmb250LWZhY2Utc3JjJywgJ2ZvbnQtZmFjZS11cmknLCAnZm9yZWlnbm9iamVjdCcsICdoYXRjaCcsICdoYXRjaHBhdGgnLCAnbWVzaCcsICdtZXNoZ3JhZGllbnQnLCAnbWVzaHBhdGNoJywgJ21lc2hyb3cnLCAnbWlzc2luZy1nbHlwaCcsICdzY3JpcHQnLCAnc2V0JywgJ3NvbGlkY29sb3InLCAndW5rbm93bicsICd1c2UnXSk7XG5cbnZhciBtYXRoTWwgPSBmcmVlemUoWydtYXRoJywgJ21lbmNsb3NlJywgJ21lcnJvcicsICdtZmVuY2VkJywgJ21mcmFjJywgJ21nbHlwaCcsICdtaScsICdtbGFiZWxlZHRyJywgJ21tdWx0aXNjcmlwdHMnLCAnbW4nLCAnbW8nLCAnbW92ZXInLCAnbXBhZGRlZCcsICdtcGhhbnRvbScsICdtcm9vdCcsICdtcm93JywgJ21zJywgJ21zcGFjZScsICdtc3FydCcsICdtc3R5bGUnLCAnbXN1YicsICdtc3VwJywgJ21zdWJzdXAnLCAnbXRhYmxlJywgJ210ZCcsICdtdGV4dCcsICdtdHInLCAnbXVuZGVyJywgJ211bmRlcm92ZXInXSk7XG5cbi8vIFNpbWlsYXJseSB0byBTVkcsIHdlIHdhbnQgdG8ga25vdyBhbGwgTWF0aE1MIGVsZW1lbnRzLFxuLy8gZXZlbiB0aG9zZSB0aGF0IHdlIGRpc2FsbG93IGJ5IGRlZmF1bHQuXG52YXIgbWF0aE1sRGlzYWxsb3dlZCA9IGZyZWV6ZShbJ21hY3Rpb24nLCAnbWFsaWduZ3JvdXAnLCAnbWFsaWdubWFyaycsICdtbG9uZ2RpdicsICdtc2NhcnJpZXMnLCAnbXNjYXJyeScsICdtc2dyb3VwJywgJ21zdGFjaycsICdtc2xpbmUnLCAnbXNyb3cnLCAnc2VtYW50aWNzJywgJ2Fubm90YXRpb24nLCAnYW5ub3RhdGlvbi14bWwnLCAnbXByZXNjcmlwdHMnLCAnbm9uZSddKTtcblxudmFyIHRleHQgPSBmcmVlemUoWycjdGV4dCddKTtcblxudmFyIGh0bWwkMSQxID0gZnJlZXplKFsnYWNjZXB0JywgJ2FjdGlvbicsICdhbGlnbicsICdhbHQnLCAnYXV0b2NhcGl0YWxpemUnLCAnYXV0b2NvbXBsZXRlJywgJ2F1dG9waWN0dXJlaW5waWN0dXJlJywgJ2F1dG9wbGF5JywgJ2JhY2tncm91bmQnLCAnYmdjb2xvcicsICdib3JkZXInLCAnY2FwdHVyZScsICdjZWxscGFkZGluZycsICdjZWxsc3BhY2luZycsICdjaGVja2VkJywgJ2NpdGUnLCAnY2xhc3MnLCAnY2xlYXInLCAnY29sb3InLCAnY29scycsICdjb2xzcGFuJywgJ2NvbnRyb2xzJywgJ2NvbnRyb2xzbGlzdCcsICdjb29yZHMnLCAnY3Jvc3NvcmlnaW4nLCAnZGF0ZXRpbWUnLCAnZGVjb2RpbmcnLCAnZGVmYXVsdCcsICdkaXInLCAnZGlzYWJsZWQnLCAnZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmUnLCAnZGlzYWJsZXJlbW90ZXBsYXliYWNrJywgJ2Rvd25sb2FkJywgJ2RyYWdnYWJsZScsICdlbmN0eXBlJywgJ2VudGVya2V5aGludCcsICdmYWNlJywgJ2ZvcicsICdoZWFkZXJzJywgJ2hlaWdodCcsICdoaWRkZW4nLCAnaGlnaCcsICdocmVmJywgJ2hyZWZsYW5nJywgJ2lkJywgJ2lucHV0bW9kZScsICdpbnRlZ3JpdHknLCAnaXNtYXAnLCAna2luZCcsICdsYWJlbCcsICdsYW5nJywgJ2xpc3QnLCAnbG9hZGluZycsICdsb29wJywgJ2xvdycsICdtYXgnLCAnbWF4bGVuZ3RoJywgJ21lZGlhJywgJ21ldGhvZCcsICdtaW4nLCAnbWlubGVuZ3RoJywgJ211bHRpcGxlJywgJ211dGVkJywgJ25hbWUnLCAnbm9zaGFkZScsICdub3ZhbGlkYXRlJywgJ25vd3JhcCcsICdvcGVuJywgJ29wdGltdW0nLCAncGF0dGVybicsICdwbGFjZWhvbGRlcicsICdwbGF5c2lubGluZScsICdwb3N0ZXInLCAncHJlbG9hZCcsICdwdWJkYXRlJywgJ3JhZGlvZ3JvdXAnLCAncmVhZG9ubHknLCAncmVsJywgJ3JlcXVpcmVkJywgJ3JldicsICdyZXZlcnNlZCcsICdyb2xlJywgJ3Jvd3MnLCAncm93c3BhbicsICdzcGVsbGNoZWNrJywgJ3Njb3BlJywgJ3NlbGVjdGVkJywgJ3NoYXBlJywgJ3NpemUnLCAnc2l6ZXMnLCAnc3BhbicsICdzcmNsYW5nJywgJ3N0YXJ0JywgJ3NyYycsICdzcmNzZXQnLCAnc3RlcCcsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmluZGV4JywgJ3RpdGxlJywgJ3RyYW5zbGF0ZScsICd0eXBlJywgJ3VzZW1hcCcsICd2YWxpZ24nLCAndmFsdWUnLCAnd2lkdGgnLCAneG1sbnMnLCAnc2xvdCddKTtcblxudmFyIHN2ZyQxID0gZnJlZXplKFsnYWNjZW50LWhlaWdodCcsICdhY2N1bXVsYXRlJywgJ2FkZGl0aXZlJywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhc2NlbnQnLCAnYXR0cmlidXRlbmFtZScsICdhdHRyaWJ1dGV0eXBlJywgJ2F6aW11dGgnLCAnYmFzZWZyZXF1ZW5jeScsICdiYXNlbGluZS1zaGlmdCcsICdiZWdpbicsICdiaWFzJywgJ2J5JywgJ2NsYXNzJywgJ2NsaXAnLCAnY2xpcHBhdGh1bml0cycsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2N4JywgJ2N5JywgJ2QnLCAnZHgnLCAnZHknLCAnZGlmZnVzZWNvbnN0YW50JywgJ2RpcmVjdGlvbicsICdkaXNwbGF5JywgJ2Rpdmlzb3InLCAnZHVyJywgJ2VkZ2Vtb2RlJywgJ2VsZXZhdGlvbicsICdlbmQnLCAnZmlsbCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2ZpbHRlcicsICdmaWx0ZXJ1bml0cycsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdmeCcsICdmeScsICdnMScsICdnMicsICdnbHlwaC1uYW1lJywgJ2dseXBocmVmJywgJ2dyYWRpZW50dW5pdHMnLCAnZ3JhZGllbnR0cmFuc2Zvcm0nLCAnaGVpZ2h0JywgJ2hyZWYnLCAnaWQnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2luJywgJ2luMicsICdrJywgJ2sxJywgJ2syJywgJ2szJywgJ2s0JywgJ2tlcm5pbmcnLCAna2V5cG9pbnRzJywgJ2tleXNwbGluZXMnLCAna2V5dGltZXMnLCAnbGFuZycsICdsZW5ndGhhZGp1c3QnLCAnbGV0dGVyLXNwYWNpbmcnLCAna2VybmVsbWF0cml4JywgJ2tlcm5lbHVuaXRsZW5ndGgnLCAnbGlnaHRpbmctY29sb3InLCAnbG9jYWwnLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdtYXJrZXJoZWlnaHQnLCAnbWFya2VydW5pdHMnLCAnbWFya2Vyd2lkdGgnLCAnbWFza2NvbnRlbnR1bml0cycsICdtYXNrdW5pdHMnLCAnbWF4JywgJ21hc2snLCAnbWVkaWEnLCAnbWV0aG9kJywgJ21vZGUnLCAnbWluJywgJ25hbWUnLCAnbnVtb2N0YXZlcycsICdvZmZzZXQnLCAnb3BlcmF0b3InLCAnb3BhY2l0eScsICdvcmRlcicsICdvcmllbnQnLCAnb3JpZW50YXRpb24nLCAnb3JpZ2luJywgJ292ZXJmbG93JywgJ3BhaW50LW9yZGVyJywgJ3BhdGgnLCAncGF0aGxlbmd0aCcsICdwYXR0ZXJuY29udGVudHVuaXRzJywgJ3BhdHRlcm50cmFuc2Zvcm0nLCAncGF0dGVybnVuaXRzJywgJ3BvaW50cycsICdwcmVzZXJ2ZWFscGhhJywgJ3ByZXNlcnZlYXNwZWN0cmF0aW8nLCAncHJpbWl0aXZldW5pdHMnLCAncicsICdyeCcsICdyeScsICdyYWRpdXMnLCAncmVmeCcsICdyZWZ5JywgJ3JlcGVhdGNvdW50JywgJ3JlcGVhdGR1cicsICdyZXN0YXJ0JywgJ3Jlc3VsdCcsICdyb3RhdGUnLCAnc2NhbGUnLCAnc2VlZCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3BlY3VsYXJjb25zdGFudCcsICdzcGVjdWxhcmV4cG9uZW50JywgJ3NwcmVhZG1ldGhvZCcsICdzdGFydG9mZnNldCcsICdzdGRkZXZpYXRpb24nLCAnc3RpdGNodGlsZXMnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlJywgJ3N0cm9rZS13aWR0aCcsICdzdHlsZScsICdzdXJmYWNlc2NhbGUnLCAnc3lzdGVtbGFuZ3VhZ2UnLCAndGFiaW5kZXgnLCAndGFyZ2V0eCcsICd0YXJnZXR5JywgJ3RyYW5zZm9ybScsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndGV4dGxlbmd0aCcsICd0eXBlJywgJ3UxJywgJ3UyJywgJ3VuaWNvZGUnLCAndmFsdWVzJywgJ3ZpZXdib3gnLCAndmlzaWJpbGl0eScsICd2ZXJzaW9uJywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dpZHRoJywgJ3dvcmQtc3BhY2luZycsICd3cmFwJywgJ3dyaXRpbmctbW9kZScsICd4Y2hhbm5lbHNlbGVjdG9yJywgJ3ljaGFubmVsc2VsZWN0b3InLCAneCcsICd4MScsICd4MicsICd4bWxucycsICd5JywgJ3kxJywgJ3kyJywgJ3onLCAnem9vbWFuZHBhbiddKTtcblxudmFyIG1hdGhNbCQxID0gZnJlZXplKFsnYWNjZW50JywgJ2FjY2VudHVuZGVyJywgJ2FsaWduJywgJ2JldmVsbGVkJywgJ2Nsb3NlJywgJ2NvbHVtbnNhbGlnbicsICdjb2x1bW5saW5lcycsICdjb2x1bW5zcGFuJywgJ2Rlbm9tYWxpZ24nLCAnZGVwdGgnLCAnZGlyJywgJ2Rpc3BsYXknLCAnZGlzcGxheXN0eWxlJywgJ2VuY29kaW5nJywgJ2ZlbmNlJywgJ2ZyYW1lJywgJ2hlaWdodCcsICdocmVmJywgJ2lkJywgJ2xhcmdlb3AnLCAnbGVuZ3RoJywgJ2xpbmV0aGlja25lc3MnLCAnbHNwYWNlJywgJ2xxdW90ZScsICdtYXRoYmFja2dyb3VuZCcsICdtYXRoY29sb3InLCAnbWF0aHNpemUnLCAnbWF0aHZhcmlhbnQnLCAnbWF4c2l6ZScsICdtaW5zaXplJywgJ21vdmFibGVsaW1pdHMnLCAnbm90YXRpb24nLCAnbnVtYWxpZ24nLCAnb3BlbicsICdyb3dhbGlnbicsICdyb3dsaW5lcycsICdyb3dzcGFjaW5nJywgJ3Jvd3NwYW4nLCAncnNwYWNlJywgJ3JxdW90ZScsICdzY3JpcHRsZXZlbCcsICdzY3JpcHRtaW5zaXplJywgJ3NjcmlwdHNpemVtdWx0aXBsaWVyJywgJ3NlbGVjdGlvbicsICdzZXBhcmF0b3InLCAnc2VwYXJhdG9ycycsICdzdHJldGNoeScsICdzdWJzY3JpcHRzaGlmdCcsICdzdXBzY3JpcHRzaGlmdCcsICdzeW1tZXRyaWMnLCAndm9mZnNldCcsICd3aWR0aCcsICd4bWxucyddKTtcblxudmFyIHhtbCA9IGZyZWV6ZShbJ3hsaW5rOmhyZWYnLCAneG1sOmlkJywgJ3hsaW5rOnRpdGxlJywgJ3htbDpzcGFjZScsICd4bWxuczp4bGluayddKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vYmV0dGVyLXJlZ2V4XG52YXIgTVVTVEFDSEVfRVhQUiA9IHNlYWwoL1xce1xce1tcXHNcXFNdKnxbXFxzXFxTXSpcXH1cXH0vZ20pOyAvLyBTcGVjaWZ5IHRlbXBsYXRlIGRldGVjdGlvbiByZWdleCBmb3IgU0FGRV9GT1JfVEVNUExBVEVTIG1vZGVcbnZhciBFUkJfRVhQUiA9IHNlYWwoLzwlW1xcc1xcU10qfFtcXHNcXFNdKiU+L2dtKTtcbnZhciBEQVRBX0FUVFIgPSBzZWFsKC9eZGF0YS1bXFwtXFx3LlxcdTAwQjctXFx1RkZGRl0vKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxudmFyIEFSSUFfQVRUUiA9IHNlYWwoL15hcmlhLVtcXC1cXHddKyQvKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxudmFyIElTX0FMTE9XRURfVVJJID0gc2VhbCgvXig/Oig/Oig/OmZ8aHQpdHBzP3xtYWlsdG98dGVsfGNhbGx0b3xjaWR8eG1wcCk6fFteYS16XXxbYS16Ky5cXC1dKyg/OlteYS16Ky5cXC06XXwkKSkvaSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4pO1xudmFyIElTX1NDUklQVF9PUl9EQVRBID0gc2VhbCgvXig/OlxcdytzY3JpcHR8ZGF0YSk6L2kpO1xudmFyIEFUVFJfV0hJVEVTUEFDRSA9IHNlYWwoL1tcXHUwMDAwLVxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMjlcXHUyMDVGXFx1MzAwMF0vZyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbik7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5JDEoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxudmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5vLW9wIHBvbGljeSBmb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gKiBEb24ndCBleHBvcnQgdGhpcyBmdW5jdGlvbiBvdXRzaWRlIHRoaXMgbW9kdWxlIVxuICogQHBhcmFtIHs/VHJ1c3RlZFR5cGVQb2xpY3lGYWN0b3J5fSB0cnVzdGVkVHlwZXMgVGhlIHBvbGljeSBmYWN0b3J5LlxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IG9iamVjdCAodG8gZGV0ZXJtaW5lIHBvbGljeSBuYW1lIHN1ZmZpeClcbiAqIEByZXR1cm4gez9UcnVzdGVkVHlwZVBvbGljeX0gVGhlIHBvbGljeSBjcmVhdGVkIChvciBudWxsLCBpZiBUcnVzdGVkIFR5cGVzXG4gKiBhcmUgbm90IHN1cHBvcnRlZCkuXG4gKi9cbnZhciBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5ID0gZnVuY3Rpb24gX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSh0cnVzdGVkVHlwZXMsIGRvY3VtZW50KSB7XG4gIGlmICgodHlwZW9mIHRydXN0ZWRUeXBlcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodHJ1c3RlZFR5cGVzKSkgIT09ICdvYmplY3QnIHx8IHR5cGVvZiB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGxvdyB0aGUgY2FsbGVycyB0byBjb250cm9sIHRoZSB1bmlxdWUgcG9saWN5IG5hbWVcbiAgLy8gYnkgYWRkaW5nIGEgZGF0YS10dC1wb2xpY3ktc3VmZml4IHRvIHRoZSBzY3JpcHQgZWxlbWVudCB3aXRoIHRoZSBET01QdXJpZnkuXG4gIC8vIFBvbGljeSBjcmVhdGlvbiB3aXRoIGR1cGxpY2F0ZSBuYW1lcyB0aHJvd3MgaW4gVHJ1c3RlZCBUeXBlcy5cbiAgdmFyIHN1ZmZpeCA9IG51bGw7XG4gIHZhciBBVFRSX05BTUUgPSAnZGF0YS10dC1wb2xpY3ktc3VmZml4JztcbiAgaWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdC5oYXNBdHRyaWJ1dGUoQVRUUl9OQU1FKSkge1xuICAgIHN1ZmZpeCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSk7XG4gIH1cblxuICB2YXIgcG9saWN5TmFtZSA9ICdkb21wdXJpZnknICsgKHN1ZmZpeCA/ICcjJyArIHN1ZmZpeCA6ICcnKTtcblxuICB0cnkge1xuICAgIHJldHVybiB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KHBvbGljeU5hbWUsIHtcbiAgICAgIGNyZWF0ZUhUTUw6IGZ1bmN0aW9uIGNyZWF0ZUhUTUwoaHRtbCQkMSkge1xuICAgICAgICByZXR1cm4gaHRtbCQkMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIFBvbGljeSBjcmVhdGlvbiBmYWlsZWQgKG1vc3QgbGlrZWx5IGFub3RoZXIgRE9NUHVyaWZ5IHNjcmlwdCBoYXNcbiAgICAvLyBhbHJlYWR5IHJ1bikuIFNraXAgY3JlYXRpbmcgdGhlIHBvbGljeSwgYXMgdGhpcyB3aWxsIG9ubHkgY2F1c2UgZXJyb3JzXG4gICAgLy8gaWYgVFQgYXJlIGVuZm9yY2VkLlxuICAgIGNvbnNvbGUud2FybignVHJ1c3RlZFR5cGVzIHBvbGljeSAnICsgcG9saWN5TmFtZSArICcgY291bGQgbm90IGJlIGNyZWF0ZWQuJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZURPTVB1cmlmeSgpIHtcbiAgdmFyIHdpbmRvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZ2V0R2xvYmFsKCk7XG5cbiAgdmFyIERPTVB1cmlmeSA9IGZ1bmN0aW9uIERPTVB1cmlmeShyb290KSB7XG4gICAgcmV0dXJuIGNyZWF0ZURPTVB1cmlmeShyb290KTtcbiAgfTtcblxuICAvKipcbiAgICogVmVyc2lvbiBsYWJlbCwgZXhwb3NlZCBmb3IgZWFzaWVyIGNoZWNrc1xuICAgKiBpZiBET01QdXJpZnkgaXMgdXAgdG8gZGF0ZSBvciBub3RcbiAgICovXG4gIERPTVB1cmlmeS52ZXJzaW9uID0gJzIuMy4zJztcblxuICAvKipcbiAgICogQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBET01QdXJpZnkgcmVtb3ZlZCBkdXJpbmcgc2FuaXRhdGlvbi5cbiAgICogRW1wdHkgaWYgbm90aGluZyB3YXMgcmVtb3ZlZC5cbiAgICovXG4gIERPTVB1cmlmeS5yZW1vdmVkID0gW107XG5cbiAgaWYgKCF3aW5kb3cgfHwgIXdpbmRvdy5kb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQubm9kZVR5cGUgIT09IDkpIHtcbiAgICAvLyBOb3QgcnVubmluZyBpbiBhIGJyb3dzZXIsIHByb3ZpZGUgYSBmYWN0b3J5IGZ1bmN0aW9uXG4gICAgLy8gc28gdGhhdCB5b3UgY2FuIHBhc3MgeW91ciBvd24gV2luZG93XG4gICAgRE9NUHVyaWZ5LmlzU3VwcG9ydGVkID0gZmFsc2U7XG5cbiAgICByZXR1cm4gRE9NUHVyaWZ5O1xuICB9XG5cbiAgdmFyIG9yaWdpbmFsRG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbiAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICB2YXIgRG9jdW1lbnRGcmFnbWVudCA9IHdpbmRvdy5Eb2N1bWVudEZyYWdtZW50LFxuICAgICAgSFRNTFRlbXBsYXRlRWxlbWVudCA9IHdpbmRvdy5IVE1MVGVtcGxhdGVFbGVtZW50LFxuICAgICAgTm9kZSA9IHdpbmRvdy5Ob2RlLFxuICAgICAgRWxlbWVudCA9IHdpbmRvdy5FbGVtZW50LFxuICAgICAgTm9kZUZpbHRlciA9IHdpbmRvdy5Ob2RlRmlsdGVyLFxuICAgICAgX3dpbmRvdyROYW1lZE5vZGVNYXAgPSB3aW5kb3cuTmFtZWROb2RlTWFwLFxuICAgICAgTmFtZWROb2RlTWFwID0gX3dpbmRvdyROYW1lZE5vZGVNYXAgPT09IHVuZGVmaW5lZCA/IHdpbmRvdy5OYW1lZE5vZGVNYXAgfHwgd2luZG93Lk1vek5hbWVkQXR0ck1hcCA6IF93aW5kb3ckTmFtZWROb2RlTWFwLFxuICAgICAgVGV4dCA9IHdpbmRvdy5UZXh0LFxuICAgICAgQ29tbWVudCA9IHdpbmRvdy5Db21tZW50LFxuICAgICAgRE9NUGFyc2VyID0gd2luZG93LkRPTVBhcnNlcixcbiAgICAgIHRydXN0ZWRUeXBlcyA9IHdpbmRvdy50cnVzdGVkVHlwZXM7XG5cblxuICB2YXIgRWxlbWVudFByb3RvdHlwZSA9IEVsZW1lbnQucHJvdG90eXBlO1xuXG4gIHZhciBjbG9uZU5vZGUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ2Nsb25lTm9kZScpO1xuICB2YXIgZ2V0TmV4dFNpYmxpbmcgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ25leHRTaWJsaW5nJyk7XG4gIHZhciBnZXRDaGlsZE5vZGVzID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdjaGlsZE5vZGVzJyk7XG4gIHZhciBnZXRQYXJlbnROb2RlID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdwYXJlbnROb2RlJyk7XG5cbiAgLy8gQXMgcGVyIGlzc3VlICM0NywgdGhlIHdlYi1jb21wb25lbnRzIHJlZ2lzdHJ5IGlzIGluaGVyaXRlZCBieSBhXG4gIC8vIG5ldyBkb2N1bWVudCBjcmVhdGVkIHZpYSBjcmVhdGVIVE1MRG9jdW1lbnQuIEFzIHBlciB0aGUgc3BlY1xuICAvLyAoaHR0cDovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3JlYXRpbmctYW5kLXBhc3NpbmctcmVnaXN0cmllcylcbiAgLy8gYSBuZXcgZW1wdHkgcmVnaXN0cnkgaXMgdXNlZCB3aGVuIGNyZWF0aW5nIGEgdGVtcGxhdGUgY29udGVudHMgb3duZXJcbiAgLy8gZG9jdW1lbnQsIHNvIHdlIHVzZSB0aGF0IGFzIG91ciBwYXJlbnQgZG9jdW1lbnQgdG8gZW5zdXJlIG5vdGhpbmdcbiAgLy8gaXMgaW5oZXJpdGVkLlxuICBpZiAodHlwZW9mIEhUTUxUZW1wbGF0ZUVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIGlmICh0ZW1wbGF0ZS5jb250ZW50ICYmIHRlbXBsYXRlLmNvbnRlbnQub3duZXJEb2N1bWVudCkge1xuICAgICAgZG9jdW1lbnQgPSB0ZW1wbGF0ZS5jb250ZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRydXN0ZWRUeXBlc1BvbGljeSA9IF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kodHJ1c3RlZFR5cGVzLCBvcmlnaW5hbERvY3VtZW50KTtcbiAgdmFyIGVtcHR5SFRNTCA9IHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoJycpIDogJyc7XG5cbiAgdmFyIF9kb2N1bWVudCA9IGRvY3VtZW50LFxuICAgICAgaW1wbGVtZW50YXRpb24gPSBfZG9jdW1lbnQuaW1wbGVtZW50YXRpb24sXG4gICAgICBjcmVhdGVOb2RlSXRlcmF0b3IgPSBfZG9jdW1lbnQuY3JlYXRlTm9kZUl0ZXJhdG9yLFxuICAgICAgY3JlYXRlRG9jdW1lbnRGcmFnbWVudCA9IF9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50LFxuICAgICAgZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBfZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWU7XG4gIHZhciBpbXBvcnROb2RlID0gb3JpZ2luYWxEb2N1bWVudC5pbXBvcnROb2RlO1xuXG5cbiAgdmFyIGRvY3VtZW50TW9kZSA9IHt9O1xuICB0cnkge1xuICAgIGRvY3VtZW50TW9kZSA9IGNsb25lKGRvY3VtZW50KS5kb2N1bWVudE1vZGUgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiB7fTtcbiAgfSBjYXRjaCAoXykge31cblxuICB2YXIgaG9va3MgPSB7fTtcblxuICAvKipcbiAgICogRXhwb3NlIHdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHJ1bm5pbmcgdGhlIGZ1bGwgRE9NUHVyaWZ5LlxuICAgKi9cbiAgRE9NUHVyaWZ5LmlzU3VwcG9ydGVkID0gdHlwZW9mIGdldFBhcmVudE5vZGUgPT09ICdmdW5jdGlvbicgJiYgaW1wbGVtZW50YXRpb24gJiYgdHlwZW9mIGltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRNb2RlICE9PSA5O1xuXG4gIHZhciBNVVNUQUNIRV9FWFBSJCQxID0gTVVTVEFDSEVfRVhQUixcbiAgICAgIEVSQl9FWFBSJCQxID0gRVJCX0VYUFIsXG4gICAgICBEQVRBX0FUVFIkJDEgPSBEQVRBX0FUVFIsXG4gICAgICBBUklBX0FUVFIkJDEgPSBBUklBX0FUVFIsXG4gICAgICBJU19TQ1JJUFRfT1JfREFUQSQkMSA9IElTX1NDUklQVF9PUl9EQVRBLFxuICAgICAgQVRUUl9XSElURVNQQUNFJCQxID0gQVRUUl9XSElURVNQQUNFO1xuICB2YXIgSVNfQUxMT1dFRF9VUkkkJDEgPSBJU19BTExPV0VEX1VSSTtcblxuICAvKipcbiAgICogV2UgY29uc2lkZXIgdGhlIGVsZW1lbnRzIGFuZCBhdHRyaWJ1dGVzIGJlbG93IHRvIGJlIHNhZmUuIElkZWFsbHlcbiAgICogZG9uJ3QgYWRkIGFueSBuZXcgb25lcyBidXQgZmVlbCBmcmVlIHRvIHJlbW92ZSB1bndhbnRlZCBvbmVzLlxuICAgKi9cblxuICAvKiBhbGxvd2VkIGVsZW1lbnQgbmFtZXMgKi9cblxuICB2YXIgQUxMT1dFRF9UQUdTID0gbnVsbDtcbiAgdmFyIERFRkFVTFRfQUxMT1dFRF9UQUdTID0gYWRkVG9TZXQoe30sIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkkMShodG1sJDIpLCBfdG9Db25zdW1hYmxlQXJyYXkkMShzdmcpLCBfdG9Db25zdW1hYmxlQXJyYXkkMShzdmdGaWx0ZXJzKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEobWF0aE1sKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEodGV4dCkpKTtcblxuICAvKiBBbGxvd2VkIGF0dHJpYnV0ZSBuYW1lcyAqL1xuICB2YXIgQUxMT1dFRF9BVFRSID0gbnVsbDtcbiAgdmFyIERFRkFVTFRfQUxMT1dFRF9BVFRSID0gYWRkVG9TZXQoe30sIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkkMShodG1sJDEkMSksIF90b0NvbnN1bWFibGVBcnJheSQxKHN2ZyQxKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEobWF0aE1sJDEpLCBfdG9Db25zdW1hYmxlQXJyYXkkMSh4bWwpKSk7XG5cbiAgLyogRXhwbGljaXRseSBmb3JiaWRkZW4gdGFncyAob3ZlcnJpZGVzIEFMTE9XRURfVEFHUy9BRERfVEFHUykgKi9cbiAgdmFyIEZPUkJJRF9UQUdTID0gbnVsbDtcblxuICAvKiBFeHBsaWNpdGx5IGZvcmJpZGRlbiBhdHRyaWJ1dGVzIChvdmVycmlkZXMgQUxMT1dFRF9BVFRSL0FERF9BVFRSKSAqL1xuICB2YXIgRk9SQklEX0FUVFIgPSBudWxsO1xuXG4gIC8qIERlY2lkZSBpZiBBUklBIGF0dHJpYnV0ZXMgYXJlIG9rYXkgKi9cbiAgdmFyIEFMTE9XX0FSSUFfQVRUUiA9IHRydWU7XG5cbiAgLyogRGVjaWRlIGlmIGN1c3RvbSBkYXRhIGF0dHJpYnV0ZXMgYXJlIG9rYXkgKi9cbiAgdmFyIEFMTE9XX0RBVEFfQVRUUiA9IHRydWU7XG5cbiAgLyogRGVjaWRlIGlmIHVua25vd24gcHJvdG9jb2xzIGFyZSBva2F5ICovXG4gIHZhciBBTExPV19VTktOT1dOX1BST1RPQ09MUyA9IGZhbHNlO1xuXG4gIC8qIE91dHB1dCBzaG91bGQgYmUgc2FmZSBmb3IgY29tbW9uIHRlbXBsYXRlIGVuZ2luZXMuXG4gICAqIFRoaXMgbWVhbnMsIERPTVB1cmlmeSByZW1vdmVzIGRhdGEgYXR0cmlidXRlcywgbXVzdGFjaGVzIGFuZCBFUkJcbiAgICovXG4gIHZhciBTQUZFX0ZPUl9URU1QTEFURVMgPSBmYWxzZTtcblxuICAvKiBEZWNpZGUgaWYgZG9jdW1lbnQgd2l0aCA8aHRtbD4uLi4gc2hvdWxkIGJlIHJldHVybmVkICovXG4gIHZhciBXSE9MRV9ET0NVTUVOVCA9IGZhbHNlO1xuXG4gIC8qIFRyYWNrIHdoZXRoZXIgY29uZmlnIGlzIGFscmVhZHkgc2V0IG9uIHRoaXMgaW5zdGFuY2Ugb2YgRE9NUHVyaWZ5LiAqL1xuICB2YXIgU0VUX0NPTkZJRyA9IGZhbHNlO1xuXG4gIC8qIERlY2lkZSBpZiBhbGwgZWxlbWVudHMgKGUuZy4gc3R5bGUsIHNjcmlwdCkgbXVzdCBiZSBjaGlsZHJlbiBvZlxuICAgKiBkb2N1bWVudC5ib2R5LiBCeSBkZWZhdWx0LCBicm93c2VycyBtaWdodCBtb3ZlIHRoZW0gdG8gZG9jdW1lbnQuaGVhZCAqL1xuICB2YXIgRk9SQ0VfQk9EWSA9IGZhbHNlO1xuXG4gIC8qIERlY2lkZSBpZiBhIERPTSBgSFRNTEJvZHlFbGVtZW50YCBzaG91bGQgYmUgcmV0dXJuZWQsIGluc3RlYWQgb2YgYSBodG1sXG4gICAqIHN0cmluZyAob3IgYSBUcnVzdGVkSFRNTCBvYmplY3QgaWYgVHJ1c3RlZCBUeXBlcyBhcmUgc3VwcG9ydGVkKS5cbiAgICogSWYgYFdIT0xFX0RPQ1VNRU5UYCBpcyBlbmFibGVkIGEgYEhUTUxIdG1sRWxlbWVudGAgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkXG4gICAqL1xuICB2YXIgUkVUVVJOX0RPTSA9IGZhbHNlO1xuXG4gIC8qIERlY2lkZSBpZiBhIERPTSBgRG9jdW1lbnRGcmFnbWVudGAgc2hvdWxkIGJlIHJldHVybmVkLCBpbnN0ZWFkIG9mIGEgaHRtbFxuICAgKiBzdHJpbmcgIChvciBhIFRydXN0ZWRIVE1MIG9iamVjdCBpZiBUcnVzdGVkIFR5cGVzIGFyZSBzdXBwb3J0ZWQpICovXG4gIHZhciBSRVRVUk5fRE9NX0ZSQUdNRU5UID0gZmFsc2U7XG5cbiAgLyogSWYgYFJFVFVSTl9ET01gIG9yIGBSRVRVUk5fRE9NX0ZSQUdNRU5UYCBpcyBlbmFibGVkLCBkZWNpZGUgaWYgdGhlIHJldHVybmVkIERPTVxuICAgKiBgTm9kZWAgaXMgaW1wb3J0ZWQgaW50byB0aGUgY3VycmVudCBgRG9jdW1lbnRgLiBJZiB0aGlzIGZsYWcgaXMgbm90IGVuYWJsZWQgdGhlXG4gICAqIGBOb2RlYCB3aWxsIGJlbG9uZyAoaXRzIG93bmVyRG9jdW1lbnQpIHRvIGEgZnJlc2ggYEhUTUxEb2N1bWVudGAsIGNyZWF0ZWQgYnlcbiAgICogRE9NUHVyaWZ5LlxuICAgKlxuICAgKiBUaGlzIGRlZmF1bHRzIHRvIGB0cnVlYCBzdGFydGluZyBET01QdXJpZnkgMi4yLjAuIE5vdGUgdGhhdCBzZXR0aW5nIGl0IHRvIGBmYWxzZWBcbiAgICogbWlnaHQgY2F1c2UgWFNTIGZyb20gYXR0YWNrcyBoaWRkZW4gaW4gY2xvc2VkIHNoYWRvd3Jvb3RzIGluIGNhc2UgdGhlIGJyb3dzZXJcbiAgICogc3VwcG9ydHMgRGVjbGFyYXRpdmUgU2hhZG93OiBET00gaHR0cHM6Ly93ZWIuZGV2L2RlY2xhcmF0aXZlLXNoYWRvdy1kb20vXG4gICAqL1xuICB2YXIgUkVUVVJOX0RPTV9JTVBPUlQgPSB0cnVlO1xuXG4gIC8qIFRyeSB0byByZXR1cm4gYSBUcnVzdGVkIFR5cGUgb2JqZWN0IGluc3RlYWQgb2YgYSBzdHJpbmcsIHJldHVybiBhIHN0cmluZyBpblxuICAgKiBjYXNlIFRydXN0ZWQgVHlwZXMgYXJlIG5vdCBzdXBwb3J0ZWQgICovXG4gIHZhciBSRVRVUk5fVFJVU1RFRF9UWVBFID0gZmFsc2U7XG5cbiAgLyogT3V0cHV0IHNob3VsZCBiZSBmcmVlIGZyb20gRE9NIGNsb2JiZXJpbmcgYXR0YWNrcz8gKi9cbiAgdmFyIFNBTklUSVpFX0RPTSA9IHRydWU7XG5cbiAgLyogS2VlcCBlbGVtZW50IGNvbnRlbnQgd2hlbiByZW1vdmluZyBlbGVtZW50PyAqL1xuICB2YXIgS0VFUF9DT05URU5UID0gdHJ1ZTtcblxuICAvKiBJZiBhIGBOb2RlYCBpcyBwYXNzZWQgdG8gc2FuaXRpemUoKSwgdGhlbiBwZXJmb3JtcyBzYW5pdGl6YXRpb24gaW4tcGxhY2UgaW5zdGVhZFxuICAgKiBvZiBpbXBvcnRpbmcgaXQgaW50byBhIG5ldyBEb2N1bWVudCBhbmQgcmV0dXJuaW5nIGEgc2FuaXRpemVkIGNvcHkgKi9cbiAgdmFyIElOX1BMQUNFID0gZmFsc2U7XG5cbiAgLyogQWxsb3cgdXNhZ2Ugb2YgcHJvZmlsZXMgbGlrZSBodG1sLCBzdmcgYW5kIG1hdGhNbCAqL1xuICB2YXIgVVNFX1BST0ZJTEVTID0ge307XG5cbiAgLyogVGFncyB0byBpZ25vcmUgY29udGVudCBvZiB3aGVuIEtFRVBfQ09OVEVOVCBpcyB0cnVlICovXG4gIHZhciBGT1JCSURfQ09OVEVOVFMgPSBudWxsO1xuICB2YXIgREVGQVVMVF9GT1JCSURfQ09OVEVOVFMgPSBhZGRUb1NldCh7fSwgWydhbm5vdGF0aW9uLXhtbCcsICdhdWRpbycsICdjb2xncm91cCcsICdkZXNjJywgJ2ZvcmVpZ25vYmplY3QnLCAnaGVhZCcsICdpZnJhbWUnLCAnbWF0aCcsICdtaScsICdtbicsICdtbycsICdtcycsICdtdGV4dCcsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ3BsYWludGV4dCcsICdzY3JpcHQnLCAnc3R5bGUnLCAnc3ZnJywgJ3RlbXBsYXRlJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3ZpZGVvJywgJ3htcCddKTtcblxuICAvKiBUYWdzIHRoYXQgYXJlIHNhZmUgZm9yIGRhdGE6IFVSSXMgKi9cbiAgdmFyIERBVEFfVVJJX1RBR1MgPSBudWxsO1xuICB2YXIgREVGQVVMVF9EQVRBX1VSSV9UQUdTID0gYWRkVG9TZXQoe30sIFsnYXVkaW8nLCAndmlkZW8nLCAnaW1nJywgJ3NvdXJjZScsICdpbWFnZScsICd0cmFjayddKTtcblxuICAvKiBBdHRyaWJ1dGVzIHNhZmUgZm9yIHZhbHVlcyBsaWtlIFwiamF2YXNjcmlwdDpcIiAqL1xuICB2YXIgVVJJX1NBRkVfQVRUUklCVVRFUyA9IG51bGw7XG4gIHZhciBERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMgPSBhZGRUb1NldCh7fSwgWydhbHQnLCAnY2xhc3MnLCAnZm9yJywgJ2lkJywgJ2xhYmVsJywgJ25hbWUnLCAncGF0dGVybicsICdwbGFjZWhvbGRlcicsICdyb2xlJywgJ3N1bW1hcnknLCAndGl0bGUnLCAndmFsdWUnLCAnc3R5bGUnLCAneG1sbnMnXSk7XG5cbiAgdmFyIE1BVEhNTF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7XG4gIHZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgdmFyIEhUTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuICAvKiBEb2N1bWVudCBuYW1lc3BhY2UgKi9cbiAgdmFyIE5BTUVTUEFDRSA9IEhUTUxfTkFNRVNQQUNFO1xuICB2YXIgSVNfRU1QVFlfSU5QVVQgPSBmYWxzZTtcblxuICAvKiBQYXJzaW5nIG9mIHN0cmljdCBYSFRNTCBkb2N1bWVudHMgKi9cbiAgdmFyIFBBUlNFUl9NRURJQV9UWVBFID0gdm9pZCAwO1xuICB2YXIgU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUyA9IFsnYXBwbGljYXRpb24veGh0bWwreG1sJywgJ3RleHQvaHRtbCddO1xuICB2YXIgREVGQVVMVF9QQVJTRVJfTUVESUFfVFlQRSA9ICd0ZXh0L2h0bWwnO1xuICB2YXIgdHJhbnNmb3JtQ2FzZUZ1bmMgPSB2b2lkIDA7XG5cbiAgLyogS2VlcCBhIHJlZmVyZW5jZSB0byBjb25maWcgdG8gcGFzcyB0byBob29rcyAqL1xuICB2YXIgQ09ORklHID0gbnVsbDtcblxuICAvKiBJZGVhbGx5LCBkbyBub3QgdG91Y2ggYW55dGhpbmcgYmVsb3cgdGhpcyBsaW5lICovXG4gIC8qIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18gKi9cblxuICB2YXIgZm9ybUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG5cbiAgLyoqXG4gICAqIF9wYXJzZUNvbmZpZ1xuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNmZyBvcHRpb25hbCBjb25maWcgbGl0ZXJhbFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgdmFyIF9wYXJzZUNvbmZpZyA9IGZ1bmN0aW9uIF9wYXJzZUNvbmZpZyhjZmcpIHtcbiAgICBpZiAoQ09ORklHICYmIENPTkZJRyA9PT0gY2ZnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyogU2hpZWxkIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZyb20gdGFtcGVyaW5nICovXG4gICAgaWYgKCFjZmcgfHwgKHR5cGVvZiBjZmcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNmZykpICE9PSAnb2JqZWN0Jykge1xuICAgICAgY2ZnID0ge307XG4gICAgfVxuXG4gICAgLyogU2hpZWxkIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZyb20gcHJvdG90eXBlIHBvbGx1dGlvbiAqL1xuICAgIGNmZyA9IGNsb25lKGNmZyk7XG5cbiAgICAvKiBTZXQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzICovXG4gICAgQUxMT1dFRF9UQUdTID0gJ0FMTE9XRURfVEFHUycgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5BTExPV0VEX1RBR1MpIDogREVGQVVMVF9BTExPV0VEX1RBR1M7XG4gICAgQUxMT1dFRF9BVFRSID0gJ0FMTE9XRURfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5BTExPV0VEX0FUVFIpIDogREVGQVVMVF9BTExPV0VEX0FUVFI7XG4gICAgVVJJX1NBRkVfQVRUUklCVVRFUyA9ICdBRERfVVJJX1NBRkVfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTKSwgY2ZnLkFERF9VUklfU0FGRV9BVFRSKSA6IERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUztcbiAgICBEQVRBX1VSSV9UQUdTID0gJ0FERF9EQVRBX1VSSV9UQUdTJyBpbiBjZmcgPyBhZGRUb1NldChjbG9uZShERUZBVUxUX0RBVEFfVVJJX1RBR1MpLCBjZmcuQUREX0RBVEFfVVJJX1RBR1MpIDogREVGQVVMVF9EQVRBX1VSSV9UQUdTO1xuICAgIEZPUkJJRF9DT05URU5UUyA9ICdGT1JCSURfQ09OVEVOVFMnIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX0NPTlRFTlRTKSA6IERFRkFVTFRfRk9SQklEX0NPTlRFTlRTO1xuICAgIEZPUkJJRF9UQUdTID0gJ0ZPUkJJRF9UQUdTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9UQUdTKSA6IHt9O1xuICAgIEZPUkJJRF9BVFRSID0gJ0ZPUkJJRF9BVFRSJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9BVFRSKSA6IHt9O1xuICAgIFVTRV9QUk9GSUxFUyA9ICdVU0VfUFJPRklMRVMnIGluIGNmZyA/IGNmZy5VU0VfUFJPRklMRVMgOiBmYWxzZTtcbiAgICBBTExPV19BUklBX0FUVFIgPSBjZmcuQUxMT1dfQVJJQV9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgQUxMT1dfREFUQV9BVFRSID0gY2ZnLkFMTE9XX0RBVEFfQVRUUiAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgIEFMTE9XX1VOS05PV05fUFJPVE9DT0xTID0gY2ZnLkFMTE9XX1VOS05PV05fUFJPVE9DT0xTIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgU0FGRV9GT1JfVEVNUExBVEVTID0gY2ZnLlNBRkVfRk9SX1RFTVBMQVRFUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFdIT0xFX0RPQ1VNRU5UID0gY2ZnLldIT0xFX0RPQ1VNRU5UIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgUkVUVVJOX0RPTSA9IGNmZy5SRVRVUk5fRE9NIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgUkVUVVJOX0RPTV9GUkFHTUVOVCA9IGNmZy5SRVRVUk5fRE9NX0ZSQUdNRU5UIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgUkVUVVJOX0RPTV9JTVBPUlQgPSBjZmcuUkVUVVJOX0RPTV9JTVBPUlQgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBSRVRVUk5fVFJVU1RFRF9UWVBFID0gY2ZnLlJFVFVSTl9UUlVTVEVEX1RZUEUgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBGT1JDRV9CT0RZID0gY2ZnLkZPUkNFX0JPRFkgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBTQU5JVElaRV9ET00gPSBjZmcuU0FOSVRJWkVfRE9NICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgS0VFUF9DT05URU5UID0gY2ZnLktFRVBfQ09OVEVOVCAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgIElOX1BMQUNFID0gY2ZnLklOX1BMQUNFIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgSVNfQUxMT1dFRF9VUkkkJDEgPSBjZmcuQUxMT1dFRF9VUklfUkVHRVhQIHx8IElTX0FMTE9XRURfVVJJJCQxO1xuICAgIE5BTUVTUEFDRSA9IGNmZy5OQU1FU1BBQ0UgfHwgSFRNTF9OQU1FU1BBQ0U7XG5cbiAgICBQQVJTRVJfTUVESUFfVFlQRSA9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWluY2x1ZGVzXG4gICAgU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUy5pbmRleE9mKGNmZy5QQVJTRVJfTUVESUFfVFlQRSkgPT09IC0xID8gUEFSU0VSX01FRElBX1RZUEUgPSBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFIDogUEFSU0VSX01FRElBX1RZUEUgPSBjZmcuUEFSU0VSX01FRElBX1RZUEU7XG5cbiAgICAvLyBIVE1MIHRhZ3MgYW5kIGF0dHJpYnV0ZXMgYXJlIG5vdCBjYXNlLXNlbnNpdGl2ZSwgY29udmVydGluZyB0byBsb3dlcmNhc2UuIEtlZXBpbmcgWEhUTUwgYXMgaXMuXG4gICAgdHJhbnNmb3JtQ2FzZUZ1bmMgPSBQQVJTRVJfTUVESUFfVFlQRSA9PT0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcgPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSA6IHN0cmluZ1RvTG93ZXJDYXNlO1xuXG4gICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgQUxMT1dfREFUQV9BVFRSID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgIFJFVFVSTl9ET00gPSB0cnVlO1xuICAgIH1cblxuICAgIC8qIFBhcnNlIHByb2ZpbGUgaW5mbyAqL1xuICAgIGlmIChVU0VfUFJPRklMRVMpIHtcbiAgICAgIEFMTE9XRURfVEFHUyA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5JDEodGV4dCkpKTtcbiAgICAgIEFMTE9XRURfQVRUUiA9IFtdO1xuICAgICAgaWYgKFVTRV9QUk9GSUxFUy5odG1sID09PSB0cnVlKSB7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgaHRtbCQyKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBodG1sJDEkMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChVU0VfUFJPRklMRVMuc3ZnID09PSB0cnVlKSB7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgc3ZnKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBzdmckMSk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgeG1sKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFVTRV9QUk9GSUxFUy5zdmdGaWx0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgc3ZnRmlsdGVycyk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgc3ZnJDEpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChVU0VfUFJPRklMRVMubWF0aE1sID09PSB0cnVlKSB7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgbWF0aE1sKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBtYXRoTWwkMSk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgeG1sKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBNZXJnZSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgKi9cbiAgICBpZiAoY2ZnLkFERF9UQUdTKSB7XG4gICAgICBpZiAoQUxMT1dFRF9UQUdTID09PSBERUZBVUxUX0FMTE9XRURfVEFHUykge1xuICAgICAgICBBTExPV0VEX1RBR1MgPSBjbG9uZShBTExPV0VEX1RBR1MpO1xuICAgICAgfVxuXG4gICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIGNmZy5BRERfVEFHUyk7XG4gICAgfVxuXG4gICAgaWYgKGNmZy5BRERfQVRUUikge1xuICAgICAgaWYgKEFMTE9XRURfQVRUUiA9PT0gREVGQVVMVF9BTExPV0VEX0FUVFIpIHtcbiAgICAgICAgQUxMT1dFRF9BVFRSID0gY2xvbmUoQUxMT1dFRF9BVFRSKTtcbiAgICAgIH1cblxuICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBjZmcuQUREX0FUVFIpO1xuICAgIH1cblxuICAgIGlmIChjZmcuQUREX1VSSV9TQUZFX0FUVFIpIHtcbiAgICAgIGFkZFRvU2V0KFVSSV9TQUZFX0FUVFJJQlVURVMsIGNmZy5BRERfVVJJX1NBRkVfQVRUUik7XG4gICAgfVxuXG4gICAgaWYgKGNmZy5GT1JCSURfQ09OVEVOVFMpIHtcbiAgICAgIGlmIChGT1JCSURfQ09OVEVOVFMgPT09IERFRkFVTFRfRk9SQklEX0NPTlRFTlRTKSB7XG4gICAgICAgIEZPUkJJRF9DT05URU5UUyA9IGNsb25lKEZPUkJJRF9DT05URU5UUyk7XG4gICAgICB9XG5cbiAgICAgIGFkZFRvU2V0KEZPUkJJRF9DT05URU5UUywgY2ZnLkZPUkJJRF9DT05URU5UUyk7XG4gICAgfVxuXG4gICAgLyogQWRkICN0ZXh0IGluIGNhc2UgS0VFUF9DT05URU5UIGlzIHNldCB0byB0cnVlICovXG4gICAgaWYgKEtFRVBfQ09OVEVOVCkge1xuICAgICAgQUxMT1dFRF9UQUdTWycjdGV4dCddID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBBZGQgaHRtbCwgaGVhZCBhbmQgYm9keSB0byBBTExPV0VEX1RBR1MgaW4gY2FzZSBXSE9MRV9ET0NVTUVOVCBpcyB0cnVlICovXG4gICAgaWYgKFdIT0xFX0RPQ1VNRU5UKSB7XG4gICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIFsnaHRtbCcsICdoZWFkJywgJ2JvZHknXSk7XG4gICAgfVxuXG4gICAgLyogQWRkIHRib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIHRhYmxlcyBhcmUgcGVybWl0dGVkLCBzZWUgIzI4NiwgIzM2NSAqL1xuICAgIGlmIChBTExPV0VEX1RBR1MudGFibGUpIHtcbiAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgWyd0Ym9keSddKTtcbiAgICAgIGRlbGV0ZSBGT1JCSURfVEFHUy50Ym9keTtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IGZ1cnRoZXIgbWFuaXB1bGF0aW9uIG9mIGNvbmZpZ3VyYXRpb24uXG4gICAgLy8gTm90IGF2YWlsYWJsZSBpbiBJRTgsIFNhZmFyaSA1LCBldGMuXG4gICAgaWYgKGZyZWV6ZSkge1xuICAgICAgZnJlZXplKGNmZyk7XG4gICAgfVxuXG4gICAgQ09ORklHID0gY2ZnO1xuICB9O1xuXG4gIHZhciBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFMgPSBhZGRUb1NldCh7fSwgWydtaScsICdtbycsICdtbicsICdtcycsICdtdGV4dCddKTtcblxuICB2YXIgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMgPSBhZGRUb1NldCh7fSwgWydmb3JlaWdub2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnLCAnYW5ub3RhdGlvbi14bWwnXSk7XG5cbiAgLyogS2VlcCB0cmFjayBvZiBhbGwgcG9zc2libGUgU1ZHIGFuZCBNYXRoTUwgdGFnc1xuICAgKiBzbyB0aGF0IHdlIGNhbiBwZXJmb3JtIHRoZSBuYW1lc3BhY2UgY2hlY2tzXG4gICAqIGNvcnJlY3RseS4gKi9cbiAgdmFyIEFMTF9TVkdfVEFHUyA9IGFkZFRvU2V0KHt9LCBzdmcpO1xuICBhZGRUb1NldChBTExfU1ZHX1RBR1MsIHN2Z0ZpbHRlcnMpO1xuICBhZGRUb1NldChBTExfU1ZHX1RBR1MsIHN2Z0Rpc2FsbG93ZWQpO1xuXG4gIHZhciBBTExfTUFUSE1MX1RBR1MgPSBhZGRUb1NldCh7fSwgbWF0aE1sKTtcbiAgYWRkVG9TZXQoQUxMX01BVEhNTF9UQUdTLCBtYXRoTWxEaXNhbGxvd2VkKTtcblxuICAvKipcbiAgICpcbiAgICpcbiAgICogQHBhcmFtICB7RWxlbWVudH0gZWxlbWVudCBhIERPTSBlbGVtZW50IHdob3NlIG5hbWVzcGFjZSBpcyBiZWluZyBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm4gZmFsc2UgaWYgdGhlIGVsZW1lbnQgaGFzIGFcbiAgICogIG5hbWVzcGFjZSB0aGF0IGEgc3BlYy1jb21wbGlhbnQgcGFyc2VyIHdvdWxkIG5ldmVyXG4gICAqICByZXR1cm4uIFJldHVybiB0cnVlIG90aGVyd2lzZS5cbiAgICovXG4gIHZhciBfY2hlY2tWYWxpZE5hbWVzcGFjZSA9IGZ1bmN0aW9uIF9jaGVja1ZhbGlkTmFtZXNwYWNlKGVsZW1lbnQpIHtcbiAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICAgIC8vIEluIEpTRE9NLCBpZiB3ZSdyZSBpbnNpZGUgc2hhZG93IERPTSwgdGhlbiBwYXJlbnROb2RlXG4gICAgLy8gY2FuIGJlIG51bGwuIFdlIGp1c3Qgc2ltdWxhdGUgcGFyZW50IGluIHRoaXMgY2FzZS5cbiAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50LnRhZ05hbWUpIHtcbiAgICAgIHBhcmVudCA9IHtcbiAgICAgICAgbmFtZXNwYWNlVVJJOiBIVE1MX05BTUVTUEFDRSxcbiAgICAgICAgdGFnTmFtZTogJ3RlbXBsYXRlJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgdGFnTmFtZSA9IHN0cmluZ1RvTG93ZXJDYXNlKGVsZW1lbnQudGFnTmFtZSk7XG4gICAgdmFyIHBhcmVudFRhZ05hbWUgPSBzdHJpbmdUb0xvd2VyQ2FzZShwYXJlbnQudGFnTmFtZSk7XG5cbiAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UpIHtcbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBIVE1MIG5hbWVzcGFjZSB0byBTVkdcbiAgICAgIC8vIGlzIHZpYSA8c3ZnPi4gSWYgaXQgaGFwcGVucyB2aWEgYW55IG90aGVyIHRhZywgdGhlblxuICAgICAgLy8gaXQgc2hvdWxkIGJlIGtpbGxlZC5cbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ3N2Zyc7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBNYXRoTUwgdG8gU1ZHIGlzIHZpYVxuICAgICAgLy8gc3ZnIGlmIHBhcmVudCBpcyBlaXRoZXIgPGFubm90YXRpb24teG1sPiBvciBNYXRoTUxcbiAgICAgIC8vIHRleHQgaW50ZWdyYXRpb24gcG9pbnRzLlxuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnICYmIChwYXJlbnRUYWdOYW1lID09PSAnYW5ub3RhdGlvbi14bWwnIHx8IE1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIG9ubHkgYWxsb3cgZWxlbWVudHMgdGhhdCBhcmUgZGVmaW5lZCBpbiBTVkdcbiAgICAgIC8vIHNwZWMuIEFsbCBvdGhlcnMgYXJlIGRpc2FsbG93ZWQgaW4gU1ZHIG5hbWVzcGFjZS5cbiAgICAgIHJldHVybiBCb29sZWFuKEFMTF9TVkdfVEFHU1t0YWdOYW1lXSk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gSFRNTCBuYW1lc3BhY2UgdG8gTWF0aE1MXG4gICAgICAvLyBpcyB2aWEgPG1hdGg+LiBJZiBpdCBoYXBwZW5zIHZpYSBhbnkgb3RoZXIgdGFnLCB0aGVuXG4gICAgICAvLyBpdCBzaG91bGQgYmUga2lsbGVkLlxuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnbWF0aCc7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBTVkcgdG8gTWF0aE1MIGlzIHZpYVxuICAgICAgLy8gPG1hdGg+IGFuZCBIVE1MIGludGVncmF0aW9uIHBvaW50c1xuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdtYXRoJyAmJiBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXTtcbiAgICAgIH1cblxuICAgICAgLy8gV2Ugb25seSBhbGxvdyBlbGVtZW50cyB0aGF0IGFyZSBkZWZpbmVkIGluIE1hdGhNTFxuICAgICAgLy8gc3BlYy4gQWxsIG90aGVycyBhcmUgZGlzYWxsb3dlZCBpbiBNYXRoTUwgbmFtZXNwYWNlLlxuICAgICAgcmV0dXJuIEJvb2xlYW4oQUxMX01BVEhNTF9UQUdTW3RhZ05hbWVdKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gU1ZHIHRvIEhUTUwgaXMgdmlhXG4gICAgICAvLyBIVE1MIGludGVncmF0aW9uIHBvaW50cywgYW5kIGZyb20gTWF0aE1MIHRvIEhUTUxcbiAgICAgIC8vIGlzIHZpYSBNYXRoTUwgdGV4dCBpbnRlZ3JhdGlvbiBwb2ludHNcbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFICYmICFIVE1MX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFICYmICFNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDZXJ0YWluIGVsZW1lbnRzIGFyZSBhbGxvd2VkIGluIGJvdGggU1ZHIGFuZCBIVE1MXG4gICAgICAvLyBuYW1lc3BhY2UuIFdlIG5lZWQgdG8gc3BlY2lmeSB0aGVtIGV4cGxpY2l0bHlcbiAgICAgIC8vIHNvIHRoYXQgdGhleSBkb24ndCBnZXQgZXJyb25vdXNseSBkZWxldGVkIGZyb21cbiAgICAgIC8vIEhUTUwgbmFtZXNwYWNlLlxuICAgICAgdmFyIGNvbW1vblN2Z0FuZEhUTUxFbGVtZW50cyA9IGFkZFRvU2V0KHt9LCBbJ3RpdGxlJywgJ3N0eWxlJywgJ2ZvbnQnLCAnYScsICdzY3JpcHQnXSk7XG5cbiAgICAgIC8vIFdlIGRpc2FsbG93IHRhZ3MgdGhhdCBhcmUgc3BlY2lmaWMgZm9yIE1hdGhNTFxuICAgICAgLy8gb3IgU1ZHIGFuZCBzaG91bGQgbmV2ZXIgYXBwZWFyIGluIEhUTUwgbmFtZXNwYWNlXG4gICAgICByZXR1cm4gIUFMTF9NQVRITUxfVEFHU1t0YWdOYW1lXSAmJiAoY29tbW9uU3ZnQW5kSFRNTEVsZW1lbnRzW3RhZ05hbWVdIHx8ICFBTExfU1ZHX1RBR1NbdGFnTmFtZV0pO1xuICAgIH1cblxuICAgIC8vIFRoZSBjb2RlIHNob3VsZCBuZXZlciByZWFjaCB0aGlzIHBsYWNlICh0aGlzIG1lYW5zXG4gICAgLy8gdGhhdCB0aGUgZWxlbWVudCBzb21laG93IGdvdCBuYW1lc3BhY2UgdGhhdCBpcyBub3RcbiAgICAvLyBIVE1MLCBTVkcgb3IgTWF0aE1MKS4gUmV0dXJuIGZhbHNlIGp1c3QgaW4gY2FzZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9mb3JjZVJlbW92ZVxuICAgKlxuICAgKiBAcGFyYW0gIHtOb2RlfSBub2RlIGEgRE9NIG5vZGVcbiAgICovXG4gIHZhciBfZm9yY2VSZW1vdmUgPSBmdW5jdGlvbiBfZm9yY2VSZW1vdmUobm9kZSkge1xuICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwgeyBlbGVtZW50OiBub2RlIH0pO1xuICAgIHRyeSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItZG9tLW5vZGUtcmVtb3ZlXG4gICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbm9kZS5vdXRlckhUTUwgPSBlbXB0eUhUTUw7XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBfcmVtb3ZlQXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBhbiBBdHRyaWJ1dGUgbmFtZVxuICAgKiBAcGFyYW0gIHtOb2RlfSBub2RlIGEgRE9NIG5vZGVcbiAgICovXG4gIHZhciBfcmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBub2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICBhdHRyaWJ1dGU6IG5vZGUuZ2V0QXR0cmlidXRlTm9kZShuYW1lKSxcbiAgICAgICAgZnJvbTogbm9kZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7XG4gICAgICAgIGF0dHJpYnV0ZTogbnVsbCxcbiAgICAgICAgZnJvbTogbm9kZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cbiAgICAvLyBXZSB2b2lkIGF0dHJpYnV0ZSB2YWx1ZXMgZm9yIHVucmVtb3ZhYmxlIFwiaXNcIlwiIGF0dHJpYnV0ZXNcbiAgICBpZiAobmFtZSA9PT0gJ2lzJyAmJiAhQUxMT1dFRF9BVFRSW25hbWVdKSB7XG4gICAgICBpZiAoUkVUVVJOX0RPTSB8fCBSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX2ZvcmNlUmVtb3ZlKG5vZGUpO1xuICAgICAgICB9IGNhdGNoIChfKSB7fVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBfaW5pdERvY3VtZW50XG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZGlydHkgYSBzdHJpbmcgb2YgZGlydHkgbWFya3VwXG4gICAqIEByZXR1cm4ge0RvY3VtZW50fSBhIERPTSwgZmlsbGVkIHdpdGggdGhlIGRpcnR5IG1hcmt1cFxuICAgKi9cbiAgdmFyIF9pbml0RG9jdW1lbnQgPSBmdW5jdGlvbiBfaW5pdERvY3VtZW50KGRpcnR5KSB7XG4gICAgLyogQ3JlYXRlIGEgSFRNTCBkb2N1bWVudCAqL1xuICAgIHZhciBkb2MgPSB2b2lkIDA7XG4gICAgdmFyIGxlYWRpbmdXaGl0ZXNwYWNlID0gdm9pZCAwO1xuXG4gICAgaWYgKEZPUkNFX0JPRFkpIHtcbiAgICAgIGRpcnR5ID0gJzxyZW1vdmU+PC9yZW1vdmU+JyArIGRpcnR5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBJZiBGT1JDRV9CT0RZIGlzbid0IHVzZWQsIGxlYWRpbmcgd2hpdGVzcGFjZSBuZWVkcyB0byBiZSBwcmVzZXJ2ZWQgbWFudWFsbHkgKi9cbiAgICAgIHZhciBtYXRjaGVzID0gc3RyaW5nTWF0Y2goZGlydHksIC9eW1xcclxcblxcdCBdKy8pO1xuICAgICAgbGVhZGluZ1doaXRlc3BhY2UgPSBtYXRjaGVzICYmIG1hdGNoZXNbMF07XG4gICAgfVxuXG4gICAgaWYgKFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJykge1xuICAgICAgLy8gUm9vdCBvZiBYSFRNTCBkb2MgbXVzdCBjb250YWluIHhtbG5zIGRlY2xhcmF0aW9uIChzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3hodG1sMS9ub3JtYXRpdmUuaHRtbCNzdHJpY3QpXG4gICAgICBkaXJ0eSA9ICc8aHRtbCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj48aGVhZD48L2hlYWQ+PGJvZHk+JyArIGRpcnR5ICsgJzwvYm9keT48L2h0bWw+JztcbiAgICB9XG5cbiAgICB2YXIgZGlydHlQYXlsb2FkID0gdHJ1c3RlZFR5cGVzUG9saWN5ID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoZGlydHkpIDogZGlydHk7XG4gICAgLypcbiAgICAgKiBVc2UgdGhlIERPTVBhcnNlciBBUEkgYnkgZGVmYXVsdCwgZmFsbGJhY2sgbGF0ZXIgaWYgbmVlZHMgYmVcbiAgICAgKiBET01QYXJzZXIgbm90IHdvcmsgZm9yIHN2ZyB3aGVuIGhhcyBtdWx0aXBsZSByb290IGVsZW1lbnQuXG4gICAgICovXG4gICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoZGlydHlQYXlsb2FkLCBQQVJTRVJfTUVESUFfVFlQRSk7XG4gICAgICB9IGNhdGNoIChfKSB7fVxuICAgIH1cblxuICAgIC8qIFVzZSBjcmVhdGVIVE1MRG9jdW1lbnQgaW4gY2FzZSBET01QYXJzZXIgaXMgbm90IGF2YWlsYWJsZSAqL1xuICAgIGlmICghZG9jIHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBkb2MgPSBpbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudChOQU1FU1BBQ0UsICd0ZW1wbGF0ZScsIG51bGwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9jLmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUwgPSBJU19FTVBUWV9JTlBVVCA/ICcnIDogZGlydHlQYXlsb2FkO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAvLyBTeW50YXggZXJyb3IgaWYgZGlydHlQYXlsb2FkIGlzIGludmFsaWQgeG1sXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJvZHkgPSBkb2MuYm9keSB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgaWYgKGRpcnR5ICYmIGxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICBib2R5Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsZWFkaW5nV2hpdGVzcGFjZSksIGJvZHkuY2hpbGROb2Rlc1swXSB8fCBudWxsKTtcbiAgICB9XG5cbiAgICAvKiBXb3JrIG9uIHdob2xlIGRvY3VtZW50IG9yIGp1c3QgaXRzIGJvZHkgKi9cbiAgICBpZiAoTkFNRVNQQUNFID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgcmV0dXJuIGdldEVsZW1lbnRzQnlUYWdOYW1lLmNhbGwoZG9jLCBXSE9MRV9ET0NVTUVOVCA/ICdodG1sJyA6ICdib2R5JylbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFdIT0xFX0RPQ1VNRU5UID8gZG9jLmRvY3VtZW50RWxlbWVudCA6IGJvZHk7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9jcmVhdGVJdGVyYXRvclxuICAgKlxuICAgKiBAcGFyYW0gIHtEb2N1bWVudH0gcm9vdCBkb2N1bWVudC9mcmFnbWVudCB0byBjcmVhdGUgaXRlcmF0b3IgZm9yXG4gICAqIEByZXR1cm4ge0l0ZXJhdG9yfSBpdGVyYXRvciBpbnN0YW5jZVxuICAgKi9cbiAgdmFyIF9jcmVhdGVJdGVyYXRvciA9IGZ1bmN0aW9uIF9jcmVhdGVJdGVyYXRvcihyb290KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGVJdGVyYXRvci5jYWxsKHJvb3Qub3duZXJEb2N1bWVudCB8fCByb290LCByb290LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19DT01NRU5UIHwgTm9kZUZpbHRlci5TSE9XX1RFWFQsIG51bGwsIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogX2lzQ2xvYmJlcmVkXG4gICAqXG4gICAqIEBwYXJhbSAge05vZGV9IGVsbSBlbGVtZW50IHRvIGNoZWNrIGZvciBjbG9iYmVyaW5nIGF0dGFja3NcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBjbG9iYmVyZWQsIGZhbHNlIGlmIHNhZmVcbiAgICovXG4gIHZhciBfaXNDbG9iYmVyZWQgPSBmdW5jdGlvbiBfaXNDbG9iYmVyZWQoZWxtKSB7XG4gICAgaWYgKGVsbSBpbnN0YW5jZW9mIFRleHQgfHwgZWxtIGluc3RhbmNlb2YgQ29tbWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZWxtLm5vZGVOYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxtLnRleHRDb250ZW50ICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxtLnJlbW92ZUNoaWxkICE9PSAnZnVuY3Rpb24nIHx8ICEoZWxtLmF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBOYW1lZE5vZGVNYXApIHx8IHR5cGVvZiBlbG0ucmVtb3ZlQXR0cmlidXRlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbG0uc2V0QXR0cmlidXRlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbG0ubmFtZXNwYWNlVVJJICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxtLmluc2VydEJlZm9yZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBfaXNOb2RlXG4gICAqXG4gICAqIEBwYXJhbSAge05vZGV9IG9iaiBvYmplY3QgdG8gY2hlY2sgd2hldGhlciBpdCdzIGEgRE9NIG5vZGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpcyBvYmplY3QgaXMgYSBET00gbm9kZVxuICAgKi9cbiAgdmFyIF9pc05vZGUgPSBmdW5jdGlvbiBfaXNOb2RlKG9iamVjdCkge1xuICAgIHJldHVybiAodHlwZW9mIE5vZGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKE5vZGUpKSA9PT0gJ29iamVjdCcgPyBvYmplY3QgaW5zdGFuY2VvZiBOb2RlIDogb2JqZWN0ICYmICh0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmplY3QpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9leGVjdXRlSG9va1xuICAgKiBFeGVjdXRlIHVzZXIgY29uZmlndXJhYmxlIGhvb2tzXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZW50cnlQb2ludCAgTmFtZSBvZiB0aGUgaG9vaydzIGVudHJ5IHBvaW50XG4gICAqIEBwYXJhbSAge05vZGV9IGN1cnJlbnROb2RlIG5vZGUgdG8gd29yayBvbiB3aXRoIHRoZSBob29rXG4gICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBhZGRpdGlvbmFsIGhvb2sgcGFyYW1ldGVyc1xuICAgKi9cbiAgdmFyIF9leGVjdXRlSG9vayA9IGZ1bmN0aW9uIF9leGVjdXRlSG9vayhlbnRyeVBvaW50LCBjdXJyZW50Tm9kZSwgZGF0YSkge1xuICAgIGlmICghaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhcnJheUZvckVhY2goaG9va3NbZW50cnlQb2ludF0sIGZ1bmN0aW9uIChob29rKSB7XG4gICAgICBob29rLmNhbGwoRE9NUHVyaWZ5LCBjdXJyZW50Tm9kZSwgZGF0YSwgQ09ORklHKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogX3Nhbml0aXplRWxlbWVudHNcbiAgICpcbiAgICogQHByb3RlY3Qgbm9kZU5hbWVcbiAgICogQHByb3RlY3QgdGV4dENvbnRlbnRcbiAgICogQHByb3RlY3QgcmVtb3ZlQ2hpbGRcbiAgICpcbiAgICogQHBhcmFtICAge05vZGV9IGN1cnJlbnROb2RlIHRvIGNoZWNrIGZvciBwZXJtaXNzaW9uIHRvIGV4aXN0XG4gICAqIEByZXR1cm4gIHtCb29sZWFufSB0cnVlIGlmIG5vZGUgd2FzIGtpbGxlZCwgZmFsc2UgaWYgbGVmdCBhbGl2ZVxuICAgKi9cbiAgdmFyIF9zYW5pdGl6ZUVsZW1lbnRzID0gZnVuY3Rpb24gX3Nhbml0aXplRWxlbWVudHMoY3VycmVudE5vZGUpIHtcbiAgICB2YXIgY29udGVudCA9IHZvaWQgMDtcblxuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2soJ2JlZm9yZVNhbml0aXplRWxlbWVudHMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG5cbiAgICAvKiBDaGVjayBpZiBlbGVtZW50IGlzIGNsb2JiZXJlZCBvciBjYW4gY2xvYmJlciAqL1xuICAgIGlmIChfaXNDbG9iYmVyZWQoY3VycmVudE5vZGUpKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyogQ2hlY2sgaWYgdGFnbmFtZSBjb250YWlucyBVbmljb2RlICovXG4gICAgaWYgKHN0cmluZ01hdGNoKGN1cnJlbnROb2RlLm5vZGVOYW1lLCAvW1xcdTAwODAtXFx1RkZGRl0vKSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qIE5vdyBsZXQncyBjaGVjayB0aGUgZWxlbWVudCdzIHR5cGUgYW5kIG5hbWUgKi9cbiAgICB2YXIgdGFnTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcblxuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2soJ3Vwb25TYW5pdGl6ZUVsZW1lbnQnLCBjdXJyZW50Tm9kZSwge1xuICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgIGFsbG93ZWRUYWdzOiBBTExPV0VEX1RBR1NcbiAgICB9KTtcblxuICAgIC8qIERldGVjdCBtWFNTIGF0dGVtcHRzIGFidXNpbmcgbmFtZXNwYWNlIGNvbmZ1c2lvbiAqL1xuICAgIGlmICghX2lzTm9kZShjdXJyZW50Tm9kZS5maXJzdEVsZW1lbnRDaGlsZCkgJiYgKCFfaXNOb2RlKGN1cnJlbnROb2RlLmNvbnRlbnQpIHx8ICFfaXNOb2RlKGN1cnJlbnROb2RlLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGQpKSAmJiByZWdFeHBUZXN0KC88Wy9cXHddL2csIGN1cnJlbnROb2RlLmlubmVySFRNTCkgJiYgcmVnRXhwVGVzdCgvPFsvXFx3XS9nLCBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBNaXRpZ2F0ZSBhIHByb2JsZW0gd2l0aCB0ZW1wbGF0ZXMgaW5zaWRlIHNlbGVjdCAqL1xuICAgIGlmICh0YWdOYW1lID09PSAnc2VsZWN0JyAmJiByZWdFeHBUZXN0KC88dGVtcGxhdGUvaSwgY3VycmVudE5vZGUuaW5uZXJIVE1MKSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qIFJlbW92ZSBlbGVtZW50IGlmIGFueXRoaW5nIGZvcmJpZHMgaXRzIHByZXNlbmNlICovXG4gICAgaWYgKCFBTExPV0VEX1RBR1NbdGFnTmFtZV0gfHwgRk9SQklEX1RBR1NbdGFnTmFtZV0pIHtcbiAgICAgIC8qIEtlZXAgY29udGVudCBleGNlcHQgZm9yIGJhZC1saXN0ZWQgZWxlbWVudHMgKi9cbiAgICAgIGlmIChLRUVQX0NPTlRFTlQgJiYgIUZPUkJJRF9DT05URU5UU1t0YWdOYW1lXSkge1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpIHx8IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gZ2V0Q2hpbGROb2RlcyhjdXJyZW50Tm9kZSkgfHwgY3VycmVudE5vZGUuY2hpbGROb2RlcztcblxuICAgICAgICBpZiAoY2hpbGROb2RlcyAmJiBwYXJlbnROb2RlKSB7XG4gICAgICAgICAgdmFyIGNoaWxkQ291bnQgPSBjaGlsZE5vZGVzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSBjaGlsZENvdW50IC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNsb25lTm9kZShjaGlsZE5vZGVzW2ldLCB0cnVlKSwgZ2V0TmV4dFNpYmxpbmcoY3VycmVudE5vZGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qIENoZWNrIHdoZXRoZXIgZWxlbWVudCBoYXMgYSB2YWxpZCBuYW1lc3BhY2UgKi9cbiAgICBpZiAoY3VycmVudE5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmICFfY2hlY2tWYWxpZE5hbWVzcGFjZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoKHRhZ05hbWUgPT09ICdub3NjcmlwdCcgfHwgdGFnTmFtZSA9PT0gJ25vZW1iZWQnKSAmJiByZWdFeHBUZXN0KC88XFwvbm8oc2NyaXB0fGVtYmVkKS9pLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyogU2FuaXRpemUgZWxlbWVudCBjb250ZW50IHRvIGJlIHRlbXBsYXRlLXNhZmUgKi9cbiAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTICYmIGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAvKiBHZXQgdGhlIGVsZW1lbnQncyB0ZXh0IGNvbnRlbnQgKi9cbiAgICAgIGNvbnRlbnQgPSBjdXJyZW50Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgIGNvbnRlbnQgPSBzdHJpbmdSZXBsYWNlKGNvbnRlbnQsIE1VU1RBQ0hFX0VYUFIkJDEsICcgJyk7XG4gICAgICBjb250ZW50ID0gc3RyaW5nUmVwbGFjZShjb250ZW50LCBFUkJfRVhQUiQkMSwgJyAnKTtcbiAgICAgIGlmIChjdXJyZW50Tm9kZS50ZXh0Q29udGVudCAhPT0gY29udGVudCkge1xuICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHsgZWxlbWVudDogY3VycmVudE5vZGUuY2xvbmVOb2RlKCkgfSk7XG4gICAgICAgIGN1cnJlbnROb2RlLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCdhZnRlclNhbml0aXplRWxlbWVudHMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9pc1ZhbGlkQXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbGNUYWcgTG93ZXJjYXNlIHRhZyBuYW1lIG9mIGNvbnRhaW5pbmcgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBsY05hbWUgTG93ZXJjYXNlIGF0dHJpYnV0ZSBuYW1lLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIHZhciBfaXNWYWxpZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKSB7XG4gICAgLyogTWFrZSBzdXJlIGF0dHJpYnV0ZSBjYW5ub3QgY2xvYmJlciAqL1xuICAgIGlmIChTQU5JVElaRV9ET00gJiYgKGxjTmFtZSA9PT0gJ2lkJyB8fCBsY05hbWUgPT09ICduYW1lJykgJiYgKHZhbHVlIGluIGRvY3VtZW50IHx8IHZhbHVlIGluIGZvcm1FbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qIEFsbG93IHZhbGlkIGRhdGEtKiBhdHRyaWJ1dGVzOiBBdCBsZWFzdCBvbmUgY2hhcmFjdGVyIGFmdGVyIFwiLVwiXG4gICAgICAgIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNlbWJlZGRpbmctY3VzdG9tLW5vbi12aXNpYmxlLWRhdGEtd2l0aC10aGUtZGF0YS0qLWF0dHJpYnV0ZXMpXG4gICAgICAgIFhNTC1jb21wYXRpYmxlIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmZyYXN0cnVjdHVyZS5odG1sI3htbC1jb21wYXRpYmxlIGFuZCBodHRwOi8vd3d3LnczLm9yZy9UUi94bWwvI2QwZTgwNClcbiAgICAgICAgV2UgZG9uJ3QgbmVlZCB0byBjaGVjayB0aGUgdmFsdWU7IGl0J3MgYWx3YXlzIFVSSSBzYWZlLiAqL1xuICAgIGlmIChBTExPV19EQVRBX0FUVFIgJiYgIUZPUkJJRF9BVFRSW2xjTmFtZV0gJiYgcmVnRXhwVGVzdChEQVRBX0FUVFIkJDEsIGxjTmFtZSkpIDsgZWxzZSBpZiAoQUxMT1dfQVJJQV9BVFRSICYmIHJlZ0V4cFRlc3QoQVJJQV9BVFRSJCQxLCBsY05hbWUpKSA7IGVsc2UgaWYgKCFBTExPV0VEX0FUVFJbbGNOYW1lXSB8fCBGT1JCSURfQVRUUltsY05hbWVdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8qIENoZWNrIHZhbHVlIGlzIHNhZmUuIEZpcnN0LCBpcyBhdHRyIGluZXJ0PyBJZiBzbywgaXMgc2FmZSAqL1xuICAgIH0gZWxzZSBpZiAoVVJJX1NBRkVfQVRUUklCVVRFU1tsY05hbWVdKSA7IGVsc2UgaWYgKHJlZ0V4cFRlc3QoSVNfQUxMT1dFRF9VUkkkJDEsIHN0cmluZ1JlcGxhY2UodmFsdWUsIEFUVFJfV0hJVEVTUEFDRSQkMSwgJycpKSkgOyBlbHNlIGlmICgobGNOYW1lID09PSAnc3JjJyB8fCBsY05hbWUgPT09ICd4bGluazpocmVmJyB8fCBsY05hbWUgPT09ICdocmVmJykgJiYgbGNUYWcgIT09ICdzY3JpcHQnICYmIHN0cmluZ0luZGV4T2YodmFsdWUsICdkYXRhOicpID09PSAwICYmIERBVEFfVVJJX1RBR1NbbGNUYWddKSA7IGVsc2UgaWYgKEFMTE9XX1VOS05PV05fUFJPVE9DT0xTICYmICFyZWdFeHBUZXN0KElTX1NDUklQVF9PUl9EQVRBJCQxLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UkJDEsICcnKSkpIDsgZWxzZSBpZiAoIXZhbHVlKSA7IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBfc2FuaXRpemVBdHRyaWJ1dGVzXG4gICAqXG4gICAqIEBwcm90ZWN0IGF0dHJpYnV0ZXNcbiAgICogQHByb3RlY3Qgbm9kZU5hbWVcbiAgICogQHByb3RlY3QgcmVtb3ZlQXR0cmlidXRlXG4gICAqIEBwcm90ZWN0IHNldEF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0gIHtOb2RlfSBjdXJyZW50Tm9kZSB0byBzYW5pdGl6ZVxuICAgKi9cbiAgdmFyIF9zYW5pdGl6ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBfc2FuaXRpemVBdHRyaWJ1dGVzKGN1cnJlbnROb2RlKSB7XG4gICAgdmFyIGF0dHIgPSB2b2lkIDA7XG4gICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgIHZhciBsY05hbWUgPSB2b2lkIDA7XG4gICAgdmFyIGwgPSB2b2lkIDA7XG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9vaygnYmVmb3JlU2FuaXRpemVBdHRyaWJ1dGVzJywgY3VycmVudE5vZGUsIG51bGwpO1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBjdXJyZW50Tm9kZS5hdHRyaWJ1dGVzO1xuXG4gICAgLyogQ2hlY2sgaWYgd2UgaGF2ZSBhdHRyaWJ1dGVzOyBpZiBub3Qgd2UgbWlnaHQgaGF2ZSBhIHRleHQgbm9kZSAqL1xuXG4gICAgaWYgKCFhdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhvb2tFdmVudCA9IHtcbiAgICAgIGF0dHJOYW1lOiAnJyxcbiAgICAgIGF0dHJWYWx1ZTogJycsXG4gICAgICBrZWVwQXR0cjogdHJ1ZSxcbiAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBBTExPV0VEX0FUVFJcbiAgICB9O1xuICAgIGwgPSBhdHRyaWJ1dGVzLmxlbmd0aDtcblxuICAgIC8qIEdvIGJhY2t3YXJkcyBvdmVyIGFsbCBhdHRyaWJ1dGVzOyBzYWZlbHkgcmVtb3ZlIGJhZCBvbmVzICovXG4gICAgd2hpbGUgKGwtLSkge1xuICAgICAgYXR0ciA9IGF0dHJpYnV0ZXNbbF07XG4gICAgICB2YXIgX2F0dHIgPSBhdHRyLFxuICAgICAgICAgIG5hbWUgPSBfYXR0ci5uYW1lLFxuICAgICAgICAgIG5hbWVzcGFjZVVSSSA9IF9hdHRyLm5hbWVzcGFjZVVSSTtcblxuICAgICAgdmFsdWUgPSBzdHJpbmdUcmltKGF0dHIudmFsdWUpO1xuICAgICAgbGNOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMobmFtZSk7XG5cbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgIGhvb2tFdmVudC5hdHRyTmFtZSA9IGxjTmFtZTtcbiAgICAgIGhvb2tFdmVudC5hdHRyVmFsdWUgPSB2YWx1ZTtcbiAgICAgIGhvb2tFdmVudC5rZWVwQXR0ciA9IHRydWU7XG4gICAgICBob29rRXZlbnQuZm9yY2VLZWVwQXR0ciA9IHVuZGVmaW5lZDsgLy8gQWxsb3dzIGRldmVsb3BlcnMgdG8gc2VlIHRoaXMgaXMgYSBwcm9wZXJ0eSB0aGV5IGNhbiBzZXRcbiAgICAgIF9leGVjdXRlSG9vaygndXBvblNhbml0aXplQXR0cmlidXRlJywgY3VycmVudE5vZGUsIGhvb2tFdmVudCk7XG4gICAgICB2YWx1ZSA9IGhvb2tFdmVudC5hdHRyVmFsdWU7XG4gICAgICAvKiBEaWQgdGhlIGhvb2tzIGFwcHJvdmUgb2YgdGhlIGF0dHJpYnV0ZT8gKi9cbiAgICAgIGlmIChob29rRXZlbnQuZm9yY2VLZWVwQXR0cikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLyogUmVtb3ZlIGF0dHJpYnV0ZSAqL1xuICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG5cbiAgICAgIC8qIERpZCB0aGUgaG9va3MgYXBwcm92ZSBvZiB0aGUgYXR0cmlidXRlPyAqL1xuICAgICAgaWYgKCFob29rRXZlbnQua2VlcEF0dHIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIFdvcmsgYXJvdW5kIGEgc2VjdXJpdHkgaXNzdWUgaW4galF1ZXJ5IDMuMCAqL1xuICAgICAgaWYgKHJlZ0V4cFRlc3QoL1xcLz4vaSwgdmFsdWUpKSB7XG4gICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLyogU2FuaXRpemUgYXR0cmlidXRlIGNvbnRlbnQgdG8gYmUgdGVtcGxhdGUtc2FmZSAqL1xuICAgICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgICB2YWx1ZSA9IHN0cmluZ1JlcGxhY2UodmFsdWUsIE1VU1RBQ0hFX0VYUFIkJDEsICcgJyk7XG4gICAgICAgIHZhbHVlID0gc3RyaW5nUmVwbGFjZSh2YWx1ZSwgRVJCX0VYUFIkJDEsICcgJyk7XG4gICAgICB9XG5cbiAgICAgIC8qIElzIGB2YWx1ZWAgdmFsaWQgZm9yIHRoaXMgYXR0cmlidXRlPyAqL1xuICAgICAgdmFyIGxjVGFnID0gdHJhbnNmb3JtQ2FzZUZ1bmMoY3VycmVudE5vZGUubm9kZU5hbWUpO1xuICAgICAgaWYgKCFfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIEhhbmRsZSBpbnZhbGlkIGRhdGEtKiBhdHRyaWJ1dGUgc2V0IGJ5IHRyeS1jYXRjaGluZyBpdCAqL1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgIGN1cnJlbnROb2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIEZhbGxiYWNrIHRvIHNldEF0dHJpYnV0ZSgpIGZvciBicm93c2VyLXVucmVjb2duaXplZCBuYW1lc3BhY2VzIGUuZy4gXCJ4LXNjaGVtYVwiLiAqL1xuICAgICAgICAgIGN1cnJlbnROb2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVBvcChET01QdXJpZnkucmVtb3ZlZCk7XG4gICAgICB9IGNhdGNoIChfKSB7fVxuICAgIH1cblxuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVBdHRyaWJ1dGVzJywgY3VycmVudE5vZGUsIG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBfc2FuaXRpemVTaGFkb3dET01cbiAgICpcbiAgICogQHBhcmFtICB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ21lbnQgdG8gaXRlcmF0ZSBvdmVyIHJlY3Vyc2l2ZWx5XG4gICAqL1xuICB2YXIgX3Nhbml0aXplU2hhZG93RE9NID0gZnVuY3Rpb24gX3Nhbml0aXplU2hhZG93RE9NKGZyYWdtZW50KSB7XG4gICAgdmFyIHNoYWRvd05vZGUgPSB2b2lkIDA7XG4gICAgdmFyIHNoYWRvd0l0ZXJhdG9yID0gX2NyZWF0ZUl0ZXJhdG9yKGZyYWdtZW50KTtcblxuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2soJ2JlZm9yZVNhbml0aXplU2hhZG93RE9NJywgZnJhZ21lbnQsIG51bGwpO1xuXG4gICAgd2hpbGUgKHNoYWRvd05vZGUgPSBzaGFkb3dJdGVyYXRvci5uZXh0Tm9kZSgpKSB7XG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBfZXhlY3V0ZUhvb2soJ3Vwb25TYW5pdGl6ZVNoYWRvd05vZGUnLCBzaGFkb3dOb2RlLCBudWxsKTtcblxuICAgICAgLyogU2FuaXRpemUgdGFncyBhbmQgZWxlbWVudHMgKi9cbiAgICAgIGlmIChfc2FuaXRpemVFbGVtZW50cyhzaGFkb3dOb2RlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLyogRGVlcCBzaGFkb3cgRE9NIGRldGVjdGVkICovXG4gICAgICBpZiAoc2hhZG93Tm9kZS5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICBfc2FuaXRpemVTaGFkb3dET00oc2hhZG93Tm9kZS5jb250ZW50KTtcbiAgICAgIH1cblxuICAgICAgLyogQ2hlY2sgYXR0cmlidXRlcywgc2FuaXRpemUgaWYgbmVjZXNzYXJ5ICovXG4gICAgICBfc2FuaXRpemVBdHRyaWJ1dGVzKHNoYWRvd05vZGUpO1xuICAgIH1cblxuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVTaGFkb3dET00nLCBmcmFnbWVudCwgbnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNhbml0aXplXG4gICAqIFB1YmxpYyBtZXRob2QgcHJvdmlkaW5nIGNvcmUgc2FuaXRhdGlvbiBmdW5jdGlvbmFsaXR5XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE5vZGV9IGRpcnR5IHN0cmluZyBvciBET00gbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIERPTVB1cmlmeS5zYW5pdGl6ZSA9IGZ1bmN0aW9uIChkaXJ0eSwgY2ZnKSB7XG4gICAgdmFyIGJvZHkgPSB2b2lkIDA7XG4gICAgdmFyIGltcG9ydGVkTm9kZSA9IHZvaWQgMDtcbiAgICB2YXIgY3VycmVudE5vZGUgPSB2b2lkIDA7XG4gICAgdmFyIG9sZE5vZGUgPSB2b2lkIDA7XG4gICAgdmFyIHJldHVybk5vZGUgPSB2b2lkIDA7XG4gICAgLyogTWFrZSBzdXJlIHdlIGhhdmUgYSBzdHJpbmcgdG8gc2FuaXRpemUuXG4gICAgICBETyBOT1QgcmV0dXJuIGVhcmx5LCBhcyB0aGlzIHdpbGwgcmV0dXJuIHRoZSB3cm9uZyB0eXBlIGlmXG4gICAgICB0aGUgdXNlciBoYXMgcmVxdWVzdGVkIGEgRE9NIG9iamVjdCByYXRoZXIgdGhhbiBhIHN0cmluZyAqL1xuICAgIElTX0VNUFRZX0lOUFVUID0gIWRpcnR5O1xuICAgIGlmIChJU19FTVBUWV9JTlBVVCkge1xuICAgICAgZGlydHkgPSAnPCEtLT4nO1xuICAgIH1cblxuICAgIC8qIFN0cmluZ2lmeSwgaW4gY2FzZSBkaXJ0eSBpcyBhbiBvYmplY3QgKi9cbiAgICBpZiAodHlwZW9mIGRpcnR5ICE9PSAnc3RyaW5nJyAmJiAhX2lzTm9kZShkaXJ0eSkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZWdhdGVkLWNvbmRpdGlvblxuICAgICAgaWYgKHR5cGVvZiBkaXJ0eS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ3RvU3RyaW5nIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJ0eSA9IGRpcnR5LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGlydHkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCdkaXJ0eSBpcyBub3QgYSBzdHJpbmcsIGFib3J0aW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBDaGVjayB3ZSBjYW4gcnVuLiBPdGhlcndpc2UgZmFsbCBiYWNrIG9yIGlnbm9yZSAqL1xuICAgIGlmICghRE9NUHVyaWZ5LmlzU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoX3R5cGVvZih3aW5kb3cudG9TdGF0aWNIVE1MKSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHdpbmRvdy50b1N0YXRpY0hUTUwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkaXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LnRvU3RhdGljSFRNTChkaXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2lzTm9kZShkaXJ0eSkpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LnRvU3RhdGljSFRNTChkaXJ0eS5vdXRlckhUTUwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaXJ0eTtcbiAgICB9XG5cbiAgICAvKiBBc3NpZ24gY29uZmlnIHZhcnMgKi9cbiAgICBpZiAoIVNFVF9DT05GSUcpIHtcbiAgICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgIH1cblxuICAgIC8qIENsZWFuIHVwIHJlbW92ZWQgZWxlbWVudHMgKi9cbiAgICBET01QdXJpZnkucmVtb3ZlZCA9IFtdO1xuXG4gICAgLyogQ2hlY2sgaWYgZGlydHkgaXMgY29ycmVjdGx5IHR5cGVkIGZvciBJTl9QTEFDRSAqL1xuICAgIGlmICh0eXBlb2YgZGlydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBJTl9QTEFDRSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChJTl9QTEFDRSkgOyBlbHNlIGlmIChkaXJ0eSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgIC8qIElmIGRpcnR5IGlzIGEgRE9NIGVsZW1lbnQsIGFwcGVuZCB0byBhbiBlbXB0eSBkb2N1bWVudCB0byBhdm9pZFxuICAgICAgICAgZWxlbWVudHMgYmVpbmcgc3RyaXBwZWQgYnkgdGhlIHBhcnNlciAqL1xuICAgICAgYm9keSA9IF9pbml0RG9jdW1lbnQoJzwhLS0tLT4nKTtcbiAgICAgIGltcG9ydGVkTm9kZSA9IGJvZHkub3duZXJEb2N1bWVudC5pbXBvcnROb2RlKGRpcnR5LCB0cnVlKTtcbiAgICAgIGlmIChpbXBvcnRlZE5vZGUubm9kZVR5cGUgPT09IDEgJiYgaW1wb3J0ZWROb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgLyogTm9kZSBpcyBhbHJlYWR5IGEgYm9keSwgdXNlIGFzIGlzICovXG4gICAgICAgIGJvZHkgPSBpbXBvcnRlZE5vZGU7XG4gICAgICB9IGVsc2UgaWYgKGltcG9ydGVkTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICAgIGJvZHkgPSBpbXBvcnRlZE5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItZG9tLW5vZGUtYXBwZW5kXG4gICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoaW1wb3J0ZWROb2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogRXhpdCBkaXJlY3RseSBpZiB3ZSBoYXZlIG5vdGhpbmcgdG8gZG8gKi9cbiAgICAgIGlmICghUkVUVVJOX0RPTSAmJiAhU0FGRV9GT1JfVEVNUExBVEVTICYmICFXSE9MRV9ET0NVTUVOVCAmJlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWluY2x1ZGVzXG4gICAgICBkaXJ0eS5pbmRleE9mKCc8JykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKGRpcnR5KSA6IGRpcnR5O1xuICAgICAgfVxuXG4gICAgICAvKiBJbml0aWFsaXplIHRoZSBkb2N1bWVudCB0byB3b3JrIG9uICovXG4gICAgICBib2R5ID0gX2luaXREb2N1bWVudChkaXJ0eSk7XG5cbiAgICAgIC8qIENoZWNrIHdlIGhhdmUgYSBET00gbm9kZSBmcm9tIHRoZSBkYXRhICovXG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgcmV0dXJuIFJFVFVSTl9ET00gPyBudWxsIDogZW1wdHlIVE1MO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIFJlbW92ZSBmaXJzdCBlbGVtZW50IG5vZGUgKG91cnMpIGlmIEZPUkNFX0JPRFkgaXMgc2V0ICovXG4gICAgaWYgKGJvZHkgJiYgRk9SQ0VfQk9EWSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgLyogR2V0IG5vZGUgaXRlcmF0b3IgKi9cbiAgICB2YXIgbm9kZUl0ZXJhdG9yID0gX2NyZWF0ZUl0ZXJhdG9yKElOX1BMQUNFID8gZGlydHkgOiBib2R5KTtcblxuICAgIC8qIE5vdyBzdGFydCBpdGVyYXRpbmcgb3ZlciB0aGUgY3JlYXRlZCBkb2N1bWVudCAqL1xuICAgIHdoaWxlIChjdXJyZW50Tm9kZSA9IG5vZGVJdGVyYXRvci5uZXh0Tm9kZSgpKSB7XG4gICAgICAvKiBGaXggSUUncyBzdHJhbmdlIGJlaGF2aW9yIHdpdGggbWFuaXB1bGF0ZWQgdGV4dE5vZGVzICM4OSAqL1xuICAgICAgaWYgKGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSAzICYmIGN1cnJlbnROb2RlID09PSBvbGROb2RlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBTYW5pdGl6ZSB0YWdzIGFuZCBlbGVtZW50cyAqL1xuICAgICAgaWYgKF9zYW5pdGl6ZUVsZW1lbnRzKGN1cnJlbnROb2RlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLyogU2hhZG93IERPTSBkZXRlY3RlZCwgc2FuaXRpemUgaXQgKi9cbiAgICAgIGlmIChjdXJyZW50Tm9kZS5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICBfc2FuaXRpemVTaGFkb3dET00oY3VycmVudE5vZGUuY29udGVudCk7XG4gICAgICB9XG5cbiAgICAgIC8qIENoZWNrIGF0dHJpYnV0ZXMsIHNhbml0aXplIGlmIG5lY2Vzc2FyeSAqL1xuICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhjdXJyZW50Tm9kZSk7XG5cbiAgICAgIG9sZE5vZGUgPSBjdXJyZW50Tm9kZTtcbiAgICB9XG5cbiAgICBvbGROb2RlID0gbnVsbDtcblxuICAgIC8qIElmIHdlIHNhbml0aXplZCBgZGlydHlgIGluLXBsYWNlLCByZXR1cm4gaXQuICovXG4gICAgaWYgKElOX1BMQUNFKSB7XG4gICAgICByZXR1cm4gZGlydHk7XG4gICAgfVxuXG4gICAgLyogUmV0dXJuIHNhbml0aXplZCBzdHJpbmcgb3IgRE9NICovXG4gICAgaWYgKFJFVFVSTl9ET00pIHtcbiAgICAgIGlmIChSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7XG4gICAgICAgIHJldHVybk5vZGUgPSBjcmVhdGVEb2N1bWVudEZyYWdtZW50LmNhbGwoYm9keS5vd25lckRvY3VtZW50KTtcblxuICAgICAgICB3aGlsZSAoYm9keS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLWFwcGVuZFxuICAgICAgICAgIHJldHVybk5vZGUuYXBwZW5kQ2hpbGQoYm9keS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuTm9kZSA9IGJvZHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChSRVRVUk5fRE9NX0lNUE9SVCkge1xuICAgICAgICAvKlxuICAgICAgICAgIEFkb3B0Tm9kZSgpIGlzIG5vdCB1c2VkIGJlY2F1c2UgaW50ZXJuYWwgc3RhdGUgaXMgbm90IHJlc2V0XG4gICAgICAgICAgKGUuZy4gdGhlIHBhc3QgbmFtZXMgbWFwIG9mIGEgSFRNTEZvcm1FbGVtZW50KSwgdGhpcyBpcyBzYWZlXG4gICAgICAgICAgaW4gdGhlb3J5IGJ1dCB3ZSB3b3VsZCByYXRoZXIgbm90IHJpc2sgYW5vdGhlciBhdHRhY2sgdmVjdG9yLlxuICAgICAgICAgIFRoZSBzdGF0ZSB0aGF0IGlzIGNsb25lZCBieSBpbXBvcnROb2RlKCkgaXMgZXhwbGljaXRseSBkZWZpbmVkXG4gICAgICAgICAgYnkgdGhlIHNwZWNzLlxuICAgICAgICAqL1xuICAgICAgICByZXR1cm5Ob2RlID0gaW1wb3J0Tm9kZS5jYWxsKG9yaWdpbmFsRG9jdW1lbnQsIHJldHVybk5vZGUsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0dXJuTm9kZTtcbiAgICB9XG5cbiAgICB2YXIgc2VyaWFsaXplZEhUTUwgPSBXSE9MRV9ET0NVTUVOVCA/IGJvZHkub3V0ZXJIVE1MIDogYm9keS5pbm5lckhUTUw7XG5cbiAgICAvKiBTYW5pdGl6ZSBmaW5hbCBzdHJpbmcgdGVtcGxhdGUtc2FmZSAqL1xuICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgIHNlcmlhbGl6ZWRIVE1MID0gc3RyaW5nUmVwbGFjZShzZXJpYWxpemVkSFRNTCwgTVVTVEFDSEVfRVhQUiQkMSwgJyAnKTtcbiAgICAgIHNlcmlhbGl6ZWRIVE1MID0gc3RyaW5nUmVwbGFjZShzZXJpYWxpemVkSFRNTCwgRVJCX0VYUFIkJDEsICcgJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoc2VyaWFsaXplZEhUTUwpIDogc2VyaWFsaXplZEhUTUw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtZXRob2QgdG8gc2V0IHRoZSBjb25maWd1cmF0aW9uIG9uY2VcbiAgICogc2V0Q29uZmlnXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIERPTVB1cmlmeS5zZXRDb25maWcgPSBmdW5jdGlvbiAoY2ZnKSB7XG4gICAgX3BhcnNlQ29uZmlnKGNmZyk7XG4gICAgU0VUX0NPTkZJRyA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtZXRob2QgdG8gcmVtb3ZlIHRoZSBjb25maWd1cmF0aW9uXG4gICAqIGNsZWFyQ29uZmlnXG4gICAqXG4gICAqL1xuICBET01QdXJpZnkuY2xlYXJDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgQ09ORklHID0gbnVsbDtcbiAgICBTRVRfQ09ORklHID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtZXRob2QgdG8gY2hlY2sgaWYgYW4gYXR0cmlidXRlIHZhbHVlIGlzIHZhbGlkLlxuICAgKiBVc2VzIGxhc3Qgc2V0IGNvbmZpZywgaWYgYW55LiBPdGhlcndpc2UsIHVzZXMgY29uZmlnIGRlZmF1bHRzLlxuICAgKiBpc1ZhbGlkQXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdGFnIFRhZyBuYW1lIG9mIGNvbnRhaW5pbmcgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBhdHRyIEF0dHJpYnV0ZSBuYW1lLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQuIE90aGVyd2lzZSwgcmV0dXJucyBmYWxzZS5cbiAgICovXG4gIERPTVB1cmlmeS5pc1ZhbGlkQXR0cmlidXRlID0gZnVuY3Rpb24gKHRhZywgYXR0ciwgdmFsdWUpIHtcbiAgICAvKiBJbml0aWFsaXplIHNoYXJlZCBjb25maWcgdmFycyBpZiBuZWNlc3NhcnkuICovXG4gICAgaWYgKCFDT05GSUcpIHtcbiAgICAgIF9wYXJzZUNvbmZpZyh7fSk7XG4gICAgfVxuXG4gICAgdmFyIGxjVGFnID0gdHJhbnNmb3JtQ2FzZUZ1bmModGFnKTtcbiAgICB2YXIgbGNOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoYXR0cik7XG4gICAgcmV0dXJuIF9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkSG9va1xuICAgKiBQdWJsaWMgbWV0aG9kIHRvIGFkZCBET01QdXJpZnkgaG9va3NcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVudHJ5UG9pbnQgZW50cnkgcG9pbnQgZm9yIHRoZSBob29rIHRvIGFkZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rRnVuY3Rpb24gZnVuY3Rpb24gdG8gZXhlY3V0ZVxuICAgKi9cbiAgRE9NUHVyaWZ5LmFkZEhvb2sgPSBmdW5jdGlvbiAoZW50cnlQb2ludCwgaG9va0Z1bmN0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBob29rRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBob29rc1tlbnRyeVBvaW50XSA9IGhvb2tzW2VudHJ5UG9pbnRdIHx8IFtdO1xuICAgIGFycmF5UHVzaChob29rc1tlbnRyeVBvaW50XSwgaG9va0Z1bmN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlSG9va1xuICAgKiBQdWJsaWMgbWV0aG9kIHRvIHJlbW92ZSBhIERPTVB1cmlmeSBob29rIGF0IGEgZ2l2ZW4gZW50cnlQb2ludFxuICAgKiAocG9wcyBpdCBmcm9tIHRoZSBzdGFjayBvZiBob29rcyBpZiBtb3JlIGFyZSBwcmVzZW50KVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW50cnlQb2ludCBlbnRyeSBwb2ludCBmb3IgdGhlIGhvb2sgdG8gcmVtb3ZlXG4gICAqL1xuICBET01QdXJpZnkucmVtb3ZlSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50KSB7XG4gICAgaWYgKGhvb2tzW2VudHJ5UG9pbnRdKSB7XG4gICAgICBhcnJheVBvcChob29rc1tlbnRyeVBvaW50XSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVIb29rc1xuICAgKiBQdWJsaWMgbWV0aG9kIHRvIHJlbW92ZSBhbGwgRE9NUHVyaWZ5IGhvb2tzIGF0IGEgZ2l2ZW4gZW50cnlQb2ludFxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVudHJ5UG9pbnQgZW50cnkgcG9pbnQgZm9yIHRoZSBob29rcyB0byByZW1vdmVcbiAgICovXG4gIERPTVB1cmlmeS5yZW1vdmVIb29rcyA9IGZ1bmN0aW9uIChlbnRyeVBvaW50KSB7XG4gICAgaWYgKGhvb2tzW2VudHJ5UG9pbnRdKSB7XG4gICAgICBob29rc1tlbnRyeVBvaW50XSA9IFtdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlQWxsSG9va3NcbiAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYWxsIERPTVB1cmlmeSBob29rc1xuICAgKlxuICAgKi9cbiAgRE9NUHVyaWZ5LnJlbW92ZUFsbEhvb2tzID0gZnVuY3Rpb24gKCkge1xuICAgIGhvb2tzID0ge307XG4gIH07XG5cbiAgcmV0dXJuIERPTVB1cmlmeTtcbn1cblxudmFyIHB1cmlmeSA9IGNyZWF0ZURPTVB1cmlmeSgpO1xuXG52YXIgQ0FOX0JFX1dISVRFX1RBR19MSVNUID0gWydpZnJhbWUnLCAnZW1iZWQnXTtcbnZhciB3aGl0ZVRhZ0xpc3QgPSBbXTtcbmZ1bmN0aW9uIHJlZ2lzdGVyVGFnV2hpdGVsaXN0SWZQb3NzaWJsZSh0YWdOYW1lKSB7XG4gICAgaWYgKGluY2x1ZGVzKENBTl9CRV9XSElURV9UQUdfTElTVCwgdGFnTmFtZSkpIHtcbiAgICAgICAgd2hpdGVUYWdMaXN0LnB1c2godGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUhUTUwoaHRtbCwgb3B0aW9ucykge1xuICAgIHJldHVybiBwdXJpZnkuc2FuaXRpemUoaHRtbCwgX19hc3NpZ24kMSh7IEFERF9UQUdTOiB3aGl0ZVRhZ0xpc3QsIEFERF9BVFRSOiBbJ3JlbCcsICd0YXJnZXQnLCAnaHJlZmxhbmcnLCAndHlwZSddLCBGT1JCSURfVEFHUzogW1xuICAgICAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgICAgICdzY3JpcHQnLFxuICAgICAgICAgICAgJ3RleHRhcmVhJyxcbiAgICAgICAgICAgICdmb3JtJyxcbiAgICAgICAgICAgICdidXR0b24nLFxuICAgICAgICAgICAgJ3NlbGVjdCcsXG4gICAgICAgICAgICAnbWV0YScsXG4gICAgICAgICAgICAnc3R5bGUnLFxuICAgICAgICAgICAgJ2xpbmsnLFxuICAgICAgICAgICAgJ3RpdGxlJyxcbiAgICAgICAgICAgICdvYmplY3QnLFxuICAgICAgICAgICAgJ2Jhc2UnLFxuICAgICAgICBdIH0sIG9wdGlvbnMpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW5IVE1MKG5vZGUsIHR5cGVOYW1lKSB7XG4gICAgcmV0dXJuIG5vZGVcbiAgICAgICAgLmxpdGVyYWwucmVwbGFjZShuZXcgUmVnRXhwKFwiKDxcXFxccypcIiArIHR5cGVOYW1lICsgXCJbXj5dKj4pfCg8L1wiICsgdHlwZU5hbWUgKyBcIlxcXFxzKls+XSlcIiwgJ2lnJyksICcnKVxuICAgICAgICAudHJpbSgpO1xufVxuZnVuY3Rpb24gZ2V0SFRNTEF0dHJzQnlIVE1MU3RyaW5nKGh0bWwpIHtcbiAgICBodG1sID0gaHRtbC5tYXRjaChyZUhUTUxUYWcpWzBdO1xuICAgIHZhciBhdHRycyA9IGh0bWwubWF0Y2gobmV3IFJlZ0V4cChBVFRSSUJVVEUkMSwgJ2cnKSk7XG4gICAgcmV0dXJuIGF0dHJzXG4gICAgICAgID8gYXR0cnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGF0dHIpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGF0dHIudHJpbSgpLnNwbGl0KCc9JyksIG5hbWUgPSBfYVswXSwgdmFsdWVzID0gX2Euc2xpY2UoMSk7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFjY1tuYW1lXSA9IHZhbHVlcy5qb2luKCc9JykucmVwbGFjZSgvJ3xcIi9nLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pXG4gICAgICAgIDoge307XG59XG5mdW5jdGlvbiBnZXRIVE1MQXR0cnMoZG9tKSB7XG4gICAgcmV0dXJuIHRvQXJyYXlfMShkb20uYXR0cmlidXRlcykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGF0dHIpIHtcbiAgICAgICAgYWNjW2F0dHIubm9kZU5hbWVdID0gYXR0ci5ub2RlVmFsdWU7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gc2FuaXRpemVET00obm9kZSwgdHlwZU5hbWUsIHNhbml0aXplciwgd3dUb0RPTUFkYXB0b3IpIHtcbiAgICB2YXIgZG9tID0gd3dUb0RPTUFkYXB0b3IuZ2V0VG9ET01Ob2RlKHR5cGVOYW1lKShub2RlKTtcbiAgICB2YXIgaHRtbCA9IHNhbml0aXplcihkb20ub3V0ZXJIVE1MKTtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgZG9tID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgdmFyIGh0bWxBdHRycyA9IGdldEhUTUxBdHRycyhkb20pO1xuICAgIHJldHVybiB7IGRvbTogZG9tLCBodG1sQXR0cnM6IGh0bWxBdHRycyB9O1xufVxudmFyIHNjaGVtYUZhY3RvcnkgPSB7XG4gICAgaHRtbEJsb2NrOiBmdW5jdGlvbiAodHlwZU5hbWUsIHNhbml0aXplSFRNTCwgd3dUb0RPTUFkYXB0b3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF0b206IHRydWUsXG4gICAgICAgICAgICBjb250ZW50OiAnYmxvY2srJyxcbiAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBodG1sQXR0cnM6IHsgZGVmYXVsdDoge30gfSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbkhUTUw6IHsgZGVmYXVsdDogJycgfSxcbiAgICAgICAgICAgICAgICBodG1sQmxvY2s6IHsgZGVmYXVsdDogdHJ1ZSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IHR5cGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sQXR0cnM6IGdldEhUTUxBdHRycyhkb20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuSFRNTDogZG9tLmlubmVySFRNTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBzYW5pdGl6ZURPTShub2RlLCB0eXBlTmFtZSwgc2FuaXRpemVIVE1MLCB3d1RvRE9NQWRhcHRvciksIGRvbSA9IF9hLmRvbSwgaHRtbEF0dHJzID0gX2EuaHRtbEF0dHJzO1xuICAgICAgICAgICAgICAgIGh0bWxBdHRycy5jbGFzcyA9IGh0bWxBdHRycy5jbGFzcyA/IGh0bWxBdHRycy5jbGFzcyArIFwiIGh0bWwtYmxvY2tcIiA6ICdodG1sLWJsb2NrJztcbiAgICAgICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheSQxKFt0eXBlTmFtZSwgaHRtbEF0dHJzXSwgdG9BcnJheV8xKGRvbS5jaGlsZE5vZGVzKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgaHRtbElubGluZTogZnVuY3Rpb24gKHR5cGVOYW1lLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIGh0bWxBdHRyczogeyBkZWZhdWx0OiB7fSB9LFxuICAgICAgICAgICAgICAgIGh0bWxJbmxpbmU6IHsgZGVmYXVsdDogdHJ1ZSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IHR5cGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sQXR0cnM6IGdldEhUTUxBdHRycyhkb20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBodG1sQXR0cnMgPSBzYW5pdGl6ZURPTShub2RlLCB0eXBlTmFtZSwgc2FuaXRpemVIVE1MLCB3d1RvRE9NQWRhcHRvcikuaHRtbEF0dHJzO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdHlwZU5hbWUsIGh0bWxBdHRycywgMF07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlSFRNTFNjaGVtYU1hcChjb252ZXJ0b3JNYXAsIHNhbml0aXplSFRNTCwgd3dUb0RPTUFkYXB0b3IpIHtcbiAgICB2YXIgaHRtbFNjaGVtYU1hcCA9IHsgbm9kZXM6IHt9LCBtYXJrczoge30gfTtcbiAgICBbJ2h0bWxCbG9jaycsICdodG1sSW5saW5lJ10uZm9yRWFjaChmdW5jdGlvbiAoaHRtbFR5cGUpIHtcbiAgICAgICAgaWYgKGNvbnZlcnRvck1hcFtodG1sVHlwZV0pIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnZlcnRvck1hcFtodG1sVHlwZV0pLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VHlwZSA9IGh0bWxUeXBlID09PSAnaHRtbEJsb2NrJyA/ICdub2RlcycgOiAnbWFya3MnO1xuICAgICAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHRhZyB3aGl0ZSBsaXN0IGZvciBwcmV2ZW50aW5nIHRvIHJlbW92ZSB0aGUgaHRtbCBpbiBzYW5pdGl6ZXJcbiAgICAgICAgICAgICAgICByZWdpc3RlclRhZ1doaXRlbGlzdElmUG9zc2libGUodHlwZSk7XG4gICAgICAgICAgICAgICAgaHRtbFNjaGVtYU1hcFt0YXJnZXRUeXBlXVt0eXBlXSA9IHNjaGVtYUZhY3RvcnlbaHRtbFR5cGVdKHR5cGUsIHNhbml0aXplSFRNTCwgd3dUb0RPTUFkYXB0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaHRtbFNjaGVtYU1hcDtcbn1cblxudmFyIHJlQ2xvc2VUYWcgPSAvXlxccyo8XFxzKlxcLy87XG52YXIgYmFzZUNvbnZlcnRvcnMgPSB7XG4gICAgcGFyYWdyYXBoOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmcsIG9yaWdpbiA9IF9hLm9yaWdpbiwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zLm5vZGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdwJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbigpO1xuICAgIH0sXG4gICAgc29mdGJyZWFrOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgaXNQcmV2Tm9kZUhUTUwgPSBub2RlLnByZXYgJiYgbm9kZS5wcmV2LnR5cGUgPT09ICdodG1sSW5saW5lJztcbiAgICAgICAgdmFyIGlzUHJldkJSID0gaXNQcmV2Tm9kZUhUTUwgJiYgLzxiciA/XFwvPz4vLnRlc3Qobm9kZS5wcmV2LmxpdGVyYWwpO1xuICAgICAgICB2YXIgY29udGVudCA9IGlzUHJldkJSID8gJ1xcbicgOiAnPGJyPlxcbic7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdodG1sJywgY29udGVudDogY29udGVudCB9O1xuICAgIH0sXG4gICAgaXRlbTogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xuICAgICAgICAgICAgaWYgKG5vZGUubGlzdERhdGEudGFzaykge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbJ2RhdGEtdGFzayddID0gJyc7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCd0YXNrLWxpc3QtaXRlbScpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmxpc3REYXRhLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdjaGVja2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbJ2RhdGEtdGFzay1jaGVja2VkJ10gPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAnbGknLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IGNsYXNzTmFtZXMsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2xpJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvZGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0geyAnZGF0YS1iYWNrdGlja3MnOiBTdHJpbmcobm9kZS50aWNrQ291bnQpIH07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2NvZGUnLCBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogbm9kZS5saXRlcmFsIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdjb2RlJyB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgY29kZUJsb2NrOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgX2EgPSBub2RlLCBmZW5jZUxlbmd0aCA9IF9hLmZlbmNlTGVuZ3RoLCBpbmZvID0gX2EuaW5mbztcbiAgICAgICAgdmFyIGluZm9Xb3JkcyA9IGluZm8gPyBpbmZvLnNwbGl0KC9cXHMrLykgOiBbXTtcbiAgICAgICAgdmFyIHByZUNsYXNzZXMgPSBbXTtcbiAgICAgICAgdmFyIGNvZGVBdHRycyA9IHt9O1xuICAgICAgICBpZiAoZmVuY2VMZW5ndGggPiAzKSB7XG4gICAgICAgICAgICBjb2RlQXR0cnNbJ2RhdGEtYmFja3RpY2tzJ10gPSBmZW5jZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mb1dvcmRzLmxlbmd0aCA+IDAgJiYgaW5mb1dvcmRzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBsYW5nID0gaW5mb1dvcmRzWzBdO1xuICAgICAgICAgICAgcHJlQ2xhc3Nlcy5wdXNoKFwibGFuZy1cIiArIGxhbmcpO1xuICAgICAgICAgICAgY29kZUF0dHJzWydkYXRhLWxhbmd1YWdlJ10gPSBsYW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ3ByZScsIGNsYXNzTmFtZXM6IHByZUNsYXNzZXMgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnY29kZScsIGF0dHJpYnV0ZXM6IGNvZGVBdHRycyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnY29kZScgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ3ByZScgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGN1c3RvbUlubGluZTogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBvcmlnaW4gPSBfYS5vcmlnaW4sIGVudGVyaW5nID0gX2EuZW50ZXJpbmcsIHNraXBDaGlsZHJlbiA9IF9hLnNraXBDaGlsZHJlbjtcbiAgICAgICAgdmFyIGluZm8gPSBub2RlLmluZm87XG4gICAgICAgIGlmIChpbmZvLmluZGV4T2YoJ3dpZGdldCcpICE9PSAtMSAmJiBlbnRlcmluZykge1xuICAgICAgICAgICAgc2tpcENoaWxkcmVuKCk7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGdldFdpZGdldENvbnRlbnQobm9kZSk7XG4gICAgICAgICAgICB2YXIgaHRtbElubGluZSA9IHdpZGdldFRvRE9NKGluZm8sIGNvbnRlbnQpLm91dGVySFRNTDtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdzcGFuJywgY2xhc3NOYW1lczogWyd0dWktd2lkZ2V0J10gfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdodG1sJywgY29udGVudDogaHRtbElubGluZSB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ3NwYW4nIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW4oKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGdldEhUTUxSZW5kZXJDb252ZXJ0b3JzKGxpbmtBdHRyaWJ1dGVzLCBjdXN0b21Db252ZXJ0b3JzKSB7XG4gICAgdmFyIGNvbnZlcnRvcnMgPSBfX2Fzc2lnbiQxKHt9LCBiYXNlQ29udmVydG9ycyk7XG4gICAgaWYgKGxpbmtBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnZlcnRvcnMubGluayA9IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmcsIG9yaWdpbiA9IF9hLm9yaWdpbjtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcmlnaW4oKTtcbiAgICAgICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hdHRyaWJ1dGVzID0gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCByZXN1bHQuYXR0cmlidXRlcyksIGxpbmtBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChjdXN0b21Db252ZXJ0b3JzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGN1c3RvbUNvbnZlcnRvcnMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVUeXBlKSB7XG4gICAgICAgICAgICB2YXIgb3JnQ29udmVydG9yID0gY29udmVydG9yc1tub2RlVHlwZV07XG4gICAgICAgICAgICB2YXIgY3VzdG9tQ29udmVydG9yID0gY3VzdG9tQ29udmVydG9yc1tub2RlVHlwZV07XG4gICAgICAgICAgICBpZiAob3JnQ29udmVydG9yICYmIGlzRnVuY3Rpb25fMShjdXN0b21Db252ZXJ0b3IpKSB7XG4gICAgICAgICAgICAgICAgY29udmVydG9yc1tub2RlVHlwZV0gPSBmdW5jdGlvbiAobm9kZSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q29udGV4dCA9IF9fYXNzaWduJDEoe30sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0Lm9yaWdpbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yZ0NvbnZlcnRvcihub2RlLCBjb250ZXh0KTsgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUNvbnZlcnRvcihub2RlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5jbHVkZXMoWydodG1sQmxvY2snLCAnaHRtbElubGluZSddLCBub2RlVHlwZSkgJiYgIWlzRnVuY3Rpb25fMShjdXN0b21Db252ZXJ0b3IpKSB7XG4gICAgICAgICAgICAgICAgY29udmVydG9yc1tub2RlVHlwZV0gPSBmdW5jdGlvbiAobm9kZSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IG5vZGUubGl0ZXJhbC5tYXRjaChyZUhUTUxUYWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RIVE1MID0gbWF0Y2hlZFswXSwgb3BlblRhZ05hbWUgPSBtYXRjaGVkWzFdLCBjbG9zZVRhZ05hbWUgPSBtYXRjaGVkWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVOYW1lID0gKG9wZW5UYWdOYW1lIHx8IGNsb3NlVGFnTmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBodG1sQ29udmVydG9yID0gY3VzdG9tQ29udmVydG9yW3R5cGVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbkhUTUwgPSBnZXRDaGlsZHJlbkhUTUwobm9kZSwgdHlwZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh0bWxDb252ZXJ0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGZvciBwcmV2ZW50aW5nIHRvIG92ZXJ3cml0ZSB0aGUgb3JpZ2luaWFsIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld05vZGUgPSBfX2Fzc2lnbiQxKHt9LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLmF0dHJzID0gZ2V0SFRNTEF0dHJzQnlIVE1MU3RyaW5nKHJvb3RIVE1MKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLmNoaWxkcmVuSFRNTCA9IGNoaWxkcmVuSFRNTDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnR5cGUgPSB0eXBlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmVudGVyaW5nID0gIXJlQ2xvc2VUYWcudGVzdChub2RlLmxpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBodG1sQ29udmVydG9yKG5ld05vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0Lm9yaWdpbigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0b3JzW25vZGVUeXBlXSA9IGN1c3RvbUNvbnZlcnRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0b3JzO1xufVxuXG52YXIgbmVzdGFibGVUeXBlcyA9IFsnbGlzdCcsICdpdGVtJywgJ2Jsb2NrUXVvdGUnXTtcbnZhciBuZXN0YWJsZVRhZ05hbWVzID0gWydVTCcsICdPTCcsICdCTE9DS1FVT1RFJ107XG5mdW5jdGlvbiBpc0JsYW5rTGluZShkb2MsIGluZGV4KSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBwbU5vZGUgPSBkb2MuY2hpbGQoaW5kZXgpO1xuICAgIHJldHVybiAhcG1Ob2RlLmNoaWxkQ291bnQgfHwgKHBtTm9kZS5jaGlsZENvdW50ID09PSAxICYmICEoKF9hID0gcG1Ob2RlLmZpcnN0Q2hpbGQudGV4dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyaW0oKSkpO1xufVxuZnVuY3Rpb24gZ2V0RWRpdG9yUmFuZ2VIZWlnaHRJbmZvKGRvYywgbWROb2RlLCBjaGlsZHJlbikge1xuICAgIHZhciBzdGFydCA9IGdldE1kU3RhcnRMaW5lKG1kTm9kZSkgLSAxO1xuICAgIHZhciBlbmQgPSBnZXRNZEVuZExpbmUobWROb2RlKSAtIDE7XG4gICAgdmFyIHJlY3QgPSBjaGlsZHJlbltzdGFydF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGhlaWdodCA9IGNoaWxkcmVuW2VuZF0ub2Zmc2V0VG9wIC1cbiAgICAgICAgY2hpbGRyZW5bc3RhcnRdLm9mZnNldFRvcCArXG4gICAgICAgIGNoaWxkcmVuW2VuZF0uY2xpZW50SGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogaGVpZ2h0IDw9IDBcbiAgICAgICAgICAgID8gY2hpbGRyZW5bc3RhcnRdLmNsaWVudEhlaWdodFxuICAgICAgICAgICAgOiBoZWlnaHQgKyBnZXRCbGFua0xpbmVzSGVpZ2h0KGRvYywgY2hpbGRyZW4sIE1hdGgubWluKGVuZCArIDEsIGRvYy5jaGlsZENvdW50IC0gMSkpLFxuICAgICAgICByZWN0OiByZWN0LFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRCbGFua0xpbmVzSGVpZ2h0KGRvYywgY2hpbGRyZW4sIHN0YXJ0KSB7XG4gICAgdmFyIGVuZCA9IGRvYy5jaGlsZENvdW50IC0gMTtcbiAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kICYmIGlzQmxhbmtMaW5lKGRvYywgc3RhcnQpKSB7XG4gICAgICAgIGhlaWdodCArPSBjaGlsZHJlbltzdGFydF0uY2xpZW50SGVpZ2h0O1xuICAgICAgICBzdGFydCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0O1xufVxuZnVuY3Rpb24gZmluZEFuY2VzdG9ySGF2aW5nSWQoZWwsIHJvb3QpIHtcbiAgICB3aGlsZSAoIWVsLmdldEF0dHJpYnV0ZSgnZGF0YS1ub2RlaWQnKSAmJiBlbC5wYXJlbnRFbGVtZW50ICE9PSByb290KSB7XG4gICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gZ2V0VG90YWxPZmZzZXRUb3AoZWwsIHJvb3QpIHtcbiAgICB2YXIgb2Zmc2V0VG9wID0gMDtcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IHJvb3QpIHtcbiAgICAgICAgaWYgKCFpbmNsdWRlcyhuZXN0YWJsZVRhZ05hbWVzLCBlbC50YWdOYW1lKSkge1xuICAgICAgICAgICAgb2Zmc2V0VG9wICs9IGVsLm9mZnNldFRvcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwub2Zmc2V0UGFyZW50ID09PSByb290Lm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0VG9wO1xufVxuZnVuY3Rpb24gZmluZEFkamFjZW50RWxlbWVudFRvU2Nyb2xsVG9wKHNjcm9sbFRvcCwgcm9vdCkge1xuICAgIHZhciBlbCA9IHJvb3Q7XG4gICAgdmFyIHByZXYgPSBudWxsO1xuICAgIHdoaWxlIChlbCkge1xuICAgICAgICB2YXIgZmlyc3RFbGVtZW50Q2hpbGQgPSBlbC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgaWYgKCFmaXJzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhc3RTaWJsaW5nID0gZmluZExhc3RTaWJsaW5nRWxlbWVudFRvU2Nyb2xsVG9wKGZpcnN0RWxlbWVudENoaWxkLCBzY3JvbGxUb3AsIGdldFRvdGFsT2Zmc2V0VG9wKGVsLCByb290KSk7XG4gICAgICAgIHByZXYgPSBlbDtcbiAgICAgICAgZWwgPSBsYXN0U2libGluZztcbiAgICB9XG4gICAgdmFyIGFkamFjZW50RWwgPSBlbCB8fCBwcmV2O1xuICAgIHJldHVybiBhZGphY2VudEVsID09PSByb290ID8gbnVsbCA6IGFkamFjZW50RWw7XG59XG5mdW5jdGlvbiBmaW5kTGFzdFNpYmxpbmdFbGVtZW50VG9TY3JvbGxUb3AoZWwsIHNjcm9sbFRvcCwgb2Zmc2V0VG9wKSB7XG4gICAgaWYgKGVsICYmIHNjcm9sbFRvcCA+IG9mZnNldFRvcCArIGVsLm9mZnNldFRvcCkge1xuICAgICAgICByZXR1cm4gKGZpbmRMYXN0U2libGluZ0VsZW1lbnRUb1Njcm9sbFRvcChlbC5uZXh0RWxlbWVudFNpYmxpbmcsIHNjcm9sbFRvcCwgb2Zmc2V0VG9wKSB8fCBlbCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0QWRkaXRpb25hbFBvcyhzY3JvbGxUb3AsIG9mZnNldFRvcCwgaGVpZ2h0LCB0YXJnZXROb2RlSGVpZ2h0KSB7XG4gICAgdmFyIHJhdGlvID0gTWF0aC5taW4oKHNjcm9sbFRvcCAtIG9mZnNldFRvcCkgLyBoZWlnaHQsIDEpO1xuICAgIHJldHVybiByYXRpbyAqIHRhcmdldE5vZGVIZWlnaHQ7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlT2JqKHByZXZpZXdDb250ZW50LCBtZE5vZGUpIHtcbiAgICB2YXIgZWwgPSBwcmV2aWV3Q29udGVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtbm9kZWlkPVxcXCJcIiArIG1kTm9kZS5pZCArIFwiXFxcIl1cIik7XG4gICAgd2hpbGUgKCFlbCB8fCBpc1N0eWxlZElubGluZU5vZGUobWROb2RlKSkge1xuICAgICAgICBtZE5vZGUgPSBtZE5vZGUucGFyZW50O1xuICAgICAgICBlbCA9IHByZXZpZXdDb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1ub2RlaWQ9XFxcIlwiICsgbWROb2RlLmlkICsgXCJcXFwiXVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldE5vbk5lc3RhYmxlTm9kZU9iaih7IG1kTm9kZTogbWROb2RlLCBlbDogZWwgfSk7XG59XG5mdW5jdGlvbiBnZXROb25OZXN0YWJsZU5vZGVPYmooX2EpIHtcbiAgICB2YXIgbWROb2RlID0gX2EubWROb2RlLCBlbCA9IF9hLmVsO1xuICAgIHdoaWxlICgoaW5jbHVkZXMobmVzdGFibGVUeXBlcywgbWROb2RlLnR5cGUpIHx8IG1kTm9kZS50eXBlID09PSAndGFibGUnKSAmJiBtZE5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBtZE5vZGUgPSBtZE5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgZWwgPSBlbC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWROb2RlOiBtZE5vZGUsIGVsOiBlbCB9O1xufVxuXG52YXIgb2Zmc2V0SW5mb01hcCA9IHt9O1xuZnVuY3Rpb24gc2V0SGVpZ2h0KGlkLCBoZWlnaHQpIHtcbiAgICBvZmZzZXRJbmZvTWFwW2lkXSA9IG9mZnNldEluZm9NYXBbaWRdIHx8IHt9O1xuICAgIG9mZnNldEluZm9NYXBbaWRdLmhlaWdodCA9IGhlaWdodDtcbn1cbmZ1bmN0aW9uIHNldE9mZnNldFRvcChpZCwgb2Zmc2V0VG9wKSB7XG4gICAgb2Zmc2V0SW5mb01hcFtpZF0gPSBvZmZzZXRJbmZvTWFwW2lkXSB8fCB7fTtcbiAgICBvZmZzZXRJbmZvTWFwW2lkXS5vZmZzZXRUb3AgPSBvZmZzZXRUb3A7XG59XG5mdW5jdGlvbiBnZXRIZWlnaHQoaWQpIHtcbiAgICByZXR1cm4gb2Zmc2V0SW5mb01hcFtpZF0gJiYgb2Zmc2V0SW5mb01hcFtpZF0uaGVpZ2h0O1xufVxuZnVuY3Rpb24gZ2V0T2Zmc2V0VG9wKGlkKSB7XG4gICAgcmV0dXJuIG9mZnNldEluZm9NYXBbaWRdICYmIG9mZnNldEluZm9NYXBbaWRdLm9mZnNldFRvcDtcbn1cbmZ1bmN0aW9uIHJlbW92ZU9mZnNldEluZm9CeU5vZGUobm9kZSkge1xuICAgIGlmIChub2RlKSB7XG4gICAgICAgIGRlbGV0ZSBvZmZzZXRJbmZvTWFwW051bWJlcihub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1ub2RlaWQnKSldO1xuICAgICAgICB0b0FycmF5XzEobm9kZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHJlbW92ZU9mZnNldEluZm9CeU5vZGUoY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRBbmRTYXZlT2Zmc2V0SW5mbyhub2RlLCByb290LCBtZE5vZGVJZCkge1xuICAgIHZhciBjYWNoZWRIZWlnaHQgPSBnZXRIZWlnaHQobWROb2RlSWQpO1xuICAgIHZhciBjYWNoZWRUb3AgPSBnZXRPZmZzZXRUb3AobWROb2RlSWQpO1xuICAgIHZhciBub2RlSGVpZ2h0ID0gY2FjaGVkSGVpZ2h0IHx8IG5vZGUuY2xpZW50SGVpZ2h0O1xuICAgIHZhciBvZmZzZXRUb3AgPSBjYWNoZWRUb3AgfHwgZ2V0VG90YWxPZmZzZXRUb3Aobm9kZSwgcm9vdCkgfHwgbm9kZS5vZmZzZXRUb3A7XG4gICAgaWYgKCFjYWNoZWRIZWlnaHQpIHtcbiAgICAgICAgc2V0SGVpZ2h0KG1kTm9kZUlkLCBub2RlSGVpZ2h0KTtcbiAgICB9XG4gICAgaWYgKCFjYWNoZWRUb3ApIHtcbiAgICAgICAgc2V0T2Zmc2V0VG9wKG1kTm9kZUlkLCBvZmZzZXRUb3ApO1xuICAgIH1cbiAgICByZXR1cm4geyBub2RlSGVpZ2h0OiBub2RlSGVpZ2h0LCBvZmZzZXRUb3A6IG9mZnNldFRvcCB9O1xufVxuXG52YXIgQ0xBU1NfSElHSExJR0hUID0gY2xzKCdtZC1wcmV2aWV3LWhpZ2hsaWdodCcpO1xuZnVuY3Rpb24gZmluZFRhYmxlQ2VsbCh0YWJsZVJvdywgY2hPZmZzZXQpIHtcbiAgICB2YXIgY2VsbCA9IHRhYmxlUm93LmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNlbGwgJiYgY2VsbC5uZXh0KSB7XG4gICAgICAgIGlmIChnZXRNZFN0YXJ0Q2goY2VsbC5uZXh0KSA+IGNoT2Zmc2V0ICsgMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2VsbCA9IGNlbGwubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGw7XG59XG4vKipcbiAqIENsYXNzIE1hcmtkb3duIFByZXZpZXdcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gYmFzZSBlbGVtZW50XG4gKiBAcGFyYW0ge2V2ZW50RW1pdHRlcn0gZXZlbnRFbWl0dGVyIC0gZXZlbnQgbWFuYWdlclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5pc1ZpZXdlciAtIHRydWUgZm9yIHZpZXctb25seSBtb2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuaGlnaGxpZ2h0IC0gdHJ1ZSBmb3IgdXNpbmcgbGl2ZS1oaWdobGlnaHQgZmVhdHVyZVxuICogQHBhcmFtIHtvYmplY3R9IG9waXRvbnMubGlua0F0dHJpYnV0ZXMgLSBhdHRyaWJ1dGVzIGZvciBsaW5rIGVsZW1lbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcGl0b25zLmN1c3RvbUhUTUxSZW5kZXJlciAtIG1hcCBvZiBjdXN0b20gSFRNTCByZW5kZXIgZnVuY3Rpb25zXG4gKlxuICogQGlnbm9yZVxuICovXG52YXIgTWFya2Rvd25QcmV2aWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcmtkb3duUHJldmlldyhldmVudEVtaXR0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBldmVudEVtaXR0ZXI7XG4gICAgICAgIHRoaXMuaXNWaWV3ZXIgPSAhIW9wdGlvbnMuaXNWaWV3ZXI7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NOYW1lID0gY2xzKCdtZC1wcmV2aWV3Jyk7XG4gICAgICAgIHZhciBsaW5rQXR0cmlidXRlcyA9IG9wdGlvbnMubGlua0F0dHJpYnV0ZXMsIGN1c3RvbUhUTUxSZW5kZXJlciA9IG9wdGlvbnMuY3VzdG9tSFRNTFJlbmRlcmVyLCBzYW5pdGl6ZXIgPSBvcHRpb25zLnNhbml0aXplciwgX2EgPSBvcHRpb25zLmhpZ2hsaWdodCwgaGlnaGxpZ2h0ID0gX2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX2E7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoe1xuICAgICAgICAgICAgZ2ZtOiB0cnVlLFxuICAgICAgICAgICAgbm9kZUlkOiB0cnVlLFxuICAgICAgICAgICAgY29udmVydG9yczogZ2V0SFRNTFJlbmRlckNvbnZlcnRvcnMobGlua0F0dHJpYnV0ZXMsIGN1c3RvbUhUTUxSZW5kZXJlciksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmN1cnNvck5vZGVJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FuaXRpemVyID0gc2FuaXRpemVyO1xuICAgICAgICB0aGlzLmluaXRFdmVudChoaWdobGlnaHQpO1xuICAgICAgICB0aGlzLmluaXRDb250ZW50U2VjdGlvbigpO1xuICAgICAgICAvLyBUbyBwcmV2ZW50IG92ZXJmbG93aW5nIGNvbnRlbnRzIGluIHRoZSB2aWV3ZXJcbiAgICAgICAgaWYgKHRoaXMuaXNWaWV3ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlld0NvbnRlbnQuc3R5bGUub3ZlcmZsb3dXcmFwID0gJ2JyZWFrLXdvcmQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuaW5pdENvbnRlbnRTZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByZXZpZXdDb250ZW50ID0gY3JlYXRlRWxlbWVudFdpdGgoXCI8ZGl2IGNsYXNzPVxcXCJcIiArIGNscygnY29udGVudHMnKSArIFwiXFxcIj48L2Rpdj5cIik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZpZXdlcikge1xuICAgICAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLnByZXZpZXdDb250ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS50b2dnbGVBY3RpdmUgPSBmdW5jdGlvbiAoYWN0aXZlKSB7XG4gICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWwsICdhY3RpdmUnLCBhY3RpdmUpO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbiAoaGlnaGxpZ2h0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbigndXBkYXRlUHJldmlldycsIHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICBpZiAodGhpcy5pc1ZpZXdlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaWdobGlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignY2hhbmdlVG9vbGJhclN0YXRlJywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1kTm9kZSA9IF9hLm1kTm9kZSwgY3Vyc29yUG9zID0gX2EuY3Vyc29yUG9zO1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZUN1cnNvck5vZGUobWROb2RlLCBjdXJzb3JQb3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlSGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBvbl8xKHRoaXMuZWwsICdzY3JvbGwnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdzY3JvbGwnLCAncHJldmlldycsIGZpbmRBZGphY2VudEVsZW1lbnRUb1Njcm9sbFRvcChldmVudC50YXJnZXQuc2Nyb2xsVG9wLCBfdGhpcy5wcmV2aWV3Q29udGVudCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdjaGFuZ2VQcmV2aWV3VGFiUHJldmlldycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRvZ2dsZUFjdGl2ZSh0cnVlKTsgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignY2hhbmdlUHJldmlld1RhYldyaXRlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudG9nZ2xlQWN0aXZlKGZhbHNlKTsgfSk7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLnJlbW92ZUhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yTm9kZUlkKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEVsID0gdGhpcy5nZXRFbGVtZW50QnlOb2RlSWQodGhpcy5jdXJzb3JOb2RlSWQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRFbCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzXzEoY3VycmVudEVsLCBDTEFTU19ISUdITElHSFQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLnVwZGF0ZUN1cnNvck5vZGUgPSBmdW5jdGlvbiAoY3Vyc29yTm9kZSwgY3Vyc29yUG9zKSB7XG4gICAgICAgIGlmIChjdXJzb3JOb2RlKSB7XG4gICAgICAgICAgICBjdXJzb3JOb2RlID0gZmluZENsb3Nlc3ROb2RlKGN1cnNvck5vZGUsIGZ1bmN0aW9uIChtZE5vZGUpIHsgcmV0dXJuICFpc0lubGluZU5vZGUkMShtZE5vZGUpOyB9KTtcbiAgICAgICAgICAgIGlmIChjdXJzb3JOb2RlLnR5cGUgPT09ICd0YWJsZVJvdycpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3JOb2RlID0gZmluZFRhYmxlQ2VsbChjdXJzb3JOb2RlLCBjdXJzb3JQb3NbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3Vyc29yTm9kZS50eXBlID09PSAndGFibGVCb2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIGVtcHR5IGxpbmUgbmV4dCB0byB0YWJsZVxuICAgICAgICAgICAgICAgIGN1cnNvck5vZGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJzb3JOb2RlSWQgPSBjdXJzb3JOb2RlID8gY3Vyc29yTm9kZS5pZCA6IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvck5vZGVJZCA9PT0gY3Vyc29yTm9kZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9sZEVMID0gdGhpcy5nZXRFbGVtZW50QnlOb2RlSWQodGhpcy5jdXJzb3JOb2RlSWQpO1xuICAgICAgICB2YXIgbmV3RUwgPSB0aGlzLmdldEVsZW1lbnRCeU5vZGVJZChjdXJzb3JOb2RlSWQpO1xuICAgICAgICBpZiAob2xkRUwpIHtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzXzEob2xkRUwsIENMQVNTX0hJR0hMSUdIVCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0VMKSB7XG4gICAgICAgICAgICBhZGRDbGFzc18xKG5ld0VMLCBDTEFTU19ISUdITElHSFQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3Vyc29yTm9kZUlkID0gY3Vyc29yTm9kZUlkO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5nZXRFbGVtZW50QnlOb2RlSWQgPSBmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgIHJldHVybiBub2RlSWRcbiAgICAgICAgICAgID8gdGhpcy5wcmV2aWV3Q29udGVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtbm9kZWlkPVxcXCJcIiArIG5vZGVJZCArIFwiXFxcIl1cIilcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGNoYW5nZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY2hhbmdlZC5mb3JFYWNoKGZ1bmN0aW9uIChlZGl0UmVzdWx0KSB7IHJldHVybiBfdGhpcy5yZXBsYWNlUmFuZ2VOb2RlcyhlZGl0UmVzdWx0KTsgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2FmdGVyUHJldmlld1JlbmRlcicsIHRoaXMpO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5yZXBsYWNlUmFuZ2VOb2RlcyA9IGZ1bmN0aW9uIChlZGl0UmVzdWx0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlcyA9IGVkaXRSZXN1bHQubm9kZXMsIHJlbW92ZWROb2RlUmFuZ2UgPSBlZGl0UmVzdWx0LnJlbW92ZWROb2RlUmFuZ2U7XG4gICAgICAgIHZhciBjb250ZW50RWwgPSB0aGlzLnByZXZpZXdDb250ZW50O1xuICAgICAgICB2YXIgbmV3SHRtbCA9IHRoaXMuZXZlbnRFbWl0dGVyLmVtaXRSZWR1Y2UoJ2JlZm9yZVByZXZpZXdSZW5kZXInLCB0aGlzLnNhbml0aXplcihub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIF90aGlzLnJlbmRlcmVyLnJlbmRlcihub2RlKTsgfSkuam9pbignJykpKTtcbiAgICAgICAgaWYgKCFyZW1vdmVkTm9kZVJhbmdlKSB7XG4gICAgICAgICAgICBjb250ZW50RWwuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmJlZ2luJywgbmV3SHRtbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2EgPSByZW1vdmVkTm9kZVJhbmdlLmlkLCBzdGFydE5vZGVJZCA9IF9hWzBdLCBlbmROb2RlSWQgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBzdGFydEVsID0gdGhpcy5nZXRFbGVtZW50QnlOb2RlSWQoc3RhcnROb2RlSWQpO1xuICAgICAgICAgICAgdmFyIGVuZEVsID0gdGhpcy5nZXRFbGVtZW50QnlOb2RlSWQoZW5kTm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChzdGFydEVsKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRFbC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWJlZ2luJywgbmV3SHRtbCk7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gc3RhcnRFbDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGVuZEVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0RWwgPSBlbC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUkMShlbCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU9mZnNldEluZm9CeU5vZGUoZWwpO1xuICAgICAgICAgICAgICAgICAgICBlbCA9IG5leHRFbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsID09PSBudWxsIHx8IGVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUkMShlbCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU9mZnNldEluZm9CeU5vZGUoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5nZXRSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXI7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9mZl8xKHRoaXMuZWwsICdzY3JvbGwnKTtcbiAgICAgICAgdGhpcy5lbCA9IG51bGw7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5nZXRIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlUHJvc2VNaXJyb3JIYWNrTm9kZXModGhpcy5wcmV2aWV3Q29udGVudC5pbm5lckhUTUwpO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5zZXRIVE1MID0gZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgdGhpcy5wcmV2aWV3Q29udGVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gICAgICAgIGNzc18xKHRoaXMuZWwsIHsgaGVpZ2h0OiBoZWlnaHQgKyBcInB4XCIgfSk7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLnNldE1pbkhlaWdodCA9IGZ1bmN0aW9uIChtaW5IZWlnaHQpIHtcbiAgICAgICAgY3NzXzEodGhpcy5lbCwgeyBtaW5IZWlnaHQ6IG1pbkhlaWdodCArIFwicHhcIiB9KTtcbiAgICB9O1xuICAgIHJldHVybiBNYXJrZG93blByZXZpZXc7XG59KCkpO1xuXG5mdW5jdGlvbiBmaW5kTm9kZUJ5KHBvcywgY29uZGl0aW9uKSB7XG4gICAgdmFyIGRlcHRoID0gcG9zLmRlcHRoO1xuICAgIHdoaWxlIChkZXB0aCkge1xuICAgICAgICB2YXIgbm9kZSA9IHBvcy5ub2RlKGRlcHRoKTtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihub2RlLCBkZXB0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICBkZXB0aDogZGVwdGgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBkZXB0aCA+IDAgPyBwb3MuYmVmb3JlKGRlcHRoKSA6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGRlcHRoIC09IDE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNJbkxpc3ROb2RlKHBvcykge1xuICAgIHJldHVybiAhIWZpbmROb2RlQnkocG9zLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAnbGlzdEl0ZW0nIHx8IHR5cGUubmFtZSA9PT0gJ2J1bGxldExpc3QnIHx8IHR5cGUubmFtZSA9PT0gJ29yZGVyZWRMaXN0JztcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzSW5UYWJsZU5vZGUocG9zKSB7XG4gICAgcmV0dXJuICEhZmluZE5vZGVCeShwb3MsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICd0YWJsZUhlYWRDZWxsJyB8fCB0eXBlLm5hbWUgPT09ICd0YWJsZUJvZHlDZWxsJztcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZpbmRMaXN0SXRlbShwb3MpIHtcbiAgICByZXR1cm4gZmluZE5vZGVCeShwb3MsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICdsaXN0SXRlbSc7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVET01JbmZvUGFyc2VkUmF3SFRNTCh0YWcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoe30sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNlbGxBdHRycyhhdHRycykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRycykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGF0dHJOYW1lKSB7XG4gICAgICAgIGlmIChhdHRyTmFtZSAhPT0gJ3Jhd0hUTUwnICYmIGF0dHJzW2F0dHJOYW1lXSkge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyTmFtZSA9PT0gJ2NsYXNzTmFtZScgPyAnY2xhc3MnIDogYXR0ck5hbWU7XG4gICAgICAgICAgICBhY2NbYXR0ck5hbWVdID0gYXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFyc2VkQ2VsbERPTSh0YWcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgIHJldHVybiBbJ3Jhd0hUTUwnLCAnY29sc3BhbicsICdyb3dzcGFuJywgJ2V4dGVuZGVkJ10ucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGF0dHJOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lSW5ET00gPSBhdHRyTmFtZSA9PT0gJ3Jhd0hUTUwnID8gJ2RhdGEtcmF3LWh0bWwnIDogYXR0ck5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IGRvbS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWVJbkRPTSk7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NbYXR0ck5hbWVdID0gaW5jbHVkZXMoWydyYXdIVE1MJywgJ2V4dGVuZGVkJ10sIGF0dHJOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhdHRyVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTnVtYmVyKGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRDdXN0b21BdHRycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBodG1sQXR0cnM6IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICBjbGFzc05hbWVzOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpIHtcbiAgICB2YXIgaHRtbEF0dHJzID0gYXR0cnMuaHRtbEF0dHJzLCBjbGFzc05hbWVzID0gYXR0cnMuY2xhc3NOYW1lcztcbiAgICByZXR1cm4gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBodG1sQXR0cnMpLCB7IGNsYXNzOiBjbGFzc05hbWVzID8gY2xhc3NOYW1lcy5qb2luKCcgJykgOiBudWxsIH0pO1xufVxuXG5mdW5jdGlvbiBmaW5kV3JhcHBpbmdPdXRzaWRlKHJhbmdlLCB0eXBlKSB7XG4gICAgdmFyIHBhcmVudCA9IHJhbmdlLnBhcmVudCwgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXgsIGVuZEluZGV4ID0gcmFuZ2UuZW5kSW5kZXg7XG4gICAgdmFyIGFyb3VuZCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChzdGFydEluZGV4KS5maW5kV3JhcHBpbmcodHlwZSk7XG4gICAgaWYgKGFyb3VuZCkge1xuICAgICAgICB2YXIgb3V0ZXIgPSBhcm91bmQubGVuZ3RoID8gYXJvdW5kWzBdIDogdHlwZTtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5jYW5SZXBsYWNlV2l0aChzdGFydEluZGV4LCBlbmRJbmRleCwgb3V0ZXIpID8gYXJvdW5kIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kV3JhcHBpbmdJbnNpZGUocmFuZ2UsIHR5cGUpIHtcbiAgICB2YXIgcGFyZW50ID0gcmFuZ2UucGFyZW50LCBzdGFydEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleCwgZW5kSW5kZXggPSByYW5nZS5lbmRJbmRleDtcbiAgICB2YXIgaW5uZXIgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCk7XG4gICAgdmFyIGluc2lkZSA9IHR5cGUuY29udGVudE1hdGNoLmZpbmRXcmFwcGluZyhpbm5lci50eXBlKTtcbiAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgIHZhciBsYXN0VHlwZSA9IGluc2lkZS5sZW5ndGggPyBpbnNpZGVbaW5zaWRlLmxlbmd0aCAtIDFdIDogdHlwZTtcbiAgICAgICAgdmFyIGlubmVyTWF0Y2ggPSBsYXN0VHlwZS5jb250ZW50TWF0Y2g7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpbm5lck1hdGNoICYmIGkgPCBlbmRJbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbm5lck1hdGNoID0gaW5uZXJNYXRjaC5tYXRjaFR5cGUocGFyZW50LmNoaWxkKGkpLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbm5lck1hdGNoICYmIGlubmVyTWF0Y2gudmFsaWRFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kV3JhcHBlcnMocmFuZ2UsIGlubmVyUmFuZ2UsIG5vZGVUeXBlLCBhdHRycykge1xuICAgIHZhciBhcm91bmQgPSBmaW5kV3JhcHBpbmdPdXRzaWRlKHJhbmdlLCBub2RlVHlwZSk7XG4gICAgdmFyIGlubmVyID0gZmluZFdyYXBwaW5nSW5zaWRlKGlubmVyUmFuZ2UsIG5vZGVUeXBlKTtcbiAgICBpZiAoYXJvdW5kICYmIGlubmVyKSB7XG4gICAgICAgIHZhciBhcm91bmROb2RlcyA9IGFyb3VuZC5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IHR5cGUgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpbm5lck5vZGVzID0gaW5uZXIubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBhdHRyczogYXR0cnMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhcm91bmROb2Rlcy5jb25jYXQoeyB0eXBlOiBub2RlVHlwZSB9KS5jb25jYXQoaW5uZXJOb2Rlcyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gd3JhcEluTGlzdCh0ciwgX2EsIHdyYXBwZXJzLCBqb2luQmVmb3JlLCBsaXN0KSB7XG4gICAgdmFyIHN0YXJ0ID0gX2Euc3RhcnQsIGVuZCA9IF9hLmVuZCwgc3RhcnRJbmRleCA9IF9hLnN0YXJ0SW5kZXgsIGVuZEluZGV4ID0gX2EuZW5kSW5kZXgsIHBhcmVudCA9IF9hLnBhcmVudDtcbiAgICB2YXIgY29udGVudCA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAodmFyIGkgPSB3cmFwcGVycy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh3cmFwcGVyc1tpXS50eXBlLmNyZWF0ZSh3cmFwcGVyc1tpXS5hdHRycywgY29udGVudCkpO1xuICAgIH1cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCAtIChqb2luQmVmb3JlID8gMiA6IDApLCBlbmQsIHN0YXJ0LCBlbmQsIG5ldyBTbGljZShjb250ZW50LCAwLCAwKSwgd3JhcHBlcnMubGVuZ3RoLCB0cnVlKSk7XG4gICAgdmFyIGZvdW5kTGlzdEluZGV4ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdyYXBwZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmICh3cmFwcGVyc1tpXS50eXBlID09PSBsaXN0KSB7XG4gICAgICAgICAgICBmb3VuZExpc3RJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNwbGl0RGVwdGggPSB3cmFwcGVycy5sZW5ndGggLSBmb3VuZExpc3RJbmRleDtcbiAgICB2YXIgc3BsaXRQb3MgPSBzdGFydCArIHdyYXBwZXJzLmxlbmd0aCAtIChqb2luQmVmb3JlID8gMiA6IDApO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4LCBsZW4gPSBlbmRJbmRleDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaXJzdCA9IGkgPT09IHN0YXJ0SW5kZXg7XG4gICAgICAgIGlmICghZmlyc3QgJiYgY2FuU3BsaXQodHIuZG9jLCBzcGxpdFBvcywgc3BsaXREZXB0aCkpIHtcbiAgICAgICAgICAgIHRyLnNwbGl0KHNwbGl0UG9zLCBzcGxpdERlcHRoKTtcbiAgICAgICAgICAgIHNwbGl0UG9zICs9IHNwbGl0RGVwdGggKiAyO1xuICAgICAgICB9XG4gICAgICAgIHNwbGl0UG9zICs9IHBhcmVudC5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRyO1xufVxuZnVuY3Rpb24gY2hhbmdlVG9MaXN0KHRyLCByYW5nZSwgbGlzdCwgYXR0cnMpIHtcbiAgICB2YXIgJGZyb20gPSByYW5nZS4kZnJvbSwgJHRvID0gcmFuZ2UuJHRvLCBkZXB0aCA9IHJhbmdlLmRlcHRoO1xuICAgIHZhciBvdXRlclJhbmdlID0gcmFuZ2U7XG4gICAgdmFyIGpvaW5CZWZvcmUgPSBmYWxzZTtcbiAgICBpZiAoZGVwdGggPj0gMiAmJlxuICAgICAgICAkZnJvbS5ub2RlKGRlcHRoIC0gMSkudHlwZS5jb21wYXRpYmxlQ29udGVudChsaXN0KSAmJlxuICAgICAgICByYW5nZS5zdGFydEluZGV4ID09PSAwICYmXG4gICAgICAgICRmcm9tLmluZGV4KGRlcHRoIC0gMSkpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2Uuc3RhcnQgLSAyKTtcbiAgICAgICAgb3V0ZXJSYW5nZSA9IG5ldyBOb2RlUmFuZ2Uoc3RhcnQsIHN0YXJ0LCBkZXB0aCk7XG4gICAgICAgIGlmIChyYW5nZS5lbmRJbmRleCA8IHJhbmdlLnBhcmVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICByYW5nZSA9IG5ldyBOb2RlUmFuZ2UoJGZyb20sIHRyLmRvYy5yZXNvbHZlKCR0by5lbmQoZGVwdGgpKSwgZGVwdGgpO1xuICAgICAgICB9XG4gICAgICAgIGpvaW5CZWZvcmUgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgd3JhcHBlcnMgPSBmaW5kV3JhcHBlcnMob3V0ZXJSYW5nZSwgcmFuZ2UsIGxpc3QsIGF0dHJzKTtcbiAgICBpZiAod3JhcHBlcnMpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBJbkxpc3QodHIsIHJhbmdlLCB3cmFwcGVycywgam9pbkJlZm9yZSwgbGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGdldEJlZm9yZUxpbmVMaXN0SXRlbShkb2MsIG9mZnNldCkge1xuICAgIHZhciBlbmRMaXN0SXRlbVBvcyA9IGRvYy5yZXNvbHZlKG9mZnNldCk7XG4gICAgd2hpbGUgKGVuZExpc3RJdGVtUG9zLm5vZGUoKS50eXBlLm5hbWUgIT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgIG9mZnNldCAtPSAyOyAvLyBUaGUgcG9zaXRpb24gdmFsdWUgb2YgPC9saT48L3VsPlxuICAgICAgICBlbmRMaXN0SXRlbVBvcyA9IGRvYy5yZXNvbHZlKG9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBmaW5kTGlzdEl0ZW0oZW5kTGlzdEl0ZW1Qb3MpO1xufVxuZnVuY3Rpb24gdG9nZ2xlVGFza0xpc3RJdGVtcyh0ciwgX2EpIHtcbiAgICB2YXIgJGZyb20gPSBfYS4kZnJvbSwgJHRvID0gX2EuJHRvO1xuICAgIHZhciBzdGFydExpc3RJdGVtID0gZmluZExpc3RJdGVtKCRmcm9tKTtcbiAgICB2YXIgZW5kTGlzdEl0ZW0gPSBmaW5kTGlzdEl0ZW0oJHRvKTtcbiAgICBpZiAoc3RhcnRMaXN0SXRlbSAmJiBlbmRMaXN0SXRlbSkge1xuICAgICAgICB3aGlsZSAoZW5kTGlzdEl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBlbmRMaXN0SXRlbS5vZmZzZXQsIG5vZGUgPSBlbmRMaXN0SXRlbS5ub2RlO1xuICAgICAgICAgICAgdmFyIGF0dHJzID0geyB0YXNrOiAhbm9kZS5hdHRycy50YXNrLCBjaGVja2VkOiBmYWxzZSB9O1xuICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChvZmZzZXQsIG51bGwsIGF0dHJzKTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IHN0YXJ0TGlzdEl0ZW0ub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRMaXN0SXRlbSA9IGdldEJlZm9yZUxpbmVMaXN0SXRlbSh0ci5kb2MsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyO1xufVxuZnVuY3Rpb24gY2hhbmdlTGlzdFR5cGUodHIsIF9hLCBsaXN0KSB7XG4gICAgdmFyICRmcm9tID0gX2EuJGZyb20sICR0byA9IF9hLiR0bztcbiAgICB2YXIgc3RhcnRMaXN0SXRlbSA9IGZpbmRMaXN0SXRlbSgkZnJvbSk7XG4gICAgdmFyIGVuZExpc3RJdGVtID0gZmluZExpc3RJdGVtKCR0byk7XG4gICAgaWYgKHN0YXJ0TGlzdEl0ZW0gJiYgZW5kTGlzdEl0ZW0pIHtcbiAgICAgICAgd2hpbGUgKGVuZExpc3RJdGVtKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZW5kTGlzdEl0ZW0ub2Zmc2V0LCBub2RlID0gZW5kTGlzdEl0ZW0ubm9kZSwgZGVwdGggPSBlbmRMaXN0SXRlbS5kZXB0aDtcbiAgICAgICAgICAgIGlmIChub2RlLmF0dHJzLnRhc2spIHtcbiAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKG9mZnNldCwgbnVsbCwgeyB0YXNrOiBmYWxzZSwgY2hlY2tlZDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZWRQb3MgPSB0ci5kb2MucmVzb2x2ZShvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkUG9zLnBhcmVudC50eXBlICE9PSBsaXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudE9mZnNldCA9IHJlc29sdmVkUG9zLmJlZm9yZShkZXB0aCAtIDEpO1xuICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocGFyZW50T2Zmc2V0LCBsaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IHN0YXJ0TGlzdEl0ZW0ub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRMaXN0SXRlbSA9IGdldEJlZm9yZUxpbmVMaXN0SXRlbSh0ci5kb2MsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyO1xufVxuZnVuY3Rpb24gY2hhbmdlTGlzdChsaXN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgdHIgPSBfYS50cjtcbiAgICAgICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tLCAkdG8gPSBzZWxlY3Rpb24uJHRvO1xuICAgICAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byk7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIG5ld1RyID0gaXNJbkxpc3ROb2RlKCRmcm9tKVxuICAgICAgICAgICAgICAgID8gY2hhbmdlTGlzdFR5cGUodHIsIHJhbmdlLCBsaXN0KVxuICAgICAgICAgICAgICAgIDogY2hhbmdlVG9MaXN0KHRyLCByYW5nZSwgbGlzdCk7XG4gICAgICAgICAgICBkaXNwYXRjaChuZXdUcik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZVRhc2soKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgdHIgPSBfYS50ciwgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sICR0byA9IHNlbGVjdGlvbi4kdG87XG4gICAgICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgbmV3VHIgPSBpc0luTGlzdE5vZGUoJGZyb20pXG4gICAgICAgICAgICAgICAgPyB0b2dnbGVUYXNrTGlzdEl0ZW1zKHRyLCByYW5nZSlcbiAgICAgICAgICAgICAgICA6IGNoYW5nZVRvTGlzdCh0ciwgcmFuZ2UsIHNjaGVtYS5ub2Rlcy5idWxsZXRMaXN0LCB7IHRhc2s6IHRydWUgfSk7XG4gICAgICAgICAgICBkaXNwYXRjaChuZXdUcik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNpbmtMaXN0SXRlbShsaXN0SXRlbSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciB0ciA9IF9hLnRyLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb247XG4gICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgJHRvID0gc2VsZWN0aW9uLiR0bztcbiAgICAgICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8sIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkQ291bnQgPSBfYS5jaGlsZENvdW50LCBmaXJzdENoaWxkID0gX2EuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHJldHVybiAhIWNoaWxkQ291bnQgJiYgZmlyc3RDaGlsZC50eXBlID09PSBsaXN0SXRlbTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyYW5nZSAmJiByYW5nZS5zdGFydEluZGV4ID4gMCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gcmFuZ2UucGFyZW50O1xuICAgICAgICAgICAgdmFyIG5vZGVCZWZvcmUgPSBwYXJlbnRfMS5jaGlsZChyYW5nZS5zdGFydEluZGV4IC0gMSk7XG4gICAgICAgICAgICBpZiAobm9kZUJlZm9yZS50eXBlICE9PSBsaXN0SXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXN0ZWRCZWZvcmUgPSBub2RlQmVmb3JlLmxhc3RDaGlsZCAmJiBub2RlQmVmb3JlLmxhc3RDaGlsZC50eXBlID09PSBwYXJlbnRfMS50eXBlO1xuICAgICAgICAgICAgdmFyIGlubmVyID0gbmVzdGVkQmVmb3JlID8gRnJhZ21lbnQuZnJvbShsaXN0SXRlbS5jcmVhdGUoKSkgOiBudWxsO1xuICAgICAgICAgICAgdmFyIHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obGlzdEl0ZW0uY3JlYXRlKG51bGwsIEZyYWdtZW50LmZyb20ocGFyZW50XzEudHlwZS5jcmVhdGUobnVsbCwgaW5uZXIpKSkpLCBuZXN0ZWRCZWZvcmUgPyAzIDogMSwgMCk7XG4gICAgICAgICAgICB2YXIgYmVmb3JlID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChiZWZvcmUgLSAobmVzdGVkQmVmb3JlID8gMyA6IDEpLCBhZnRlciwgYmVmb3JlLCBhZnRlciwgc2xpY2UsIDEsIHRydWUpKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbGlmdFRvT3V0ZXJMaXN0KHRyLCByYW5nZSwgbGlzdEl0ZW0pIHtcbiAgICB2YXIgJGZyb20gPSByYW5nZS4kZnJvbSwgJHRvID0gcmFuZ2UuJHRvLCBlbmQgPSByYW5nZS5lbmQsIGRlcHRoID0gcmFuZ2UuZGVwdGgsIHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgICB2YXIgZW5kT2ZMaXN0ID0gJHRvLmVuZChkZXB0aCk7XG4gICAgaWYgKGVuZCA8IGVuZE9mTGlzdCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgc2libGluZ3MgYWZ0ZXIgdGhlIGxpZnRlZCBpdGVtcywgd2hpY2ggbXVzdCBiZWNvbWVcbiAgICAgICAgLy8gY2hpbGRyZW4gb2YgdGhlIGxhc3QgaXRlbVxuICAgICAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChlbmQgLSAxLCBlbmRPZkxpc3QsIGVuZCwgZW5kT2ZMaXN0LCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShsaXN0SXRlbS5jcmVhdGUobnVsbCwgcGFyZW50LmNvcHkoKSkpLCAxLCAwKSwgMSwgdHJ1ZSkpO1xuICAgICAgICByYW5nZSA9IG5ldyBOb2RlUmFuZ2UodHIuZG9jLnJlc29sdmUoJGZyb20ucG9zKSwgdHIuZG9jLnJlc29sdmUoZW5kT2ZMaXN0KSwgZGVwdGgpO1xuICAgIH1cbiAgICB0ci5saWZ0KHJhbmdlLCBsaWZ0VGFyZ2V0KHJhbmdlKSk7XG4gICAgcmV0dXJuIHRyO1xufVxuZnVuY3Rpb24gbGlmdE91dE9mTGlzdCh0ciwgcmFuZ2UpIHtcbiAgICB2YXIgbGlzdCA9IHJhbmdlLnBhcmVudDtcbiAgICB2YXIgcG9zID0gcmFuZ2UuZW5kO1xuICAgIC8vIE1lcmdlIHRoZSBsaXN0IGl0ZW1zIGludG8gYSBzaW5nbGUgYmlnIGl0ZW1cbiAgICBmb3IgKHZhciBpID0gcmFuZ2UuZW5kSW5kZXggLSAxLCBsZW4gPSByYW5nZS5zdGFydEluZGV4OyBpID4gbGVuOyBpIC09IDEpIHtcbiAgICAgICAgcG9zIC09IGxpc3QuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICAgIHRyLmRlbGV0ZShwb3MgLSAxLCBwb3MgKyAxKTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0UG9zID0gdHIuZG9jLnJlc29sdmUocmFuZ2Uuc3RhcnQpO1xuICAgIHZhciBsaXN0SXRlbSA9IHN0YXJ0UG9zLm5vZGVBZnRlcjtcbiAgICB2YXIgYXRTdGFydCA9IHJhbmdlLnN0YXJ0SW5kZXggPT09IDA7XG4gICAgdmFyIGF0RW5kID0gcmFuZ2UuZW5kSW5kZXggPT09IGxpc3QuY2hpbGRDb3VudDtcbiAgICB2YXIgcGFyZW50ID0gc3RhcnRQb3Mubm9kZSgtMSk7XG4gICAgdmFyIGluZGV4QmVmb3JlID0gc3RhcnRQb3MuaW5kZXgoLTEpO1xuICAgIHZhciBjYW5SZXBsYWNlUGFyZW50ID0gcGFyZW50LmNhblJlcGxhY2UoaW5kZXhCZWZvcmUgKyAoYXRTdGFydCA/IDAgOiAxKSwgaW5kZXhCZWZvcmUgKyAxLCBsaXN0SXRlbSA9PT0gbnVsbCB8fCBsaXN0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdEl0ZW0uY29udGVudC5hcHBlbmQoYXRFbmQgPyBGcmFnbWVudC5lbXB0eSA6IEZyYWdtZW50LmZyb20obGlzdCkpKTtcbiAgICBpZiAobGlzdEl0ZW0gJiYgY2FuUmVwbGFjZVBhcmVudCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBzdGFydFBvcy5wb3M7XG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxpc3RJdGVtLm5vZGVTaXplO1xuICAgICAgICAvLyBTdHJpcCBvZmYgdGhlIHN1cnJvdW5kaW5nIGxpc3QuIEF0IHRoZSBzaWRlcyB3aGVyZSB3ZSdyZSBub3QgYXRcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgbGlzdCwgdGhlIGV4aXN0aW5nIGxpc3QgaXMgY2xvc2VkLiBBdCBzaWRlcyB3aGVyZVxuICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQsIGl0IGlzIG92ZXJ3cml0dGVuIHRvIGl0cyBlbmQuXG4gICAgICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0IC0gKGF0U3RhcnQgPyAxIDogMCksIGVuZCArIChhdEVuZCA/IDEgOiAwKSwgc3RhcnQgKyAxLCBlbmQgLSAxLCBuZXcgU2xpY2UoKGF0U3RhcnQgPyBGcmFnbWVudC5lbXB0eSA6IEZyYWdtZW50LmZyb20obGlzdC5jb3B5KEZyYWdtZW50LmVtcHR5KSkpLmFwcGVuZChhdEVuZCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSksIGF0U3RhcnQgPyAwIDogMSwgYXRFbmQgPyAwIDogMSksIGF0U3RhcnQgPyAwIDogMSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBsaWZ0TGlzdEl0ZW0obGlzdEl0ZW0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICB2YXIgdHIgPSBfYS50ciwgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sICR0byA9IHNlbGVjdGlvbi4kdG87XG4gICAgICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZENvdW50ID0gX2EuY2hpbGRDb3VudCwgZmlyc3RDaGlsZCA9IF9hLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICByZXR1cm4gISFjaGlsZENvdW50ICYmIGZpcnN0Q2hpbGQudHlwZSA9PT0gbGlzdEl0ZW07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciB0b3BMaXN0SXRlbSA9ICRmcm9tLm5vZGUocmFuZ2UuZGVwdGggLSAxKS50eXBlID09PSBsaXN0SXRlbTtcbiAgICAgICAgICAgIHZhciBuZXdUciA9IHRvcExpc3RJdGVtID8gbGlmdFRvT3V0ZXJMaXN0KHRyLCByYW5nZSwgbGlzdEl0ZW0pIDogbGlmdE91dE9mTGlzdCh0ciwgcmFuZ2UpO1xuICAgICAgICAgICAgZGlzcGF0Y2gobmV3VHIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5mdW5jdGlvbiBzcGxpdExpc3RJdGVtKGxpc3RJdGVtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIHRyID0gX2EudHIsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tLCAkdG8gPSBzZWxlY3Rpb24uJHRvO1xuICAgICAgICBpZiAoJGZyb20uZGVwdGggPCAyIHx8ICEkZnJvbS5zYW1lUGFyZW50KCR0bykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKTtcbiAgICAgICAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT09IGxpc3RJdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRmcm9tLnBhcmVudC5jb250ZW50LnNpemUgPT09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PT0gJGZyb20uaW5kZXhBZnRlcigtMSkpIHtcbiAgICAgICAgICAgIC8vIEluIGFuIGVtcHR5IGJsb2NrLiBJZiB0aGlzIGlzIGEgbmVzdGVkIGxpc3QsIHRoZSB3cmFwcGluZ1xuICAgICAgICAgICAgLy8gbGlzdCBpdGVtIHNob3VsZCBiZSBzcGxpdC4gT3RoZXJ3aXNlLCBiYWlsIG91dCBhbmQgbGV0IG5leHRcbiAgICAgICAgICAgIC8vIGNvbW1hbmQgaGFuZGxlIGxpZnRpbmcuXG4gICAgICAgICAgICBpZiAoJGZyb20uZGVwdGggPT09IDIgfHxcbiAgICAgICAgICAgICAgICAkZnJvbS5ub2RlKC0zKS50eXBlICE9PSBsaXN0SXRlbSB8fFxuICAgICAgICAgICAgICAgICRmcm9tLmluZGV4KC0yKSAhPT0gJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIga2VlcEl0ZW0gPSAkZnJvbS5pbmRleCgtMSkgPiAwO1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgIC8vIEJ1aWxkIGEgZnJhZ21lbnQgY29udGFpbmluZyBlbXB0eSB2ZXJzaW9ucyBvZiB0aGUgc3RydWN0dXJlXG4gICAgICAgICAgICAvLyBmcm9tIHRoZSBvdXRlciBsaXN0IGl0ZW0gdG8gdGhlIHBhcmVudCBub2RlIG9mIHRoZSBjdXJzb3JcbiAgICAgICAgICAgIGZvciAodmFyIGRlcHRoID0gJGZyb20uZGVwdGggLSAoa2VlcEl0ZW0gPyAxIDogMik7IGRlcHRoID49ICRmcm9tLmRlcHRoIC0gMzsgZGVwdGggLT0gMSkge1xuICAgICAgICAgICAgICAgIHdyYXBwZXIgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoZGVwdGgpLmNvcHkod3JhcHBlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIGEgc2Vjb25kIGxpc3QgaXRlbSB3aXRoIGFuIGVtcHR5IGRlZmF1bHQgc3RhcnQgbm9kZVxuICAgICAgICAgICAgd3JhcHBlciA9IHdyYXBwZXIuYXBwZW5kKEZyYWdtZW50LmZyb20obGlzdEl0ZW0uY3JlYXRlQW5kRmlsbCgpKSk7XG4gICAgICAgICAgICB0ci5yZXBsYWNlKGtlZXBJdGVtID8gJGZyb20uYmVmb3JlKCkgOiAkZnJvbS5iZWZvcmUoLTEpLCAkZnJvbS5hZnRlcigtMyksIG5ldyBTbGljZSh3cmFwcGVyLCBrZWVwSXRlbSA/IDMgOiAyLCAyKSk7XG4gICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoJGZyb20ucG9zICsgKGtlZXBJdGVtID8gMyA6IDIpKSkpO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHRUeXBlID0gJHRvLnBvcyA9PT0gJGZyb20uZW5kKCkgPyBncmFuZFBhcmVudC5jb250ZW50TWF0Y2hBdCgwKS5kZWZhdWx0VHlwZSA6IG51bGw7XG4gICAgICAgIHZhciB0eXBlcyA9IG5leHRUeXBlICYmIFtudWxsLCB7IHR5cGU6IG5leHRUeXBlIH1dO1xuICAgICAgICB0ci5kZWxldGUoJGZyb20ucG9zLCAkdG8ucG9zKTtcbiAgICAgICAgaWYgKGNhblNwbGl0KHRyLmRvYywgJGZyb20ucG9zLCAyLCB0eXBlcykpIHtcbiAgICAgICAgICAgIHRyLnNwbGl0KCRmcm9tLnBvcywgMiwgdHlwZXMpO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGluZGVudCgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgJHRvID0gc2VsZWN0aW9uLiR0bztcbiAgICAgICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pO1xuICAgICAgICBpZiAocmFuZ2UgJiYgaXNJbkxpc3ROb2RlKCRmcm9tKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpbmtMaXN0SXRlbShzY2hlbWEubm9kZXMubGlzdEl0ZW0pKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07IH07XG59XG5mdW5jdGlvbiBvdXRkZW50KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tLCAkdG8gPSBzZWxlY3Rpb24uJHRvO1xuICAgICAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byk7XG4gICAgICAgIGlmIChyYW5nZSAmJiBpc0luTGlzdE5vZGUoJGZyb20pKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlmdExpc3RJdGVtKHNjaGVtYS5ub2Rlcy5saXN0SXRlbSkoc3RhdGUsIGRpc3BhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTsgfTtcbn1cbmZ1bmN0aW9uIGdldFd3Q29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZW50OiBpbmRlbnQoKSxcbiAgICAgICAgb3V0ZGVudDogb3V0ZGVudCgpLFxuICAgIH07XG59XG5cbnZhciBjYWNoZSA9IG5ldyBNYXAoKTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xudmFyIFRhYmxlT2Zmc2V0TWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhYmxlT2Zmc2V0TWFwKHRhYmxlLCB0YWJsZVJvd3MsIHRhYmxlU3RhcnRQb3MsIHJvd0luZm8pIHtcbiAgICAgICAgdGhpcy50YWJsZSA9IHRhYmxlO1xuICAgICAgICB0aGlzLnRhYmxlUm93cyA9IHRhYmxlUm93cztcbiAgICAgICAgdGhpcy50YWJsZVN0YXJ0UG9zID0gdGFibGVTdGFydFBvcztcbiAgICAgICAgdGhpcy5yb3dJbmZvID0gcm93SW5mbztcbiAgICB9XG4gICAgVGFibGVPZmZzZXRNYXAuY3JlYXRlID0gZnVuY3Rpb24gKGNlbGxQb3MpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gZmluZE5vZGVCeShjZWxsUG9zLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICd0YWJsZSc7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGFibGUpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGFibGUubm9kZSwgZGVwdGggPSB0YWJsZS5kZXB0aCwgb2Zmc2V0ID0gdGFibGUub2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGNhY2hlZCA9IGNhY2hlLmdldChub2RlKTtcbiAgICAgICAgICAgIGlmICgoY2FjaGVkID09PSBudWxsIHx8IGNhY2hlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FjaGVkLnRhYmxlU3RhcnRQb3MpID09PSBvZmZzZXQgKyAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByb3dzXzEgPSBbXTtcbiAgICAgICAgICAgIHZhciB0YWJsZVBvcyA9IGNlbGxQb3Muc3RhcnQoZGVwdGgpO1xuICAgICAgICAgICAgdmFyIHRoZWFkID0gbm9kZS5jaGlsZCgwKTtcbiAgICAgICAgICAgIHZhciB0Ym9keSA9IG5vZGUuY2hpbGQoMSk7XG4gICAgICAgICAgICB2YXIgdGhlYWRDZWxsSW5mbyA9IGNyZWF0ZU9mZnNldE1hcCh0aGVhZCwgdGFibGVQb3MpO1xuICAgICAgICAgICAgdmFyIHRib2R5Q2VsbEluZm8gPSBjcmVhdGVPZmZzZXRNYXAodGJvZHksIHRhYmxlUG9zICsgdGhlYWQubm9kZVNpemUpO1xuICAgICAgICAgICAgdGhlYWQuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7IHJldHVybiByb3dzXzEucHVzaChyb3cpOyB9KTtcbiAgICAgICAgICAgIHRib2R5LmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93c18xLnB1c2gocm93KTsgfSk7XG4gICAgICAgICAgICB2YXIgbWFwID0gbmV3IFRhYmxlT2Zmc2V0TWFwKG5vZGUsIHJvd3NfMSwgdGFibGVQb3MsIHRoZWFkQ2VsbEluZm8uY29uY2F0KHRib2R5Q2VsbEluZm8pKTtcbiAgICAgICAgICAgIGNhY2hlLnNldChub2RlLCBtYXApO1xuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUsIFwidG90YWxSb3dDb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SW5mby5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLCBcInRvdGFsQ29sdW1uQ291bnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0luZm9bMF0ubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZSwgXCJ0YWJsZVN0YXJ0T2Zmc2V0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWJsZVN0YXJ0UG9zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZSwgXCJ0YWJsZUVuZE9mZnNldFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFibGVTdGFydFBvcyArIHRoaXMudGFibGUubm9kZVNpemUgLSAxO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldENlbGxJbmZvID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd0luZm9bcm93SWR4XVtjb2xJZHhdO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLnBvc0F0ID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCByb3dTdGFydCA9IHRoaXMudGFibGVTdGFydFBvczs7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHJvd0VuZCA9IHJvd1N0YXJ0ICsgdGhpcy50YWJsZVJvd3NbaV0ubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoaSA9PT0gcm93SWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gY29sSWR4O1xuICAgICAgICAgICAgICAgIC8vIFNraXAgdGhlIGNlbGxzIGZyb20gcHJldmlvdXMgcm93KHZpYSByb3dzcGFuKVxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IHRoaXMudG90YWxDb2x1bW5Db3VudCAmJiB0aGlzLnJvd0luZm9baV1baW5kZXhdLm9mZnNldCA8IHJvd1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gdGhpcy50b3RhbENvbHVtbkNvdW50ID8gcm93RW5kIDogdGhpcy5yb3dJbmZvW2ldW2luZGV4XS5vZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dTdGFydCA9IHJvd0VuZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldE5vZGVBbmRQb3MgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgdmFyIGNlbGxJbmZvID0gdGhpcy5yb3dJbmZvW3Jvd0lkeF1bY29sSWR4XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGU6IHRoaXMudGFibGUubm9kZUF0KGNlbGxJbmZvLm9mZnNldCAtIHRoaXMudGFibGVTdGFydE9mZnNldCksXG4gICAgICAgICAgICBwb3M6IGNlbGxJbmZvLm9mZnNldCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5leHRlbmRlZFJvd3NwYW4gPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmV4dGVuZGVkQ29sc3BhbiA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Um93c3BhbkNvdW50ID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldENvbHNwYW5Db3VudCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5kZWNyZWFzZUNvbHNwYW5Db3VudCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5kZWNyZWFzZVJvd3NwYW5Db3VudCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDb2xzcGFuU3RhcnRJbmZvID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldFJvd3NwYW5TdGFydEluZm8gPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Q2VsbFN0YXJ0T2Zmc2V0ID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnJvd0luZm9bcm93SWR4XVtjb2xJZHhdLm9mZnNldDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kZWRSb3dzcGFuKHJvd0lkeCwgY29sSWR4KSA/IHRoaXMucG9zQXQocm93SWR4LCBjb2xJZHgpIDogb2Zmc2V0O1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldENlbGxFbmRPZmZzZXQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5yb3dJbmZvW3Jvd0lkeF1bY29sSWR4XSwgb2Zmc2V0ID0gX2Eub2Zmc2V0LCBub2RlU2l6ZSA9IF9hLm5vZGVTaXplO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlbmRlZFJvd3NwYW4ocm93SWR4LCBjb2xJZHgpID8gdGhpcy5wb3NBdChyb3dJZHgsIGNvbElkeCkgOiBvZmZzZXQgKyBub2RlU2l6ZTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDZWxsSW5kZXggPSBmdW5jdGlvbiAoY2VsbFBvcykge1xuICAgICAgICBmb3IgKHZhciByb3dJZHggPSAwOyByb3dJZHggPCB0aGlzLnRvdGFsUm93Q291bnQ7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgcm93SW5mbyA9IHRoaXMucm93SW5mb1tyb3dJZHhdO1xuICAgICAgICAgICAgZm9yICh2YXIgY29sSWR4ID0gMDsgY29sSWR4IDwgdGhpcy50b3RhbENvbHVtbkNvdW50OyBjb2xJZHggKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChyb3dJbmZvW2NvbElkeF0ub2Zmc2V0ICsgMSA+IGNlbGxQb3MucG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbcm93SWR4LCBjb2xJZHhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldFJlY3RPZmZzZXRzID0gZnVuY3Rpb24gKHN0YXJ0Q2VsbFBvcywgZW5kQ2VsbFBvcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKGVuZENlbGxQb3MgPT09IHZvaWQgMCkgeyBlbmRDZWxsUG9zID0gc3RhcnRDZWxsUG9zOyB9XG4gICAgICAgIGlmIChzdGFydENlbGxQb3MucG9zID4gZW5kQ2VsbFBvcy5wb3MpIHtcbiAgICAgICAgICAgIF9hID0gW2VuZENlbGxQb3MsIHN0YXJ0Q2VsbFBvc10sIHN0YXJ0Q2VsbFBvcyA9IF9hWzBdLCBlbmRDZWxsUG9zID0gX2FbMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9kID0gdGhpcy5nZXRDZWxsSW5kZXgoc3RhcnRDZWxsUG9zKSwgc3RhcnRSb3dJZHggPSBfZFswXSwgc3RhcnRDb2xJZHggPSBfZFsxXTtcbiAgICAgICAgdmFyIF9lID0gdGhpcy5nZXRDZWxsSW5kZXgoZW5kQ2VsbFBvcyksIGVuZFJvd0lkeCA9IF9lWzBdLCBlbmRDb2xJZHggPSBfZVsxXTtcbiAgICAgICAgX2IgPSBnZXRTb3J0ZWROdW1QYWlyKHN0YXJ0Um93SWR4LCBlbmRSb3dJZHgpLCBzdGFydFJvd0lkeCA9IF9iWzBdLCBlbmRSb3dJZHggPSBfYlsxXTtcbiAgICAgICAgX2MgPSBnZXRTb3J0ZWROdW1QYWlyKHN0YXJ0Q29sSWR4LCBlbmRDb2xJZHgpLCBzdGFydENvbElkeCA9IF9jWzBdLCBlbmRDb2xJZHggPSBfY1sxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3Bhbm5lZE9mZnNldHMoeyBzdGFydFJvd0lkeDogc3RhcnRSb3dJZHgsIHN0YXJ0Q29sSWR4OiBzdGFydENvbElkeCwgZW5kUm93SWR4OiBlbmRSb3dJZHgsIGVuZENvbElkeDogZW5kQ29sSWR4IH0pO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldFNwYW5uZWRPZmZzZXRzID0gZnVuY3Rpb24gKHNlbGVjdGlvbkluZm8pIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkluZm87XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVPZmZzZXRNYXA7XG59KCkpO1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbnZhciBjcmVhdGVPZmZzZXRNYXAgPSBmdW5jdGlvbiAoaGVhZE9yQm9keSwgc3RhcnRPZmZzZXQpIHtcbiAgICB2YXIgY2VsbEluZm9NYXRyaXggPSBbXTtcbiAgICBoZWFkT3JCb2R5LmZvckVhY2goZnVuY3Rpb24gKHJvdywgcm93T2Zmc2V0KSB7XG4gICAgICAgIC8vIGdldCByb3cgaW5kZXggYmFzZWQgb24gdGFibGUobm90IHRhYmxlIGhlYWQgb3IgdGFibGUgYm9keSlcbiAgICAgICAgdmFyIHJvd0luZm8gPSB7IHJvd3NwYW5NYXA6IHt9LCBjb2xzcGFuTWFwOiB7fSwgbGVuZ3RoOiAwIH07XG4gICAgICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uIChfYSwgY2VsbE9mZnNldCkge1xuICAgICAgICAgICAgdmFyIG5vZGVTaXplID0gX2Eubm9kZVNpemU7XG4gICAgICAgICAgICB2YXIgY29sSWR4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChyb3dJbmZvW2NvbElkeF0pIHtcbiAgICAgICAgICAgICAgICBjb2xJZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd0luZm9bY29sSWR4XSA9IHtcbiAgICAgICAgICAgICAgICAvLyAyIGlzIHRoZSBzdW0gb2YgdGhlIGZyb250IGFuZCBiYWNrIHBvc2l0aW9ucyBvZiB0aGUgdGFnXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBzdGFydE9mZnNldCArIHJvd09mZnNldCArIGNlbGxPZmZzZXQgKyAyLFxuICAgICAgICAgICAgICAgIG5vZGVTaXplOiBub2RlU2l6ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByb3dJbmZvLmxlbmd0aCArPSAxO1xuICAgICAgICB9KTtcbiAgICAgICAgY2VsbEluZm9NYXRyaXgucHVzaChyb3dJbmZvKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2VsbEluZm9NYXRyaXg7XG59O1xuZnVuY3Rpb24gbWl4aW5UYWJsZU9mZnNldE1hcFByb3RvdHlwZShvZmZzZXRNYXBNaXhpbiwgY3JlYXRlT2Zmc2V0TWFwTWl4aW4pIHtcbiAgICBhc3NpZ24oVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLCBvZmZzZXRNYXBNaXhpbik7XG4gICAgY3JlYXRlT2Zmc2V0TWFwID0gY3JlYXRlT2Zmc2V0TWFwTWl4aW47XG4gICAgcmV0dXJuIFRhYmxlT2Zmc2V0TWFwO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25SYW5nZXMoZG9jLCBtYXAsIF9hKSB7XG4gICAgdmFyIHN0YXJ0Um93SWR4ID0gX2Euc3RhcnRSb3dJZHgsIHN0YXJ0Q29sSWR4ID0gX2Euc3RhcnRDb2xJZHgsIGVuZFJvd0lkeCA9IF9hLmVuZFJvd0lkeCwgZW5kQ29sSWR4ID0gX2EuZW5kQ29sSWR4O1xuICAgIHZhciByYW5nZXMgPSBbXTtcbiAgICBmb3IgKHZhciByb3dJZHggPSBzdGFydFJvd0lkeDsgcm93SWR4IDw9IGVuZFJvd0lkeDsgcm93SWR4ICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgY29sSWR4ID0gc3RhcnRDb2xJZHg7IGNvbElkeCA8PSBlbmRDb2xJZHg7IGNvbElkeCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBtYXAuZ2V0Q2VsbEluZm8ocm93SWR4LCBjb2xJZHgpLCBvZmZzZXQgPSBfYi5vZmZzZXQsIG5vZGVTaXplID0gX2Iubm9kZVNpemU7XG4gICAgICAgICAgICByYW5nZXMucHVzaChuZXcgU2VsZWN0aW9uUmFuZ2UoZG9jLnJlc29sdmUob2Zmc2V0ICsgMSksIGRvYy5yZXNvbHZlKG9mZnNldCArIG5vZGVTaXplIC0gMSkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuZnVuY3Rpb24gY3JlYXRlVGFibGVGcmFnbWVudCh0YWJsZUhlYWQsIHRhYmxlQm9keSkge1xuICAgIHZhciBmcmFnbWVudCA9IFtdO1xuICAgIGlmICh0YWJsZUhlYWQuY2hpbGRDb3VudCkge1xuICAgICAgICBmcmFnbWVudC5wdXNoKHRhYmxlSGVhZCk7XG4gICAgfVxuICAgIGlmICh0YWJsZUJvZHkuY2hpbGRDb3VudCkge1xuICAgICAgICBmcmFnbWVudC5wdXNoKHRhYmxlQm9keSk7XG4gICAgfVxuICAgIHJldHVybiBGcmFnbWVudC5mcm9tKGZyYWdtZW50KTtcbn1cbnZhciBDZWxsU2VsZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKENlbGxTZWxlY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2VsbFNlbGVjdGlvbihzdGFydENlbGxQb3MsIGVuZENlbGxQb3MpIHtcbiAgICAgICAgaWYgKGVuZENlbGxQb3MgPT09IHZvaWQgMCkgeyBlbmRDZWxsUG9zID0gc3RhcnRDZWxsUG9zOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkb2MgPSBzdGFydENlbGxQb3Mubm9kZSgwKTtcbiAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShzdGFydENlbGxQb3MpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uSW5mbyA9IG1hcC5nZXRSZWN0T2Zmc2V0cyhzdGFydENlbGxQb3MsIGVuZENlbGxQb3MpO1xuICAgICAgICB2YXIgcmFuZ2VzID0gZ2V0U2VsZWN0aW9uUmFuZ2VzKGRvYywgbWFwLCBzZWxlY3Rpb25JbmZvKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByYW5nZXNbMF0uJGZyb20sIHJhbmdlc1swXS4kdG8sIHJhbmdlcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhcnRDZWxsID0gc3RhcnRDZWxsUG9zO1xuICAgICAgICBfdGhpcy5lbmRDZWxsID0gZW5kQ2VsbFBvcztcbiAgICAgICAgX3RoaXMub2Zmc2V0TWFwID0gbWFwO1xuICAgICAgICBfdGhpcy5pc0NlbGxTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAvLyBUaGlzIHByb3BlcnR5IGlzIHRoZSBhcGkgb2YgdGhlICdTZWxlY3Rpb24nIGluIHByb3NlbWlycm9yLFxuICAgICAgICAvLyBhbmQgaXMgdXNlZCB0byBkaXNhYmxlIHRoZSB0ZXh0IHNlbGVjdGlvbi5cbiAgICAgICAgX3RoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChkb2MsIG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydENlbGwucG9zO1xuICAgICAgICB2YXIgZW5kUG9zID0gdGhpcy5lbmRDZWxsLnBvcztcbiAgICAgICAgdmFyIHN0YXJ0Q2VsbCA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHN0YXJ0UG9zKSk7XG4gICAgICAgIHZhciBlbmRDZWxsID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAoZW5kUG9zKSk7XG4gICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoc3RhcnRDZWxsKTtcbiAgICAgICAgLy8gdGV4dCBzZWxlY3Rpb24gd2hlbiByb3dzIG9yIGNvbHVtbnMgYXJlIGRlbGV0ZWRcbiAgICAgICAgaWYgKHRoaXMub2Zmc2V0TWFwLnRvdGFsQ29sdW1uQ291bnQgPiBtYXAudG90YWxDb2x1bW5Db3VudCB8fFxuICAgICAgICAgICAgdGhpcy5vZmZzZXRNYXAudG90YWxSb3dDb3VudCA+IG1hcC50b3RhbFJvd0NvdW50KSB7XG4gICAgICAgICAgICB2YXIgZGVwdGhNYXAgPSB7IHRhYmxlQm9keTogMSwgdGFibGVSb3c6IDIsIHRhYmxlQ2VsbDogMywgcGFyYWdyYXBoOiA0IH07XG4gICAgICAgICAgICB2YXIgZGVwdGhGcm9tVGFibGUgPSBkZXB0aE1hcFtlbmRDZWxsLnBhcmVudC50eXBlLm5hbWVdO1xuICAgICAgICAgICAgdmFyIHRhYmxlRW5kUG9zID0gZW5kQ2VsbC5lbmQoZW5kQ2VsbC5kZXB0aCAtIGRlcHRoRnJvbVRhYmxlKTtcbiAgICAgICAgICAgIC8vIHN1YnRyYWN0IDQoPC90ZD48L3RyPjwvdGJvZHk+PC90YWJsZT4gdGFnIGxlbmd0aClcbiAgICAgICAgICAgIHZhciBmcm9tID0gTWF0aC5taW4odGFibGVFbmRQb3MgLSA0LCBlbmRDZWxsLnBvcyk7XG4gICAgICAgICAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENlbGxTZWxlY3Rpb24oc3RhcnRDZWxsLCBlbmRDZWxsKTtcbiAgICB9O1xuICAgIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgcmV0dXJuIChjZWxsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbiAmJlxuICAgICAgICAgICAgY2VsbC5zdGFydENlbGwucG9zID09PSB0aGlzLnN0YXJ0Q2VsbC5wb3MgJiZcbiAgICAgICAgICAgIGNlbGwuZW5kQ2VsbC5wb3MgPT09IHRoaXMuZW5kQ2VsbC5wb3MpO1xuICAgIH07XG4gICAgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gdGhpcy5zdGFydENlbGwubm9kZSgtMik7XG4gICAgICAgIHZhciB0YWJsZU9mZnNldCA9IHRoaXMuc3RhcnRDZWxsLnN0YXJ0KC0yKTtcbiAgICAgICAgdmFyIHJvdyA9IHRhYmxlLmNoaWxkKDEpLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciB0YWJsZUhlYWQgPSB0YWJsZS5jaGlsZCgwKS50eXBlLmNyZWF0ZSgpO1xuICAgICAgICB2YXIgdGFibGVCb2R5ID0gdGFibGUuY2hpbGQoMSkudHlwZS5jcmVhdGUoKTtcbiAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZSh0aGlzLnN0YXJ0Q2VsbCk7XG4gICAgICAgIHZhciBzZWxlY3Rpb25JbmZvID0gbWFwLmdldFJlY3RPZmZzZXRzKHRoaXMuc3RhcnRDZWxsLCB0aGlzLmVuZENlbGwpO1xuICAgICAgICB2YXIgc3RhcnRSb3dJZHggPSBzZWxlY3Rpb25JbmZvLnN0YXJ0Um93SWR4LCBzdGFydENvbElkeCA9IHNlbGVjdGlvbkluZm8uc3RhcnRDb2xJZHgsIGVuZFJvd0lkeCA9IHNlbGVjdGlvbkluZm8uZW5kUm93SWR4LCBlbmRDb2xJZHggPSBzZWxlY3Rpb25JbmZvLmVuZENvbElkeDtcbiAgICAgICAgdmFyIGlzVGFibGVIZWFkQ2VsbCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciByb3dJZHggPSBzdGFydFJvd0lkeDsgcm93SWR4IDw9IGVuZFJvd0lkeDsgcm93SWR4ICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjZWxscyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgY29sSWR4ID0gc3RhcnRDb2xJZHg7IGNvbElkeCA8PSBlbmRDb2xJZHg7IGNvbElkeCArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IG1hcC5nZXRDZWxsSW5mbyhyb3dJZHgsIGNvbElkeCkub2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciBjZWxsID0gdGFibGUubm9kZUF0KG9mZnNldCAtIHRhYmxlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgICAgICBpc1RhYmxlSGVhZENlbGwgPSBjZWxsLnR5cGUubmFtZSA9PT0gJ3RhYmxlSGVhZENlbGwnO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIHRoZSBleHRlbmRlZCBjZWxsIGZvciBwYXN0aW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuZXh0ZW5kZWRSb3dzcGFuKHJvd0lkeCwgY29sSWR4KSB8fCBtYXAuZXh0ZW5kZWRDb2xzcGFuKHJvd0lkeCwgY29sSWR4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbHMucHVzaChjZWxsLnR5cGUuY3JlYXRlKHsgZXh0ZW5kZWQ6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbHMucHVzaChjZWxsLmNvcHkoY2VsbC5jb250ZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29waWVkUm93ID0gcm93LmNvcHkoRnJhZ21lbnQuZnJvbShjZWxscykpO1xuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSBpc1RhYmxlSGVhZENlbGwgPyB0YWJsZUhlYWQgOiB0YWJsZUJvZHk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0YXJnZXROb2RlLmNvbnRlbnQgPSB0YXJnZXROb2RlLmNvbnRlbnQuYXBwZW5kKEZyYWdtZW50LmZyb20oY29waWVkUm93KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShjcmVhdGVUYWJsZUZyYWdtZW50KHRhYmxlSGVhZCwgdGFibGVCb2R5KSwgMSwgMSk7XG4gICAgfTtcbiAgICBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBDZWxsU2VsZWN0aW9uO1xufShTZWxlY3Rpb24pKTtcblxuZnVuY3Rpb24gY3JlYXRlVGFibGVIZWFkUm93KGNvbHVtbkNvdW50LCBzY2hlbWEsIGRhdGEpIHtcbiAgICB2YXIgX2EgPSBzY2hlbWEubm9kZXMsIHRhYmxlUm93ID0gX2EudGFibGVSb3csIHRhYmxlSGVhZENlbGwgPSBfYS50YWJsZUhlYWRDZWxsLCBwYXJhZ3JhcGggPSBfYS5wYXJhZ3JhcGg7XG4gICAgdmFyIGNlbGxzID0gW107XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGNvbHVtbkNvdW50OyBpbmRleCArPSAxKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZGF0YSAmJiBkYXRhW2luZGV4XTtcbiAgICAgICAgdmFyIHBhcmEgPSBwYXJhZ3JhcGguY3JlYXRlKG51bGwsIHRleHQgPyBzY2hlbWEudGV4dCh0ZXh0KSA6IFtdKTtcbiAgICAgICAgY2VsbHMucHVzaCh0YWJsZUhlYWRDZWxsLmNyZWF0ZShudWxsLCBwYXJhKSk7XG4gICAgfVxuICAgIHJldHVybiBbdGFibGVSb3cuY3JlYXRlKG51bGwsIGNlbGxzKV07XG59XG5mdW5jdGlvbiBjcmVhdGVUYWJsZUJvZHlSb3dzKHJvd0NvdW50LCBjb2x1bW5Db3VudCwgc2NoZW1hLCBkYXRhKSB7XG4gICAgdmFyIF9hID0gc2NoZW1hLm5vZGVzLCB0YWJsZVJvdyA9IF9hLnRhYmxlUm93LCB0YWJsZUJvZHlDZWxsID0gX2EudGFibGVCb2R5Q2VsbCwgcGFyYWdyYXBoID0gX2EucGFyYWdyYXBoO1xuICAgIHZhciB0YWJsZVJvd3MgPSBbXTtcbiAgICBmb3IgKHZhciByb3dJZHggPSAwOyByb3dJZHggPCByb3dDb3VudDsgcm93SWR4ICs9IDEpIHtcbiAgICAgICAgdmFyIGNlbGxzID0gW107XG4gICAgICAgIGZvciAodmFyIGNvbElkeCA9IDA7IGNvbElkeCA8IGNvbHVtbkNvdW50OyBjb2xJZHggKz0gMSkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSBkYXRhICYmIGRhdGFbcm93SWR4ICogY29sdW1uQ291bnQgKyBjb2xJZHhdO1xuICAgICAgICAgICAgdmFyIHBhcmEgPSBwYXJhZ3JhcGguY3JlYXRlKG51bGwsIHRleHQgPyBzY2hlbWEudGV4dCh0ZXh0KSA6IFtdKTtcbiAgICAgICAgICAgIGNlbGxzLnB1c2godGFibGVCb2R5Q2VsbC5jcmVhdGUobnVsbCwgcGFyYSkpO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlUm93cy5wdXNoKHRhYmxlUm93LmNyZWF0ZShudWxsLCBjZWxscykpO1xuICAgIH1cbiAgICByZXR1cm4gdGFibGVSb3dzO1xufVxuZnVuY3Rpb24gY3JlYXRlRHVtbXlDZWxscyhjb2x1bW5Db3VudCwgcm93SWR4LCBzY2hlbWEsIGF0dHJzKSB7XG4gICAgaWYgKGF0dHJzID09PSB2b2lkIDApIHsgYXR0cnMgPSBudWxsOyB9XG4gICAgdmFyIF9hID0gc2NoZW1hLm5vZGVzLCB0YWJsZUhlYWRDZWxsID0gX2EudGFibGVIZWFkQ2VsbCwgdGFibGVCb2R5Q2VsbCA9IF9hLnRhYmxlQm9keUNlbGwsIHBhcmFncmFwaCA9IF9hLnBhcmFncmFwaDtcbiAgICB2YXIgY2VsbCA9IHJvd0lkeCA9PT0gMCA/IHRhYmxlSGVhZENlbGwgOiB0YWJsZUJvZHlDZWxsO1xuICAgIHZhciBjZWxscyA9IFtdO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjb2x1bW5Db3VudDsgaW5kZXggKz0gMSkge1xuICAgICAgICBjZWxscy5wdXNoKGNlbGwuY3JlYXRlKGF0dHJzLCBwYXJhZ3JhcGguY3JlYXRlKCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGxzO1xufVxuZnVuY3Rpb24gZmluZENlbGxFbGVtZW50KG5vZGUsIHJvb3QpIHtcbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSByb290KSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnVEQnIHx8IG5vZGUubm9kZU5hbWUgPT09ICdUSCcpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZENlbGwocG9zKSB7XG4gICAgcmV0dXJuIGZpbmROb2RlQnkocG9zLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAndGFibGVIZWFkQ2VsbCcgfHwgdHlwZS5uYW1lID09PSAndGFibGVCb2R5Q2VsbCc7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZlZFNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xuICAgICAgICB2YXIgJGFuY2hvciA9IHNlbGVjdGlvbi4kYW5jaG9yO1xuICAgICAgICB2YXIgZm91bmRDZWxsID0gZmluZENlbGwoJGFuY2hvcik7XG4gICAgICAgIGlmIChmb3VuZENlbGwpIHtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSAkYW5jaG9yLm5vZGUoMCkucmVzb2x2ZSgkYW5jaG9yLmJlZm9yZShmb3VuZENlbGwuZGVwdGgpKTtcbiAgICAgICAgICAgIHJldHVybiB7IGFuY2hvcjogYW5jaG9yLCBoZWFkOiBhbmNob3IgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgX2EgPSBzZWxlY3Rpb24sIHN0YXJ0Q2VsbCA9IF9hLnN0YXJ0Q2VsbCwgZW5kQ2VsbCA9IF9hLmVuZENlbGw7XG4gICAgcmV0dXJuIHsgYW5jaG9yOiBzdGFydENlbGwsIGhlYWQ6IGVuZENlbGwgfTtcbn1cbmZ1bmN0aW9uIGdldFRhYmxlQ29udGVudEZyb21TbGljZShzbGljZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoc2xpY2Uuc2l6ZSkge1xuICAgICAgICB2YXIgY29udGVudCA9IHNsaWNlLmNvbnRlbnQsIG9wZW5TdGFydCA9IHNsaWNlLm9wZW5TdGFydCwgb3BlbkVuZCA9IHNsaWNlLm9wZW5FbmQ7XG4gICAgICAgIGlmIChjb250ZW50LmNoaWxkQ291bnQgIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjb250ZW50LmNoaWxkQ291bnQgPT09IDEgJiZcbiAgICAgICAgICAgICgob3BlblN0YXJ0ID4gMCAmJiBvcGVuRW5kID4gMCkgfHwgKChfYSA9IGNvbnRlbnQuZmlyc3RDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUubmFtZSkgPT09ICd0YWJsZScpKSB7XG4gICAgICAgICAgICBvcGVuU3RhcnQgLT0gMTtcbiAgICAgICAgICAgIG9wZW5FbmQgLT0gMTtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudC5maXJzdENoaWxkLnR5cGUubmFtZSA9PT0gJ3RhYmxlSGVhZCcgfHxcbiAgICAgICAgICAgIGNvbnRlbnQuZmlyc3RDaGlsZC50eXBlLm5hbWUgPT09ICd0YWJsZUJvZHknKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFJvd0FuZENvbHVtbkNvdW50KF9hKSB7XG4gICAgdmFyIHN0YXJ0Um93SWR4ID0gX2Euc3RhcnRSb3dJZHgsIHN0YXJ0Q29sSWR4ID0gX2Euc3RhcnRDb2xJZHgsIGVuZFJvd0lkeCA9IF9hLmVuZFJvd0lkeCwgZW5kQ29sSWR4ID0gX2EuZW5kQ29sSWR4O1xuICAgIHZhciByb3dDb3VudCA9IGVuZFJvd0lkeCAtIHN0YXJ0Um93SWR4ICsgMTtcbiAgICB2YXIgY29sdW1uQ291bnQgPSBlbmRDb2xJZHggLSBzdGFydENvbElkeCArIDE7XG4gICAgcmV0dXJuIHsgcm93Q291bnQ6IHJvd0NvdW50LCBjb2x1bW5Db3VudDogY29sdW1uQ291bnQgfTtcbn1cbmZ1bmN0aW9uIHNldEF0dHJzKGNlbGwsIGF0dHJzKSB7XG4gICAgcmV0dXJuIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgY2VsbC5hdHRycyksIGF0dHJzKTtcbn1cblxudmFyIHBsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkoJ2NlbGxTZWxlY3Rpb24nKTtcbnZhciBNT1VTRV9SSUdIVF9CVVRUT04gPSAyO1xudmFyIFRhYmxlU2VsZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhYmxlU2VsZWN0aW9uKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHtcbiAgICAgICAgICAgIG1vdXNlZG93bjogdGhpcy5oYW5kbGVNb3VzZWRvd24uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG1vdXNlbW92ZTogdGhpcy5oYW5kbGVNb3VzZW1vdmUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG1vdXNldXA6IHRoaXMuaGFuZGxlTW91c2V1cC5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXJ0Q2VsbFBvcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBUYWJsZVNlbGVjdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZXJzLm1vdXNlZG93bik7XG4gICAgfTtcbiAgICBUYWJsZVNlbGVjdGlvbi5wcm90b3R5cGUuaGFuZGxlTW91c2Vkb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBmb3VuZENlbGwgPSBmaW5kQ2VsbEVsZW1lbnQoZXYudGFyZ2V0LCB0aGlzLnZpZXcuZG9tKTtcbiAgICAgICAgaWYgKGV2LmJ1dHRvbiA9PT0gTU9VU0VfUklHSFRfQlVUVE9OKSB7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZENlbGwpIHtcbiAgICAgICAgICAgIHZhciBzdGFydENlbGxQb3MgPSB0aGlzLmdldENlbGxQb3MoZXYpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0Q2VsbFBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRDZWxsUG9zID0gc3RhcnRDZWxsUG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iaW5kRXZlbnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFibGVTZWxlY3Rpb24ucHJvdG90eXBlLmhhbmRsZU1vdXNlbW92ZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB2YXIgcHJldkVuZENlbGxPZmZzZXQgPSBwbHVnaW5LZXkuZ2V0U3RhdGUodGhpcy52aWV3LnN0YXRlKTtcbiAgICAgICAgdmFyIGVuZENlbGxQb3MgPSB0aGlzLmdldENlbGxQb3MoZXYpO1xuICAgICAgICB2YXIgc3RhcnRDZWxsUG9zID0gdGhpcy5zdGFydENlbGxQb3M7XG4gICAgICAgIHZhciBwcmV2RW5kQ2VsbFBvcztcbiAgICAgICAgaWYgKHByZXZFbmRDZWxsT2Zmc2V0KSB7XG4gICAgICAgICAgICBwcmV2RW5kQ2VsbFBvcyA9IHRoaXMudmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwcmV2RW5kQ2VsbE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhcnRDZWxsUG9zICE9PSBlbmRDZWxsUG9zKSB7XG4gICAgICAgICAgICBwcmV2RW5kQ2VsbFBvcyA9IHN0YXJ0Q2VsbFBvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkVuZENlbGxQb3MgJiYgc3RhcnRDZWxsUG9zICYmIGVuZENlbGxQb3MpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2VsbFNlbGVjdGlvbihzdGFydENlbGxQb3MsIGVuZENlbGxQb3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWJsZVNlbGVjdGlvbi5wcm90b3R5cGUuaGFuZGxlTW91c2V1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGFydENlbGxQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLnVuYmluZEV2ZW50KCk7XG4gICAgICAgIGlmIChwbHVnaW5LZXkuZ2V0U3RhdGUodGhpcy52aWV3LnN0YXRlKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRoaXMudmlldy5zdGF0ZS50ci5zZXRNZXRhKHBsdWdpbktleSwgLTEpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFibGVTZWxlY3Rpb24ucHJvdG90eXBlLmJpbmRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvbSA9IHRoaXMudmlldy5kb207XG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZXJzLm1vdXNlbW92ZSk7XG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVycy5tb3VzZXVwKTtcbiAgICB9O1xuICAgIFRhYmxlU2VsZWN0aW9uLnByb3RvdHlwZS51bmJpbmRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvbSA9IHRoaXMudmlldy5kb207XG4gICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZXJzLm1vdXNlbW92ZSk7XG4gICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVycy5tb3VzZXVwKTtcbiAgICB9O1xuICAgIFRhYmxlU2VsZWN0aW9uLnByb3RvdHlwZS5nZXRDZWxsUG9zID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBjbGllbnRYID0gX2EuY2xpZW50WCwgY2xpZW50WSA9IF9hLmNsaWVudFk7XG4gICAgICAgIHZhciBtb3VzZVBvcyA9IHRoaXMudmlldy5wb3NBdENvb3Jkcyh7IGxlZnQ6IGNsaWVudFgsIHRvcDogY2xpZW50WSB9KTtcbiAgICAgICAgaWYgKG1vdXNlUG9zKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gdGhpcy52aWV3LnN0YXRlLmRvYztcbiAgICAgICAgICAgIHZhciBjdXJyZW50UG9zID0gZG9jLnJlc29sdmUobW91c2VQb3MucG9zKTtcbiAgICAgICAgICAgIHZhciBmb3VuZENlbGwgPSBmaW5kQ2VsbChjdXJyZW50UG9zKTtcbiAgICAgICAgICAgIGlmIChmb3VuZENlbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbE9mZnNldCA9IGN1cnJlbnRQb3MuYmVmb3JlKGZvdW5kQ2VsbC5kZXB0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvYy5yZXNvbHZlKGNlbGxPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVGFibGVTZWxlY3Rpb24ucHJvdG90eXBlLnNldENlbGxTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc3RhcnRDZWxsUG9zLCBlbmRDZWxsUG9zKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCB0ciA9IF9hLnRyO1xuICAgICAgICB2YXIgc3RhcnRpbmcgPSBwbHVnaW5LZXkuZ2V0U3RhdGUodGhpcy52aWV3LnN0YXRlKSA9PT0gbnVsbDtcbiAgICAgICAgdmFyIGNlbGxTZWxlY3Rpb24gPSBuZXcgQ2VsbFNlbGVjdGlvbihzdGFydENlbGxQb3MsIGVuZENlbGxQb3MpO1xuICAgICAgICBpZiAoc3RhcnRpbmcgfHwgIXNlbGVjdGlvbi5lcShjZWxsU2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgdmFyIG5ld1RyID0gdHIuc2V0U2VsZWN0aW9uKGNlbGxTZWxlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHN0YXJ0aW5nKSB7XG4gICAgICAgICAgICAgICAgbmV3VHIuc2V0TWV0YShwbHVnaW5LZXksIGVuZENlbGxQb3MucG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaChuZXdUcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYmxlU2VsZWN0aW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlcnMubW91c2Vkb3duKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZVNlbGVjdGlvbjtcbn0oKSk7XG5cbnZhciBTRUxFQ1RFRF9DRUxMX0NMQVNTX05BTUUgPSBjbHMoJ2NlbGwtc2VsZWN0ZWQnKTtcbmZ1bmN0aW9uIGRyYXdDZWxsU2VsZWN0aW9uKF9hKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgZG9jID0gX2EuZG9jO1xuICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBjZWxsc18xID0gW107XG4gICAgICAgIHZhciByYW5nZXMgPSBzZWxlY3Rpb24ucmFuZ2VzO1xuICAgICAgICByYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciAkZnJvbSA9IF9hLiRmcm9tLCAkdG8gPSBfYS4kdG87XG4gICAgICAgICAgICBjZWxsc18xLnB1c2goRGVjb3JhdGlvbi5ub2RlKCRmcm9tLnBvcyAtIDEsICR0by5wb3MgKyAxLCB7IGNsYXNzOiBTRUxFQ1RFRF9DRUxMX0NMQVNTX05BTUUgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKGRvYywgY2VsbHNfMSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdGFibGVTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IHBsdWdpbktleSxcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcHBseTogZnVuY3Rpb24gKHRyLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsT2Zmc2V0ID0gdHIuZ2V0TWV0YShwbHVnaW5LZXkpO1xuICAgICAgICAgICAgICAgIGlmIChjZWxsT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWxsT2Zmc2V0ID09PSAtMSA/IG51bGwgOiBjZWxsT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsXzEodmFsdWUpIHx8ICF0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gdHIubWFwcGluZy5tYXBSZXN1bHQodmFsdWUpLCBkZWxldGVkID0gX2EuZGVsZXRlZCwgcG9zID0gX2EucG9zO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWxldGVkID8gbnVsbCA6IHBvcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBkZWNvcmF0aW9uczogZHJhd0NlbGxTZWxlY3Rpb24sXG4gICAgICAgICAgICBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbF8xKHBsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdmlldzogZnVuY3Rpb24gKGVkaXRvclZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFibGVTZWxlY3Rpb24oZWRpdG9yVmlldyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAaWdub3JlXG4gKiBAY2xhc3NkZXNjIEVTNiBNYXBcbiAqL1xudmFyIE1hcCQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcCgpIHtcbiAgICAgICAgdGhpcy5rZXlzID0gW107XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgfVxuICAgIE1hcC5wcm90b3R5cGUuZ2V0S2V5SW5kZXggPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBpbkFycmF5XzEoa2V5LCB0aGlzLmtleXMpO1xuICAgIH07XG4gICAgTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1t0aGlzLmdldEtleUluZGV4KGtleSldO1xuICAgIH07XG4gICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIga2V5SW5kZXggPSB0aGlzLmdldEtleUluZGV4KGtleSk7XG4gICAgICAgIGlmIChrZXlJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlc1trZXlJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXlJbmRleChrZXkpID4gLTE7XG4gICAgfTtcbiAgICBNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGtleUluZGV4ID0gdGhpcy5nZXRLZXlJbmRleChrZXkpO1xuICAgICAgICBpZiAoa2V5SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5rZXlzLnNwbGljZShrZXlJbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2Uoa2V5SW5kZXgsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzQXJnID09PSB2b2lkIDApIHsgdGhpc0FyZyA9IHRoaXM7IH1cbiAgICAgICAgdGhpcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgX3RoaXMua2V5c1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBfdGhpcy5rZXlzW2luZGV4XSwgX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcDtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBJbXBsZW1lbnRzIGkxOG5cbiAqIEBhdXRob3IgTkhOIENsb3VkIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG52YXIgREVGQVVMVF9DT0RFID0gJ2VuLVVTJztcbi8qKlxuICogQ2xhc3MgSTE4blxuICogQGlnbm9yZVxuICovXG52YXIgSTE4biA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJMThuKCkge1xuICAgICAgICB0aGlzLmNvZGUgPSBERUZBVUxUX0NPREU7XG4gICAgICAgIHRoaXMubGFuZ3MgPSBuZXcgTWFwJDEoKTtcbiAgICB9XG4gICAgSTE4bi5wcm90b3R5cGUuc2V0Q29kZSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGUgfHwgREVGQVVMVF9DT0RFO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGxhbmd1YWdlIHNldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBjb2RlcyBsb2NhbGUgY29kZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGxhbmd1YWdlIHNldFxuICAgICAqL1xuICAgIEkxOG4ucHJvdG90eXBlLnNldExhbmd1YWdlID0gZnVuY3Rpb24gKGNvZGVzLCBkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvZGVzID0gW10uY29uY2F0KGNvZGVzKTtcbiAgICAgICAgY29kZXMuZm9yRWFjaChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5sYW5ncy5oYXMoY29kZSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sYW5ncy5zZXQoY29kZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZ0RhdGEgPSBfdGhpcy5sYW5ncy5nZXQoY29kZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMubGFuZ3Muc2V0KGNvZGUsIGV4dGVuZF8xKGxhbmdEYXRhLCBkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSTE4bi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSwgY29kZSkge1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhbmdTZXQgPSB0aGlzLmxhbmdzLmdldChjb2RlKTtcbiAgICAgICAgaWYgKCFsYW5nU2V0KSB7XG4gICAgICAgICAgICBsYW5nU2V0ID0gdGhpcy5sYW5ncy5nZXQoREVGQVVMVF9DT0RFKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dCA9IGxhbmdTZXRba2V5XTtcbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyB0ZXh0IGtleSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaW4gXCIgKyBjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIHJldHVybiBJMThuO1xufSgpKTtcbnZhciBpMThuID0gbmV3IEkxOG4oKTtcblxudmFyIGNvbnRleHRNZW51R3JvdXBzID0gW1xuICAgIFtcbiAgICAgICAge1xuICAgICAgICAgICAgYWN0aW9uOiAnQWRkIHJvdyB0byB1cCcsXG4gICAgICAgICAgICBjb21tYW5kOiAnYWRkUm93VG9VcCcsXG4gICAgICAgICAgICBkaXNhYmxlSW5UaGVhZDogdHJ1ZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2FkZC1yb3ctdXAnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBhY3Rpb246ICdBZGQgcm93IHRvIGRvd24nLFxuICAgICAgICAgICAgY29tbWFuZDogJ2FkZFJvd1RvRG93bicsXG4gICAgICAgICAgICBkaXNhYmxlSW5UaGVhZDogdHJ1ZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2FkZC1yb3ctZG93bicsXG4gICAgICAgIH0sXG4gICAgICAgIHsgYWN0aW9uOiAnUmVtb3ZlIHJvdycsIGNvbW1hbmQ6ICdyZW1vdmVSb3cnLCBkaXNhYmxlSW5UaGVhZDogdHJ1ZSwgY2xhc3NOYW1lOiAncmVtb3ZlLXJvdycgfSxcbiAgICBdLFxuICAgIFtcbiAgICAgICAgeyBhY3Rpb246ICdBZGQgY29sdW1uIHRvIGxlZnQnLCBjb21tYW5kOiAnYWRkQ29sdW1uVG9MZWZ0JywgY2xhc3NOYW1lOiAnYWRkLWNvbHVtbi1sZWZ0JyB9LFxuICAgICAgICB7IGFjdGlvbjogJ0FkZCBjb2x1bW4gdG8gcmlnaHQnLCBjb21tYW5kOiAnYWRkQ29sdW1uVG9SaWdodCcsIGNsYXNzTmFtZTogJ2FkZC1jb2x1bW4tcmlnaHQnIH0sXG4gICAgICAgIHsgYWN0aW9uOiAnUmVtb3ZlIGNvbHVtbicsIGNvbW1hbmQ6ICdyZW1vdmVDb2x1bW4nLCBjbGFzc05hbWU6ICdyZW1vdmUtY29sdW1uJyB9LFxuICAgIF0sXG4gICAgW1xuICAgICAgICB7XG4gICAgICAgICAgICBhY3Rpb246ICdBbGlnbiBjb2x1bW4gdG8gbGVmdCcsXG4gICAgICAgICAgICBjb21tYW5kOiAnYWxpZ25Db2x1bW4nLFxuICAgICAgICAgICAgcGF5bG9hZDogeyBhbGlnbjogJ2xlZnQnIH0sXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdhbGlnbi1jb2x1bW4tbGVmdCcsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ0FsaWduIGNvbHVtbiB0byBjZW50ZXInLFxuICAgICAgICAgICAgY29tbWFuZDogJ2FsaWduQ29sdW1uJyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHsgYWxpZ246ICdjZW50ZXInIH0sXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdhbGlnbi1jb2x1bW4tY2VudGVyJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgYWN0aW9uOiAnQWxpZ24gY29sdW1uIHRvIHJpZ2h0JyxcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdhbGlnbkNvbHVtbicsXG4gICAgICAgICAgICBwYXlsb2FkOiB7IGFsaWduOiAncmlnaHQnIH0sXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdhbGlnbi1jb2x1bW4tcmlnaHQnLFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgW3sgYWN0aW9uOiAnUmVtb3ZlIHRhYmxlJywgY29tbWFuZDogJ3JlbW92ZVRhYmxlJywgY2xhc3NOYW1lOiAncmVtb3ZlLXRhYmxlJyB9XSxcbl07XG5mdW5jdGlvbiBnZXRDb250ZXh0TWVudUdyb3VwcyhldmVudEVtaXR0ZXIsIGluVGFibGVIZWFkKSB7XG4gICAgcmV0dXJuIGNvbnRleHRNZW51R3JvdXBzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGNvbnRleHRNZW51R3JvdXApIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZW51R3JvdXAubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IF9hLmFjdGlvbiwgY29tbWFuZCA9IF9hLmNvbW1hbmQsIHBheWxvYWQgPSBfYS5wYXlsb2FkLCBkaXNhYmxlSW5UaGVhZCA9IF9hLmRpc2FibGVJblRoZWFkLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBpMThuLmdldChhY3Rpb24pLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ2NvbW1hbmQnLCBjb21tYW5kLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBpblRhYmxlSGVhZCAmJiAhIWRpc2FibGVJblRoZWFkLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAgICAgLmNvbmNhdCgpO1xufVxuZnVuY3Rpb24gdGFibGVDb250ZXh0TWVudShldmVudEVtaXR0ZXIpIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgICAgICBjb250ZXh0bWVudTogZnVuY3Rpb24gKHZpZXcsIGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZUNlbGwgPSBmaW5kQ2VsbEVsZW1lbnQoZXYudGFyZ2V0LCB2aWV3LmRvbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWJsZUNlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBldiwgY2xpZW50WCA9IF9hLmNsaWVudFgsIGNsaWVudFkgPSBfYS5jbGllbnRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gdmlldy5kb20ucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbGVmdCA9IF9iLmxlZnQsIHRvcF8xID0gX2IudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluVGFibGVIZWFkID0gdGFibGVDZWxsLm5vZGVOYW1lID09PSAnVEgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ2NvbnRleHRtZW51Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogeyBsZWZ0OiBjbGllbnRYIC0gbGVmdCArIDEwICsgXCJweFwiLCB0b3A6IGNsaWVudFkgLSB0b3BfMSArIDMwICsgXCJweFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVudUdyb3VwczogZ2V0Q29udGV4dE1lbnVHcm91cHMoZXZlbnRFbWl0dGVyLCBpblRhYmxlSGVhZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDZWxsOiB0YWJsZUNlbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gdGFzaygpIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgICAgICBtb3VzZWRvd246IGZ1bmN0aW9uICh2aWV3LCBldikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBldiwgY2xpZW50WCA9IF9hLmNsaWVudFgsIGNsaWVudFkgPSBfYS5jbGllbnRZO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgbGVmdDogY2xpZW50WCwgdG9wOiBjbGllbnRZIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW91c2VQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IHZpZXcuc3RhdGUsIGRvYyA9IF9iLmRvYywgdHIgPSBfYi50cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UG9zID0gZG9jLnJlc29sdmUobW91c2VQb3MucG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0SXRlbSA9IGZpbmRMaXN0SXRlbShjdXJyZW50UG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldi50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCwgJzpiZWZvcmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYyA9IGV2LCBvZmZzZXRYID0gX2Mub2Zmc2V0WCwgb2Zmc2V0WSA9IF9jLm9mZnNldFk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxpc3RJdGVtIHx8ICFpc1Bvc2l0aW9uSW5Cb3goc3R5bGUsIG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBjdXJyZW50UG9zLmJlZm9yZShsaXN0SXRlbS5kZXB0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBsaXN0SXRlbS5ub2RlLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChvZmZzZXQsIG51bGwsIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgYXR0cnMpLCB7IGNoZWNrZWQ6ICFhdHRycy5jaGVja2VkIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG52YXIgRVhDRVBUX1RZUEVTID0gWydpbWFnZScsICdsaW5rJywgJ2N1c3RvbUJsb2NrJywgJ2Zyb250TWF0dGVyJ107XG52YXIgTUFSS19UWVBFUyA9IFsnc3Ryb25nJywgJ3N0cmlrZScsICdlbXBoJywgJ2NvZGUnXTtcbnZhciBMSVNUX1RZUEVTID0gWydidWxsZXRMaXN0JywgJ29yZGVyZWRMaXN0JywgJ3Rhc2tMaXN0J107XG5mdW5jdGlvbiBnZXRUb29sYmFyU3RhdGVUeXBlKG5vZGUsIHBhcmVudE5vZGUpIHtcbiAgICB2YXIgdHlwZSA9IG5vZGUudHlwZS5uYW1lO1xuICAgIGlmICh0eXBlID09PSAnbGlzdEl0ZW0nKSB7XG4gICAgICAgIHJldHVybiBub2RlLmF0dHJzLnRhc2sgPyAndGFza0xpc3QnIDogcGFyZW50Tm9kZS50eXBlLm5hbWU7XG4gICAgfVxuICAgIGlmICh0eXBlLmluZGV4T2YoJ3RhYmxlJykgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiAndGFibGUnO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn1cbmZ1bmN0aW9uIHNldExpc3ROb2RlVG9vbGJhclN0YXRlKHR5cGUsIG5vZGVUeXBlU3RhdGUpIHtcbiAgICBub2RlVHlwZVN0YXRlW3R5cGVdID0geyBhY3RpdmU6IHRydWUgfTtcbiAgICBMSVNUX1RZUEVTLmZpbHRlcihmdW5jdGlvbiAobGlzdE5hbWUpIHsgcmV0dXJuIGxpc3ROYW1lICE9PSB0eXBlOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0VHlwZSkge1xuICAgICAgICBpZiAobm9kZVR5cGVTdGF0ZVtsaXN0VHlwZV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBub2RlVHlwZVN0YXRlW2xpc3RUeXBlXTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0TWFya1R5cGVTdGF0ZXMoZnJvbSwgdG8sIHNjaGVtYSwgdG9vbGJhclN0YXRlKSB7XG4gICAgTUFSS19UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBtYXJrID0gc2NoZW1hLm1hcmtzW3R5cGVdO1xuICAgICAgICB2YXIgbWFya3NBdFBvcyA9IGZyb20ubWFya3NBY3Jvc3ModG8pIHx8IFtdO1xuICAgICAgICB2YXIgZm91bmRNYXJrID0gISFtYXJrLmlzSW5TZXQobWFya3NBdFBvcyk7XG4gICAgICAgIGlmIChmb3VuZE1hcmspIHtcbiAgICAgICAgICAgIHRvb2xiYXJTdGF0ZVt0eXBlXSA9IHsgYWN0aXZlOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFRvb2xiYXJTdGF0ZShzZWxlY3Rpb24sIGRvYywgc2NoZW1hKSB7XG4gICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tLCAkdG8gPSBzZWxlY3Rpb24uJHRvLCBmcm9tID0gc2VsZWN0aW9uLmZyb20sIHRvID0gc2VsZWN0aW9uLnRvO1xuICAgIHZhciB0b29sYmFyU3RhdGUgPSB7XG4gICAgICAgIGluZGVudDogeyBhY3RpdmU6IGZhbHNlLCBkaXNhYmxlZDogdHJ1ZSB9LFxuICAgICAgICBvdXRkZW50OiB7IGFjdGl2ZTogZmFsc2UsIGRpc2FibGVkOiB0cnVlIH0sXG4gICAgfTtcbiAgICBkb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmdW5jdGlvbiAobm9kZSwgXywgcGFyZW50Tm9kZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFRvb2xiYXJTdGF0ZVR5cGUobm9kZSwgcGFyZW50Tm9kZSk7XG4gICAgICAgIGlmIChpbmNsdWRlcyhFWENFUFRfVFlQRVMsIHR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVzKExJU1RfVFlQRVMsIHR5cGUpKSB7XG4gICAgICAgICAgICBzZXRMaXN0Tm9kZVRvb2xiYXJTdGF0ZSh0eXBlLCB0b29sYmFyU3RhdGUpO1xuICAgICAgICAgICAgdG9vbGJhclN0YXRlLmluZGVudC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdG9vbGJhclN0YXRlLm91dGRlbnQuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAncGFyYWdyYXBoJyB8fCB0eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHNldE1hcmtUeXBlU3RhdGVzKCRmcm9tLCAkdG8sIHNjaGVtYSwgdG9vbGJhclN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvb2xiYXJTdGF0ZVt0eXBlXSA9IHsgYWN0aXZlOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdG9vbGJhclN0YXRlO1xufVxuZnVuY3Rpb24gdG9vbGJhclN0YXRlSGlnaGxpZ2h0KGV2ZW50RW1pdHRlcikge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgdmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHZpZXcuc3RhdGUsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgZG9jID0gX2EuZG9jLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2VUb29sYmFyU3RhdGUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sYmFyU3RhdGU6IGdldFRvb2xiYXJTdGF0ZShzZWxlY3Rpb24sIGRvYywgc2NoZW1hKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbnZhciBDdXN0b21CbG9ja1ZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ3VzdG9tQmxvY2tWaWV3KG5vZGUsIHZpZXcsIGdldFBvcywgdG9ET01BZGFwdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMub3BlbkVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pbm5lckVkaXRvclZpZXcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlZGl0b3IgaXMgYWxyZWFkeSBvcGVuZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5kb20uZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy53cmFwcGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBfdGhpcy5pbm5lclZpZXdDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICBfdGhpcy5pbm5lckVkaXRvclZpZXcgPSBuZXcgRWRpdG9yVmlldyhfdGhpcy5pbm5lclZpZXdDb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogRWRpdG9yU3RhdGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZG9jOiBfdGhpcy5ub2RlLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXltYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdNb2Qteic6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZG8oX3RoaXMuaW5uZXJFZGl0b3JWaWV3LnN0YXRlLCBfdGhpcy5pbm5lckVkaXRvclZpZXcuZGlzcGF0Y2gpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdTaGlmdC1Nb2Qteic6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZG8oX3RoaXMuaW5uZXJFZGl0b3JWaWV3LnN0YXRlLCBfdGhpcy5pbm5lckVkaXRvclZpZXcuZGlzcGF0Y2gpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRhYjogZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5pbnNlcnRUZXh0KCdcXHQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRW50ZXI6IG5ld2xpbmVJbkNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRXNjYXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNhbmNlbEVkaXRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ3RybC1FbnRlcic6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2F2ZUFuZEZpbmlzaEVkaXRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlzdG9yeSgpLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb246IGZ1bmN0aW9uICh0cikgeyByZXR1cm4gX3RoaXMuZGlzcGF0Y2hJbm5lcih0cik7IH0sXG4gICAgICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlZG93bjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmVkaXRvclZpZXcuaGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlubmVyRWRpdG9yVmlldy5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGJsdXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNhdmVBbmRGaW5pc2hFZGl0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5pbm5lckVkaXRvclZpZXcuZm9jdXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5lZGl0b3JWaWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5nZXRQb3MgPSBnZXRQb3M7XG4gICAgICAgIHRoaXMudG9ET01BZGFwdG9yID0gdG9ET01BZGFwdG9yO1xuICAgICAgICB0aGlzLmlubmVyRWRpdG9yVmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FuY2VsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gY2xzKCdjdXN0b20tYmxvY2snKTtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMud3JhcHBlci5jbGFzc05hbWUgPSBjbHMoJ2N1c3RvbS1ibG9jay12aWV3Jyk7XG4gICAgICAgIHRoaXMuY3JlYXRlSW5uZXJWaWV3Q29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMucmVuZGVyQ3VzdG9tQmxvY2soKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5pbm5lclZpZXdDb250YWluZXIpO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgIH1cbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLnJlbmRlclRvb2xBcmVhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdG9vbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICB0b29sLmNsYXNzTmFtZSA9ICd0b29sJztcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHRoaXMubm9kZS5hdHRycy5pbmZvO1xuICAgICAgICBzcGFuLmNsYXNzTmFtZSA9ICdpbmZvJztcbiAgICAgICAgYnV0dG9uLnR5cGUgPSAnYnV0dG9uJztcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub3BlbkVkaXRvcigpOyB9KTtcbiAgICAgICAgdG9vbC5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgdG9vbC5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgICB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodG9vbCk7XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLnJlbmRlckN1c3RvbUJsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9ET01Ob2RlID0gdGhpcy50b0RPTUFkYXB0b3IuZ2V0VG9ET01Ob2RlKHRoaXMubm9kZS5hdHRycy5pbmZvKTtcbiAgICAgICAgaWYgKHRvRE9NTm9kZSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0b0RPTU5vZGUodGhpcy5ub2RlKTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLndyYXBwZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMud3JhcHBlci5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRvb2xBcmVhKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEN1c3RvbUJsb2NrVmlldy5wcm90b3R5cGUuY3JlYXRlSW5uZXJWaWV3Q29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlubmVyVmlld0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmlubmVyVmlld0NvbnRhaW5lci5jbGFzc05hbWUgPSBjbHMoJ2N1c3RvbS1ibG9jay1lZGl0b3InKTtcbiAgICAgICAgdGhpcy5pbm5lclZpZXdDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9O1xuICAgIEN1c3RvbUJsb2NrVmlldy5wcm90b3R5cGUuY2xvc2VFZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlubmVyRWRpdG9yVmlldykge1xuICAgICAgICAgICAgdGhpcy5pbm5lckVkaXRvclZpZXcuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5pbm5lckVkaXRvclZpZXcgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5pbm5lclZpZXdDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyYXBwZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLnNhdmVBbmRGaW5pc2hFZGl0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG8gPSB0aGlzLmVkaXRvclZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICB2YXIgb3V0ZXJTdGF0ZSA9IHRoaXMuZWRpdG9yVmlldy5zdGF0ZTtcbiAgICAgICAgdGhpcy5lZGl0b3JWaWV3LmRpc3BhdGNoKG91dGVyU3RhdGUudHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24ob3V0ZXJTdGF0ZS50ciwgdG8pKSk7XG4gICAgICAgIHRoaXMuZWRpdG9yVmlldy5mb2N1cygpO1xuICAgICAgICB0aGlzLnJlbmRlckN1c3RvbUJsb2NrKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFZGl0b3IoKTtcbiAgICB9O1xuICAgIEN1c3RvbUJsb2NrVmlldy5wcm90b3R5cGUuY2FuY2VsRWRpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVuZG9hYmxlQ291bnQgPSB1bmRvRGVwdGgodGhpcy5pbm5lckVkaXRvclZpZXcuc3RhdGUpO1xuICAgICAgICB0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gc2hvdWxkIHVuZG8gZWRpdGluZyByZXN1bHRcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBsdXNwbHVzXG4gICAgICAgIHdoaWxlICh1bmRvYWJsZUNvdW50LS0pIHtcbiAgICAgICAgICAgIHVuZG8odGhpcy5pbm5lckVkaXRvclZpZXcuc3RhdGUsIHRoaXMuaW5uZXJFZGl0b3JWaWV3LmRpc3BhdGNoKTtcbiAgICAgICAgICAgIHVuZG8odGhpcy5lZGl0b3JWaWV3LnN0YXRlLCB0aGlzLmVkaXRvclZpZXcuZGlzcGF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FuY2VsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRvID0gdGhpcy5lZGl0b3JWaWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgdmFyIG91dGVyU3RhdGUgPSB0aGlzLmVkaXRvclZpZXcuc3RhdGU7XG4gICAgICAgIHRoaXMuZWRpdG9yVmlldy5kaXNwYXRjaChvdXRlclN0YXRlLnRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZShvdXRlclN0YXRlLmRvYywgdG8pKSk7XG4gICAgICAgIHRoaXMuZWRpdG9yVmlldy5mb2N1cygpO1xuICAgICAgICB0aGlzLmNsb3NlRWRpdG9yKCk7XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLmRpc3BhdGNoSW5uZXIgPSBmdW5jdGlvbiAodHIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5pbm5lckVkaXRvclZpZXcuc3RhdGUuYXBwbHlUcmFuc2FjdGlvbih0ciksIHN0YXRlID0gX2Euc3RhdGUsIHRyYW5zYWN0aW9ucyA9IF9hLnRyYW5zYWN0aW9ucztcbiAgICAgICAgdGhpcy5pbm5lckVkaXRvclZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgICAgICBpZiAoIXRoaXMuY2FuY2VsZWQgJiYgaXNGdW5jdGlvbl8xKHRoaXMuZ2V0UG9zKSkge1xuICAgICAgICAgICAgdmFyIG91dGVyVHIgPSB0aGlzLmVkaXRvclZpZXcuc3RhdGUudHI7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0TWFwID0gU3RlcE1hcC5vZmZzZXQodGhpcy5nZXRQb3MoKSArIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2FjdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RlcHMgPSB0cmFuc2FjdGlvbnNbaV0uc3RlcHM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdGVwcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRlclRyLnN0ZXAoc3RlcHNbal0ubWFwKG9mZnNldE1hcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdXRlclRyLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvclZpZXcuZGlzcGF0Y2gob3V0ZXJUcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEN1c3RvbUJsb2NrVmlldy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlLnNhbWVNYXJrdXAodGhpcy5ub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIGlmICghdGhpcy5pbm5lckVkaXRvclZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ3VzdG9tQmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEN1c3RvbUJsb2NrVmlldy5wcm90b3R5cGUuc3RvcEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiAoISF0aGlzLmlubmVyRWRpdG9yVmlldyAmJlxuICAgICAgICAgICAgISFldmVudC50YXJnZXQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5uZXJFZGl0b3JWaWV3LmRvbS5jb250YWlucyhldmVudC50YXJnZXQpKTtcbiAgICB9O1xuICAgIEN1c3RvbUJsb2NrVmlldy5wcm90b3R5cGUuaWdub3JlTXV0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgQ3VzdG9tQmxvY2tWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMub3BlbkVkaXRvcik7XG4gICAgICAgIHRoaXMuY2xvc2VFZGl0b3IoKTtcbiAgICB9O1xuICAgIHJldHVybiBDdXN0b21CbG9ja1ZpZXc7XG59KCkpO1xuXG52YXIgSU1BR0VfTElOS19DTEFTU19OQU1FID0gJ2ltYWdlLWxpbmsnO1xudmFyIEltYWdlVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbWFnZVZpZXcobm9kZSwgdmlldywgZ2V0UG9zLCBldmVudEVtaXR0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlZG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldi50YXJnZXQsIG9mZnNldFggPSBldi5vZmZzZXRYLCBvZmZzZXRZID0gZXYub2Zmc2V0WTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pbWFnZUxpbmsgJiZcbiAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uXzEoX3RoaXMuZ2V0UG9zKSAmJlxuICAgICAgICAgICAgICAgIGhhc0NsYXNzXzEodGFyZ2V0LCBJTUFHRV9MSU5LX0NMQVNTX05BTUUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQsICc6YmVmb3JlJyk7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUG9zaXRpb25JbkJveChzdHlsZSwgb2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyID0gX3RoaXMudmlldy5zdGF0ZS50cjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IF90aGlzLmdldFBvcygpO1xuICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgcG9zLCBwb3MgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnb3BlblBvcHVwJywgJ2xpbmsnLCBfdGhpcy5pbWFnZUxpbmsuYXR0cnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5nZXRQb3MgPSBnZXRQb3M7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gZXZlbnRFbWl0dGVyO1xuICAgICAgICB0aGlzLmltYWdlTGluayA9IChfYSA9IG5vZGUubWFya3MuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ2xpbmsnO1xuICAgICAgICB9KVswXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSB0aGlzLmNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5iaW5kRXZlbnQoKTtcbiAgICB9XG4gICAgSW1hZ2VWaWV3LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmNyZWF0ZUltYWdlRWxlbWVudCh0aGlzLm5vZGUpO1xuICAgICAgICBpZiAodGhpcy5pbWFnZUxpbmspIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgd3JhcHBlci5jbGFzc05hbWUgPSBJTUFHRV9MSU5LX0NMQVNTX05BTUU7XG4gICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGltYWdlKTtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9O1xuICAgIEltYWdlVmlldy5wcm90b3R5cGUuY3JlYXRlSW1hZ2VFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIHZhciBfYSA9IG5vZGUuYXR0cnMsIGltYWdlVXJsID0gX2EuaW1hZ2VVcmwsIGFsdFRleHQgPSBfYS5hbHRUZXh0O1xuICAgICAgICB2YXIgYXR0cnMgPSBnZXRDdXN0b21BdHRycyhub2RlLmF0dHJzKTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gaW1hZ2VVcmw7XG4gICAgICAgIGlmIChhbHRUZXh0KSB7XG4gICAgICAgICAgICBpbWFnZS5hbHQgPSBhbHRUZXh0O1xuICAgICAgICB9XG4gICAgICAgIHNldEF0dHJpYnV0ZXMoYXR0cnMsIGltYWdlKTtcbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH07XG4gICAgSW1hZ2VWaWV3LnByb3RvdHlwZS5iaW5kRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlTGluaykge1xuICAgICAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZWRvd24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbWFnZVZpZXcucHJvdG90eXBlLnN0b3BFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBJbWFnZVZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlTGluaykge1xuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZWRvd24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSW1hZ2VWaWV3O1xufSgpKTtcblxudmFyIFdSQVBQRVJfQ0xBU1NfTkFNRSA9ICd0b2FzdHVpLWVkaXRvci13dy1jb2RlLWJsb2NrJztcbnZhciBDT0RFX0JMT0NLX0xBTkdfQ0xBU1NfTkFNRSA9ICd0b2FzdHVpLWVkaXRvci13dy1jb2RlLWJsb2NrLWxhbmd1YWdlJztcbnZhciBDb2RlQmxvY2tWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvZGVCbG9ja1ZpZXcobm9kZSwgdmlldywgZ2V0UG9zLCBldmVudEVtaXR0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb250ZW50RE9NID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnB1dCA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlZG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0LCAnOmFmdGVyJyk7XG4gICAgICAgICAgICAvLyBqdWRnZSB0byBjbGljayBwc2V1ZG8gZWxlbWVudCB3aXRoIGJhY2tncm91bmQgaW1hZ2UgZm9yIElFMTFcbiAgICAgICAgICAgIGlmIChzdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgIT09ICdub25lJyAmJiBpc0Z1bmN0aW9uXzEoX3RoaXMuZ2V0UG9zKSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnZpZXcuY29vcmRzQXRQb3MoX3RoaXMuZ2V0UG9zKCkpLCB0b3BfMSA9IF9hLnRvcCwgcmlnaHQgPSBfYS5yaWdodDtcbiAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVMYW5ndWFnZUVkaXRvcih7IHRvcDogdG9wXzEsIHJpZ2h0OiByaWdodCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVLZXlkb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYua2V5ID09PSAnRW50ZXInICYmIF90aGlzLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VMYW5ndWFnZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmdldFBvcyA9IGdldFBvcztcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBldmVudEVtaXR0ZXI7XG4gICAgICAgIHRoaXMuY3JlYXRlRWxlbWVudCgpO1xuICAgICAgICB0aGlzLmJpbmRET01FdmVudCgpO1xuICAgICAgICB0aGlzLmJpbmRFdmVudCgpO1xuICAgIH1cbiAgICBDb2RlQmxvY2tWaWV3LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSB0aGlzLm5vZGUuYXR0cnMubGFuZ3VhZ2U7XG4gICAgICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKCdkYXRhLWxhbmd1YWdlJywgbGFuZ3VhZ2UgfHwgJ3RleHQnKTtcbiAgICAgICAgd3JhcHBlci5jbGFzc05hbWUgPSBXUkFQUEVSX0NMQVNTX05BTUU7XG4gICAgICAgIHZhciBwcmUgPSB0aGlzLmNyZWF0ZUNvZGVCbG9ja0VsZW1lbnQoKTtcbiAgICAgICAgdmFyIGNvZGUgPSBwcmUuZmlyc3RDaGlsZDtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChwcmUpO1xuICAgICAgICB0aGlzLmRvbSA9IHdyYXBwZXI7XG4gICAgICAgIHRoaXMuY29udGVudERPTSA9IGNvZGU7XG4gICAgfTtcbiAgICBDb2RlQmxvY2tWaWV3LnByb3RvdHlwZS5jcmVhdGVDb2RlQmxvY2tFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncHJlJyk7XG4gICAgICAgIHZhciBjb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29kZScpO1xuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSB0aGlzLm5vZGUuYXR0cnMubGFuZ3VhZ2U7XG4gICAgICAgIHZhciBhdHRycyA9IGdldEN1c3RvbUF0dHJzKHRoaXMubm9kZS5hdHRycyk7XG4gICAgICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgICAgICAgY29kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGFuZ3VhZ2UnLCBsYW5ndWFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0QXR0cmlidXRlcyhhdHRycywgcHJlKTtcbiAgICAgICAgcHJlLmFwcGVuZENoaWxkKGNvZGUpO1xuICAgICAgICByZXR1cm4gcHJlO1xuICAgIH07XG4gICAgQ29kZUJsb2NrVmlldy5wcm90b3R5cGUuY3JlYXRlTGFuZ3VhZ2VFZGl0b3IgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRvcCA9IF9hLnRvcCwgcmlnaHQgPSBfYS5yaWdodDtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHdyYXBwZXIuY2xhc3NOYW1lID0gQ09ERV9CTE9DS19MQU5HX0NMQVNTX05BTUU7XG4gICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGlucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy5ub2RlLmF0dHJzLmxhbmd1YWdlO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5wYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgICAgICB2YXIgd3JwcGVyV2lkdGggPSB3cmFwcGVyLmNsaWVudFdpZHRoO1xuICAgICAgICBjc3NfMSh3cmFwcGVyLCB7XG4gICAgICAgICAgICB0b3A6IHRvcCArIDEwICsgXCJweFwiLFxuICAgICAgICAgICAgbGVmdDogcmlnaHQgLSB3cnBwZXJXaWR0aCAtIDEwICsgXCJweFwiLFxuICAgICAgICAgICAgd2lkdGg6IHdycHBlcldpZHRoICsgXCJweFwiLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jaGFuZ2VMYW5ndWFnZSgpOyB9KTtcbiAgICAgICAgdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlkb3duKTtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29kZUJsb2NrVmlldy5wcm90b3R5cGUuYmluZERPTUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb20pIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVNb3VzZWRvd24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2RlQmxvY2tWaWV3LnByb3RvdHlwZS5iaW5kRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3Rlbignc2Nyb2xsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb2RlQmxvY2tWaWV3LnByb3RvdHlwZS5jaGFuZ2VMYW5ndWFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQgJiYgaXNGdW5jdGlvbl8xKHRoaXMuZ2V0UG9zKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5pbnB1dC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmdldFBvcygpO1xuICAgICAgICAgICAgdmFyIHRyID0gdGhpcy52aWV3LnN0YXRlLnRyO1xuICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIG51bGwsIHsgbGFuZ3VhZ2U6IHZhbHVlIH0pO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29kZUJsb2NrVmlldy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMuaW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50XzEgPSB0aGlzLmlucHV0LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUkMShwYXJlbnRfMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvZGVCbG9ja1ZpZXcucHJvdG90eXBlLmNsZWFyVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29kZUJsb2NrVmlldy5wcm90b3R5cGUuc3RvcEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIENvZGVCbG9ja1ZpZXcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIENvZGVCbG9ja1ZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZU1vdXNlZG93bik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb2RlQmxvY2tWaWV3O1xufSgpKTtcblxudmFyIHJlTVNPTGlzdENsYXNzTmFtZSA9IC9Nc29MaXN0UGFyYWdyYXBoLztcbnZhciByZU1TT1N0eWxlUHJlZml4ID0gL3N0eWxlPSgufFxcbikqbXNvLS87XG52YXIgcmVNU09MaXN0U3R5bGUgPSAvbXNvLWxpc3Q6KC4qKS87XG52YXIgcmVNU09UYWdOYW1lID0gL086UC87XG52YXIgcmVNU09MaXN0QnVsbGV0ID0gL14obnx1fGwpLztcbnZhciBNU09fQ0xBU1NfTkFNRV9MSVNUX1BBUkEgPSAncC5Nc29MaXN0UGFyYWdyYXBoJztcbmZ1bmN0aW9uIGlzRnJvbU1zbyhodG1sKSB7XG4gICAgcmV0dXJuIHJlTVNPU3R5bGVQcmVmaXgudGVzdChodG1sKTtcbn1cbmZ1bmN0aW9uIGdldExpc3RJdGVtQ29udGVudHMocGFyYSkge1xuICAgIHZhciByZW1vdmVkTm9kZXMgPSBbXTtcbiAgICB2YXIgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihwYXJhLCAxLCBudWxsLCBmYWxzZSk7XG4gICAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgIHZhciBub2RlID0gd2Fsa2VyLmN1cnJlbnROb2RlO1xuICAgICAgICBpZiAoaXNFbGVtTm9kZShub2RlKSkge1xuICAgICAgICAgICAgdmFyIF9hID0gbm9kZSwgb3V0ZXJIVE1MID0gX2Eub3V0ZXJIVE1MLCB0ZXh0Q29udGVudCA9IF9hLnRleHRDb250ZW50O1xuICAgICAgICAgICAgdmFyIG1zb1NwYW4gPSByZU1TT1N0eWxlUHJlZml4LnRlc3Qob3V0ZXJIVE1MKTtcbiAgICAgICAgICAgIHZhciBidWxsZXRTcGFuID0gcmVNU09MaXN0U3R5bGUudGVzdChvdXRlckhUTUwpO1xuICAgICAgICAgICAgaWYgKG1zb1NwYW4gJiYgIWJ1bGxldFNwYW4gJiYgdGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkTm9kZXMucHVzaChbbm9kZSwgdHJ1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVNU09UYWdOYW1lLnRlc3Qobm9kZS5ub2RlTmFtZSkgfHwgKG1zb1NwYW4gJiYgIXRleHRDb250ZW50KSB8fCBidWxsZXRTcGFuKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZE5vZGVzLnB1c2goW25vZGUsIGZhbHNlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2FbMF0sIGlzVW53cmFwID0gX2FbMV07XG4gICAgICAgIGlmIChpc1Vud3JhcCkge1xuICAgICAgICAgICAgdW53cmFwTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUkMShub2RlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYXJhLmlubmVySFRNTC50cmltKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVMaXN0SXRlbURhdGFGcm9tUGFyYWdyYXBoKHBhcmEsIGluZGV4KSB7XG4gICAgdmFyIHN0eWxlQXR0ciA9IHBhcmEuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgIGlmIChzdHlsZUF0dHIpIHtcbiAgICAgICAgdmFyIF9hID0gc3R5bGVBdHRyLm1hdGNoKHJlTVNPTGlzdFN0eWxlKSwgbGlzdEl0ZW1JbmZvID0gX2FbMV07XG4gICAgICAgIHZhciBfYiA9IGxpc3RJdGVtSW5mby50cmltKCkuc3BsaXQoJyAnKSwgbGV2ZWxTdHIgPSBfYlsxXTtcbiAgICAgICAgdmFyIGxldmVsID0gcGFyc2VJbnQobGV2ZWxTdHIucmVwbGFjZSgnbGV2ZWwnLCAnJyksIDEwKTtcbiAgICAgICAgdmFyIHVub3JkZXJlZCA9IHJlTVNPTGlzdEJ1bGxldC50ZXN0KHBhcmEudGV4dENvbnRlbnQgfHwgJycpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGluZGV4LFxuICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgcHJldjogbnVsbCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIHVub3JkZXJlZDogdW5vcmRlcmVkLFxuICAgICAgICAgICAgY29udGVudHM6IGdldExpc3RJdGVtQ29udGVudHMocGFyYSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYWRkTGlzdEl0ZW1EZXRhaWxEYXRhKGRhdGEsIHByZXZEYXRhKSB7XG4gICAgaWYgKHByZXZEYXRhLmxldmVsIDwgZGF0YS5sZXZlbCkge1xuICAgICAgICBwcmV2RGF0YS5jaGlsZHJlbi5wdXNoKGRhdGEpO1xuICAgICAgICBkYXRhLnBhcmVudCA9IHByZXZEYXRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2hpbGUgKHByZXZEYXRhKSB7XG4gICAgICAgICAgICBpZiAocHJldkRhdGEubGV2ZWwgPT09IGRhdGEubGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZEYXRhID0gcHJldkRhdGEucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2RGF0YSkge1xuICAgICAgICAgICAgZGF0YS5wcmV2ID0gcHJldkRhdGE7XG4gICAgICAgICAgICBkYXRhLnBhcmVudCA9IHByZXZEYXRhLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChkYXRhLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGRhdGEucGFyZW50LmNoaWxkcmVuLnB1c2goZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVMaXN0RGF0YShwYXJhcykge1xuICAgIHZhciBsaXN0RGF0YSA9IFtdO1xuICAgIHBhcmFzLmZvckVhY2goZnVuY3Rpb24gKHBhcmEsIGluZGV4KSB7XG4gICAgICAgIHZhciBwcmV2TGlzdEl0ZW1EYXRhID0gbGlzdERhdGFbaW5kZXggLSAxXTtcbiAgICAgICAgdmFyIGxpc3RJdGVtRGF0YSA9IGNyZWF0ZUxpc3RJdGVtRGF0YUZyb21QYXJhZ3JhcGgocGFyYSwgaW5kZXgpO1xuICAgICAgICBpZiAobGlzdEl0ZW1EYXRhKSB7XG4gICAgICAgICAgICBpZiAocHJldkxpc3RJdGVtRGF0YSkge1xuICAgICAgICAgICAgICAgIGFkZExpc3RJdGVtRGV0YWlsRGF0YShsaXN0SXRlbURhdGEsIHByZXZMaXN0SXRlbURhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdERhdGEucHVzaChsaXN0SXRlbURhdGEpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGxpc3REYXRhO1xufVxuZnVuY3Rpb24gbWFrZUxpc3QobGlzdERhdGEpIHtcbiAgICB2YXIgbGlzdFRhZ05hbWUgPSBsaXN0RGF0YVswXS51bm9yZGVyZWQgPyAndWwnIDogJ29sJztcbiAgICB2YXIgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobGlzdFRhZ05hbWUpO1xuICAgIGxpc3REYXRhLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZGF0YS5jaGlsZHJlbiwgY29udGVudHMgPSBkYXRhLmNvbnRlbnRzO1xuICAgICAgICB2YXIgbGlzdEl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICBsaXN0SXRlbS5pbm5lckhUTUwgPSBjb250ZW50cztcbiAgICAgICAgbGlzdC5hcHBlbmRDaGlsZChsaXN0SXRlbSk7XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxpc3QuYXBwZW5kQ2hpbGQobWFrZUxpc3QoY2hpbGRyZW4pKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBsaXN0O1xufVxuZnVuY3Rpb24gbWFrZUxpc3RGcm9tUGFyYWdyYXBocyhwYXJhcykge1xuICAgIHZhciBsaXN0RGF0YSA9IGNyZWF0ZUxpc3REYXRhKHBhcmFzKTtcbiAgICB2YXIgcm9vdENoaWxkcmVuID0gbGlzdERhdGEuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gX2EucGFyZW50O1xuICAgICAgICByZXR1cm4gIXBhcmVudDtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFrZUxpc3Qocm9vdENoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIGlzTXNvTGlzdFBhcmFncmFwaEVuZChub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzRWxlbU5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZSA/ICFyZU1TT0xpc3RDbGFzc05hbWUudGVzdChub2RlLmNsYXNzTmFtZSkgOiB0cnVlO1xufVxuZnVuY3Rpb24gY29udmVydE1zb1BhcmFncmFwaHNUb0xpc3QoaHRtbCkge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB2YXIgcGFyYXMgPSBbXTtcbiAgICB2YXIgZm91bmRQYXJhcyA9IGZpbmROb2Rlcyhjb250YWluZXIsIE1TT19DTEFTU19OQU1FX0xJU1RfUEFSQSk7XG4gICAgZm91bmRQYXJhcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhKSB7XG4gICAgICAgIHZhciBtc29MaXN0UGFyYUVuZCA9IGlzTXNvTGlzdFBhcmFncmFwaEVuZChwYXJhLm5leHRTaWJsaW5nKTtcbiAgICAgICAgcGFyYXMucHVzaChwYXJhKTtcbiAgICAgICAgaWYgKG1zb0xpc3RQYXJhRW5kKSB7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IG1ha2VMaXN0RnJvbVBhcmFncmFwaHMocGFyYXMpO1xuICAgICAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gcGFyYS5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmIChuZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZU5vZGUobGlzdCwgbmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kTm9kZXMoY29udGFpbmVyLCBsaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlTm9kZSQxKHBhcmEpO1xuICAgIH0pO1xuICAgIC8vIHdpdGhvdXQgYDxwPjwvcD5gLCB0aGUgbGlzdCBzdHJpbmcgd2FzIHBhcnNlZCBhcyBhIHBhcmFncmFwaCBub2RlIGFuZCBhZGRlZFxuICAgIHZhciBleHRyYUhUTUwgPSBmb3VuZFBhcmFzLmxlbmd0aCA/ICc8cD48L3A+JyA6ICcnO1xuICAgIHJldHVybiBcIlwiICsgZXh0cmFIVE1MICsgY29udGFpbmVyLmlubmVySFRNTDtcbn1cblxudmFyIFNUQVJUX0ZSQUdNRU5UX0NPTU1FTlQgPSAnPCEtLVN0YXJ0RnJhZ21lbnQtLT4nO1xudmFyIEVORF9GUkFHTUVOVF9DT01NRU5UID0gJzwhLS1FbmRGcmFnbWVudC0tPic7XG5mdW5jdGlvbiBnZXRDb250ZW50QmV0d2VlbkZyYWdtZW50Q29tbWVudHMoaHRtbCkge1xuICAgIHZhciBzdGFydEZyYWdtZW50SW5kZXggPSBodG1sLmluZGV4T2YoU1RBUlRfRlJBR01FTlRfQ09NTUVOVCk7XG4gICAgdmFyIGVuZEZyYWdtZW50SW5kZXggPSBodG1sLmxhc3RJbmRleE9mKEVORF9GUkFHTUVOVF9DT01NRU5UKTtcbiAgICBpZiAoc3RhcnRGcmFnbWVudEluZGV4ID4gLTEgJiYgZW5kRnJhZ21lbnRJbmRleCA+IC0xKSB7XG4gICAgICAgIGh0bWwgPSBodG1sLnNsaWNlKHN0YXJ0RnJhZ21lbnRJbmRleCArIFNUQVJUX0ZSQUdNRU5UX0NPTU1FTlQubGVuZ3RoLCBlbmRGcmFnbWVudEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWwucmVwbGFjZSgvPGJyW14+XSo+L2csIEFMVEVSTkFUSVZFX1RBR19GT1JfQlIpO1xufVxuZnVuY3Rpb24gY29udmVydE1zb1RhYmxlVG9Db21wbGV0ZWRUYWJsZShodG1sKSB7XG4gICAgLy8gd3JhcCB3aXRoIDx0cj4gaWYgaHRtbCBjb250YWlucyBkYW5nbGluZyA8dGQ+IHRhZ3NcbiAgICAvLyBkYW5nbGluZyA8dGQ+IHRhZyBpcyB0aGF0IHRhZyBkb2VzIG5vdCBoYXZlIDx0cj4gYXMgcGFyZW50IG5vZGVcbiAgICBpZiAoLzxcXC90ZD4oKD8hPFxcL3RyPilbXFxzXFxTXSkqJC9pLnRlc3QoaHRtbCkpIHtcbiAgICAgICAgaHRtbCA9IFwiPHRyPlwiICsgaHRtbCArIFwiPC90cj5cIjtcbiAgICB9XG4gICAgLy8gd3JhcCB3aXRoIDx0YWJsZT4gaWYgaHRtbCBjb250YWlucyBkYW5nbGluZyA8dHI+IHRhZ3NcbiAgICAvLyBkYW5nbGluZyA8dHI+IHRhZyBpcyB0aGF0IHRhZyBkb2VzIG5vdCBoYXZlIDx0YWJsZT4gYXMgcGFyZW50IG5vZGVcbiAgICBpZiAoLzxcXC90cj4oKD8hPFxcL3RhYmxlPilbXFxzXFxTXSkqJC9pLnRlc3QoaHRtbCkpIHtcbiAgICAgICAgaHRtbCA9IFwiPHRhYmxlPlwiICsgaHRtbCArIFwiPC90YWJsZT5cIjtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG59XG5mdW5jdGlvbiBjaGFuZ2VQYXN0ZWRIVE1MKGh0bWwpIHtcbiAgICBodG1sID0gZ2V0Q29udGVudEJldHdlZW5GcmFnbWVudENvbW1lbnRzKGh0bWwpO1xuICAgIGh0bWwgPSBjb252ZXJ0TXNvVGFibGVUb0NvbXBsZXRlZFRhYmxlKGh0bWwpO1xuICAgIGlmIChpc0Zyb21Nc28oaHRtbCkpIHtcbiAgICAgICAgaHRtbCA9IGNvbnZlcnRNc29QYXJhZ3JhcGhzVG9MaXN0KGh0bWwpO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbn1cbmZ1bmN0aW9uIGdldE1heENvbHVtbkNvdW50KHJvd3MpIHtcbiAgICB2YXIgcm93ID0gcm93cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZSb3csIGN1cnJlbnRSb3cpIHtcbiAgICAgICAgcmV0dXJuIHByZXZSb3cuY2hpbGRDb3VudCA+IGN1cnJlbnRSb3cuY2hpbGRDb3VudCA/IHByZXZSb3cgOiBjdXJyZW50Um93O1xuICAgIH0pO1xuICAgIHJldHVybiByb3cuY2hpbGRDb3VudDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNlbGxzKG9yZ1JvdywgbWF4Q29sdW1uQ291bnQsIGNlbGwpIHtcbiAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICB2YXIgY2VsbENvdW50ID0gb3JnUm93LmNoaWxkQ291bnQ7XG4gICAgZm9yICh2YXIgY29sSWR4ID0gMDsgY29sSWR4IDwgY2VsbENvdW50OyBjb2xJZHggKz0gMSkge1xuICAgICAgICBpZiAoIW9yZ1Jvdy5jaGlsZChjb2xJZHgpLmF0dHJzLmV4dGVuZGVkKSB7XG4gICAgICAgICAgICB2YXIgY29waWVkQ2VsbCA9IGNvbElkeCA8IGNlbGxDb3VudFxuICAgICAgICAgICAgICAgID8gY2VsbC5jcmVhdGUob3JnUm93LmNoaWxkKGNvbElkeCkuYXR0cnMsIG9yZ1Jvdy5jaGlsZChjb2xJZHgpLmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgOiBjZWxsLmNyZWF0ZUFuZEZpbGwoKTtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goY29waWVkQ2VsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNlbGxzO1xufVxuZnVuY3Rpb24gY29weVRhYmxlSGVhZFJvdyhvcmdSb3csIG1heENvbHVtbkNvdW50LCBzY2hlbWEpIHtcbiAgICB2YXIgX2EgPSBzY2hlbWEubm9kZXMsIHRhYmxlUm93ID0gX2EudGFibGVSb3csIHRhYmxlSGVhZENlbGwgPSBfYS50YWJsZUhlYWRDZWxsO1xuICAgIHZhciBjZWxscyA9IGNyZWF0ZUNlbGxzKG9yZ1JvdywgbWF4Q29sdW1uQ291bnQsIHRhYmxlSGVhZENlbGwpO1xuICAgIHJldHVybiB0YWJsZVJvdy5jcmVhdGUobnVsbCwgY2VsbHMpO1xufVxuZnVuY3Rpb24gY29weVRhYmxlQm9keVJvdyhvcmdSb3csIG1heENvbHVtbkNvdW50LCBzY2hlbWEpIHtcbiAgICB2YXIgX2EgPSBzY2hlbWEubm9kZXMsIHRhYmxlUm93ID0gX2EudGFibGVSb3csIHRhYmxlQm9keUNlbGwgPSBfYS50YWJsZUJvZHlDZWxsO1xuICAgIHZhciBjZWxscyA9IGNyZWF0ZUNlbGxzKG9yZ1JvdywgbWF4Q29sdW1uQ291bnQsIHRhYmxlQm9keUNlbGwpO1xuICAgIHJldHVybiB0YWJsZVJvdy5jcmVhdGUobnVsbCwgY2VsbHMpO1xufVxuZnVuY3Rpb24gY3JlYXRUYWJsZUJvZHlEdW1teVJvdyhjb2x1bW5Db3VudCwgc2NoZW1hKSB7XG4gICAgdmFyIF9hID0gc2NoZW1hLm5vZGVzLCB0YWJsZVJvdyA9IF9hLnRhYmxlUm93LCB0YWJsZUJvZHlDZWxsID0gX2EudGFibGVCb2R5Q2VsbDtcbiAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICBmb3IgKHZhciBjb2x1bW5JbmRleCA9IDA7IGNvbHVtbkluZGV4IDwgY29sdW1uQ291bnQ7IGNvbHVtbkluZGV4ICs9IDEpIHtcbiAgICAgICAgdmFyIGR1bW15Q2VsbCA9IHRhYmxlQm9keUNlbGwuY3JlYXRlQW5kRmlsbCgpO1xuICAgICAgICBjZWxscy5wdXNoKGR1bW15Q2VsbCk7XG4gICAgfVxuICAgIHJldHVybiB0YWJsZVJvdy5jcmVhdGUoeyBkdW1teVJvd0ZvclBhc3Rpbmc6IHRydWUgfSwgY2VsbHMpO1xufVxuZnVuY3Rpb24gY3JlYXRlUm93c0Zyb21QYXN0aW5nVGFibGUodGFibGVDb250ZW50KSB7XG4gICAgdmFyIHRhYmxlSGVhZFJvd3MgPSBbXTtcbiAgICB2YXIgdGFibGVCb2R5Um93cyA9IFtdO1xuICAgIGlmICh0YWJsZUNvbnRlbnQuZmlyc3RDaGlsZC50eXBlLm5hbWUgPT09ICd0YWJsZUhlYWQnKSB7XG4gICAgICAgIHZhciB0YWJsZUhlYWQgPSB0YWJsZUNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgdGFibGVIZWFkLmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gdGFibGVIZWFkUm93cy5wdXNoKHJvdyk7IH0pO1xuICAgIH1cbiAgICBpZiAodGFibGVDb250ZW50Lmxhc3RDaGlsZC50eXBlLm5hbWUgPT09ICd0YWJsZUJvZHknKSB7XG4gICAgICAgIHZhciB0YWJsZUJvZHkgPSB0YWJsZUNvbnRlbnQubGFzdENoaWxkO1xuICAgICAgICB0YWJsZUJvZHkuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7IHJldHVybiB0YWJsZUJvZHlSb3dzLnB1c2gocm93KTsgfSk7XG4gICAgfVxuICAgIHJldHVybiBfX3NwcmVhZEFycmF5JDEoX19zcHJlYWRBcnJheSQxKFtdLCB0YWJsZUhlYWRSb3dzKSwgdGFibGVCb2R5Um93cyk7XG59XG5mdW5jdGlvbiBjcmVhdGVUYWJsZUhlYWQodGFibGVIZWFkUm93LCBtYXhDb2x1bW5Db3VudCwgc2NoZW1hKSB7XG4gICAgdmFyIGNvcGllZFJvdyA9IGNvcHlUYWJsZUhlYWRSb3codGFibGVIZWFkUm93LCBtYXhDb2x1bW5Db3VudCwgc2NoZW1hKTtcbiAgICByZXR1cm4gc2NoZW1hLm5vZGVzLnRhYmxlSGVhZC5jcmVhdGUobnVsbCwgY29waWVkUm93KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlQm9keSh0YWJsZUJvZHlSb3dzLCBtYXhDb2x1bW5Db3VudCwgc2NoZW1hKSB7XG4gICAgdmFyIGNvcGllZFJvd3MgPSB0YWJsZUJvZHlSb3dzLm1hcChmdW5jdGlvbiAodGFibGVCb2R5Um93KSB7XG4gICAgICAgIHJldHVybiBjb3B5VGFibGVCb2R5Um93KHRhYmxlQm9keVJvdywgbWF4Q29sdW1uQ291bnQsIHNjaGVtYSk7XG4gICAgfSk7XG4gICAgaWYgKCF0YWJsZUJvZHlSb3dzLmxlbmd0aCkge1xuICAgICAgICB2YXIgZHVtbXlUYWJsZVJvdyA9IGNyZWF0VGFibGVCb2R5RHVtbXlSb3cobWF4Q29sdW1uQ291bnQsIHNjaGVtYSk7XG4gICAgICAgIGNvcGllZFJvd3MucHVzaChkdW1teVRhYmxlUm93KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYS5ub2Rlcy50YWJsZUJvZHkuY3JlYXRlKG51bGwsIGNvcGllZFJvd3MpO1xufVxuZnVuY3Rpb24gY3JlYXRlVGFibGVGcm9tUGFzdGluZ1RhYmxlKHJvd3MsIHNjaGVtYSwgc3RhcnRGcm9tQm9keSwgaXNJblRhYmxlKSB7XG4gICAgdmFyIGNvbHVtbkNvdW50ID0gZ2V0TWF4Q29sdW1uQ291bnQocm93cyk7XG4gICAgaWYgKHN0YXJ0RnJvbUJvZHkgJiYgaXNJblRhYmxlKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEubm9kZXMudGFibGUuY3JlYXRlKG51bGwsIFtjcmVhdGVUYWJsZUJvZHkocm93cywgY29sdW1uQ291bnQsIHNjaGVtYSldKTtcbiAgICB9XG4gICAgdmFyIHRhYmxlSGVhZFJvdyA9IHJvd3NbMF07XG4gICAgdmFyIHRhYmxlQm9keVJvd3MgPSByb3dzLnNsaWNlKDEpO1xuICAgIHZhciBub2RlcyA9IFtjcmVhdGVUYWJsZUhlYWQodGFibGVIZWFkUm93LCBjb2x1bW5Db3VudCwgc2NoZW1hKV07XG4gICAgaWYgKHRhYmxlQm9keVJvd3MubGVuZ3RoKSB7XG4gICAgICAgIG5vZGVzLnB1c2goY3JlYXRlVGFibGVCb2R5KHRhYmxlQm9keVJvd3MsIGNvbHVtbkNvdW50LCBzY2hlbWEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYS5ub2Rlcy50YWJsZS5jcmVhdGUobnVsbCwgbm9kZXMpO1xufVxuZnVuY3Rpb24gY2hhbmdlUGFzdGVkU2xpY2Uoc2xpY2UsIHNjaGVtYSwgaXNJblRhYmxlKSB7XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIGNvbnRlbnQgPSBzbGljZS5jb250ZW50LCBvcGVuU3RhcnQgPSBzbGljZS5vcGVuU3RhcnQsIG9wZW5FbmQgPSBzbGljZS5vcGVuRW5kO1xuICAgIGNvbnRlbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS50eXBlLm5hbWUgPT09ICd0YWJsZScpIHtcbiAgICAgICAgICAgIHZhciB0YWJsZUNvbnRlbnQgPSBnZXRUYWJsZUNvbnRlbnRGcm9tU2xpY2UobmV3IFNsaWNlKEZyYWdtZW50LmZyb20obm9kZSksIDAsIDApKTtcbiAgICAgICAgICAgIGlmICh0YWJsZUNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93cyA9IGNyZWF0ZVJvd3NGcm9tUGFzdGluZ1RhYmxlKHRhYmxlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0RnJvbUJvZHkgPSB0YWJsZUNvbnRlbnQuZmlyc3RDaGlsZC50eXBlLm5hbWUgPT09ICd0YWJsZUJvZHknO1xuICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IGNyZWF0ZVRhYmxlRnJvbVBhc3RpbmdUYWJsZShyb3dzLCBzY2hlbWEsIHN0YXJ0RnJvbUJvZHksIGlzSW5UYWJsZSk7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaCh0YWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5vZGVzKSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbn1cblxudmFyIERVTU1ZX0NFTExfU0laRSA9IDQ7XG52YXIgVFJfTk9ERVNfU0laRSA9IDI7XG5mdW5jdGlvbiBnZXREdW1teUNlbGxTaXplKGR1bW15Q2VsbENvdW50KSB7XG4gICAgcmV0dXJuIGR1bW15Q2VsbENvdW50ICogRFVNTVlfQ0VMTF9TSVpFO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFzdGluZ0NlbGxzKHRhYmxlQ29udGVudCwgY3VyU2VsZWN0aW9uSW5mbywgc2NoZW1hKSB7XG4gICAgdmFyIHBhc3RpbmdSb3dzID0gW107XG4gICAgdmFyIHBhc3RpbmdUYWJsZVJvd3MgPSBjcmVhdGVSb3dzRnJvbVBhc3RpbmdUYWJsZSh0YWJsZUNvbnRlbnQpO1xuICAgIHZhciBjb2x1bW5Db3VudCA9IHBhc3RpbmdUYWJsZVJvd3NbMF0uY2hpbGRDb3VudDtcbiAgICB2YXIgcm93Q291bnQgPSBwYXN0aW5nVGFibGVSb3dzLmxlbmd0aDtcbiAgICB2YXIgc3RhcnRUb1RhYmxlSGVhZCA9IGN1clNlbGVjdGlvbkluZm8uc3RhcnRSb3dJZHggPT09IDA7XG4gICAgdmFyIHNsaWNlZFJvd3MgPSBwYXN0aW5nVGFibGVSb3dzLnNsaWNlKDAsIHJvd0NvdW50KTtcbiAgICBpZiAoc3RhcnRUb1RhYmxlSGVhZCkge1xuICAgICAgICB2YXIgdGFibGVIZWFkUm93ID0gc2xpY2VkUm93cy5zaGlmdCgpO1xuICAgICAgICBpZiAodGFibGVIZWFkUm93KSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGNvcHlUYWJsZUhlYWRSb3codGFibGVIZWFkUm93LCBjb2x1bW5Db3VudCwgc2NoZW1hKS5jb250ZW50O1xuICAgICAgICAgICAgcGFzdGluZ1Jvd3MucHVzaChjb250ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzbGljZWRSb3dzLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlQm9keVJvdykge1xuICAgICAgICBpZiAoIXRhYmxlQm9keVJvdy5hdHRycy5kdW1teVJvd0ZvclBhc3RpbmcpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gY29weVRhYmxlQm9keVJvdyh0YWJsZUJvZHlSb3csIGNvbHVtbkNvdW50LCBzY2hlbWEpLmNvbnRlbnQ7XG4gICAgICAgICAgICBwYXN0aW5nUm93cy5wdXNoKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhc3RpbmdSb3dzO1xufVxuZnVuY3Rpb24gZ2V0UGFzdGluZ1JhbmdlSW5mbyhtYXAsIF9hLCBwYXN0aW5nQ2VsbHMpIHtcbiAgICB2YXIgc3RhcnRSb3dJZHggPSBfYS5zdGFydFJvd0lkeCwgc3RhcnRDb2xJZHggPSBfYS5zdGFydENvbElkeDtcbiAgICB2YXIgcGFzdGluZ1Jvd0NvdW50ID0gcGFzdGluZ0NlbGxzLmxlbmd0aDtcbiAgICB2YXIgcGFzdGluZ0NvbHVtbkNvdW50ID0gMDtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBjb2x1bW5Db3VudCA9IHBhc3RpbmdDZWxsc1tpXS5jaGlsZENvdW50O1xuICAgICAgICBwYXN0aW5nQ2VsbHNbaV0uZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgdmFyIGNvbHNwYW4gPSBhdHRycy5jb2xzcGFuO1xuICAgICAgICAgICAgaWYgKGNvbHNwYW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uQ291bnQgKz0gY29sc3BhbiAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXN0aW5nQ29sdW1uQ291bnQgPSBNYXRoLm1heChwYXN0aW5nQ29sdW1uQ291bnQsIGNvbHVtbkNvdW50KTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFzdGluZ1Jvd0NvdW50OyBpICs9IDEpIHtcbiAgICAgICAgX2xvb3BfMShpKTtcbiAgICB9XG4gICAgdmFyIGVuZFJvd0lkeCA9IHN0YXJ0Um93SWR4ICsgcGFzdGluZ1Jvd0NvdW50IC0gMTtcbiAgICB2YXIgZW5kQ29sSWR4ID0gc3RhcnRDb2xJZHggKyBwYXN0aW5nQ29sdW1uQ291bnQgLSAxO1xuICAgIHZhciBhZGRlZFJvd0NvdW50ID0gTWF0aC5tYXgoZW5kUm93SWR4ICsgMSAtIG1hcC50b3RhbFJvd0NvdW50LCAwKTtcbiAgICB2YXIgYWRkZWRDb2x1bW5Db3VudCA9IE1hdGgubWF4KGVuZENvbElkeCArIDEgLSBtYXAudG90YWxDb2x1bW5Db3VudCwgMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRSb3dJZHg6IHN0YXJ0Um93SWR4LFxuICAgICAgICBzdGFydENvbElkeDogc3RhcnRDb2xJZHgsXG4gICAgICAgIGVuZFJvd0lkeDogZW5kUm93SWR4LFxuICAgICAgICBlbmRDb2xJZHg6IGVuZENvbElkeCxcbiAgICAgICAgYWRkZWRSb3dDb3VudDogYWRkZWRSb3dDb3VudCxcbiAgICAgICAgYWRkZWRDb2x1bW5Db3VudDogYWRkZWRDb2x1bW5Db3VudCxcbiAgICB9O1xufVxuZnVuY3Rpb24gYWRkUmVwbGFjZWRPZmZzZXRzKF9hLCBjZWxsc09mZnNldHMpIHtcbiAgICB2YXIgc3RhcnRSb3dJZHggPSBfYS5zdGFydFJvd0lkeCwgc3RhcnRDb2xJZHggPSBfYS5zdGFydENvbElkeCwgZW5kUm93SWR4ID0gX2EuZW5kUm93SWR4LCBlbmRDb2xJZHggPSBfYS5lbmRDb2xJZHgsIGFkZGVkUm93Q291bnQgPSBfYS5hZGRlZFJvd0NvdW50LCBhZGRlZENvbHVtbkNvdW50ID0gX2EuYWRkZWRDb2x1bW5Db3VudDtcbiAgICBmb3IgKHZhciByb3dJZHggPSBzdGFydFJvd0lkeDsgcm93SWR4IDw9IGVuZFJvd0lkeCAtIGFkZGVkUm93Q291bnQ7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgIGNlbGxzT2Zmc2V0cy5wdXNoKHtcbiAgICAgICAgICAgIHJvd0lkeDogcm93SWR4LFxuICAgICAgICAgICAgc3RhcnRDb2xJZHg6IHN0YXJ0Q29sSWR4LFxuICAgICAgICAgICAgZW5kQ29sSWR4OiBlbmRDb2xJZHggLSBhZGRlZENvbHVtbkNvdW50LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBleHBhbmRDb2x1bW5zKHRyLCBzY2hlbWEsIG1hcCwgX2EsIGNlbGxzT2Zmc2V0cykge1xuICAgIHZhciBzdGFydFJvd0lkeCA9IF9hLnN0YXJ0Um93SWR4LCBzdGFydENvbElkeCA9IF9hLnN0YXJ0Q29sSWR4LCBlbmRSb3dJZHggPSBfYS5lbmRSb3dJZHgsIGVuZENvbElkeCA9IF9hLmVuZENvbElkeCwgYWRkZWRSb3dDb3VudCA9IF9hLmFkZGVkUm93Q291bnQsIGFkZGVkQ29sdW1uQ291bnQgPSBfYS5hZGRlZENvbHVtbkNvdW50O1xuICAgIHZhciB0b3RhbFJvd0NvdW50ID0gbWFwLnRvdGFsUm93Q291bnQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBmb3IgKHZhciByb3dJZHggPSAwOyByb3dJZHggPCB0b3RhbFJvd0NvdW50OyByb3dJZHggKz0gMSkge1xuICAgICAgICB2YXIgX2IgPSBtYXAuZ2V0Q2VsbEluZm8ocm93SWR4LCBlbmRDb2xJZHggLSBhZGRlZENvbHVtbkNvdW50KSwgb2Zmc2V0ID0gX2Iub2Zmc2V0LCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplO1xuICAgICAgICB2YXIgaW5zZXJ0T2Zmc2V0ID0gdHIubWFwcGluZy5tYXAob2Zmc2V0ICsgbm9kZVNpemUpO1xuICAgICAgICB2YXIgY2VsbHMgPSBjcmVhdGVEdW1teUNlbGxzKGFkZGVkQ29sdW1uQ291bnQsIHJvd0lkeCwgc2NoZW1hKTtcbiAgICAgICAgdHIuaW5zZXJ0KGluc2VydE9mZnNldCwgY2VsbHMpO1xuICAgICAgICBpZiAocm93SWR4ID49IHN0YXJ0Um93SWR4ICYmIHJvd0lkeCA8PSBlbmRSb3dJZHggLSBhZGRlZFJvd0NvdW50KSB7XG4gICAgICAgICAgICB2YXIgY2VsbEluZm8gPSBtYXAuZ2V0Q2VsbEluZm8ocm93SWR4LCBlbmRDb2xJZHggLSBhZGRlZENvbHVtbkNvdW50KTtcbiAgICAgICAgICAgIHZhciBzdGFydENlbGxPZmZzZXQgPSB0ci5tYXBwaW5nLm1hcChjZWxsSW5mby5vZmZzZXQpO1xuICAgICAgICAgICAgdmFyIGVuZENlbGxPZmZzZXQgPSBpbnNlcnRPZmZzZXQgKyBnZXREdW1teUNlbGxTaXplKGFkZGVkQ29sdW1uQ291bnQpO1xuICAgICAgICAgICAgY2VsbHNPZmZzZXRzW2luZGV4XSA9IHtcbiAgICAgICAgICAgICAgICByb3dJZHg6IHJvd0lkeCxcbiAgICAgICAgICAgICAgICBzdGFydENvbElkeDogc3RhcnRDb2xJZHgsXG4gICAgICAgICAgICAgICAgZW5kQ29sSWR4OiBlbmRDb2xJZHgsXG4gICAgICAgICAgICAgICAgZHVtbXlPZmZzZXRzOiBbc3RhcnRDZWxsT2Zmc2V0LCBlbmRDZWxsT2Zmc2V0XSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZXhwYW5kUm93cyh0ciwgc2NoZW1hLCBtYXAsIF9hLCBjZWxsc09mZnNldHMpIHtcbiAgICB2YXIgYWRkZWRSb3dDb3VudCA9IF9hLmFkZGVkUm93Q291bnQsIGFkZGVkQ29sdW1uQ291bnQgPSBfYS5hZGRlZENvbHVtbkNvdW50LCBzdGFydENvbElkeCA9IF9hLnN0YXJ0Q29sSWR4LCBlbmRDb2xJZHggPSBfYS5lbmRDb2xJZHg7XG4gICAgdmFyIG1hcFN0YXJ0ID0gdHIubWFwcGluZy5tYXBzLmxlbmd0aDtcbiAgICB2YXIgdGFibGVFbmRQb3MgPSBtYXAudGFibGVFbmRPZmZzZXQgLSAyO1xuICAgIHZhciByb3dzID0gY3JlYXRlVGFibGVCb2R5Um93cyhhZGRlZFJvd0NvdW50LCBtYXAudG90YWxDb2x1bW5Db3VudCArIGFkZGVkQ29sdW1uQ291bnQsIHNjaGVtYSk7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGFibGVFbmRQb3M7XG4gICAgdHIuaW5zZXJ0KHRyLm1hcHBpbmcuc2xpY2UobWFwU3RhcnQpLm1hcChzdGFydE9mZnNldCksIHJvd3MpO1xuICAgIGZvciAodmFyIHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCBhZGRlZFJvd0NvdW50OyByb3dJbmRleCArPSAxKSB7XG4gICAgICAgIHZhciBzdGFydENlbGxPZmZzZXQgPSBzdGFydE9mZnNldCArIGdldER1bW15Q2VsbFNpemUoc3RhcnRDb2xJZHgpICsgMTtcbiAgICAgICAgdmFyIGVuZENlbGxPZmZzZXQgPSBzdGFydE9mZnNldCArIGdldER1bW15Q2VsbFNpemUoZW5kQ29sSWR4ICsgMSkgKyAxO1xuICAgICAgICB2YXIgbmV4dENlbGxPZmZzZXQgPSBzdGFydE9mZnNldCArIGdldER1bW15Q2VsbFNpemUobWFwLnRvdGFsQ29sdW1uQ291bnQgKyBhZGRlZENvbHVtbkNvdW50KSArIFRSX05PREVTX1NJWkU7XG4gICAgICAgIGNlbGxzT2Zmc2V0cy5wdXNoKHtcbiAgICAgICAgICAgIHJvd0lkeDogcm93SW5kZXggKyBtYXAudG90YWxSb3dDb3VudCxcbiAgICAgICAgICAgIHN0YXJ0Q29sSWR4OiBzdGFydENvbElkeCxcbiAgICAgICAgICAgIGVuZENvbElkeDogZW5kQ29sSWR4LFxuICAgICAgICAgICAgZHVtbXlPZmZzZXRzOiBbc3RhcnRDZWxsT2Zmc2V0LCBlbmRDZWxsT2Zmc2V0XSxcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gbmV4dENlbGxPZmZzZXQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZUNlbGxzKHRyLCBwYXN0aW5nUm93cywgY2VsbHNPZmZzZXRzLCBtYXApIHtcbiAgICB2YXIgbWFwU3RhcnQgPSB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoO1xuICAgIGNlbGxzT2Zmc2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChvZmZzZXRzLCBpbmRleCkge1xuICAgICAgICB2YXIgcm93SWR4ID0gb2Zmc2V0cy5yb3dJZHgsIHN0YXJ0Q29sSWR4ID0gb2Zmc2V0cy5zdGFydENvbElkeCwgZW5kQ29sSWR4ID0gb2Zmc2V0cy5lbmRDb2xJZHgsIGR1bW15T2Zmc2V0cyA9IG9mZnNldHMuZHVtbXlPZmZzZXRzO1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwU3RhcnQpO1xuICAgICAgICB2YXIgY2VsbHMgPSBuZXcgU2xpY2UocGFzdGluZ1Jvd3NbaW5kZXhdLCAwLCAwKTtcbiAgICAgICAgdmFyIGZyb20gPSBkdW1teU9mZnNldHMgPyBkdW1teU9mZnNldHNbMF0gOiBtYXAuZ2V0Q2VsbFN0YXJ0T2Zmc2V0KHJvd0lkeCwgc3RhcnRDb2xJZHgpO1xuICAgICAgICB2YXIgdG8gPSBkdW1teU9mZnNldHMgPyBkdW1teU9mZnNldHNbMV0gOiBtYXAuZ2V0Q2VsbEVuZE9mZnNldChyb3dJZHgsIGVuZENvbElkeCk7XG4gICAgICAgIHRyLnJlcGxhY2UobWFwcGluZy5tYXAoZnJvbSksIG1hcHBpbmcubWFwKHRvKSwgY2VsbHMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcGFzdGVUb1RhYmxlKHZpZXcsIHNsaWNlKSB7XG4gICAgdmFyIF9hID0gdmlldy5zdGF0ZSwgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCBzY2hlbWEgPSBfYS5zY2hlbWEsIHRyID0gX2EudHI7XG4gICAgdmFyIF9iID0gZ2V0UmVzb2x2ZWRTZWxlY3Rpb24oc2VsZWN0aW9uKSwgYW5jaG9yID0gX2IuYW5jaG9yLCBoZWFkID0gX2IuaGVhZDtcbiAgICBpZiAoYW5jaG9yICYmIGhlYWQpIHtcbiAgICAgICAgdmFyIHRhYmxlQ29udGVudCA9IGdldFRhYmxlQ29udGVudEZyb21TbGljZShzbGljZSk7XG4gICAgICAgIGlmICghdGFibGVDb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShhbmNob3IpO1xuICAgICAgICB2YXIgY3VyU2VsZWN0aW9uSW5mbyA9IG1hcC5nZXRSZWN0T2Zmc2V0cyhhbmNob3IsIGhlYWQpO1xuICAgICAgICB2YXIgcGFzdGluZ0NlbGxzID0gY3JlYXRlUGFzdGluZ0NlbGxzKHRhYmxlQ29udGVudCwgY3VyU2VsZWN0aW9uSW5mbywgc2NoZW1hKTtcbiAgICAgICAgdmFyIHBhc3RpbmdJbmZvID0gZ2V0UGFzdGluZ1JhbmdlSW5mbyhtYXAsIGN1clNlbGVjdGlvbkluZm8sIHBhc3RpbmdDZWxscyk7XG4gICAgICAgIHZhciBjZWxsc09mZnNldHMgPSBbXTtcbiAgICAgICAgLy8gQFRPRE86IHVubWVyZ2UgdGhlIHNwYW4gYW5kIHBhc3RlIHRoZSBjZWxsXG4gICAgICAgIGlmIChjYW5NZXJnZShtYXAsIHBhc3RpbmdJbmZvKSkge1xuICAgICAgICAgICAgYWRkUmVwbGFjZWRPZmZzZXRzKHBhc3RpbmdJbmZvLCBjZWxsc09mZnNldHMpO1xuICAgICAgICAgICAgaWYgKHBhc3RpbmdJbmZvLmFkZGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgICAgICBleHBhbmRDb2x1bW5zKHRyLCBzY2hlbWEsIG1hcCwgcGFzdGluZ0luZm8sIGNlbGxzT2Zmc2V0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFzdGluZ0luZm8uYWRkZWRSb3dDb3VudCkge1xuICAgICAgICAgICAgICAgIGV4cGFuZFJvd3ModHIsIHNjaGVtYSwgbWFwLCBwYXN0aW5nSW5mbywgY2VsbHNPZmZzZXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcGxhY2VDZWxscyh0ciwgcGFzdGluZ0NlbGxzLCBjZWxsc09mZnNldHMsIG1hcCk7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbih2aWV3LCBjZWxsc09mZnNldHMsIG1hcC5nZXRDZWxsSW5mbygwLCAwKS5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZXRTZWxlY3Rpb24odmlldywgY2VsbHNPZmZzZXRzLCBwb3MpIHtcbiAgICB2YXIgX2EgPSB2aWV3LnN0YXRlLCB0ciA9IF9hLnRyLCBkb2MgPSBfYS5kb2M7XG4gICAgLy8gZ2V0IGNoYW5nZWQgY2VsbCBvZmZzZXRzXG4gICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShkb2MucmVzb2x2ZShwb3MpKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICB2YXIgX2IgPSBjZWxsc09mZnNldHNbMF0sIHN0YXJ0Um93SWR4ID0gX2Iucm93SWR4LCBzdGFydENvbElkeCA9IF9iLnN0YXJ0Q29sSWR4O1xuICAgIHZhciBfYyA9IGxhc3QkMShjZWxsc09mZnNldHMpLCBlbmRSb3dJZHggPSBfYy5yb3dJZHgsIGVuZENvbElkeCA9IF9jLmVuZENvbElkeDtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSBtYXAuZ2V0Q2VsbEluZm8oc3RhcnRSb3dJZHgsIHN0YXJ0Q29sSWR4KS5vZmZzZXQ7XG4gICAgdmFyIGVuZE9mZnNldCA9IG1hcC5nZXRDZWxsSW5mbyhlbmRSb3dJZHgsIGVuZENvbElkeCkub2Zmc2V0O1xuICAgIHZpZXcuZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKG5ldyBDZWxsU2VsZWN0aW9uKGRvYy5yZXNvbHZlKHN0YXJ0T2Zmc2V0KSwgZG9jLnJlc29sdmUoZW5kT2Zmc2V0KSkpKTtcbn1cbmZ1bmN0aW9uIGNhbk1lcmdlKG1hcCwgcGFzdGluZ0luZm8pIHtcbiAgICB2YXIgcmFuZ2VzID0gbWFwLmdldFNwYW5uZWRPZmZzZXRzKHBhc3RpbmdJbmZvKTtcbiAgICB2YXIgX2EgPSBnZXRSb3dBbmRDb2x1bW5Db3VudChyYW5nZXMpLCByb3dDb3VudCA9IF9hLnJvd0NvdW50LCBjb2x1bW5Db3VudCA9IF9hLmNvbHVtbkNvdW50O1xuICAgIHZhciBfYiA9IGdldFJvd0FuZENvbHVtbkNvdW50KHBhc3RpbmdJbmZvKSwgcGFzdGluZ1Jvd0NvdW50ID0gX2Iucm93Q291bnQsIHBhc3RpbmdDb2x1bW5Db3VudCA9IF9iLmNvbHVtbkNvdW50O1xuICAgIHJldHVybiByb3dDb3VudCA9PT0gcGFzdGluZ1Jvd0NvdW50ICYmIGNvbHVtbkNvdW50ID09PSBwYXN0aW5nQ29sdW1uQ291bnQ7XG59XG5cbnZhciBEb2MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoRG9jLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERvYygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ2Jsb2NrKycsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIERvYztcbn0oTm9kZSQyKSk7XG5cbnZhciBQYXJhZ3JhcGggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoUGFyYWdyYXBoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhcmFncmFwaCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFyYWdyYXBoLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3BhcmFncmFwaCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFyYWdyYXBoLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ2lubGluZSonLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHt9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFt7IHRhZzogJ3AnIH1dLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3AnLCBnZXRDdXN0b21BdHRycyhhdHRycyksIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFBhcmFncmFwaDtcbn0oTm9kZSQyKSk7XG5cbnZhciByZVNvZnRUYWJMZW4gPSAvXFxzezEsNH0kLztcbnZhciBUZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0ZXh0JztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0LnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRleHQucHJvdG90eXBlLmFkZFNwYWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHI7XG4gICAgICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sICR0byA9IHNlbGVjdGlvbi4kdG87XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byk7XG4gICAgICAgICAgICBpZiAocmFuZ2UgJiYgIWlzSW5MaXN0Tm9kZSgkZnJvbSkgJiYgIWlzSW5UYWJsZU5vZGUoJGZyb20pKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuaW5zZXJ0VGV4dCgnICAgICcsICRmcm9tLnBvcywgJHRvLnBvcykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUucmVtb3ZlU3BhY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgdHIgPSBfYS50cjtcbiAgICAgICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgJHRvID0gc2VsZWN0aW9uLiR0bywgZnJvbSA9IHNlbGVjdGlvbi5mcm9tO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pO1xuICAgICAgICAgICAgaWYgKHJhbmdlICYmICFpc0luTGlzdE5vZGUoJGZyb20pICYmICFpc0luVGFibGVOb2RlKCRmcm9tKSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlQmVmb3JlID0gJGZyb20ubm9kZUJlZm9yZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZUJlZm9yZSAmJiBub2RlQmVmb3JlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IG5vZGVCZWZvcmUudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRTcGFjZVRleHQgPSB0ZXh0LnJlcGxhY2UocmVTb2Z0VGFiTGVuLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZXMgPSB0ZXh0Lmxlbmd0aCAtIHJlbW92ZWRTcGFjZVRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5kZWxldGUoZnJvbSAtIHNwYWNlcywgZnJvbSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgVGFiOiB0aGlzLmFkZFNwYWNlcygpLFxuICAgICAgICAgICAgJ1NoaWZ0LVRhYic6IHRoaXMucmVtb3ZlU3BhY2VzKCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dDtcbn0oTm9kZSQyKSk7XG5cbnZhciBIZWFkaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEhlYWRpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVhZGluZygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVhZGluZy5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdoZWFkaW5nJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWFkaW5nLnByb3RvdHlwZSwgXCJsZXZlbHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbMSwgMiwgMywgNCwgNSwgNl07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVhZGluZy5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VET00gPSB0aGlzLmxldmVscy5tYXAoZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBcImhcIiArIGxldmVsLFxuICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7IGxldmVsOiBsZXZlbCB9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyBsZXZlbDogeyBkZWZhdWx0OiAxIH0sIGhlYWRpbmdUeXBlOiB7IGRlZmF1bHQ6ICdhdHgnIH0sIHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnaW5saW5lKicsXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgZGVmaW5pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IHBhcnNlRE9NLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJoXCIgKyBhdHRycy5sZXZlbCwgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpLCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEhlYWRpbmcucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBub2RlVHlwZSA9IHN0YXRlLnNjaGVtYS5ub2Rlc1twYXlsb2FkLmxldmVsID8gJ2hlYWRpbmcnIDogJ3BhcmFncmFwaCddO1xuICAgICAgICAgICAgcmV0dXJuIHNldEJsb2NrVHlwZShub2RlVHlwZSwgcGF5bG9hZCkoc3RhdGUsIGRpc3BhdGNoKTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIHJldHVybiBIZWFkaW5nO1xufShOb2RlJDIpKTtcblxudmFyIENvZGVCbG9jayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShDb2RlQmxvY2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29kZUJsb2NrKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2RlQmxvY2sucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnY29kZUJsb2NrJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2RlQmxvY2sucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAndGV4dConLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgbGFuZ3VhZ2U6IHsgZGVmYXVsdDogbnVsbCB9LCByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgY29kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkZWZpbmluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtYXJrczogJycsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAncHJlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJ2Z1bGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBkb20uZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoeyBsYW5ndWFnZTogKGNoaWxkID09PSBudWxsIHx8IGNoaWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGFuZ3VhZ2UnKSkgfHwgbnVsbCB9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRycy5yYXdIVE1MIHx8ICdwcmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgWydjb2RlJywgX19hc3NpZ24kMSh7ICdkYXRhLWxhbmd1YWdlJzogYXR0cnMubGFuZ3VhZ2UgfSwgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpKSwgMF0sXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDb2RlQmxvY2sucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkgeyByZXR1cm4gc2V0QmxvY2tUeXBlKHN0YXRlLnNjaGVtYS5ub2Rlcy5jb2RlQmxvY2spKHN0YXRlLCBkaXNwYXRjaCk7IH07IH07XG4gICAgfTtcbiAgICBDb2RlQmxvY2sucHJvdG90eXBlLm1vdmVDdXJzb3IgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgdHIgPSBzdGF0ZS50ciwgZG9jID0gc3RhdGUuZG9jLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgJGZyb20gPSBzdGF0ZS5zZWxlY3Rpb24uJGZyb207XG4gICAgICAgICAgICB2YXIgdmlldyA9IF90aGlzLmNvbnRleHQudmlldztcbiAgICAgICAgICAgIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpcmVjdGlvbikgJiYgJGZyb20ubm9kZSgpLnR5cGUubmFtZSA9PT0gJ2NvZGVCbG9jaycpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSAkZnJvbS5wYXJlbnQudGV4dENvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBkaXJlY3Rpb24gPT09ICd1cCcgPyAkZnJvbS5zdGFydCgpIDogJGZyb20uZW5kKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZGlyZWN0aW9uID09PSAndXAnXG4gICAgICAgICAgICAgICAgICAgID8gW29mZnNldCwgbGluZXNbMF0ubGVuZ3RoICsgb2Zmc2V0XVxuICAgICAgICAgICAgICAgICAgICA6IFtvZmZzZXQgLSBsYXN0JDEobGluZXMpLmxlbmd0aCwgb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gZG9jLnJlc29sdmUoZGlyZWN0aW9uID09PSAndXAnID8gJGZyb20uYmVmb3JlKCkgOiAkZnJvbS5hZnRlcigpKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGRpcmVjdGlvbiA9PT0gJ3VwJyA/IHBvcy5ub2RlQmVmb3JlIDogcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgICAgICAgICBpZiAoYmV0d2VlbiQxKCRmcm9tLnBvcywgcmFuZ2VbMF0sIHJhbmdlWzFdKSAmJiAhbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHIgPSBhZGRQYXJhZ3JhcGgodHIsIHBvcywgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChuZXdUcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvZGVCbG9jay5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvZGVDb21tYW5kID0gdGhpcy5jb21tYW5kcygpKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnU2hpZnQtTW9kLXAnOiBjb2RlQ29tbWFuZCxcbiAgICAgICAgICAgICdTaGlmdC1Nb2QtUCc6IGNvZGVDb21tYW5kLFxuICAgICAgICAgICAgQXJyb3dVcDogdGhpcy5tb3ZlQ3Vyc29yKCd1cCcpLFxuICAgICAgICAgICAgQXJyb3dEb3duOiB0aGlzLm1vdmVDdXJzb3IoJ2Rvd24nKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb2RlQmxvY2s7XG59KE5vZGUkMikpO1xuXG52YXIgQnVsbGV0TGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShCdWxsZXRMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1bGxldExpc3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1bGxldExpc3QucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnYnVsbGV0TGlzdCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVsbGV0TGlzdC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdsaXN0SXRlbSsnLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbY3JlYXRlRE9NSW5mb1BhcnNlZFJhd0hUTUwoJ3VsJyldLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3VsJywgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpLCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEJ1bGxldExpc3QucHJvdG90eXBlLmNoYW5nZUxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7IHJldHVybiBjaGFuZ2VMaXN0KHN0YXRlLnNjaGVtYS5ub2Rlcy5idWxsZXRMaXN0KShzdGF0ZSwgZGlzcGF0Y2gpOyB9O1xuICAgIH07XG4gICAgQnVsbGV0TGlzdC5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBidWxsZXRMaXN0OiB0aGlzLmNoYW5nZUxpc3QsXG4gICAgICAgICAgICB0YXNrTGlzdDogdG9nZ2xlVGFzayxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEJ1bGxldExpc3QucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidWxsZXRMaXN0Q29tbWFuZCA9IHRoaXMuY2hhbmdlTGlzdCgpO1xuICAgICAgICB2YXIgX2EgPSBnZXRXd0NvbW1hbmRzKCksIGluZGVudCA9IF9hLmluZGVudCwgb3V0ZGVudCA9IF9hLm91dGRlbnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLXUnOiBidWxsZXRMaXN0Q29tbWFuZCxcbiAgICAgICAgICAgICdNb2QtVSc6IGJ1bGxldExpc3RDb21tYW5kLFxuICAgICAgICAgICAgVGFiOiBpbmRlbnQoKSxcbiAgICAgICAgICAgICdTaGlmdC1UYWInOiBvdXRkZW50KCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQnVsbGV0TGlzdDtcbn0oTm9kZSQyKSk7XG5cbnZhciBPcmRlcmVkTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShPcmRlcmVkTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPcmRlcmVkTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3JkZXJlZExpc3QucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnb3JkZXJlZExpc3QnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9yZGVyZWRMaXN0LnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ2xpc3RJdGVtKycsXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyBvcmRlcjogeyBkZWZhdWx0OiAxIH0sIHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICdvbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoeyBvcmRlcjogZG9tLmhhc0F0dHJpYnV0ZSgnc3RhcnQnKSA/IE51bWJlcihzdGFydCkgOiAxIH0sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLnJhd0hUTUwgfHwgJ29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fYXNzaWduJDEoeyBzdGFydDogYXR0cnMub3JkZXIgPT09IDEgPyBudWxsIDogYXR0cnMub3JkZXIgfSwgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPcmRlcmVkTGlzdC5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7IHJldHVybiBjaGFuZ2VMaXN0KHN0YXRlLnNjaGVtYS5ub2Rlcy5vcmRlcmVkTGlzdCkoc3RhdGUsIGRpc3BhdGNoKTsgfTsgfTtcbiAgICB9O1xuICAgIE9yZGVyZWRMaXN0LnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3JkZXJlZExpc3RDb21tYW5kID0gdGhpcy5jb21tYW5kcygpKCk7XG4gICAgICAgIHZhciBfYSA9IGdldFd3Q29tbWFuZHMoKSwgaW5kZW50ID0gX2EuaW5kZW50LCBvdXRkZW50ID0gX2Eub3V0ZGVudDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2Qtbyc6IG9yZGVyZWRMaXN0Q29tbWFuZCxcbiAgICAgICAgICAgICdNb2QtTyc6IG9yZGVyZWRMaXN0Q29tbWFuZCxcbiAgICAgICAgICAgIFRhYjogaW5kZW50KCksXG4gICAgICAgICAgICAnU2hpZnQtVGFiJzogb3V0ZGVudCgpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIE9yZGVyZWRMaXN0O1xufShOb2RlJDIpKTtcblxudmFyIExpc3RJdGVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKExpc3RJdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpc3RJdGVtKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0SXRlbS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdsaXN0SXRlbSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGlzdEl0ZW0ucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAncGFyYWdyYXBoIGJsb2NrKicsXG4gICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgdGFzazogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgIHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVmaW5pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAnbGknLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7IHRhc2s6IGRvbS5oYXNBdHRyaWJ1dGUoJ2RhdGEtdGFzaycpLCBjaGVja2VkOiBkb20uaGFzQXR0cmlidXRlKCdkYXRhLXRhc2stY2hlY2tlZCcpIH0sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhc2sgPSBhdHRycy50YXNrLCBjaGVja2VkID0gYXR0cnMuY2hlY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2F0dHJzLnJhd0hUTUwgfHwgJ2xpJywgMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbJ3Rhc2stbGlzdC1pdGVtJ107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2NoZWNrZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMucmF3SFRNTCB8fCAnbGknLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19hc3NpZ24kMSh7IGNsYXNzOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgJ2RhdGEtdGFzayc6IHRhc2sgfSwgKGNoZWNrZWQgJiYgeyAnZGF0YS10YXNrLWNoZWNrZWQnOiBjaGVja2VkIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMaXN0SXRlbS5wcm90b3R5cGUubGlmdFRvUHJldkxpc3RJdGVtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50ciwgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICAgICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tLCBlbXB0eSA9IHNlbGVjdGlvbi5lbXB0eTtcbiAgICAgICAgICAgIHZhciBsaXN0SXRlbSA9IHNjaGVtYS5ub2Rlcy5saXN0SXRlbTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSAkZnJvbS5wYXJlbnQ7XG4gICAgICAgICAgICB2YXIgbGlzdEl0ZW1QYXJlbnQgPSAkZnJvbS5ub2RlKC0xKTtcbiAgICAgICAgICAgIGlmIChlbXB0eSAmJiAhcGFyZW50LmNoaWxkQ291bnQgJiYgbGlzdEl0ZW1QYXJlbnQudHlwZSA9PT0gbGlzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRvIHByZXZpb3VzIHNpYmxpbmcgbGlzdCBpdGVtIHdoZW4gdGhlIGN1cnJlbnQgbGlzdCBpdGVtIGlzIG5vdCB0b3AgbGlzdCBpdGVtXG4gICAgICAgICAgICAgICAgaWYgKCRmcm9tLmluZGV4KC0yKSA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBzdWJ0cmFjdCAnMScgZm9yIGNvbnNpZGVyaW5nIHRhZyBsZW5ndGgoPGxpPilcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKCRmcm9tLnN0YXJ0KC0xKSAtIDEsICRmcm9tLmVuZCgtMSkpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZ3JhbmRQYXJlbnRMaXN0SXRlbSA9ICRmcm9tLm5vZGUoLTMpO1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgdG8gcGFyZW50IGxpc3QgaXRlbSB3aGVuIHRoZSBjdXJyZW50IGxpc3QgaXRlbSBpcyB0b3AgbGlzdCBpdGVtXG4gICAgICAgICAgICAgICAgaWYgKGdyYW5kUGFyZW50TGlzdEl0ZW0udHlwZSA9PT0gbGlzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIHN1YnRyYWN0ICcxJyBmb3IgY29uc2lkZXJpbmcgdGFnIGxlbmd0aCg8dWw+KVxuICAgICAgICAgICAgICAgICAgICB0ci5kZWxldGUoJGZyb20uc3RhcnQoLTIpIC0gMSwgJGZyb20uZW5kKC0xKSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgTGlzdEl0ZW0ucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBzcGxpdExpc3RJdGVtKHN0YXRlLnNjaGVtYS5ub2Rlcy5saXN0SXRlbSkoc3RhdGUsIGRpc3BhdGNoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEJhY2tzcGFjZTogdGhpcy5saWZ0VG9QcmV2TGlzdEl0ZW0oKSxcbiAgICAgICAgICAgIEVudGVyOiBzcGxpdCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBMaXN0SXRlbTtcbn0oTm9kZSQyKSk7XG5cbnZhciBCbG9ja1F1b3RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEJsb2NrUXVvdGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmxvY2tRdW90ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmxvY2tRdW90ZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdibG9ja1F1b3RlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCbG9ja1F1b3RlLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgY29udGVudDogJ2Jsb2NrKycsXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtjcmVhdGVET01JbmZvUGFyc2VkUmF3SFRNTCgnYmxvY2txdW90ZScpXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydibG9ja3F1b3RlJywgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpLCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEJsb2NrUXVvdGUucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkgeyByZXR1cm4gd3JhcEluKHN0YXRlLnNjaGVtYS5ub2Rlcy5ibG9ja1F1b3RlKShzdGF0ZSwgZGlzcGF0Y2gpOyB9OyB9O1xuICAgIH07XG4gICAgQmxvY2tRdW90ZS5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJsb2NrUXV0b2VDb21tYW5kID0gdGhpcy5jb21tYW5kcygpKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnQWx0LXEnOiBibG9ja1F1dG9lQ29tbWFuZCxcbiAgICAgICAgICAgICdBbHQtUSc6IGJsb2NrUXV0b2VDb21tYW5kLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEJsb2NrUXVvdGU7XG59KE5vZGUkMikpO1xuXG52YXIgY2VsbE9mZnNldEZuTWFwID0ge1xuICAgIGxlZnQ6IGdldExlZnRDZWxsT2Zmc2V0LFxuICAgIHJpZ2h0OiBnZXRSaWdodENlbGxPZmZzZXQsXG4gICAgdXA6IGdldFVwQ2VsbE9mZnNldCxcbiAgICBkb3duOiBnZXREb3duQ2VsbE9mZnNldCxcbn07XG5mdW5jdGlvbiBpc0luRmlyc3RMaXN0SXRlbShwb3MsIGRvYywgX2EpIHtcbiAgICB2YXIgcGFyYURlcHRoID0gX2FbMF0sIGxpc3REZXB0aCA9IF9hWzFdO1xuICAgIHZhciBsaXN0SXRlbU5vZGUgPSBkb2MucmVzb2x2ZShwb3MuYmVmb3JlKHBhcmFEZXB0aCAtIDEpKTtcbiAgICByZXR1cm4gbGlzdERlcHRoID09PSBwYXJhRGVwdGggJiYgIWxpc3RJdGVtTm9kZS5ub2RlQmVmb3JlO1xufVxuZnVuY3Rpb24gaXNJbkxhc3RMaXN0SXRlbShwb3MpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGRlcHRoID0gcG9zLmRlcHRoO1xuICAgIHZhciBwYXJlbnROb2RlO1xuICAgIHdoaWxlIChkZXB0aCkge1xuICAgICAgICBwYXJlbnROb2RlID0gcG9zLm5vZGUoZGVwdGgpO1xuICAgICAgICBpZiAocGFyZW50Tm9kZS50eXBlLm5hbWUgPT09ICd0YWJsZUJvZHlDZWxsJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudE5vZGUudHlwZS5uYW1lID09PSAnbGlzdEl0ZW0nKSB7XG4gICAgICAgICAgICB2YXIgZ3JhbmRQYXJlbnQgPSBwb3Mubm9kZShkZXB0aCAtIDEpO1xuICAgICAgICAgICAgdmFyIGxhc3RMaXN0SXRlbSA9IGdyYW5kUGFyZW50Lmxhc3RDaGlsZCA9PT0gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHZhciBoYXNDaGlsZHJlbiA9ICgoX2EgPSBwYXJlbnROb2RlLmxhc3RDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUubmFtZSkgIT09ICdwYXJhZ3JhcGgnO1xuICAgICAgICAgICAgaWYgKCFsYXN0TGlzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIWhhc0NoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIGRlcHRoIC09IDE7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhbk1vdmVUb0JlZm9yZUNlbGwoZGlyZWN0aW9uLCBfYSwgZnJvbSwgZG9jLCBpbkxpc3QpIHtcbiAgICB2YXIgcGFyYURlcHRoID0gX2FbMF0sIGxpc3REZXB0aCA9IF9hWzFdLCBjdXJEZXB0aCA9IF9hWzJdO1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwibGVmdFwiIC8qIExFRlQgKi8gfHwgZGlyZWN0aW9uID09PSBcInVwXCIgLyogVVAgKi8pIHtcbiAgICAgICAgaWYgKGluTGlzdCAmJiAhaXNJbkZpcnN0TGlzdEl0ZW0oZnJvbSwgZG9jLCBbcGFyYURlcHRoLCBsaXN0RGVwdGhdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmRPZmZzZXQgPSBmcm9tLmJlZm9yZShjdXJEZXB0aCk7XG4gICAgICAgIHZhciBub2RlQmVmb3JlID0gZG9jLnJlc29sdmUoZW5kT2Zmc2V0KS5ub2RlQmVmb3JlO1xuICAgICAgICBpZiAobm9kZUJlZm9yZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2FuTW92ZVRvQWZ0ZXJDZWxsKGRpcmVjdGlvbiwgY3VyRGVwdGgsIGZyb20sIGRvYywgaW5MaXN0KSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJyaWdodFwiIC8qIFJJR0hUICovIHx8IGRpcmVjdGlvbiA9PT0gXCJkb3duXCIgLyogRE9XTiAqLykge1xuICAgICAgICBpZiAoaW5MaXN0ICYmICFpc0luTGFzdExpc3RJdGVtKGZyb20pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuZE9mZnNldCA9IGZyb20uYWZ0ZXIoY3VyRGVwdGgpO1xuICAgICAgICB2YXIgbm9kZUFmdGVyID0gZG9jLnJlc29sdmUoZW5kT2Zmc2V0KS5ub2RlQWZ0ZXI7XG4gICAgICAgIGlmIChub2RlQWZ0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNhbk1vdmVCZXR3ZWVuQ2VsbHMoZGlyZWN0aW9uLCBfYSwgZnJvbSwgZG9jKSB7XG4gICAgdmFyIGNlbGxEZXB0aCA9IF9hWzBdLCBwYXJhRGVwdGggPSBfYVsxXTtcbiAgICB2YXIgbGlzdERlcHRoID0gY2VsbERlcHRoICsgMzsgLy8gMyBpcyBwb3NpdGlvbiBvZiA8dWw+PGxpPjxwPlxuICAgIHZhciBpbkxpc3QgPSBwYXJhRGVwdGggPj0gbGlzdERlcHRoO1xuICAgIHZhciBjdXJEZXB0aCA9IGluTGlzdCA/IGNlbGxEZXB0aCArIDEgOiBwYXJhRGVwdGg7XG4gICAgdmFyIG1vdmVCZWZvcmVDZWxsID0gY2FuTW92ZVRvQmVmb3JlQ2VsbChkaXJlY3Rpb24sIFtwYXJhRGVwdGgsIGxpc3REZXB0aCwgY3VyRGVwdGhdLCBmcm9tLCBkb2MsIGluTGlzdCk7XG4gICAgdmFyIG1vdmVBZnRlckNlbGwgPSBjYW5Nb3ZlVG9BZnRlckNlbGwoZGlyZWN0aW9uLCBjdXJEZXB0aCwgZnJvbSwgZG9jLCBpbkxpc3QpO1xuICAgIHJldHVybiBtb3ZlQmVmb3JlQ2VsbCAmJiBtb3ZlQWZ0ZXJDZWxsO1xufVxuZnVuY3Rpb24gY2FuQmVPdXRPZlRhYmxlKGRpcmVjdGlvbiwgbWFwLCBfYSkge1xuICAgIHZhciByb3dJZHggPSBfYVswXSwgY29sSWR4ID0gX2FbMV07XG4gICAgdmFyIHJvd3NwYW5JbmZvID0gbWFwLmdldFJvd3NwYW5TdGFydEluZm8ocm93SWR4LCBjb2xJZHgpO1xuICAgIHZhciBpbkZpcnN0Um93ID0gZGlyZWN0aW9uID09PSBcInVwXCIgLyogVVAgKi8gJiYgcm93SWR4ID09PSAwO1xuICAgIHZhciBpbkxhc3RSb3cgPSBkaXJlY3Rpb24gPT09IFwiZG93blwiIC8qIERPV04gKi8gJiZcbiAgICAgICAgKChyb3dzcGFuSW5mbyA9PT0gbnVsbCB8fCByb3dzcGFuSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm93c3BhbkluZm8uY291bnQpID4gMSA/IHJvd0lkeCArIHJvd3NwYW5JbmZvLmNvdW50IC0gMSA6IHJvd0lkeCkgPT09IG1hcC50b3RhbFJvd0NvdW50IC0gMTtcbiAgICByZXR1cm4gaW5GaXJzdFJvdyB8fCBpbkxhc3RSb3c7XG59XG5mdW5jdGlvbiBhZGRQYXJhZ3JhcGhCZWZvcmVUYWJsZSh0ciwgbWFwLCBzY2hlbWEpIHtcbiAgICB2YXIgdGFibGVTdGFydFBvcyA9IHRyLmRvYy5yZXNvbHZlKG1hcC50YWJsZVN0YXJ0T2Zmc2V0IC0gMSk7XG4gICAgaWYgKCF0YWJsZVN0YXJ0UG9zLm5vZGVCZWZvcmUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFBhcmFncmFwaCh0ciwgdGFibGVTdGFydFBvcywgc2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0YWJsZVN0YXJ0UG9zLCAtMSkpO1xufVxuZnVuY3Rpb24gYWRkUGFyYWdyYXBoQWZ0ZXJUYWJsZSh0ciwgbWFwLCBzY2hlbWEsIGZvcmNlZEFkZHRpb24pIHtcbiAgICBpZiAoZm9yY2VkQWRkdGlvbiA9PT0gdm9pZCAwKSB7IGZvcmNlZEFkZHRpb24gPSBmYWxzZTsgfVxuICAgIHZhciB0YWJsZUVuZFBvcyA9IHRyLmRvYy5yZXNvbHZlKG1hcC50YWJsZUVuZE9mZnNldCk7XG4gICAgaWYgKGZvcmNlZEFkZHRpb24gfHwgIXRhYmxlRW5kUG9zLm5vZGVBZnRlcikge1xuICAgICAgICByZXR1cm4gYWRkUGFyYWdyYXBoKHRyLCB0YWJsZUVuZFBvcywgc2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0YWJsZUVuZFBvcywgMSkpO1xufVxuZnVuY3Rpb24gZ2V0UmlnaHRDZWxsT2Zmc2V0KF9hLCBtYXApIHtcbiAgICB2YXIgcm93SWR4ID0gX2FbMF0sIGNvbElkeCA9IF9hWzFdO1xuICAgIHZhciB0b3RhbFJvd0NvdW50ID0gbWFwLnRvdGFsUm93Q291bnQsIHRvdGFsQ29sdW1uQ291bnQgPSBtYXAudG90YWxDb2x1bW5Db3VudDtcbiAgICB2YXIgbGFzdENlbGxJblJvdyA9IGNvbElkeCA9PT0gdG90YWxDb2x1bW5Db3VudCAtIDE7XG4gICAgdmFyIGxhc3RDZWxsSW5UYWJsZSA9IHJvd0lkeCA9PT0gdG90YWxSb3dDb3VudCAtIDEgJiYgbGFzdENlbGxJblJvdztcbiAgICBpZiAoIWxhc3RDZWxsSW5UYWJsZSkge1xuICAgICAgICB2YXIgbmV4dENvbElkeCA9IGNvbElkeCArIDE7XG4gICAgICAgIHZhciBjb2xzcGFuSW5mbyA9IG1hcC5nZXRDb2xzcGFuU3RhcnRJbmZvKHJvd0lkeCwgY29sSWR4KTtcbiAgICAgICAgaWYgKChjb2xzcGFuSW5mbyA9PT0gbnVsbCB8fCBjb2xzcGFuSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sc3BhbkluZm8uY291bnQpID4gMSkge1xuICAgICAgICAgICAgbmV4dENvbElkeCArPSBjb2xzcGFuSW5mby5jb3VudCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RDZWxsSW5Sb3cgfHwgbmV4dENvbElkeCA9PT0gdG90YWxDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgcm93SWR4ICs9IDE7XG4gICAgICAgICAgICBuZXh0Q29sSWR4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0ID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgbmV4dENvbElkeCkub2Zmc2V0O1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRMZWZ0Q2VsbE9mZnNldChfYSwgbWFwKSB7XG4gICAgdmFyIHJvd0lkeCA9IF9hWzBdLCBjb2xJZHggPSBfYVsxXTtcbiAgICB2YXIgdG90YWxDb2x1bW5Db3VudCA9IG1hcC50b3RhbENvbHVtbkNvdW50O1xuICAgIHZhciBmaXJzdENlbGxJblJvdyA9IGNvbElkeCA9PT0gMDtcbiAgICB2YXIgZmlyc3RDZWxsSW5UYWJsZSA9IHJvd0lkeCA9PT0gMCAmJiBmaXJzdENlbGxJblJvdztcbiAgICBpZiAoIWZpcnN0Q2VsbEluVGFibGUpIHtcbiAgICAgICAgY29sSWR4IC09IDE7XG4gICAgICAgIGlmIChmaXJzdENlbGxJblJvdykge1xuICAgICAgICAgICAgcm93SWR4IC09IDE7XG4gICAgICAgICAgICBjb2xJZHggPSB0b3RhbENvbHVtbkNvdW50IC0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2IgPSBtYXAuZ2V0Q2VsbEluZm8ocm93SWR4LCBjb2xJZHgpLCBvZmZzZXQgPSBfYi5vZmZzZXQsIG5vZGVTaXplID0gX2Iubm9kZVNpemU7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyBub2RlU2l6ZSAtIDI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VXBDZWxsT2Zmc2V0KF9hLCBtYXApIHtcbiAgICB2YXIgcm93SWR4ID0gX2FbMF0sIGNvbElkeCA9IF9hWzFdO1xuICAgIGlmIChyb3dJZHggPiAwKSB7XG4gICAgICAgIHZhciBfYiA9IG1hcC5nZXRDZWxsSW5mbyhyb3dJZHggLSAxLCBjb2xJZHgpLCBvZmZzZXQgPSBfYi5vZmZzZXQsIG5vZGVTaXplID0gX2Iubm9kZVNpemU7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyBub2RlU2l6ZSAtIDI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RG93bkNlbGxPZmZzZXQoX2EsIG1hcCkge1xuICAgIHZhciByb3dJZHggPSBfYVswXSwgY29sSWR4ID0gX2FbMV07XG4gICAgdmFyIHRvdGFsUm93Q291bnQgPSBtYXAudG90YWxSb3dDb3VudDtcbiAgICBpZiAocm93SWR4IDwgdG90YWxSb3dDb3VudCAtIDEpIHtcbiAgICAgICAgdmFyIG5leHRSb3dJZHggPSByb3dJZHggKyAxO1xuICAgICAgICB2YXIgcm93c3BhbkluZm8gPSBtYXAuZ2V0Um93c3BhblN0YXJ0SW5mbyhyb3dJZHgsIGNvbElkeCk7XG4gICAgICAgIGlmICgocm93c3BhbkluZm8gPT09IG51bGwgfHwgcm93c3BhbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvd3NwYW5JbmZvLmNvdW50KSA+IDEpIHtcbiAgICAgICAgICAgIG5leHRSb3dJZHggKz0gcm93c3BhbkluZm8uY291bnQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZzZXQgPSBtYXAuZ2V0Q2VsbEluZm8obmV4dFJvd0lkeCwgY29sSWR4KS5vZmZzZXQ7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyAyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG1vdmVUb0NlbGwoZGlyZWN0aW9uLCB0ciwgY2VsbEluZGV4LCBtYXApIHtcbiAgICB2YXIgY2VsbE9mZnNldEZuID0gY2VsbE9mZnNldEZuTWFwW2RpcmVjdGlvbl07XG4gICAgdmFyIG9mZnNldCA9IGNlbGxPZmZzZXRGbihjZWxsSW5kZXgsIG1hcCk7XG4gICAgaWYgKG9mZnNldCkge1xuICAgICAgICB2YXIgZGlyID0gZGlyZWN0aW9uID09PSBcInJpZ2h0XCIgLyogUklHSFQgKi8gfHwgZGlyZWN0aW9uID09PSBcImRvd25cIiAvKiBET1dOICovID8gMSA6IC0xO1xuICAgICAgICByZXR1cm4gdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKG9mZnNldCksIGRpcikpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNhblNlbGVjdFRhYmxlTm9kZShkaXJlY3Rpb24sIG1hcCwgX2EpIHtcbiAgICB2YXIgcm93SWR4ID0gX2FbMF0sIGNvbElkeCA9IF9hWzFdO1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwidXBcIiAvKiBVUCAqLyB8fCBkaXJlY3Rpb24gPT09IFwiZG93blwiIC8qIERPV04gKi8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdGFibGVTdGFydE9mZnNldCA9IG1hcC50YWJsZVN0YXJ0T2Zmc2V0LCB0YWJsZUVuZE9mZnNldCA9IG1hcC50YWJsZUVuZE9mZnNldDtcbiAgICB2YXIgX2IgPSBtYXAuZ2V0Q2VsbEluZm8ocm93SWR4LCBjb2xJZHgpLCBvZmZzZXQgPSBfYi5vZmZzZXQsIG5vZGVTaXplID0gX2Iubm9kZVNpemU7XG4gICAgdmFyIHBvcyA9IGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgLyogTEVGVCAqLyA/IHRhYmxlU3RhcnRPZmZzZXQgOiB0YWJsZUVuZE9mZnNldDtcbiAgICB2YXIgY3VyUG9zID0gZGlyZWN0aW9uID09PSBcImxlZnRcIiAvKiBMRUZUICovID8gb2Zmc2V0IC0gMiA6IG9mZnNldCArIG5vZGVTaXplICsgMztcbiAgICByZXR1cm4gcG9zID09PSBjdXJQb3M7XG59XG5mdW5jdGlvbiBzZWxlY3ROb2RlKHRyLCBwb3MsIGRlcHRoKSB7XG4gICAgdmFyIHRhYmxlUG9zID0gdHIuZG9jLnJlc29sdmUocG9zLmJlZm9yZShkZXB0aCAtIDMpKTtcbiAgICByZXR1cm4gdHIuc2V0U2VsZWN0aW9uKG5ldyBOb2RlU2VsZWN0aW9uKHRhYmxlUG9zKSk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldFJvd0luZm8oZGlyZWN0aW9uLCBtYXAsIHNlbGVjdGlvbkluZm8pIHtcbiAgICB2YXIgdGFyZ2V0Um93SWR4O1xuICAgIHZhciBpbnNlcnRDb2xJZHg7XG4gICAgdmFyIG5vZGVTaXplO1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwidXBcIiAvKiBVUCAqLykge1xuICAgICAgICB0YXJnZXRSb3dJZHggPSBzZWxlY3Rpb25JbmZvLnN0YXJ0Um93SWR4O1xuICAgICAgICBpbnNlcnRDb2xJZHggPSAwO1xuICAgICAgICBub2RlU2l6ZSA9IC0xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Um93SWR4ID0gc2VsZWN0aW9uSW5mby5lbmRSb3dJZHg7XG4gICAgICAgIGluc2VydENvbElkeCA9IG1hcC50b3RhbENvbHVtbkNvdW50IC0gMTtcbiAgICAgICAgbm9kZVNpemUgPSBtYXAuZ2V0Q2VsbEluZm8odGFyZ2V0Um93SWR4LCBpbnNlcnRDb2xJZHgpLm5vZGVTaXplICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGFyZ2V0Um93SWR4OiB0YXJnZXRSb3dJZHgsIGluc2VydENvbElkeDogaW5zZXJ0Q29sSWR4LCBub2RlU2l6ZTogbm9kZVNpemUgfTtcbn1cbmZ1bmN0aW9uIGdldFJvd1JhbmdlcyhtYXAsIHJvd0lkeCwgdG90YWxDb2x1bW5Db3VudCkge1xuICAgIHZhciBzdGFydE9mZnNldCA9IG1hcC5nZXRDZWxsSW5mbyhyb3dJZHgsIDApLm9mZnNldDtcbiAgICB2YXIgX2EgPSBtYXAuZ2V0Q2VsbEluZm8ocm93SWR4LCB0b3RhbENvbHVtbkNvdW50IC0gMSksIG9mZnNldCA9IF9hLm9mZnNldCwgbm9kZVNpemUgPSBfYS5ub2RlU2l6ZTtcbiAgICByZXR1cm4geyBmcm9tOiBzdGFydE9mZnNldCwgdG86IG9mZnNldCArIG5vZGVTaXplIH07XG59XG52YXIgVGFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RhYmxlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd0YWJsZUhlYWR7MX0gdGFibGVCb2R5ezF9JyxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW2NyZWF0ZURPTUluZm9QYXJzZWRSYXdIVE1MKCd0YWJsZScpXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyd0YWJsZScsIGdldEN1c3RvbUF0dHJzKGF0dHJzKSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUYWJsZS5wcm90b3R5cGUuYWRkVGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQgPT09IHZvaWQgMCkgeyBwYXlsb2FkID0geyByb3dDb3VudDogMiwgY29sdW1uQ291bnQ6IDEsIGRhdGE6IFtdIH07IH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gcGF5bG9hZC5yb3dDb3VudCwgY29sdW1uQ291bnQgPSBwYXlsb2FkLmNvbHVtbkNvdW50LCBkYXRhID0gcGF5bG9hZC5kYXRhO1xuICAgICAgICAgICAgICAgIHZhciBzY2hlbWEgPSBzdGF0ZS5zY2hlbWEsIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHNlbGVjdGlvbi5mcm9tLCB0byA9IHNlbGVjdGlvbi50bywgJGZyb20gPSBzZWxlY3Rpb24uJGZyb207XG4gICAgICAgICAgICAgICAgdmFyIGNvbGxhcHNlZCA9IGZyb20gPT09IHRvO1xuICAgICAgICAgICAgICAgIGlmIChjb2xsYXBzZWQgJiYgIWlzSW5UYWJsZU5vZGUoJGZyb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHNjaGVtYS5ub2RlcywgdGFibGVIZWFkID0gX2EudGFibGVIZWFkLCB0YWJsZUJvZHkgPSBfYS50YWJsZUJvZHk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGVhZERhdGEgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuc2xpY2UoMCwgY29sdW1uQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGJvZHlEYXRhID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnNsaWNlKGNvbHVtbkNvdW50LCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZUhlYWRSb3cgPSBjcmVhdGVUYWJsZUhlYWRSb3coY29sdW1uQ291bnQsIHNjaGVtYSwgdGhlYWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlQm9keVJvd3MgPSBjcmVhdGVUYWJsZUJvZHlSb3dzKHJvd0NvdW50IC0gMSwgY29sdW1uQ291bnQsIHNjaGVtYSwgdGJvZHlEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gc2NoZW1hLm5vZGVzLnRhYmxlLmNyZWF0ZShudWxsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUhlYWQuY3JlYXRlKG51bGwsIHRhYmxlSGVhZFJvdyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUJvZHkuY3JlYXRlKG51bGwsIHRhYmxlQm9keVJvd3MpLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godHIucmVwbGFjZVNlbGVjdGlvbldpdGgodGFibGUpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUucmVtb3ZlVGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShzZWxlY3Rpb24uJGFuY2hvcik7XG4gICAgICAgICAgICBpZiAobWFwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlU3RhcnRPZmZzZXQgPSBtYXAudGFibGVTdGFydE9mZnNldCwgdGFibGVFbmRPZmZzZXQgPSBtYXAudGFibGVFbmRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGFibGVTdGFydE9mZnNldCAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnNvclBvcyA9IGNyZWF0ZVRleHRTZWxlY3Rpb24odHIuZGVsZXRlKHN0YXJ0T2Zmc2V0LCB0YWJsZUVuZE9mZnNldCksIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oY3Vyc29yUG9zKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUuYWRkQ29sdW1uID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50ciwgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmVzb2x2ZWRTZWxlY3Rpb24oc2VsZWN0aW9uKSwgYW5jaG9yID0gX2EuYW5jaG9yLCBoZWFkID0gX2EuaGVhZDtcbiAgICAgICAgICAgIGlmIChhbmNob3IgJiYgaGVhZCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uSW5mbyA9IG1hcC5nZXRSZWN0T2Zmc2V0cyhhbmNob3IsIGhlYWQpO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRDb2xJZHggPSBkaXJlY3Rpb24gPT09IFwibGVmdFwiIC8qIExFRlQgKi8gPyBzZWxlY3Rpb25JbmZvLnN0YXJ0Q29sSWR4IDogc2VsZWN0aW9uSW5mby5lbmRDb2xJZHggKyAxO1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5Db3VudCA9IGdldFJvd0FuZENvbHVtbkNvdW50KHNlbGVjdGlvbkluZm8pLmNvbHVtbkNvdW50O1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbFJvd0NvdW50ID0gbWFwLnRvdGFsUm93Q291bnQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcm93SWR4ID0gMDsgcm93SWR4IDwgdG90YWxSb3dDb3VudDsgcm93SWR4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxzID0gY3JlYXRlRHVtbXlDZWxscyhjb2x1bW5Db3VudCwgcm93SWR4LCBzY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICB0ci5pbnNlcnQodHIubWFwcGluZy5tYXAobWFwLnBvc0F0KHJvd0lkeCwgdGFyZ2V0Q29sSWR4KSksIGNlbGxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLnJlbW92ZUNvbHVtbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSZXNvbHZlZFNlbGVjdGlvbihzZWxlY3Rpb24pLCBhbmNob3IgPSBfYS5hbmNob3IsIGhlYWQgPSBfYS5oZWFkO1xuICAgICAgICAgICAgaWYgKGFuY2hvciAmJiBoZWFkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShhbmNob3IpO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25JbmZvID0gbWFwLmdldFJlY3RPZmZzZXRzKGFuY2hvciwgaGVhZCk7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsQ29sdW1uQ291bnQgPSBtYXAudG90YWxDb2x1bW5Db3VudCwgdG90YWxSb3dDb3VudCA9IG1hcC50b3RhbFJvd0NvdW50O1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5Db3VudCA9IGdldFJvd0FuZENvbHVtbkNvdW50KHNlbGVjdGlvbkluZm8pLmNvbHVtbkNvdW50O1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEFsbENvbHVtbiA9IGNvbHVtbkNvdW50ID09PSB0b3RhbENvbHVtbkNvdW50O1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZEFsbENvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdGFydENvbElkeCA9IHNlbGVjdGlvbkluZm8uc3RhcnRDb2xJZHgsIGVuZENvbElkeCA9IHNlbGVjdGlvbkluZm8uZW5kQ29sSWR4O1xuICAgICAgICAgICAgICAgIHZhciBtYXBTdGFydCA9IHRyLm1hcHBpbmcubWFwcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcm93SWR4ID0gMDsgcm93SWR4IDwgdG90YWxSb3dDb3VudDsgcm93SWR4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29sSWR4ID0gZW5kQ29sSWR4OyBjb2xJZHggPj0gc3RhcnRDb2xJZHg7IGNvbElkeCAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBtYXAuZ2V0Q2VsbEluZm8ocm93SWR4LCBjb2xJZHgpLCBvZmZzZXQgPSBfYi5vZmZzZXQsIG5vZGVTaXplID0gX2Iubm9kZVNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHRyLm1hcHBpbmcuc2xpY2UobWFwU3RhcnQpLm1hcChvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvID0gZnJvbSArIG5vZGVTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUuYWRkUm93ID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgc2NoZW1hID0gc3RhdGUuc2NoZW1hLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmVzb2x2ZWRTZWxlY3Rpb24oc2VsZWN0aW9uKSwgYW5jaG9yID0gX2EuYW5jaG9yLCBoZWFkID0gX2EuaGVhZDtcbiAgICAgICAgICAgIGlmIChhbmNob3IgJiYgaGVhZCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxDb2x1bW5Db3VudCA9IG1hcC50b3RhbENvbHVtbkNvdW50O1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25JbmZvID0gbWFwLmdldFJlY3RPZmZzZXRzKGFuY2hvciwgaGVhZCk7XG4gICAgICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gZ2V0Um93QW5kQ29sdW1uQ291bnQoc2VsZWN0aW9uSW5mbykucm93Q291bnQ7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gZ2V0VGFyZ2V0Um93SW5mbyhkaXJlY3Rpb24sIG1hcCwgc2VsZWN0aW9uSW5mbyksIHRhcmdldFJvd0lkeCA9IF9iLnRhcmdldFJvd0lkeCwgaW5zZXJ0Q29sSWR4ID0gX2IuaW5zZXJ0Q29sSWR4LCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZFRoZWFkID0gdGFyZ2V0Um93SWR4ID09PSAwO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0ZWRUaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHRyLm1hcHBpbmcubWFwKG1hcC5wb3NBdCh0YXJnZXRSb3dJZHgsIGluc2VydENvbElkeCkpICsgbm9kZVNpemU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxscyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2xJZHggPSAwOyBjb2xJZHggPCB0b3RhbENvbHVtbkNvdW50OyBjb2xJZHggKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbHMgPSBjZWxscy5jb25jYXQoY3JlYXRlRHVtbXlDZWxscygxLCB0YXJnZXRSb3dJZHgsIHNjaGVtYSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93Q291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKHNjaGVtYS5ub2Rlcy50YWJsZVJvdy5jcmVhdGUobnVsbCwgY2VsbHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5pbnNlcnQoZnJvbSwgcm93cykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUucmVtb3ZlUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJlc29sdmVkU2VsZWN0aW9uKHNlbGVjdGlvbiksIGFuY2hvciA9IF9hLmFuY2hvciwgaGVhZCA9IF9hLmhlYWQ7XG4gICAgICAgICAgICBpZiAoYW5jaG9yICYmIGhlYWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKGFuY2hvcik7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsUm93Q291bnQgPSBtYXAudG90YWxSb3dDb3VudCwgdG90YWxDb2x1bW5Db3VudCA9IG1hcC50b3RhbENvbHVtbkNvdW50O1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25JbmZvID0gbWFwLmdldFJlY3RPZmZzZXRzKGFuY2hvciwgaGVhZCk7XG4gICAgICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gZ2V0Um93QW5kQ29sdW1uQ291bnQoc2VsZWN0aW9uSW5mbykucm93Q291bnQ7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Um93SWR4ID0gc2VsZWN0aW9uSW5mby5zdGFydFJvd0lkeCwgZW5kUm93SWR4ID0gc2VsZWN0aW9uSW5mby5lbmRSb3dJZHg7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkVGhlYWQgPSBzdGFydFJvd0lkeCA9PT0gMDtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRBbGxUYm9keVJvdyA9IHJvd0NvdW50ID09PSB0b3RhbFJvd0NvdW50IC0gMTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRBbGxUYm9keVJvdyB8fCBzZWxlY3RlZFRoZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcm93SWR4ID0gZW5kUm93SWR4OyByb3dJZHggPj0gc3RhcnRSb3dJZHg7IHJvd0lkeCAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IGdldFJvd1JhbmdlcyhtYXAsIHJvd0lkeCwgdG90YWxDb2x1bW5Db3VudCksIGZyb20gPSBfYi5mcm9tLCB0byA9IF9iLnRvO1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUgdGFibGUgcm93XG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShmcm9tIC0gMSwgdG8gKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmFsaWduQ29sdW1uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkID09PSB2b2lkIDApIHsgcGF5bG9hZCA9IHsgYWxpZ246ICdjZW50ZXInIH07IH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFsaWduID0gcGF5bG9hZC5hbGlnbjtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGdldFJlc29sdmVkU2VsZWN0aW9uKHNlbGVjdGlvbiksIGFuY2hvciA9IF9hLmFuY2hvciwgaGVhZCA9IF9hLmhlYWQ7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvciAmJiBoZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsUm93Q291bnQgPSBtYXAudG90YWxSb3dDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkluZm8gPSBtYXAuZ2V0UmVjdE9mZnNldHMoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q29sSWR4ID0gc2VsZWN0aW9uSW5mby5zdGFydENvbElkeCwgZW5kQ29sSWR4ID0gc2VsZWN0aW9uSW5mby5lbmRDb2xJZHg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHJvd0lkeCA9IDA7IHJvd0lkeCA8IHRvdGFsUm93Q291bnQ7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2xJZHggPSBzdGFydENvbElkeDsgY29sSWR4IDw9IGVuZENvbElkeDsgY29sSWR4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcC5leHRlbmRlZFJvd3NwYW4ocm93SWR4LCBjb2xJZHgpICYmICFtYXAuZXh0ZW5kZWRDb2xzcGFuKHJvd0lkeCwgY29sSWR4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBtYXAuZ2V0Tm9kZUFuZFBvcyhyb3dJZHgsIGNvbElkeCksIG5vZGUgPSBfYi5ub2RlLCBwb3MgPSBfYi5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IHNldEF0dHJzKG5vZGUsIHsgYWxpZ246IGFsaWduIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgbnVsbCwgYXR0cnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLm1vdmVUb0NlbGwgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCB0ciA9IHN0YXRlLnRyLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSZXNvbHZlZFNlbGVjdGlvbihzZWxlY3Rpb24pLCBhbmNob3IgPSBfYS5hbmNob3IsIGhlYWQgPSBfYS5oZWFkO1xuICAgICAgICAgICAgaWYgKGFuY2hvciAmJiBoZWFkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShhbmNob3IpO1xuICAgICAgICAgICAgICAgIHZhciBjZWxsSW5kZXggPSBtYXAuZ2V0Q2VsbEluZGV4KGFuY2hvcik7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1RyID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChjYW5CZU91dE9mVGFibGUoZGlyZWN0aW9uLCBtYXAsIGNlbGxJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGVyZSBpcyBubyBjb250ZW50IGJlZm9yZSBvciBhZnRlciB0aGUgdGFibGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGVtcHR5IGxpbmUoJ3BhcmFncmFwaCcpIGlzIGNyZWF0ZWQgYnkgcHJlc3NpbmcgdGhlIGFycm93IGtleXMuXG4gICAgICAgICAgICAgICAgICAgIG5ld1RyID0gYWRkUGFyYWdyYXBoQWZ0ZXJUYWJsZSh0ciwgbWFwLCBzY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VHIgPSBtb3ZlVG9DZWxsKGRpcmVjdGlvbiwgdHIsIGNlbGxJbmRleCwgbWFwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5ld1RyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLm1vdmVJbkNlbGwgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCB0ciA9IHN0YXRlLnRyLCBkb2MgPSBzdGF0ZS5kb2MsIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gX3RoaXMuY29udGV4dC52aWV3O1xuICAgICAgICAgICAgaWYgKCF2aWV3LmVuZE9mVGV4dGJsb2NrKGRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2VsbCA9IGZpbmROb2RlQnkoJGZyb20sIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAndGFibGVIZWFkQ2VsbCcgfHwgdHlwZS5uYW1lID09PSAndGFibGVCb2R5Q2VsbCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjZWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmEgPSBmaW5kTm9kZUJ5KCRmcm9tLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAncGFyYWdyYXBoJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbERlcHRoID0gY2VsbC5kZXB0aDtcbiAgICAgICAgICAgICAgICBpZiAocGFyYSAmJiBjYW5Nb3ZlQmV0d2VlbkNlbGxzKGRpcmVjdGlvbiwgW2NlbGxEZXB0aCwgcGFyYS5kZXB0aF0sICRmcm9tLCBkb2MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3IgPSBnZXRSZXNvbHZlZFNlbGVjdGlvbihzZWxlY3Rpb24pLmFuY2hvcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShhbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbEluZGV4ID0gbWFwLmdldENlbGxJbmRleChhbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5TZWxlY3RUYWJsZU5vZGUoZGlyZWN0aW9uLCBtYXAsIGNlbGxJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGN1cnNvciBwb3NpdGlvbiBpcyBhdCB0aGUgZW5kIG9mIHRoZSBjZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHRhYmxlIGlzIHNlbGVjdGVkIHdoZW4gdGhlIGxlZnQgLyByaWdodCBhcnJvdyBrZXlzIGFyZSBwcmVzc2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHIgPSBzZWxlY3ROb2RlKHRyLCAkZnJvbSwgY2VsbERlcHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjYW5CZU91dE9mVGFibGUoZGlyZWN0aW9uLCBtYXAsIGNlbGxJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gY29udGVudCBiZWZvcmUgb3IgYWZ0ZXIgdGhlIHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gZW1wdHkgbGluZSgncGFyYWdyYXBoJykgaXMgY3JlYXRlZCBieSBwcmVzc2luZyB0aGUgYXJyb3cga2V5cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwidXBcIiAvKiBVUCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RyID0gYWRkUGFyYWdyYXBoQmVmb3JlVGFibGUodHIsIG1hcCwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCJkb3duXCIgLyogRE9XTiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RyID0gYWRkUGFyYWdyYXBoQWZ0ZXJUYWJsZSh0ciwgbWFwLCBzY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHIgPSBtb3ZlVG9DZWxsKGRpcmVjdGlvbiwgdHIsIGNlbGxJbmRleCwgbWFwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5ld1RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmRlbGV0ZUNlbGxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHN0YXRlLnNjaGVtYSwgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmVzb2x2ZWRTZWxlY3Rpb24oc2VsZWN0aW9uKSwgYW5jaG9yID0gX2EuYW5jaG9yLCBoZWFkID0gX2EuaGVhZDtcbiAgICAgICAgICAgIHZhciB0ZXh0U2VsZWN0aW9uID0gc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmIChhbmNob3IgJiYgaGVhZCAmJiAhdGV4dFNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBtYXAuZ2V0UmVjdE9mZnNldHMoYW5jaG9yLCBoZWFkKSwgc3RhcnRSb3dJZHggPSBfYi5zdGFydFJvd0lkeCwgc3RhcnRDb2xJZHggPSBfYi5zdGFydENvbElkeCwgZW5kUm93SWR4ID0gX2IuZW5kUm93SWR4LCBlbmRDb2xJZHggPSBfYi5lbmRDb2xJZHg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcm93SWR4ID0gc3RhcnRSb3dJZHg7IHJvd0lkeCA8PSBlbmRSb3dJZHg7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbElkeCA9IHN0YXJ0Q29sSWR4OyBjb2xJZHggPD0gZW5kQ29sSWR4OyBjb2xJZHggKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXAuZXh0ZW5kZWRSb3dzcGFuKHJvd0lkeCwgY29sSWR4KSAmJiAhbWFwLmV4dGVuZGVkQ29sc3Bhbihyb3dJZHgsIGNvbElkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2MgPSBtYXAuZ2V0Tm9kZUFuZFBvcyhyb3dJZHgsIGNvbElkeCksIG5vZGUgPSBfYy5ub2RlLCBwb3MgPSBfYy5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxzID0gY3JlYXRlRHVtbXlDZWxscygxLCByb3dJZHgsIHNjaGVtYSwgbm9kZS5hdHRycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgodHIubWFwcGluZy5tYXAocG9zKSwgdHIubWFwcGluZy5tYXAocG9zICsgbm9kZS5ub2RlU2l6ZSksIGNlbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUuZXhpdFRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50ciwgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICAgICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tO1xuICAgICAgICAgICAgdmFyIGNlbGwgPSBmaW5kTm9kZUJ5KCRmcm9tLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ3RhYmxlSGVhZENlbGwnIHx8IHR5cGUubmFtZSA9PT0gJ3RhYmxlQm9keUNlbGwnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhID0gZmluZE5vZGVCeSgkZnJvbSwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ3BhcmFncmFwaCc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvciA9IGdldFJlc29sdmVkU2VsZWN0aW9uKHNlbGVjdGlvbikuYW5jaG9yO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKGFuY2hvcik7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKGFkZFBhcmFncmFwaEFmdGVyVGFibGUodHIsIG1hcCwgc2NoZW1hLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZFRhYmxlOiB0aGlzLmFkZFRhYmxlKCksXG4gICAgICAgICAgICByZW1vdmVUYWJsZTogdGhpcy5yZW1vdmVUYWJsZSgpLFxuICAgICAgICAgICAgYWRkQ29sdW1uVG9MZWZ0OiB0aGlzLmFkZENvbHVtbihcImxlZnRcIiAvKiBMRUZUICovKSxcbiAgICAgICAgICAgIGFkZENvbHVtblRvUmlnaHQ6IHRoaXMuYWRkQ29sdW1uKFwicmlnaHRcIiAvKiBSSUdIVCAqLyksXG4gICAgICAgICAgICByZW1vdmVDb2x1bW46IHRoaXMucmVtb3ZlQ29sdW1uKCksXG4gICAgICAgICAgICBhZGRSb3dUb1VwOiB0aGlzLmFkZFJvdyhcInVwXCIgLyogVVAgKi8pLFxuICAgICAgICAgICAgYWRkUm93VG9Eb3duOiB0aGlzLmFkZFJvdyhcImRvd25cIiAvKiBET1dOICovKSxcbiAgICAgICAgICAgIHJlbW92ZVJvdzogdGhpcy5yZW1vdmVSb3coKSxcbiAgICAgICAgICAgIGFsaWduQ29sdW1uOiB0aGlzLmFsaWduQ29sdW1uKCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlbGV0ZUNlbGxDb250ZW50ID0gdGhpcy5kZWxldGVDZWxscygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgVGFiOiB0aGlzLm1vdmVUb0NlbGwoXCJyaWdodFwiIC8qIFJJR0hUICovKSxcbiAgICAgICAgICAgICdTaGlmdC1UYWInOiB0aGlzLm1vdmVUb0NlbGwoXCJsZWZ0XCIgLyogTEVGVCAqLyksXG4gICAgICAgICAgICBBcnJvd1VwOiB0aGlzLm1vdmVJbkNlbGwoXCJ1cFwiIC8qIFVQICovKSxcbiAgICAgICAgICAgIEFycm93RG93bjogdGhpcy5tb3ZlSW5DZWxsKFwiZG93blwiIC8qIERPV04gKi8pLFxuICAgICAgICAgICAgQXJyb3dMZWZ0OiB0aGlzLm1vdmVJbkNlbGwoXCJsZWZ0XCIgLyogTEVGVCAqLyksXG4gICAgICAgICAgICBBcnJvd1JpZ2h0OiB0aGlzLm1vdmVJbkNlbGwoXCJyaWdodFwiIC8qIFJJR0hUICovKSxcbiAgICAgICAgICAgIEJhY2tzcGFjZTogZGVsZXRlQ2VsbENvbnRlbnQsXG4gICAgICAgICAgICAnTW9kLUJhY2tzcGFjZSc6IGRlbGV0ZUNlbGxDb250ZW50LFxuICAgICAgICAgICAgRGVsZXRlOiBkZWxldGVDZWxsQ29udGVudCxcbiAgICAgICAgICAgICdNb2QtRGVsZXRlJzogZGVsZXRlQ2VsbENvbnRlbnQsXG4gICAgICAgICAgICAnTW9kLUVudGVyJzogdGhpcy5leGl0VGFibGUoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZTtcbn0oTm9kZSQyKSk7XG5cbnZhciBUYWJsZUhlYWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGFibGVIZWFkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlSGVhZCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVIZWFkLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RhYmxlSGVhZCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVIZWFkLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ3RhYmxlUm93ezF9JyxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW2NyZWF0ZURPTUluZm9QYXJzZWRSYXdIVE1MKCd0aGVhZCcpXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyd0aGVhZCcsIGdldEN1c3RvbUF0dHJzKGF0dHJzKSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVGFibGVIZWFkO1xufShOb2RlJDIpKTtcblxudmFyIFRhYmxlQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUYWJsZUJvZHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVCb2R5KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZUJvZHkucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGFibGVCb2R5JztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZUJvZHkucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAndGFibGVSb3crJyxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICd0Ym9keScsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3dzID0gZG9tLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSByb3dzWzBdLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7fSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyd0Ym9keScsIGdldEN1c3RvbUF0dHJzKGF0dHJzKSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVGFibGVCb2R5O1xufShOb2RlJDIpKTtcblxudmFyIFRhYmxlUm93ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYmxlUm93LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlUm93KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZVJvdy5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0YWJsZVJvdyc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVSb3cucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnKHRhYmxlSGVhZENlbGwgfCB0YWJsZUJvZHlDZWxsKSonLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ3RyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBkb20uY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29sdW1ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHt9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3RyJywgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpLCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBUYWJsZVJvdztcbn0oTm9kZSQyKSk7XG5cbnZhciBUYWJsZUhlYWRDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYmxlSGVhZENlbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVIZWFkQ2VsbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVIZWFkQ2VsbC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0YWJsZUhlYWRDZWxsJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZUhlYWRDZWxsLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ3BhcmFncmFwaCsnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgYWxpZ246IHsgZGVmYXVsdDogbnVsbCB9LCBjbGFzc05hbWU6IHsgZGVmYXVsdDogbnVsbCB9LCByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSwgY29sc3BhbjogeyBkZWZhdWx0OiBudWxsIH0sIGV4dGVuZGVkOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgaXNvbGF0aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbY3JlYXRlUGFyc2VkQ2VsbERPTSgndGgnKV0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxBdHRycyA9IGNyZWF0ZUNlbGxBdHRycyhhdHRycyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3RoJywgX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBjZWxsQXR0cnMpLCBnZXRDdXN0b21BdHRycyhhdHRycykpLCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBUYWJsZUhlYWRDZWxsO1xufShOb2RlJDIpKTtcblxudmFyIFRhYmxlQm9keUNlbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGFibGVCb2R5Q2VsbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUJvZHlDZWxsKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZUJvZHlDZWxsLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RhYmxlQm9keUNlbGwnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlQm9keUNlbGwucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnKHBhcmFncmFwaCB8IGJ1bGxldExpc3QgfCBvcmRlcmVkTGlzdCkrJyxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICBhbGlnbjogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBjb2xzcGFuOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgcm93c3BhbjogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzb2xhdGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW2NyZWF0ZVBhcnNlZENlbGxET00oJ3RkJyldLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsQXR0cnMgPSBjcmVhdGVDZWxsQXR0cnMoYXR0cnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyd0ZCcsIGNlbGxBdHRycywgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVGFibGVCb2R5Q2VsbDtcbn0oTm9kZSQyKSk7XG5cbnZhciBJbWFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShJbWFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbWFnZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW1hZ2UucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnaW1hZ2UnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEltYWdlLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5saW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgaW1hZ2VVcmw6IHsgZGVmYXVsdDogJycgfSwgYWx0VGV4dDogeyBkZWZhdWx0OiBudWxsIH0sIHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBncm91cDogJ2lubGluZScsXG4gICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAnaW1nW3NyY10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2FuaXRpemVkRE9NID0gc2FuaXRpemVIVE1MKGRvbSwgeyBSRVRVUk5fRE9NX0ZSQUdNRU5UOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVVybCA9IHNhbml0aXplZERPTS5nZXRBdHRyaWJ1dGUoJ3NyYycpIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gc2FuaXRpemVkRE9NLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbHRUZXh0ID0gc2FuaXRpemVkRE9NLmdldEF0dHJpYnV0ZSgnYWx0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoeyBpbWFnZVVybDogaW1hZ2VVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdFRleHQ6IGFsdFRleHQgfSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMucmF3SFRNTCB8fCAnaW1nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7IHNyYzogZXNjYXBlWG1sJDEoYXR0cnMuaW1hZ2VVcmwpIH0sIChhdHRycy5hbHRUZXh0ICYmIHsgYWx0OiBhdHRycy5hbHRUZXh0IH0pKSwgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpKSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEltYWdlLnByb3RvdHlwZS5hZGRJbWFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1hID0gX2Euc2NoZW1hLCB0ciA9IF9hLnRyO1xuICAgICAgICAgICAgdmFyIF9iID0gcGF5bG9hZCwgaW1hZ2VVcmwgPSBfYi5pbWFnZVVybCwgYWx0VGV4dCA9IF9iLmFsdFRleHQ7XG4gICAgICAgICAgICBpZiAoIWltYWdlVXJsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vZGUgPSBzY2hlbWEubm9kZXMuaW1hZ2UuY3JlYXRlQW5kRmlsbChfX2Fzc2lnbiQxKHsgaW1hZ2VVcmw6IGltYWdlVXJsIH0sIChhbHRUZXh0ICYmIHsgYWx0VGV4dDogYWx0VGV4dCB9KSkpO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIucmVwbGFjZVNlbGVjdGlvbldpdGgobm9kZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIEltYWdlLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZEltYWdlOiB0aGlzLmFkZEltYWdlKCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gSW1hZ2U7XG59KE5vZGUkMikpO1xuXG52YXIgUk9PVF9CTE9DS19ERVBUSCA9IDE7XG52YXIgVGhlbWF0aWNCcmVhayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUaGVtYXRpY0JyZWFrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRoZW1hdGljQnJlYWsoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRoZW1hdGljQnJlYWsucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGhlbWF0aWNCcmVhayc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGhlbWF0aWNCcmVhay5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbeyB0YWc6ICdocicgfV0sXG4gICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnZGl2JywgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpLCBbYXR0cnMucmF3SFRNTCB8fCAnaHInXV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUaGVtYXRpY0JyZWFrLnByb3RvdHlwZS5ociA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBfYiA9IHN0YXRlLnNlbGVjdGlvbiwgJGZyb20gPSBfYi4kZnJvbSwgJHRvID0gX2IuJHRvO1xuICAgICAgICAgICAgaWYgKCRmcm9tID09PSAkdG8pIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gc3RhdGUuZG9jO1xuICAgICAgICAgICAgICAgIHZhciBfYyA9IHN0YXRlLnNjaGVtYS5ub2RlcywgdGhlbWF0aWNCcmVhayA9IF9jLnRoZW1hdGljQnJlYWssIHBhcmFncmFwaCA9IF9jLnBhcmFncmFwaDtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSBbdGhlbWF0aWNCcmVhay5jcmVhdGUoKV07XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RCbG9jayA9ICRmcm9tLm5vZGUoUk9PVF9CTE9DS19ERVBUSCk7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RCbG9jayA9IGRvYy5jaGlsZChkb2MuY2hpbGRDb3VudCAtIDEpID09PSByb290QmxvY2s7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrRW5kID0gZG9jLnJlc29sdmUoJGZyb20uYWZ0ZXIoUk9PVF9CTE9DS19ERVBUSCkpO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0SHIgPSAoKF9hID0gJGZyb20ubm9kZUFmdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZS5uYW1lKSA9PT0gX3RoaXMubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEJsb2NrIHx8IG5leHRIcikge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKHBhcmFncmFwaC5jcmVhdGUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmluc2VydChibG9ja0VuZC5wb3MsIG5vZGVzKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIFRoZW1hdGljQnJlYWsucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBocjogdGhpcy5ocigpIH07XG4gICAgfTtcbiAgICBUaGVtYXRpY0JyZWFrLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaHJDb21tYW5kID0gdGhpcy5ocigpKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLWwnOiBockNvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLUwnOiBockNvbW1hbmQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGhlbWF0aWNCcmVhaztcbn0oTm9kZSQyKSk7XG5cbnZhciBTdHJvbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoU3Ryb25nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0cm9uZygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3Ryb25nLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3N0cm9uZyc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3Ryb25nLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZURPTSA9IFsnYicsICdzdHJvbmcnXS5tYXAoZnVuY3Rpb24gKHRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7fSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBwYXJzZURPTSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2F0dHJzLnJhd0hUTUwgfHwgJ3N0cm9uZycsIGdldEN1c3RvbUF0dHJzKGF0dHJzKV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdHJvbmcucHJvdG90eXBlLmJvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7IHJldHVybiB0b2dnbGVNYXJrJDEoc3RhdGUuc2NoZW1hLm1hcmtzLnN0cm9uZykoc3RhdGUsIGRpc3BhdGNoKTsgfTsgfTtcbiAgICB9O1xuICAgIFN0cm9uZy5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IGJvbGQ6IHRoaXMuYm9sZCgpIH07XG4gICAgfTtcbiAgICBTdHJvbmcucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBib2xkQ29tbWFuZCA9IHRoaXMuYm9sZCgpKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLWInOiBib2xkQ29tbWFuZCxcbiAgICAgICAgICAgICdNb2QtQic6IGJvbGRDb21tYW5kLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFN0cm9uZztcbn0oTWFyaykpO1xuXG52YXIgRW1waCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShFbXBoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVtcGgoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtcGgucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnZW1waCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1waC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VET00gPSBbJ2knLCAnZW0nXS5tYXAoZnVuY3Rpb24gKHRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7fSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBwYXJzZURPTSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2F0dHJzLnJhd0hUTUwgfHwgJ2VtJywgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEVtcGgucHJvdG90eXBlLml0YWxpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHsgcmV0dXJuIHRvZ2dsZU1hcmskMShzdGF0ZS5zY2hlbWEubWFya3MuZW1waCkoc3RhdGUsIGRpc3BhdGNoKTsgfTsgfTtcbiAgICB9O1xuICAgIEVtcGgucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBpdGFsaWM6IHRoaXMuaXRhbGljKCkgfTtcbiAgICB9O1xuICAgIEVtcGgucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGFsaWNDb21tYW5kID0gdGhpcy5pdGFsaWMoKSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1pJzogaXRhbGljQ29tbWFuZCxcbiAgICAgICAgICAgICdNb2QtSSc6IGl0YWxpY0NvbW1hbmQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gRW1waDtcbn0oTWFyaykpO1xuXG52YXIgU3RyaWtlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFN0cmlrZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHJpa2UoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmlrZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdzdHJpa2UnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmlrZS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VET00gPSBbJ3MnLCAnZGVsJ10ubWFwKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoe30sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogcGFyc2VET00sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthdHRycy5yYXdIVE1MIHx8ICdkZWwnLCBnZXRDdXN0b21BdHRycyhhdHRycyldO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3RyaWtlLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHsgcmV0dXJuIHRvZ2dsZU1hcmskMShzdGF0ZS5zY2hlbWEubWFya3Muc3RyaWtlKShzdGF0ZSwgZGlzcGF0Y2gpOyB9OyB9O1xuICAgIH07XG4gICAgU3RyaWtlLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RyaWtlQ29tbWFuZCA9IHRoaXMuY29tbWFuZHMoKSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1zJzogc3RyaWtlQ29tbWFuZCxcbiAgICAgICAgICAgICdNb2QtUyc6IHN0cmlrZUNvbW1hbmQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gU3RyaWtlO1xufShNYXJrKSk7XG5cbnZhciBMaW5rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKExpbmssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGluayhsaW5rQXR0cmlidXRlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5saW5rQXR0cmlidXRlcyA9IGxpbmtBdHRyaWJ1dGVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5rLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2xpbmsnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmsucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyBsaW5rVXJsOiB7IGRlZmF1bHQ6ICcnIH0sIHRpdGxlOiB7IGRlZmF1bHQ6IG51bGwgfSwgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAnYVtocmVmXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYW5pdGl6ZWRET00gPSBzYW5pdGl6ZUhUTUwoZG9tLCB7IFJFVFVSTl9ET01fRlJBR01FTlQ6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBzYW5pdGl6ZWRET00uZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpdGxlID0gc2FuaXRpemVkRE9NLmdldEF0dHJpYnV0ZSgndGl0bGUnKSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IHNhbml0aXplZERPTS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7IGxpbmtVcmw6IGhyZWYsIHRpdGxlOiB0aXRsZSB9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRycy5yYXdIVE1MIHx8ICdhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7IGhyZWY6IGVzY2FwZVhtbCQxKGF0dHJzLmxpbmtVcmwpIH0sIF90aGlzLmxpbmtBdHRyaWJ1dGVzKSwgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpKSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIExpbmsucHJvdG90eXBlLmFkZExpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIF9hID0gcGF5bG9hZCwgbGlua1VybCA9IF9hLmxpbmtVcmwsIF9iID0gX2EubGlua1RleHQsIGxpbmtUZXh0ID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7XG4gICAgICAgICAgICB2YXIgc2NoZW1hID0gc3RhdGUuc2NoZW1hLCB0ciA9IHN0YXRlLnRyLCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICB2YXIgZW1wdHkgPSBzZWxlY3Rpb24uZW1wdHksIGZyb20gPSBzZWxlY3Rpb24uZnJvbSwgdG8gPSBzZWxlY3Rpb24udG87XG4gICAgICAgICAgICBpZiAoZnJvbSAmJiB0byAmJiBsaW5rVXJsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJzID0geyBsaW5rVXJsOiBsaW5rVXJsIH07XG4gICAgICAgICAgICAgICAgdmFyIG1hcmsgPSBzY2hlbWEubWFyaygnbGluaycsIGF0dHJzKTtcbiAgICAgICAgICAgICAgICBpZiAoZW1wdHkgJiYgbGlua1RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgbGlua1RleHQsIG1hcmspO1xuICAgICAgICAgICAgICAgICAgICB0ci5yZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoZnJvbSwgdG8sIG1hcmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIExpbmsucHJvdG90eXBlLnRvZ2dsZUxpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRvZ2dsZU1hcmskMShzdGF0ZS5zY2hlbWEubWFya3MubGluaywgcGF5bG9hZCkoc3RhdGUsIGRpc3BhdGNoKTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIExpbmsucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkTGluazogdGhpcy5hZGRMaW5rKCksXG4gICAgICAgICAgICB0b2dnbGVMaW5rOiB0aGlzLnRvZ2dsZUxpbmsoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBMaW5rO1xufShNYXJrKSk7XG5cbnZhciBDb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKENvZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29kZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdjb2RlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2RlLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAnY29kZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHt9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYXR0cnMucmF3SFRNTCB8fCAnY29kZScsIGdldEN1c3RvbUF0dHJzKGF0dHJzKV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDb2RlLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHsgcmV0dXJuIHRvZ2dsZU1hcmskMShzdGF0ZS5zY2hlbWEubWFya3MuY29kZSkoc3RhdGUsIGRpc3BhdGNoKTsgfTsgfTtcbiAgICB9O1xuICAgIENvZGUucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2RlQ29tbWFuZCA9IHRoaXMuY29tbWFuZHMoKSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ1NoaWZ0LU1vZC1jJzogY29kZUNvbW1hbmQsXG4gICAgICAgICAgICAnU2hpZnQtTW9kLUMnOiBjb2RlQ29tbWFuZCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb2RlO1xufShNYXJrKSk7XG5cbnZhciBDdXN0b21CbG9jayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShDdXN0b21CbG9jaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDdXN0b21CbG9jaygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tQmxvY2sucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnY3VzdG9tQmxvY2snO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbUJsb2NrLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ3RleHQqJyxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICBpbmZvOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGF0b206IHRydWUsXG4gICAgICAgICAgICAgICAgY29kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkZWZpbmluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICdkaXZbZGF0YS1jdXN0b20taW5mb10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtY3VzdG9tLWluZm8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpbmZvOiBpbmZvIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnZGl2JywgeyAnZGF0YS1jdXN0b20taW5mbyc6IGF0dHJzLmluZm8gfHwgbnVsbCB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEN1c3RvbUJsb2NrLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5pbmZvKVxuICAgICAgICAgICAgICAgID8gc2V0QmxvY2tUeXBlKHN0YXRlLnNjaGVtYS5ub2Rlcy5jdXN0b21CbG9jaywgcGF5bG9hZCkoc3RhdGUsIGRpc3BhdGNoKVxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICByZXR1cm4gQ3VzdG9tQmxvY2s7XG59KE5vZGUkMikpO1xuXG52YXIgRnJvbnRNYXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoRnJvbnRNYXR0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnJvbnRNYXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyb250TWF0dGVyLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Zyb250TWF0dGVyJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcm9udE1hdHRlci5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd0ZXh0KicsXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgY29kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkZWZpbmluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICdmdWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ2RpdltkYXRhLWZyb250LW1hdHRlcl0nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnZGl2JywgeyAnZGF0YS1mcm9udC1tYXR0ZXInOiAndHJ1ZScgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBGcm9udE1hdHRlci5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gICAgICAgICAgICB2YXIgJGZyb20gPSBzdGF0ZS5zZWxlY3Rpb24uJGZyb207XG4gICAgICAgICAgICBpZiAodmlldy5lbmRPZlRleHRibG9jaygnZG93bicpICYmICRmcm9tLm5vZGUoKS50eXBlLm5hbWUgPT09ICdmcm9udE1hdHRlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpdENvZGUoc3RhdGUsIGRpc3BhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIEZyb250TWF0dGVyLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgRW50ZXI6IHRoaXMuY29tbWFuZHMoKSgpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEZyb250TWF0dGVyO1xufShOb2RlJDIpKTtcblxudmFyIEhUTUxDb21tZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEhUTUxDb21tZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhUTUxDb21tZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MQ29tbWVudC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdodG1sQ29tbWVudCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTENvbW1lbnQucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAndGV4dConLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGNvZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGVmaW5pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFt7IHByZXNlcnZlV2hpdGVzcGFjZTogJ2Z1bGwnLCB0YWc6ICdkaXZbZGF0YS1odG1sLWNvbW1lbnRdJyB9XSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydkaXYnLCB7ICdkYXRhLWh0bWwtY29tbWVudCc6ICd0cnVlJyB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEhUTUxDb21tZW50LnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICAgICAgICAgIHZhciAkZnJvbSA9IHN0YXRlLnNlbGVjdGlvbi4kZnJvbTtcbiAgICAgICAgICAgIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKCdkb3duJykgJiYgJGZyb20ubm9kZSgpLnR5cGUubmFtZSA9PT0gJ2h0bWxDb21tZW50Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGl0Q29kZShzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgSFRNTENvbW1lbnQucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBFbnRlcjogdGhpcy5jb21tYW5kcygpKCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gSFRNTENvbW1lbnQ7XG59KE5vZGUkMikpO1xuXG5mdW5jdGlvbiBjcmVhdGVTcGVjcyhsaW5rQXR0cmlidXRlcykge1xuICAgIHJldHVybiBuZXcgU3BlY01hbmFnZXIoW1xuICAgICAgICBuZXcgRG9jKCksXG4gICAgICAgIG5ldyBQYXJhZ3JhcGgoKSxcbiAgICAgICAgbmV3IFRleHQoKSxcbiAgICAgICAgbmV3IEhlYWRpbmcoKSxcbiAgICAgICAgbmV3IENvZGVCbG9jaygpLFxuICAgICAgICBuZXcgQnVsbGV0TGlzdCgpLFxuICAgICAgICBuZXcgT3JkZXJlZExpc3QoKSxcbiAgICAgICAgbmV3IExpc3RJdGVtKCksXG4gICAgICAgIG5ldyBCbG9ja1F1b3RlKCksXG4gICAgICAgIG5ldyBUYWJsZSgpLFxuICAgICAgICBuZXcgVGFibGVIZWFkKCksXG4gICAgICAgIG5ldyBUYWJsZUJvZHkoKSxcbiAgICAgICAgbmV3IFRhYmxlUm93KCksXG4gICAgICAgIG5ldyBUYWJsZUhlYWRDZWxsKCksXG4gICAgICAgIG5ldyBUYWJsZUJvZHlDZWxsKCksXG4gICAgICAgIG5ldyBJbWFnZSgpLFxuICAgICAgICBuZXcgVGhlbWF0aWNCcmVhaygpLFxuICAgICAgICBuZXcgU3Ryb25nKCksXG4gICAgICAgIG5ldyBFbXBoKCksXG4gICAgICAgIG5ldyBTdHJpa2UoKSxcbiAgICAgICAgbmV3IExpbmsobGlua0F0dHJpYnV0ZXMpLFxuICAgICAgICBuZXcgQ29kZSgpLFxuICAgICAgICBuZXcgQ3VzdG9tQmxvY2soKSxcbiAgICAgICAgbmV3IEZyb250TWF0dGVyKCksXG4gICAgICAgIG5ldyBXaWRnZXQoKSxcbiAgICAgICAgbmV3IEhUTUxDb21tZW50KCksXG4gICAgXSk7XG59XG5cbnZhciBDT05URU5UU19DTEFTU19OQU1FID0gY2xzKCdjb250ZW50cycpO1xudmFyIFd5c2l3eWdFZGl0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoV3lzaXd5Z0VkaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXeXNpd3lnRWRpdG9yKGV2ZW50RW1pdHRlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBldmVudEVtaXR0ZXIpIHx8IHRoaXM7XG4gICAgICAgIHZhciB0b0RPTUFkYXB0b3IgPSBvcHRpb25zLnRvRE9NQWRhcHRvciwgX2EgPSBvcHRpb25zLmh0bWxTY2hlbWFNYXAsIGh0bWxTY2hlbWFNYXAgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2IgPSBvcHRpb25zLmxpbmtBdHRyaWJ1dGVzLCBsaW5rQXR0cmlidXRlcyA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iLCBfYyA9IG9wdGlvbnMudXNlQ29tbWFuZFNob3J0Y3V0LCB1c2VDb21tYW5kU2hvcnRjdXQgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBfZCA9IG9wdGlvbnMud3dQbHVnaW5zLCB3d1BsdWdpbnMgPSBfZCA9PT0gdm9pZCAwID8gW10gOiBfZCwgX2UgPSBvcHRpb25zLnd3Tm9kZVZpZXdzLCB3d05vZGVWaWV3cyA9IF9lID09PSB2b2lkIDAgPyB7fSA6IF9lO1xuICAgICAgICBfdGhpcy5lZGl0b3JUeXBlID0gJ3d5c2l3eWcnO1xuICAgICAgICBfdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCd3dy1tb2RlJyk7XG4gICAgICAgIF90aGlzLnRvRE9NQWRhcHRvciA9IHRvRE9NQWRhcHRvcjtcbiAgICAgICAgX3RoaXMubGlua0F0dHJpYnV0ZXMgPSBsaW5rQXR0cmlidXRlcztcbiAgICAgICAgX3RoaXMuZXh0cmFQbHVnaW5zID0gd3dQbHVnaW5zO1xuICAgICAgICBfdGhpcy5wbHVnaW5Ob2RlVmlld3MgPSB3d05vZGVWaWV3cztcbiAgICAgICAgX3RoaXMuc3BlY3MgPSBfdGhpcy5jcmVhdGVTcGVjcygpO1xuICAgICAgICBfdGhpcy5zY2hlbWEgPSBfdGhpcy5jcmVhdGVTY2hlbWEoaHRtbFNjaGVtYU1hcCk7XG4gICAgICAgIF90aGlzLmNvbnRleHQgPSBfdGhpcy5jcmVhdGVDb250ZXh0KCk7XG4gICAgICAgIF90aGlzLmtleW1hcHMgPSBfdGhpcy5jcmVhdGVLZXltYXBzKHVzZUNvbW1hbmRTaG9ydGN1dCk7XG4gICAgICAgIF90aGlzLnZpZXcgPSBfdGhpcy5jcmVhdGVWaWV3KCk7XG4gICAgICAgIF90aGlzLmNvbW1hbmRzID0gX3RoaXMuY3JlYXRlQ29tbWFuZHMoKTtcbiAgICAgICAgX3RoaXMuc3BlY3Muc2V0Q29udGV4dChfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIF90aGlzLmNvbnRleHQpLCB7IHZpZXc6IF90aGlzLnZpZXcgfSkpO1xuICAgICAgICBfdGhpcy5pbml0RXZlbnQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVTcGVjcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNwZWNzKHRoaXMubGlua0F0dHJpYnV0ZXMpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICAgICAgICBldmVudEVtaXR0ZXI6IHRoaXMuZXZlbnRFbWl0dGVyLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuY3JlYXRlU2NoZW1hID0gZnVuY3Rpb24gKGh0bWxTY2hlbWFNYXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2hlbWEoe1xuICAgICAgICAgICAgbm9kZXM6IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgdGhpcy5zcGVjcy5ub2RlcyksIGh0bWxTY2hlbWFNYXAubm9kZXMpLFxuICAgICAgICAgICAgbWFya3M6IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgdGhpcy5zcGVjcy5tYXJrcyksIGh0bWxTY2hlbWFNYXAubWFya3MpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVBsdWdpbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5JDEoW1xuICAgICAgICAgICAgdGFibGVTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgIHRhYmxlQ29udGV4dE1lbnUodGhpcy5ldmVudEVtaXR0ZXIpLFxuICAgICAgICAgICAgdGFzaygpLFxuICAgICAgICAgICAgdG9vbGJhclN0YXRlSGlnaGxpZ2h0KHRoaXMuZXZlbnRFbWl0dGVyKVxuICAgICAgICBdLCB0aGlzLmNyZWF0ZVBsdWdpblByb3BzKCkpLmNvbmNhdCh0aGlzLmRlZmF1bHRQbHVnaW5zKTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVBsdWdpbk5vZGVWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyLCBwbHVnaW5Ob2RlVmlld3MgPSBfYS5wbHVnaW5Ob2RlVmlld3M7XG4gICAgICAgIHZhciBwbHVnaW5Ob2RlVmlld01hcCA9IHt9O1xuICAgICAgICBpZiAocGx1Z2luTm9kZVZpZXdzKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwbHVnaW5Ob2RlVmlld3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHBsdWdpbk5vZGVWaWV3TWFwW2tleV0gPSBmdW5jdGlvbiAobm9kZSwgdmlldywgZ2V0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW5Ob2RlVmlld3Nba2V5XShub2RlLCB2aWV3LCBnZXRQb3MsIGV2ZW50RW1pdHRlcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbHVnaW5Ob2RlVmlld01hcDtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHRvRE9NQWRhcHRvciA9IF9hLnRvRE9NQWRhcHRvciwgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyO1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclZpZXcodGhpcy5lbCwge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuY3JlYXRlU3RhdGUoKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogQ09OVEVOVFNfQ0xBU1NfTkFNRSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub2RlVmlld3M6IF9fYXNzaWduJDEoeyBjdXN0b21CbG9jazogZnVuY3Rpb24gKG5vZGUsIHZpZXcsIGdldFBvcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUJsb2NrVmlldyhub2RlLCB2aWV3LCBnZXRQb3MsIHRvRE9NQWRhcHRvcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbWFnZTogZnVuY3Rpb24gKG5vZGUsIHZpZXcsIGdldFBvcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltYWdlVmlldyhub2RlLCB2aWV3LCBnZXRQb3MsIGV2ZW50RW1pdHRlcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb2RlQmxvY2s6IGZ1bmN0aW9uIChub2RlLCB2aWV3LCBnZXRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2RlQmxvY2tWaWV3KG5vZGUsIHZpZXcsIGdldFBvcywgZXZlbnRFbWl0dGVyKTtcbiAgICAgICAgICAgICAgICB9LCB3aWRnZXQ6IHdpZGdldE5vZGVWaWV3IH0sIHRoaXMuY3JlYXRlUGx1Z2luTm9kZVZpZXdzKCkpLFxuICAgICAgICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbjogZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gX3RoaXMudmlldy5zdGF0ZS5hcHBseVRyYW5zYWN0aW9uKHRyKS5zdGF0ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0Q2hhbmdlRXZlbnQodHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3NldEZvY3VzZWROb2RlJywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm5vZGUoMSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zZm9ybVBhc3RlZEhUTUw6IGNoYW5nZVBhc3RlZEhUTUwsXG4gICAgICAgICAgICB0cmFuc2Zvcm1QYXN0ZWQ6IGZ1bmN0aW9uIChzbGljZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2VQYXN0ZWRTbGljZShzbGljZSwgX3RoaXMuc2NoZW1hLCBpc0luVGFibGVOb2RlKF90aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLiRmcm9tKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlUGFzdGU6IGZ1bmN0aW9uICh2aWV3LCBfLCBzbGljZSkgeyByZXR1cm4gcGFzdGVUb1RhYmxlKHZpZXcsIHNsaWNlKTsgfSxcbiAgICAgICAgICAgIGhhbmRsZUtleURvd246IGZ1bmN0aW9uIChfLCBldikge1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdrZXlkb3duJywgX3RoaXMuZWRpdG9yVHlwZSwgZXYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgICAgICBwYXN0ZTogZnVuY3Rpb24gKF8sIGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGlwYm9hcmREYXRhID0gZXYuY2xpcGJvYXJkRGF0YSB8fCB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gY2xpcGJvYXJkRGF0YSA9PT0gbnVsbCB8fCBjbGlwYm9hcmREYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGlwYm9hcmREYXRhLml0ZW1zO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluUnRmSXRlbSA9IHRvQXJyYXlfMShpdGVtcykuc29tZShmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5raW5kID09PSAnc3RyaW5nJyAmJiBpdGVtLnR5cGUgPT09ICd0ZXh0L3J0Zic7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgY29udGFpbnMgcnRmLCBpdCdzIG1vc3QgbGlrZWx5IGNvcHkgcGFzdGUgZnJvbSBvZmZpY2UgLT4gbm8gaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29udGFpblJ0Zkl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VCbG9iID0gcGFzdGVJbWFnZU9ubHkoaXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZUJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEltYWdlQmxvYkhvb2soX3RoaXMuZXZlbnRFbWl0dGVyLCBpbWFnZUJsb2IsIGV2LnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBrZXl1cDogZnVuY3Rpb24gKF8sIGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdrZXl1cCcsIF90aGlzLmVkaXRvclR5cGUsIGV2KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2Nyb2xsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdzY3JvbGwnLCAnZWRpdG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmNyZWF0ZUNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjcy5jb21tYW5kcyh0aGlzLnZpZXcsIGdldFd3Q29tbWFuZHMoKSk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5nZXRIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlUHJvc2VNaXJyb3JIYWNrTm9kZXModGhpcy52aWV3LmRvbS5pbm5lckhUTUwpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuZ2V0TW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZG9jO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLCBmcm9tID0gX2EuZnJvbSwgdG8gPSBfYS50bztcbiAgICAgICAgcmV0dXJuIFtmcm9tLCB0b107XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5nZXRTY2hlbWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuc2NoZW1hO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUucmVwbGFjZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgc2NoZW1hID0gX2Euc2NoZW1hLCB0ciA9IF9hLnRyO1xuICAgICAgICB2YXIgbGluZVRleHRzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIHZhciBwYXJhcyA9IGxpbmVUZXh0cy5tYXAoZnVuY3Rpb24gKGxpbmVUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUGFyYWdyYXBoKHNjaGVtYSwgY3JlYXRlTm9kZXNXaXRoV2lkZ2V0KGxpbmVUZXh0LCBzY2hlbWEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzbGljZSA9IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHBhcmFzKSwgMSwgMSk7XG4gICAgICAgIHZhciBuZXdUciA9IGlzTnVtYmVyXzEoc3RhcnQpICYmIGlzTnVtYmVyXzEoZW5kKVxuICAgICAgICAgICAgPyB0ci5yZXBsYWNlUmFuZ2Uoc3RhcnQsIGVuZCwgc2xpY2UpXG4gICAgICAgICAgICA6IHRyLnJlcGxhY2VTZWxlY3Rpb24oc2xpY2UpO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2gobmV3VHIpO1xuICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5kZWxldGVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgdHIgPSB0aGlzLnZpZXcuc3RhdGUudHI7XG4gICAgICAgIHZhciBuZXdUciA9IGlzTnVtYmVyXzEoc3RhcnQpICYmIGlzTnVtYmVyXzEoZW5kKSA/IHRyLmRlbGV0ZVJhbmdlKHN0YXJ0LCBlbmQpIDogdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaChuZXdUci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmdldFNlbGVjdGVkVGV4dCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgZG9jID0gX2EuZG9jLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb247XG4gICAgICAgIHZhciBmcm9tID0gc2VsZWN0aW9uLmZyb20sIHRvID0gc2VsZWN0aW9uLnRvO1xuICAgICAgICBpZiAoaXNOdW1iZXJfMShzdGFydCkgJiYgaXNOdW1iZXJfMShlbmQpKSB7XG4gICAgICAgICAgICBmcm9tID0gc3RhcnQ7XG4gICAgICAgICAgICB0byA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jLnRleHRCZXR3ZWVuKGZyb20sIHRvLCAnXFxuJyk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5zZXRNb2RlbCA9IGZ1bmN0aW9uIChuZXdEb2MsIGN1cnNvclRvRW5kKSB7XG4gICAgICAgIGlmIChjdXJzb3JUb0VuZCA9PT0gdm9pZCAwKSB7IGN1cnNvclRvRW5kID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCB0ciA9IF9hLnRyLCBkb2MgPSBfYS5kb2M7XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0ci5yZXBsYWNlV2l0aCgwLCBkb2MuY29udGVudC5zaXplLCBuZXdEb2MpKTtcbiAgICAgICAgaWYgKGN1cnNvclRvRW5kKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUb0VuZCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IHN0YXJ0OyB9XG4gICAgICAgIHZhciB0ciA9IHRoaXMudmlldy5zdGF0ZS50cjtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5hZGRXaWRnZXQgPSBmdW5jdGlvbiAobm9kZSwgc3R5bGUsIHBvcykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcsIGRpc3BhdGNoID0gX2EuZGlzcGF0Y2gsIHN0YXRlID0gX2Euc3RhdGU7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldE1ldGEoJ3dpZGdldCcsIHsgcG9zOiBwb3MgIT09IG51bGwgJiYgcG9zICE9PSB2b2lkIDAgPyBwb3MgOiBzdGF0ZS5zZWxlY3Rpb24udG8sIG5vZGU6IG5vZGUsIHN0eWxlOiBzdHlsZSB9KSk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5yZXBsYWNlV2l0aFdpZGdldCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB0ZXh0KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgdHIgPSBfYS50ciwgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICB2YXIgbm9kZXMgPSBjcmVhdGVOb2Rlc1dpdGhXaWRnZXQodGV4dCwgc2NoZW1hKTtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyLnJlcGxhY2VXaXRoKHN0YXJ0LCBlbmQsIG5vZGVzKSk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5nZXRSYW5nZUluZm9PZk5vZGUgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgZG9jID0gX2EuZG9jLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb247XG4gICAgICAgIHZhciAkcG9zID0gcG9zID8gZG9jLnJlc29sdmUocG9zKSA6IHNlbGVjdGlvbi4kZnJvbTtcbiAgICAgICAgdmFyIG1hcmtzID0gJHBvcy5tYXJrcygpO1xuICAgICAgICB2YXIgbm9kZSA9ICRwb3Mubm9kZSgpO1xuICAgICAgICB2YXIgc3RhcnQgPSAkcG9zLnN0YXJ0KCk7XG4gICAgICAgIHZhciBlbmQgPSAkcG9zLmVuZCgpO1xuICAgICAgICB2YXIgdHlwZSA9IG5vZGUudHlwZS5uYW1lO1xuICAgICAgICBpZiAobWFya3MubGVuZ3RoIHx8IHR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICB2YXIgbWFya18xID0gbWFya3NbbWFya3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgbWF5YmVIYXNNYXJrXzEgPSBmdW5jdGlvbiAobm9kZU1hcmtzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVNYXJrcy5sZW5ndGggPyBpbmNsdWRlcyhub2RlTWFya3MsIG1hcmtfMSkgOiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHR5cGUgPSBtYXJrXzEgPyBtYXJrXzEudHlwZS5uYW1lIDogJ3RleHQnO1xuICAgICAgICAgICAgbm9kZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzVGV4dCA9IGNoaWxkLmlzVGV4dCwgbm9kZVNpemUgPSBjaGlsZC5ub2RlU2l6ZSwgbm9kZU1hcmtzID0gY2hpbGQubWFya3M7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gJHBvcy5wb3MgLSBzdGFydDtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA8PSBzdGFydE9mZnNldCAmJlxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKyBub2RlU2l6ZSA+PSBzdGFydE9mZnNldCAmJlxuICAgICAgICAgICAgICAgICAgICBtYXliZUhhc01hcmtfMShub2RlTWFya3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgbm9kZVNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IFtzdGFydCwgZW5kXSwgdHlwZTogdHlwZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIFd5c2l3eWdFZGl0b3I7XG59KEVkaXRvckJhc2UpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGV4aXN0aW5nIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBpc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkXzE7XG52YXIgaXNOdWxsID0gaXNOdWxsXzE7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgZXhpc3Rpbmcgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIG5vdCBudWxsIGFuZCBub3QgdW5kZWZpbmVkLCByZXR1cm5zIHRydWUuXG4gKiBAcGFyYW0geyp9IHBhcmFtIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIGV4aXN0eT9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICogQGV4YW1wbGVcbiAqIC8vIEVTNlxuICogaW1wb3J0IGlzRXhpc3R5IGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvdHlwZS9pc0V4aXN0eScpO1xuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgaXNFeGlzdHkgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L3R5cGUvaXNFeGlzdHknKTtcbiAqXG4gKiBpc0V4aXN0eSgnJyk7IC8vdHJ1ZVxuICogaXNFeGlzdHkoMCk7IC8vdHJ1ZVxuICogaXNFeGlzdHkoW10pOyAvL3RydWVcbiAqIGlzRXhpc3R5KHt9KTsgLy90cnVlXG4gKiBpc0V4aXN0eShudWxsKTsgLy9mYWxzZVxuICogaXNFeGlzdHkodW5kZWZpbmVkKTsgLy9mYWxzZVxuKi9cbmZ1bmN0aW9uIGlzRXhpc3R5JDEocGFyYW0pIHtcbiAgcmV0dXJuICFpc1VuZGVmaW5lZChwYXJhbSkgJiYgIWlzTnVsbChwYXJhbSk7XG59XG5cbnZhciBpc0V4aXN0eV8xID0gaXNFeGlzdHkkMTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIHRydXRoeSBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaXNFeGlzdHkgPSBpc0V4aXN0eV8xO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIHRydXRoeSBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgbm90IG51bGwgb3Igbm90IHVuZGVmaW5lZCBvciBub3QgZmFsc2UsIHJldHVybnMgdHJ1ZS5cbiAqIChJdCByZWdhcmRzIDAgYXMgdHJ1ZSlcbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIHRydXRoeT9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc1RydXRoeSQxKG9iaikge1xuICByZXR1cm4gaXNFeGlzdHkob2JqKSAmJiBvYmogIT09IGZhbHNlO1xufVxuXG52YXIgaXNUcnV0aHlfMSA9IGlzVHJ1dGh5JDE7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBmYWxzeSBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaXNUcnV0aHkgPSBpc1RydXRoeV8xO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGZhbHN5IG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBmYWxzZSwgcmV0dXJucyB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgZmFsc3k/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNGYWxzeShvYmopIHtcbiAgcmV0dXJuICFpc1RydXRoeShvYmopO1xufVxuXG52YXIgaXNGYWxzeV8xID0gaXNGYWxzeTtcblxudmFyIGV2ZW50VHlwZUxpc3QgPSBbXG4gICAgJ2FmdGVyUHJldmlld1JlbmRlcicsXG4gICAgJ3VwZGF0ZVByZXZpZXcnLFxuICAgICdjaGFuZ2VNb2RlJyxcbiAgICAnbmVlZENoYW5nZU1vZGUnLFxuICAgICdjb21tYW5kJyxcbiAgICAnY2hhbmdlUHJldmlld1N0eWxlJyxcbiAgICAnY2hhbmdlUHJldmlld1RhYlByZXZpZXcnLFxuICAgICdjaGFuZ2VQcmV2aWV3VGFiV3JpdGUnLFxuICAgICdzY3JvbGwnLFxuICAgICdjb250ZXh0bWVudScsXG4gICAgJ3Nob3cnLFxuICAgICdoaWRlJyxcbiAgICAnY2hhbmdlTGFuZ3VhZ2UnLFxuICAgICdjaGFuZ2VUb29sYmFyU3RhdGUnLFxuICAgICd0b2dnbGVTY3JvbGxTeW5jJyxcbiAgICAnbWl4aW5UYWJsZU9mZnNldE1hcFByb3RvdHlwZScsXG4gICAgJ3NldEZvY3VzZWROb2RlJyxcbiAgICAncmVtb3ZlUG9wdXBXaWRnZXQnLFxuICAgICdxdWVyeScsXG4gICAgLy8gcHJvdmlkZSBldmVudCBmb3IgdXNlclxuICAgICdvcGVuUG9wdXAnLFxuICAgICdjbG9zZVBvcHVwJyxcbiAgICAnYWRkSW1hZ2VCbG9iSG9vaycsXG4gICAgJ2JlZm9yZVByZXZpZXdSZW5kZXInLFxuICAgICdiZWZvcmVDb252ZXJ0V3lzaXd5Z1RvTWFya2Rvd24nLFxuICAgICdsb2FkJyxcbiAgICAnbG9hZFVJJyxcbiAgICAnY2hhbmdlJyxcbiAgICAnY2FyZXRDaGFuZ2UnLFxuICAgICdkZXN0cm95JyxcbiAgICAnZm9jdXMnLFxuICAgICdibHVyJyxcbiAgICAna2V5ZG93bicsXG4gICAgJ2tleXVwJyxcbl07XG4vKipcbiAqIENsYXNzIEV2ZW50RW1pdHRlclxuICogQGlnbm9yZVxuICovXG52YXIgRXZlbnRFbWl0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgTWFwJDEoKTtcbiAgICAgICAgdGhpcy5ldmVudFR5cGVzID0gZXZlbnRUeXBlTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKHR5cGVzLCB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCB0eXBlcyksIHsgdHlwZTogdHlwZSB9KTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLmhvbGQgPSBmYWxzZTtcbiAgICAgICAgZXZlbnRUeXBlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgICAgICAgIF90aGlzLmFkZEV2ZW50VHlwZShldmVudFR5cGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdGVuIGV2ZW50IGFuZCBiaW5kIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIHR5cGVJbmZvID0gdGhpcy5nZXRUeXBlSW5mbyh0eXBlKTtcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB0aGlzLmV2ZW50cy5nZXQodHlwZUluZm8udHlwZSkgfHwgW107XG4gICAgICAgIGlmICghdGhpcy5oYXNFdmVudFR5cGUodHlwZUluZm8udHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIGV2ZW50IHR5cGUgXCIgKyB0eXBlSW5mby50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZUluZm8ubmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBoYW5kbGVyLm5hbWVzcGFjZSA9IHR5cGVJbmZvLm5hbWVzcGFjZTtcbiAgICAgICAgfVxuICAgICAgICBldmVudEhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZlbnRzLnNldCh0eXBlSW5mby50eXBlLCBldmVudEhhbmRsZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVtaXQgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWUgdG8gZW1pdFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZUluZm8gPSB0aGlzLmdldFR5cGVJbmZvKHR5cGUpO1xuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuZXZlbnRzLmdldCh0eXBlSW5mby50eXBlKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLmhvbGQgJiYgZXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgZXZlbnRIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGhhbmRsZXIuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkXzEocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVtaXQgZ2l2ZW4gZXZlbnQgYW5kIHJldHVybiByZXN1bHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWUgdG8gZW1pdFxuICAgICAqIEBwYXJhbSB7YW55fSBzb3VyY2UgU291cmNlIHRvIGNoYW5nZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0UmVkdWNlID0gZnVuY3Rpb24gKHR5cGUsIHNvdXJjZSkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuZXZlbnRzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCF0aGlzLmhvbGQgJiYgZXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgZXZlbnRIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGhhbmRsZXIuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5JDEoW3NvdXJjZV0sIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmFsc3lfMShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGV2ZW50IHR5cGUgYW5kIG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUgbmFtZVxuICAgICAqIEByZXR1cm5zIHt7dHlwZTogc3RyaW5nLCBuYW1lc3BhY2U6IHN0cmluZ319XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldFR5cGVJbmZvID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHNwbGl0ZWQgPSB0eXBlLnNwbGl0KCcuJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBzcGxpdGVkWzBdLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiBzcGxpdGVkWzFdLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciBldmVudCB0eXBlIGV4aXN0cyBvciBub3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuaGFzRXZlbnRUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuICFpc1VuZGVmaW5lZF8xKHRoaXMuZXZlbnRUeXBlc1t0aGlzLmdldFR5cGVJbmZvKHR5cGUpLnR5cGVdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBldmVudCB0eXBlIHdoZW4gZ2l2ZW4gZXZlbnQgbm90IGV4aXN0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUgbmFtZVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzRXZlbnRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBhbHJlYWR5IGhhdmUgZXZlbnQgdHlwZSBcIiArIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRUeXBlc1t0eXBlXSA9IHR5cGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXZlbnQgaGFuZGxlciBmcm9tIGdpdmVuIGV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUgbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtoYW5kbGVyXSAtIHJlZ2lzdGVyZWQgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldFR5cGVJbmZvKGV2ZW50VHlwZSksIHR5cGUgPSBfYS50eXBlLCBuYW1lc3BhY2UgPSBfYS5uYW1lc3BhY2U7XG4gICAgICAgIGlmICh0eXBlICYmIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRIYW5kbGVyV2l0aEhhbmRsZXIodHlwZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSAmJiAhbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5kZWxldGUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXR5cGUgJiYgbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfLCBldnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlRXZlbnRIYW5kbGVyV2l0aFR5cGVJbmZvKGV2dFR5cGUsIG5hbWVzcGFjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlICYmIG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudEhhbmRsZXJXaXRoVHlwZUluZm8odHlwZSwgbmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50IGhhbmRsZXIgd2l0aCBldmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBldmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gZXZlbnQgaGFuZGxlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudEhhbmRsZXJXaXRoSGFuZGxlciA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBldmVudEhhbmRsZXJzID0gdGhpcy5ldmVudHMuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoZXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXJJbmRleCA9IGV2ZW50SGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcikgPj0gMCkge1xuICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlcnMuc3BsaWNlKGhhbmRsZXJJbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBldmVudCBoYW5kbGVyIHdpdGggZXZlbnQgdHlwZSBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lc3BhY2UgRXZlbnQgbmFtZXNwYWNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50SGFuZGxlcldpdGhUeXBlSW5mbyA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzVG9TdXJ2aXZlID0gW107XG4gICAgICAgIHZhciBldmVudEhhbmRsZXJzID0gdGhpcy5ldmVudHMuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIWV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudEhhbmRsZXJzLm1hcChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIubmFtZXNwYWNlICE9PSBuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyc1RvU3Vydml2ZS5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50cy5zZXQodHlwZSwgaGFuZGxlcnNUb1N1cnZpdmUpO1xuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50cztcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuaG9sZEV2ZW50SW52b2tlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuaG9sZCA9IHRydWU7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHRoaXMuaG9sZCA9IGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0oKSk7XG5cbnZhciBDb21tYW5kTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21tYW5kTWFuYWdlcihldmVudEVtaXR0ZXIsIG1kQ29tbWFuZHMsIHd3Q29tbWFuZHMsIGdldEVkaXRvclR5cGUpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBldmVudEVtaXR0ZXI7XG4gICAgICAgIHRoaXMubWRDb21tYW5kcyA9IG1kQ29tbWFuZHM7XG4gICAgICAgIHRoaXMud3dDb21tYW5kcyA9IHd3Q29tbWFuZHM7XG4gICAgICAgIHRoaXMuZ2V0RWRpdG9yVHlwZSA9IGdldEVkaXRvclR5cGU7XG4gICAgICAgIHRoaXMuaW5pdEV2ZW50KCk7XG4gICAgfVxuICAgIENvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignY29tbWFuZCcsIGZ1bmN0aW9uIChjb21tYW5kLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICBfdGhpcy5leGVjKGNvbW1hbmQsIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZS5hZGRDb21tYW5kID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIGNvbW1hbmQpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdtYXJrZG93bicpIHtcbiAgICAgICAgICAgIHRoaXMubWRDb21tYW5kc1tuYW1lXSA9IGNvbW1hbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnd3Q29tbWFuZHNbbmFtZV0gPSBjb21tYW5kO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21tYW5kTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlQ29tbWFuZCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnbWFya2Rvd24nKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5tZENvbW1hbmRzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMud3dDb21tYW5kc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAobmFtZSwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuZ2V0RWRpdG9yVHlwZSgpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ21hcmtkb3duJykge1xuICAgICAgICAgICAgdGhpcy5tZENvbW1hbmRzW25hbWVdKHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53d0NvbW1hbmRzW25hbWVdKHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29tbWFuZE1hbmFnZXI7XG59KCkpO1xuXG5mdW5jdGlvbiBnZXRUZXh0V2l0aG91dFRyYWlsaW5nTmV3bGluZSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHRbdGV4dC5sZW5ndGggLSAxXSA9PT0gJ1xcbicgPyB0ZXh0LnNsaWNlKDAsIHRleHQubGVuZ3RoIC0gMSkgOiB0ZXh0O1xufVxuZnVuY3Rpb24gaXNDdXN0b21IVE1MSW5saW5lTm9kZShfYSwgbm9kZSkge1xuICAgIHZhciBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgdmFyIGh0bWwgPSBub2RlLmxpdGVyYWw7XG4gICAgdmFyIG1hdGNoZWQgPSBodG1sLm1hdGNoKHJlSFRNTFRhZyk7XG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgdmFyIG9wZW5UYWdOYW1lID0gbWF0Y2hlZFsxXSwgY2xvc2VUYWdOYW1lID0gbWF0Y2hlZFszXTtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gKG9wZW5UYWdOYW1lIHx8IGNsb3NlVGFnTmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2h0bWxJbmxpbmUnICYmICEhKHNjaGVtYS5tYXJrc1t0eXBlTmFtZV0gfHwgc2NoZW1hLm5vZGVzW3R5cGVOYW1lXSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSW5saW5lTm9kZShfYSkge1xuICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICByZXR1cm4gaW5jbHVkZXMoWyd0ZXh0JywgJ3N0cm9uZycsICdlbXBoJywgJ3N0cmlrZScsICdpbWFnZScsICdsaW5rJywgJ2NvZGUnXSwgdHlwZSk7XG59XG5mdW5jdGlvbiBpc1NvZnRicmVhayhtZE5vZGUpIHtcbiAgICByZXR1cm4gKG1kTm9kZSA9PT0gbnVsbCB8fCBtZE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1kTm9kZS50eXBlKSA9PT0gJ3NvZnRicmVhayc7XG59XG5mdW5jdGlvbiBpc0xpc3ROb2RlKF9hKSB7XG4gICAgdmFyIHR5cGUgPSBfYS50eXBlLCBsaXRlcmFsID0gX2EubGl0ZXJhbDtcbiAgICB2YXIgbWF0Y2hlZCA9IHR5cGUgPT09ICdodG1sSW5saW5lJyAmJiBsaXRlcmFsLm1hdGNoKHJlSFRNTFRhZyk7XG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgdmFyIG9wZW5UYWdOYW1lID0gbWF0Y2hlZFsxXSwgY2xvc2VUYWdOYW1lID0gbWF0Y2hlZFszXTtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBvcGVuVGFnTmFtZSB8fCBjbG9zZVRhZ05hbWU7XG4gICAgICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5jbHVkZXMoWyd1bCcsICdvbCcsICdsaSddLCB0YWdOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldExpc3RJdGVtQXR0cnMoX2EpIHtcbiAgICB2YXIgbGl0ZXJhbCA9IF9hLmxpdGVyYWw7XG4gICAgdmFyIHRhc2sgPSAvZGF0YS10YXNrLy50ZXN0KGxpdGVyYWwpO1xuICAgIHZhciBjaGVja2VkID0gL2RhdGEtdGFzay1jaGVja2VkLy50ZXN0KGxpdGVyYWwpO1xuICAgIHJldHVybiB7IHRhc2s6IHRhc2ssIGNoZWNrZWQ6IGNoZWNrZWQgfTtcbn1cbmZ1bmN0aW9uIGdldE1hdGNoZWRBdHRyaWJ1dGVWYWx1ZShyYXdIVE1MKSB7XG4gICAgdmFyIGF0dHJOYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGF0dHJOYW1lc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB3cmFwcGVyLmlubmVySFRNTCA9IHNhbml0aXplSFRNTChyYXdIVE1MKTtcbiAgICB2YXIgZWwgPSB3cmFwcGVyLmZpcnN0Q2hpbGQ7XG4gICAgcmV0dXJuIGF0dHJOYW1lcy5tYXAoZnVuY3Rpb24gKGF0dHJOYW1lKSB7IHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpIHx8ICcnOyB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnZlcnRvcnMoY29udmVydG9ycykge1xuICAgIHZhciBjb252ZXJ0b3JNYXAgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjb252ZXJ0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRhZ05hbWVzID0ga2V5LnNwbGl0KCcsICcpO1xuICAgICAgICB0YWdOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnZlcnRvck1hcFtuYW1lXSA9IGNvbnZlcnRvcnNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnZlcnRvck1hcDtcbn1cbnZhciBjb252ZXJ0b3JzID0ge1xuICAgICdiLCBzdHJvbmcnOiBmdW5jdGlvbiAoc3RhdGUsIF8sIG9wZW5UYWdOYW1lKSB7XG4gICAgICAgIHZhciBzdHJvbmcgPSBzdGF0ZS5zY2hlbWEubWFya3Muc3Ryb25nO1xuICAgICAgICBpZiAob3BlblRhZ05hbWUpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5NYXJrKHN0cm9uZy5jcmVhdGUoeyByYXdIVE1MOiBvcGVuVGFnTmFtZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU1hcmsoc3Ryb25nKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgJ2ksIGVtJzogZnVuY3Rpb24gKHN0YXRlLCBfLCBvcGVuVGFnTmFtZSkge1xuICAgICAgICB2YXIgZW1waCA9IHN0YXRlLnNjaGVtYS5tYXJrcy5lbXBoO1xuICAgICAgICBpZiAob3BlblRhZ05hbWUpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5NYXJrKGVtcGguY3JlYXRlKHsgcmF3SFRNTDogb3BlblRhZ05hbWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VNYXJrKGVtcGgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAncywgZGVsJzogZnVuY3Rpb24gKHN0YXRlLCBfLCBvcGVuVGFnTmFtZSkge1xuICAgICAgICB2YXIgc3RyaWtlID0gc3RhdGUuc2NoZW1hLm1hcmtzLnN0cmlrZTtcbiAgICAgICAgaWYgKG9wZW5UYWdOYW1lKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhzdHJpa2UuY3JlYXRlKHsgcmF3SFRNTDogb3BlblRhZ05hbWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VNYXJrKHN0cmlrZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvZGU6IGZ1bmN0aW9uIChzdGF0ZSwgXywgb3BlblRhZ05hbWUpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdGF0ZS5zY2hlbWEubWFya3MuY29kZTtcbiAgICAgICAgaWYgKG9wZW5UYWdOYW1lKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhjb2RlLmNyZWF0ZSh7IHJhd0hUTUw6IG9wZW5UYWdOYW1lIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTWFyayhjb2RlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYTogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBvcGVuVGFnTmFtZSkge1xuICAgICAgICB2YXIgdGFnID0gbm9kZS5saXRlcmFsO1xuICAgICAgICB2YXIgbGluayA9IHN0YXRlLnNjaGVtYS5tYXJrcy5saW5rO1xuICAgICAgICBpZiAob3BlblRhZ05hbWUpIHtcbiAgICAgICAgICAgIHZhciBsaW5rVXJsID0gZ2V0TWF0Y2hlZEF0dHJpYnV0ZVZhbHVlKHRhZywgJ2hyZWYnKVswXTtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5NYXJrKGxpbmsuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBsaW5rVXJsOiBsaW5rVXJsLFxuICAgICAgICAgICAgICAgIHJhd0hUTUw6IG9wZW5UYWdOYW1lLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VNYXJrKGxpbmspO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBpbWc6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgb3BlblRhZ05hbWUpIHtcbiAgICAgICAgdmFyIHRhZyA9IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgaWYgKG9wZW5UYWdOYW1lKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRNYXRjaGVkQXR0cmlidXRlVmFsdWUodGFnLCAnc3JjJywgJ2FsdCcpLCBpbWFnZVVybCA9IF9hWzBdLCBhbHRUZXh0ID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSBzdGF0ZS5zY2hlbWEubm9kZXMuaW1hZ2U7XG4gICAgICAgICAgICBzdGF0ZS5hZGROb2RlKGltYWdlLCBfX2Fzc2lnbiQxKHsgcmF3SFRNTDogb3BlblRhZ05hbWUsIGltYWdlVXJsOiBpbWFnZVVybCB9LCAoYWx0VGV4dCAmJiB7IGFsdFRleHQ6IGFsdFRleHQgfSkpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaHI6IGZ1bmN0aW9uIChzdGF0ZSwgXywgb3BlblRhZ05hbWUpIHtcbiAgICAgICAgc3RhdGUuYWRkTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMudGhlbWF0aWNCcmVhaywgeyByYXdIVE1MOiBvcGVuVGFnTmFtZSB9KTtcbiAgICB9LFxuICAgIGJyOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUpIHtcbiAgICAgICAgdmFyIHBhcmFncmFwaCA9IHN0YXRlLnNjaGVtYS5ub2Rlcy5wYXJhZ3JhcGg7XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudCwgcHJldiA9IG5vZGUucHJldiwgbmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgaWYgKChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQudHlwZSkgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgb3BlbiBhIHBhcmFncmFwaCBub2RlIHdoZW4gbGluZSB0ZXh0IGhhcyBvbmx5IDxicj4gdGFnXG4gICAgICAgICAgICAvLyBleCkgZmlyc3QgbGluZVxcblxcbjxicj5cXG5mb3VydGggbGluZVxuICAgICAgICAgICAgaWYgKGlzU29mdGJyZWFrKHByZXYpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUocGFyYWdyYXBoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNob3VsZCBjbG9zZSBhIHBhcmFncmFwaCBub2RlIHdoZW4gbGluZSB0ZXh0IGhhcyBvbmx5IDxicj4gdGFnXG4gICAgICAgICAgICAvLyBleCkgZmlyc3QgbGluZVxcblxcbjxicj5cXG5mb3VydGggbGluZVxuICAgICAgICAgICAgaWYgKGlzU29mdGJyZWFrKG5leHQpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGNsb3NlIGEgcGFyYWdyYXBoIG5vZGUgYW5kIG9wZW4gYSBwYXJhZ3JhcGggbm9kZSB0byBzZXBhcmF0ZSBiZXR3ZWVuIGJsb2Nrc1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gPGJyPiB0YWcgaXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgcGFyYWdyYXBoXG4gICAgICAgICAgICAgICAgLy8gZXgpIGZpcnN0IDxicj5saW5lXFxudGhpcmQgbGluZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHBhcmFncmFwaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC50eXBlKSA9PT0gJ3RhYmxlQ2VsbCcpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIChpc0lubGluZU5vZGUocHJldikgfHwgaXNDdXN0b21IVE1MSW5saW5lTm9kZShzdGF0ZSwgcHJldikpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCAmJiAoaXNJbmxpbmVOb2RlKG5leHQpIHx8IGlzQ3VzdG9tSFRNTElubGluZU5vZGUoc3RhdGUsIG5leHQpKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHBhcmFncmFwaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHByZTogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBvcGVuVGFnTmFtZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBub2RlLmxpdGVyYWw7XG4gICAgICAgIHZhciBsaXRlcmFsID0gKF9iID0gKF9hID0gY29udGFpbmVyLmZpcnN0Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maXJzdENoaWxkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudGV4dENvbnRlbnQ7XG4gICAgICAgIHN0YXRlLm9wZW5Ob2RlKHN0YXRlLnNjaGVtYS5ub2Rlcy5jb2RlQmxvY2ssIHsgcmF3SFRNTDogb3BlblRhZ05hbWUgfSk7XG4gICAgICAgIHN0YXRlLmFkZFRleHQoZ2V0VGV4dFdpdGhvdXRUcmFpbGluZ05ld2xpbmUobGl0ZXJhbCkpO1xuICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICB9LFxuICAgICd1bCwgb2wnOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIG9wZW5UYWdOYW1lKSB7XG4gICAgICAgIC8vIGluIHRoZSB0YWJsZSBjZWxsLCAnPHVsPicsICc8b2w+JyBpcyBwYXJzZWQgYXMgJ2h0bWxJbmxpbmUnIG5vZGVcbiAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09ICd0YWJsZUNlbGwnKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBzdGF0ZS5zY2hlbWEubm9kZXMsIGJ1bGxldExpc3QgPSBfYS5idWxsZXRMaXN0LCBvcmRlcmVkTGlzdCA9IF9hLm9yZGVyZWRMaXN0LCBwYXJhZ3JhcGggPSBfYS5wYXJhZ3JhcGg7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IG9wZW5UYWdOYW1lID09PSAndWwnID8gYnVsbGV0TGlzdCA6IG9yZGVyZWRMaXN0O1xuICAgICAgICAgICAgaWYgKG9wZW5UYWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucHJldiAmJiAhaXNMaXN0Tm9kZShub2RlLnByZXYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShsaXN0LCB7IHJhd0hUTUw6IG9wZW5UYWdOYW1lIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmV4dCAmJiAhaXNMaXN0Tm9kZShub2RlLm5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHBhcmFncmFwaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBsaTogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBvcGVuVGFnTmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIGluIHRoZSB0YWJsZSBjZWxsLCAnPGxpPicgaXMgcGFyc2VkIGFzICdodG1sSW5saW5lJyBub2RlXG4gICAgICAgIGlmICgoKF9hID0gbm9kZS5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gJ3RhYmxlQ2VsbCcpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IHN0YXRlLnNjaGVtYS5ub2RlcywgbGlzdEl0ZW0gPSBfYi5saXN0SXRlbSwgcGFyYWdyYXBoID0gX2IucGFyYWdyYXBoO1xuICAgICAgICAgICAgaWYgKG9wZW5UYWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gZ2V0TGlzdEl0ZW1BdHRycyhub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wcmV2ICYmICFpc0xpc3ROb2RlKG5vZGUucHJldikpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKGxpc3RJdGVtLCBfX2Fzc2lnbiQxKHsgcmF3SFRNTDogb3BlblRhZ05hbWUgfSwgYXR0cnMpKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5uZXh0ICYmICFpc0xpc3ROb2RlKG5vZGUubmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUocGFyYWdyYXBoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wcmV2ICYmICFpc0xpc3ROb2RlKG5vZGUucHJldikpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG52YXIgaHRtbFRvV3dDb252ZXJ0b3JzID0gY3JlYXRlQ29udmVydG9ycyhjb252ZXJ0b3JzKTtcblxuZnVuY3Rpb24gaXNCUlRhZyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2h0bWxJbmxpbmUnICYmIHJlQlIudGVzdChub2RlLmxpdGVyYWwpO1xufVxuZnVuY3Rpb24gYWRkUmF3SFRNTEF0dHJpYnV0ZVRvRE9NKHBhcmVudCkge1xuICAgIHRvQXJyYXlfMShwYXJlbnQuY2hpbGROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGlzRWxlbU5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICB2YXIgb3BlblRhZ05hbWUgPSBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJywgb3BlblRhZ05hbWUpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICBhZGRSYXdIVE1MQXR0cmlidXRlVG9ET00oY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG52YXIgdG9Xd0NvbnZlcnRvcnMgPSB7XG4gICAgdGV4dDogZnVuY3Rpb24gKHN0YXRlLCBub2RlKSB7XG4gICAgICAgIHN0YXRlLmFkZFRleHQobm9kZS5saXRlcmFsIHx8ICcnKTtcbiAgICB9LFxuICAgIHBhcmFncmFwaDogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgcGFyYWdyYXBoID0gc3RhdGUuc2NoZW1hLm5vZGVzLnBhcmFncmFwaDtcbiAgICAgICAgICAgIC8vIFRoZSBgXFxuXFxuYCBlbnRlcmVkIGluIG1hcmtkb3duIHNlcGFyYXRlcyB0aGUgcGFyYWdyYXBoLlxuICAgICAgICAgICAgLy8gV2hlbiBjaGFuZ2luZyB0byB3eXNpd3lnLCBhIG5ld2xpbmUgaXMgYWRkZWQgYmV0d2VlbiB0aGUgdHdvIHBhcmFncmFwaHMuXG4gICAgICAgICAgICBpZiAoKChfYiA9IG5vZGUucHJldikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnR5cGUpID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHBhcmFncmFwaCwgY3VzdG9tQXR0cnMpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUocGFyYWdyYXBoLCBjdXN0b21BdHRycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaGVhZGluZzogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgdmFyIF9iID0gbm9kZSwgbGV2ZWwgPSBfYi5sZXZlbCwgaGVhZGluZ1R5cGUgPSBfYi5oZWFkaW5nVHlwZTtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHN0YXRlLnNjaGVtYS5ub2Rlcy5oZWFkaW5nLCBfX2Fzc2lnbiQxKHsgbGV2ZWw6IGxldmVsLCBoZWFkaW5nVHlwZTogaGVhZGluZ1R5cGUgfSwgY3VzdG9tQXR0cnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjb2RlQmxvY2s6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGNvZGVCbG9jayA9IHN0YXRlLnNjaGVtYS5ub2Rlcy5jb2RlQmxvY2s7XG4gICAgICAgIHZhciBfYSA9IG5vZGUsIGluZm8gPSBfYS5pbmZvLCBsaXRlcmFsID0gX2EubGl0ZXJhbDtcbiAgICAgICAgc3RhdGUub3Blbk5vZGUoY29kZUJsb2NrLCBfX2Fzc2lnbiQxKHsgbGFuZ3VhZ2U6IGluZm8gfSwgY3VzdG9tQXR0cnMpKTtcbiAgICAgICAgc3RhdGUuYWRkVGV4dChnZXRUZXh0V2l0aG91dFRyYWlsaW5nTmV3bGluZShsaXRlcmFsIHx8ICcnKSk7XG4gICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgIH0sXG4gICAgbGlzdDogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgdmFyIF9iID0gc3RhdGUuc2NoZW1hLm5vZGVzLCBidWxsZXRMaXN0ID0gX2IuYnVsbGV0TGlzdCwgb3JkZXJlZExpc3QgPSBfYi5vcmRlcmVkTGlzdDtcbiAgICAgICAgICAgIHZhciBfYyA9IG5vZGUubGlzdERhdGEsIHR5cGUgPSBfYy50eXBlLCBzdGFydCA9IF9jLnN0YXJ0O1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdidWxsZXQnKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUoYnVsbGV0TGlzdCwgY3VzdG9tQXR0cnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUob3JkZXJlZExpc3QsIF9fYXNzaWduJDEoeyBvcmRlcjogc3RhcnQgfSwgY3VzdG9tQXR0cnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBpdGVtOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgdmFyIGxpc3RJdGVtID0gc3RhdGUuc2NoZW1hLm5vZGVzLmxpc3RJdGVtO1xuICAgICAgICB2YXIgX2IgPSBub2RlLmxpc3REYXRhLCB0YXNrID0gX2IudGFzaywgY2hlY2tlZCA9IF9iLmNoZWNrZWQ7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gX19hc3NpZ24kMShfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sICh0YXNrICYmIHsgdGFzazogdGFzayB9KSksIChjaGVja2VkICYmIHsgY2hlY2tlZDogY2hlY2tlZCB9KSksIGN1c3RvbUF0dHJzKTtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKGxpc3RJdGVtLCBhdHRycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYmxvY2tRdW90ZTogZnVuY3Rpb24gKHN0YXRlLCBfLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLmJsb2NrUXVvdGUsIGN1c3RvbUF0dHJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBpbWFnZTogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmcsIHNraXBDaGlsZHJlbiA9IF9hLnNraXBDaGlsZHJlbjtcbiAgICAgICAgdmFyIGltYWdlID0gc3RhdGUuc2NoZW1hLm5vZGVzLmltYWdlO1xuICAgICAgICB2YXIgX2IgPSBub2RlLCBkZXN0aW5hdGlvbiA9IF9iLmRlc3RpbmF0aW9uLCBmaXJzdENoaWxkID0gX2IuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGVudGVyaW5nICYmIHNraXBDaGlsZHJlbikge1xuICAgICAgICAgICAgc2tpcENoaWxkcmVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYWRkTm9kZShpbWFnZSwgX19hc3NpZ24kMShfX2Fzc2lnbiQxKHsgaW1hZ2VVcmw6IGRlc3RpbmF0aW9uIH0sIChmaXJzdENoaWxkICYmIHsgYWx0VGV4dDogZmlyc3RDaGlsZC5saXRlcmFsIH0pKSwgY3VzdG9tQXR0cnMpKTtcbiAgICB9LFxuICAgIHRoZW1hdGljQnJlYWs6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgXywgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgc3RhdGUuYWRkTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMudGhlbWF0aWNCcmVhaywgY3VzdG9tQXR0cnMpO1xuICAgIH0sXG4gICAgc3Ryb25nOiBmdW5jdGlvbiAoc3RhdGUsIF8sIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgdmFyIHN0cm9uZyA9IHN0YXRlLnNjaGVtYS5tYXJrcy5zdHJvbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgc3RhdGUub3Blbk1hcmsoc3Ryb25nLmNyZWF0ZShjdXN0b21BdHRycykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VNYXJrKHN0cm9uZyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGVtcGg6IGZ1bmN0aW9uIChzdGF0ZSwgXywgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICB2YXIgZW1waCA9IHN0YXRlLnNjaGVtYS5tYXJrcy5lbXBoO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5NYXJrKGVtcGguY3JlYXRlKGN1c3RvbUF0dHJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU1hcmsoZW1waCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICB2YXIgbGluayA9IHN0YXRlLnNjaGVtYS5tYXJrcy5saW5rO1xuICAgICAgICB2YXIgX2IgPSBub2RlLCBkZXN0aW5hdGlvbiA9IF9iLmRlc3RpbmF0aW9uLCB0aXRsZSA9IF9iLnRpdGxlO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IF9fYXNzaWduJDEoeyBsaW5rVXJsOiBkZXN0aW5hdGlvbiwgdGl0bGU6IHRpdGxlIH0sIGN1c3RvbUF0dHJzKTtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5NYXJrKGxpbmsuY3JlYXRlKGF0dHJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU1hcmsobGluayk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNvZnRicmVhazogZnVuY3Rpb24gKHN0YXRlLCBub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnBhcmVudC50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgdmFyIHByZXYgPSBub2RlLnByZXYsIG5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICBpZiAocHJldiAmJiAhaXNCUlRhZyhwcmV2KSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgJiYgIWlzQlJUYWcobmV4dCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMucGFyYWdyYXBoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gR0ZNIHNwZWNpZmljYXRpb25zIG5vZGVcbiAgICB0YWJsZTogZnVuY3Rpb24gKHN0YXRlLCBfLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLnRhYmxlLCBjdXN0b21BdHRycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdGFibGVIZWFkOiBmdW5jdGlvbiAoc3RhdGUsIF8sIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMudGFibGVIZWFkLCBjdXN0b21BdHRycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdGFibGVCb2R5OiBmdW5jdGlvbiAoc3RhdGUsIF8sIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMudGFibGVCb2R5LCBjdXN0b21BdHRycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdGFibGVSb3c6IGZ1bmN0aW9uIChzdGF0ZSwgXywgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHN0YXRlLnNjaGVtYS5ub2Rlcy50YWJsZVJvdywgY3VzdG9tQXR0cnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRhYmxlQ2VsbDogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKCFub2RlLmlnbm9yZWQpIHtcbiAgICAgICAgICAgIHZhciBoYXNQYXJhTm9kZSA9IGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlICYmIChpc0lubGluZU5vZGUoY2hpbGROb2RlKSB8fCBpc0N1c3RvbUhUTUxJbmxpbmVOb2RlKHN0YXRlLCBjaGlsZE5vZGUpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBzdGF0ZS5zY2hlbWEubm9kZXMsIHRhYmxlSGVhZENlbGwgPSBfYi50YWJsZUhlYWRDZWxsLCB0YWJsZUJvZHlDZWxsID0gX2IudGFibGVCb2R5Q2VsbCwgcGFyYWdyYXBoID0gX2IucGFyYWdyYXBoO1xuICAgICAgICAgICAgICAgIHZhciB0YWJsZVBhcnQgPSBub2RlLnBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB0YWJsZVBhcnQudHlwZSA9PT0gJ3RhYmxlSGVhZCcgPyB0YWJsZUhlYWRDZWxsIDogdGFibGVCb2R5Q2VsbDtcbiAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSB0YWJsZVBhcnQucGFyZW50O1xuICAgICAgICAgICAgICAgIHZhciBhbGlnbiA9ICh0YWJsZS5jb2x1bW5zW25vZGUuc3RhcnRJZHhdIHx8IHt9KS5hbGlnbjtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfX2Fzc2lnbiQxKHt9LCBub2RlLmF0dHJzKTtcbiAgICAgICAgICAgICAgICBpZiAoYWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuYWxpZ24gPSBhbGlnbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUoY2VsbCwgYXR0cnMpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNQYXJhTm9kZShub2RlLmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHBhcmFncmFwaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1BhcmFOb2RlKG5vZGUubGFzdENoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN0cmlrZTogZnVuY3Rpb24gKHN0YXRlLCBfLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHZhciBzdHJpa2UgPSBzdGF0ZS5zY2hlbWEubWFya3Muc3RyaWtlO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5NYXJrKHN0cmlrZS5jcmVhdGUoY3VzdG9tQXR0cnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTWFyayhzdHJpa2UpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjb2RlOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIF8sIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RhdGUuc2NoZW1hLm1hcmtzLmNvZGU7XG4gICAgICAgIHN0YXRlLm9wZW5NYXJrKGNvZGUuY3JlYXRlKGN1c3RvbUF0dHJzKSk7XG4gICAgICAgIHN0YXRlLmFkZFRleHQoZ2V0VGV4dFdpdGhvdXRUcmFpbGluZ05ld2xpbmUobm9kZS5saXRlcmFsIHx8ICcnKSk7XG4gICAgICAgIHN0YXRlLmNsb3NlTWFyayhjb2RlKTtcbiAgICB9LFxuICAgIGN1c3RvbUJsb2NrOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUpIHtcbiAgICAgICAgdmFyIF9hID0gc3RhdGUuc2NoZW1hLm5vZGVzLCBjdXN0b21CbG9jayA9IF9hLmN1c3RvbUJsb2NrLCBwYXJhZ3JhcGggPSBfYS5wYXJhZ3JhcGg7XG4gICAgICAgIHZhciBfYiA9IG5vZGUsIGluZm8gPSBfYi5pbmZvLCBsaXRlcmFsID0gX2IubGl0ZXJhbDtcbiAgICAgICAgc3RhdGUub3Blbk5vZGUoY3VzdG9tQmxvY2ssIHsgaW5mbzogaW5mbyB9KTtcbiAgICAgICAgc3RhdGUuYWRkVGV4dChnZXRUZXh0V2l0aG91dFRyYWlsaW5nTmV3bGluZShsaXRlcmFsIHx8ICcnKSk7XG4gICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAvLyBhZGQgZW1wdHkgbGluZSB0byBlZGl0IHRoZSBjb250ZW50IGluIG5leHQgbGluZVxuICAgICAgICBpZiAoIW5vZGUubmV4dCkge1xuICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUocGFyYWdyYXBoKTtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBmcm9udE1hdHRlcjogZnVuY3Rpb24gKHN0YXRlLCBub2RlKSB7XG4gICAgICAgIHN0YXRlLm9wZW5Ob2RlKHN0YXRlLnNjaGVtYS5ub2Rlcy5mcm9udE1hdHRlcik7XG4gICAgICAgIHN0YXRlLmFkZFRleHQobm9kZS5saXRlcmFsKTtcbiAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgfSxcbiAgICBodG1sSW5saW5lOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBub2RlLmxpdGVyYWw7XG4gICAgICAgIHZhciBtYXRjaGVkID0gaHRtbC5tYXRjaChyZUhUTUxUYWcpO1xuICAgICAgICB2YXIgb3BlblRhZ05hbWUgPSBtYXRjaGVkWzFdLCBjbG9zZVRhZ05hbWUgPSBtYXRjaGVkWzNdO1xuICAgICAgICB2YXIgdHlwZU5hbWUgPSAob3BlblRhZ05hbWUgfHwgY2xvc2VUYWdOYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgbWFya1R5cGUgPSBzdGF0ZS5zY2hlbWEubWFya3NbdHlwZU5hbWVdO1xuICAgICAgICB2YXIgc2FuaXRpemVkSFRNTCA9IHNhbml0aXplSFRNTChodG1sKTtcbiAgICAgICAgLy8gZm9yIHVzZXIgZGVmaW5lZCBodG1sIHNjaGVtYVxuICAgICAgICBpZiAobWFya1R5cGUgPT09IG51bGwgfHwgbWFya1R5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtUeXBlLnNwZWMuYXR0cnMuaHRtbElubGluZSkge1xuICAgICAgICAgICAgaWYgKG9wZW5UYWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWxBdHRycyA9IGdldEhUTUxBdHRyc0J5SFRNTFN0cmluZyhzYW5pdGl6ZWRIVE1MKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhtYXJrVHlwZS5jcmVhdGUoeyBodG1sQXR0cnM6IGh0bWxBdHRycyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU1hcmsobWFya1R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGh0bWxUb1d3Q29udmVydG9yID0gaHRtbFRvV3dDb252ZXJ0b3JzW3R5cGVOYW1lXTtcbiAgICAgICAgICAgIGlmIChodG1sVG9Xd0NvbnZlcnRvcikge1xuICAgICAgICAgICAgICAgIGh0bWxUb1d3Q29udmVydG9yKHN0YXRlLCBub2RlLCBvcGVuVGFnTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGh0bWxCbG9jazogZnVuY3Rpb24gKHN0YXRlLCBub2RlKSB7XG4gICAgICAgIHZhciBodG1sID0gbm9kZS5saXRlcmFsO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhciBpc0hUTUxDb21tZW50ID0gcmVIVE1MQ29tbWVudC50ZXN0KGh0bWwpO1xuICAgICAgICBpZiAoaXNIVE1MQ29tbWVudCkge1xuICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLmh0bWxDb21tZW50KTtcbiAgICAgICAgICAgIHN0YXRlLmFkZFRleHQobm9kZS5saXRlcmFsKTtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBodG1sLm1hdGNoKHJlSFRNTFRhZyk7XG4gICAgICAgICAgICB2YXIgb3BlblRhZ05hbWUgPSBtYXRjaGVkWzFdLCBjbG9zZVRhZ05hbWUgPSBtYXRjaGVkWzNdO1xuICAgICAgICAgICAgdmFyIHR5cGVOYW1lID0gKG9wZW5UYWdOYW1lIHx8IGNsb3NlVGFnTmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBub2RlVHlwZSA9IHN0YXRlLnNjaGVtYS5ub2Rlc1t0eXBlTmFtZV07XG4gICAgICAgICAgICB2YXIgc2FuaXRpemVkSFRNTCA9IHNhbml0aXplSFRNTChodG1sKTtcbiAgICAgICAgICAgIC8vIGZvciB1c2VyIGRlZmluZWQgaHRtbCBzY2hlbWFcbiAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gbnVsbCB8fCBub2RlVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZVR5cGUuc3BlYy5hdHRycy5odG1sQmxvY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaHRtbEF0dHJzID0gZ2V0SFRNTEF0dHJzQnlIVE1MU3RyaW5nKHNhbml0aXplZEhUTUwpO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbkhUTUwgPSBnZXRDaGlsZHJlbkhUTUwobm9kZSwgdHlwZU5hbWUpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFkZE5vZGUobm9kZVR5cGUsIHsgaHRtbEF0dHJzOiBodG1sQXR0cnMsIGNoaWxkcmVuSFRNTDogY2hpbGRyZW5IVE1MIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IHNhbml0aXplZEhUTUw7XG4gICAgICAgICAgICAgICAgYWRkUmF3SFRNTEF0dHJpYnV0ZVRvRE9NKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgc3RhdGUuY29udmVydEJ5RE9NUGFyc2VyKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGN1c3RvbUlubGluZTogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZywgc2tpcENoaWxkcmVuID0gX2Euc2tpcENoaWxkcmVuO1xuICAgICAgICB2YXIgX2IgPSBub2RlLCBpbmZvID0gX2IuaW5mbywgZmlyc3RDaGlsZCA9IF9iLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgICAgIGlmIChpbmZvLmluZGV4T2YoJ3dpZGdldCcpICE9PSAtMSAmJiBlbnRlcmluZykge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBnZXRXaWRnZXRDb250ZW50KG5vZGUpO1xuICAgICAgICAgICAgc2tpcENoaWxkcmVuKCk7XG4gICAgICAgICAgICBzdGF0ZS5hZGROb2RlKHNjaGVtYS5ub2Rlcy53aWRnZXQsIHsgaW5mbzogaW5mbyB9LCBbXG4gICAgICAgICAgICAgICAgc2NoZW1hLnRleHQoY3JlYXRlV2lkZ2V0Q29udGVudChpbmZvLCBjb250ZW50KSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gJyQkJztcbiAgICAgICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gZmlyc3RDaGlsZCA/IGluZm8gKyBcIiBcIiA6IGluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5hZGRUZXh0KHRleHQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVXd0NvbnZlcnRvcnMoY3VzdG9tQ29udmVydG9ycykge1xuICAgIHZhciBjdXN0b21Db252ZXJ0b3JUeXBlcyA9IE9iamVjdC5rZXlzKGN1c3RvbUNvbnZlcnRvcnMpO1xuICAgIHZhciBjb252ZXJ0b3JzID0gX19hc3NpZ24kMSh7fSwgdG9Xd0NvbnZlcnRvcnMpO1xuICAgIHZhciByZW5kZXJlciA9IG5ldyBSZW5kZXJlcih7XG4gICAgICAgIGdmbTogdHJ1ZSxcbiAgICAgICAgbm9kZUlkOiB0cnVlLFxuICAgICAgICBjb252ZXJ0b3JzOiBjdXN0b21Db252ZXJ0b3JzLFxuICAgIH0pO1xuICAgIHZhciBvcmdDb252ZXJ0b3JzID0gcmVuZGVyZXIuZ2V0Q29udmVydG9ycygpO1xuICAgIGN1c3RvbUNvbnZlcnRvclR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHd3Q29udmVydG9yID0gdG9Xd0NvbnZlcnRvcnNbdHlwZV07XG4gICAgICAgIGlmICh3d0NvbnZlcnRvciAmJiAhaW5jbHVkZXMoWydodG1sQmxvY2snLCAnaHRtbElubGluZSddLCB0eXBlKSkge1xuICAgICAgICAgICAgY29udmVydG9yc1t0eXBlXSA9IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQub3JpZ2luID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb3JnQ29udmVydG9yc1t0eXBlXShub2RlLCBjb250ZXh0LCBvcmdDb252ZXJ0b3JzKTsgfTtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gY3VzdG9tQ29udmVydG9yc1t0eXBlXShub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cnM7XG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBBcnJheS5pc0FycmF5KHRva2VucykgPyB0b2tlbnNbMF0gOiB0b2tlbnMsIGh0bWxBdHRycyA9IF9hLmF0dHJpYnV0ZXMsIGNsYXNzTmFtZXMgPSBfYS5jbGFzc05hbWVzO1xuICAgICAgICAgICAgICAgICAgICBhdHRycyA9IHsgaHRtbEF0dHJzOiBodG1sQXR0cnMsIGNsYXNzTmFtZXM6IGNsYXNzTmFtZXMgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3dDb252ZXJ0b3Ioc3RhdGUsIG5vZGUsIGNvbnRleHQsIGF0dHJzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29udmVydG9ycztcbn1cblxuZnVuY3Rpb24gbWVyZ2VNYXJrVGV4dChhLCBiKSB7XG4gICAgaWYgKGEuaXNUZXh0ICYmIGIuaXNUZXh0ICYmIE1hcmskMS5zYW1lU2V0KGEubWFya3MsIGIubWFya3MpKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgLy8gdHlwZSBpcyBub3QgZGVmaW5lZCBmb3IgXCJ3aXRoVGV4dFwiIGluIHByb3NlbWlycm9yLW1vZGVsXG4gICAgICAgIHJldHVybiBhLndpdGhUZXh0KGEudGV4dCArIGIudGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbnZhciBUb1d3Q29udmVydG9yU3RhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9Xd0NvbnZlcnRvclN0YXRlKHNjaGVtYSwgY29udmVydG9ycykge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5jb252ZXJ0b3JzID0gY29udmVydG9ycztcbiAgICAgICAgdGhpcy5zdGFjayA9IFt7IHR5cGU6IHRoaXMuc2NoZW1hLnRvcE5vZGVUeXBlLCBhdHRyczogbnVsbCwgY29udGVudDogW10gfV07XG4gICAgICAgIHRoaXMubWFya3MgPSBNYXJrJDEubm9uZTtcbiAgICB9XG4gICAgVG9Xd0NvbnZlcnRvclN0YXRlLnByb3RvdHlwZS50b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsYXN0JDEodGhpcy5zdGFjayk7XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudG9wKCkuY29udGVudC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLmFkZFRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy50b3AoKS5jb250ZW50O1xuICAgICAgICAgICAgdmFyIGxhc3ROb2RlID0gbGFzdCQxKG5vZGVzKTtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zY2hlbWEudGV4dCh0ZXh0LCB0aGlzLm1hcmtzKTtcbiAgICAgICAgICAgIHZhciBtZXJnZWQgPSBsYXN0Tm9kZSAmJiBtZXJnZU1hcmtUZXh0KGxhc3ROb2RlLCBub2RlKTtcbiAgICAgICAgICAgIGlmIChtZXJnZWQpIHtcbiAgICAgICAgICAgICAgICBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSA9IG1lcmdlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvV3dDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUub3Blbk1hcmsgPSBmdW5jdGlvbiAobWFyaykge1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFyay5hZGRUb1NldCh0aGlzLm1hcmtzKTtcbiAgICB9O1xuICAgIFRvV3dDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY2xvc2VNYXJrID0gZnVuY3Rpb24gKG1hcmspIHtcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmsucmVtb3ZlRnJvbVNldCh0aGlzLm1hcmtzKTtcbiAgICB9O1xuICAgIFRvV3dDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuYWRkTm9kZSA9IGZ1bmN0aW9uICh0eXBlLCBhdHRycywgY29udGVudCkge1xuICAgICAgICB2YXIgbm9kZSA9IHR5cGUuY3JlYXRlQW5kRmlsbChhdHRycywgY29udGVudCwgdGhpcy5tYXJrcyk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRvV3dDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUub3Blbk5vZGUgPSBmdW5jdGlvbiAodHlwZSwgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHsgdHlwZTogdHlwZSwgYXR0cnM6IGF0dHJzLCBjb250ZW50OiBbXSB9KTtcbiAgICB9O1xuICAgIFRvV3dDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY2xvc2VOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubWFya3MgPSBNYXJrJDEubm9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YWNrLnBvcCgpLCB0eXBlID0gX2EudHlwZSwgYXR0cnMgPSBfYS5hdHRycywgY29udGVudCA9IF9hLmNvbnRlbnQ7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGUodHlwZSwgYXR0cnMsIGNvbnRlbnQpO1xuICAgIH07XG4gICAgVG9Xd0NvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5jb252ZXJ0QnlET01QYXJzZXIgPSBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZG9jID0gRE9NUGFyc2VyLmZyb21TY2hlbWEodGhpcy5zY2hlbWEpLnBhcnNlKHJvb3QpO1xuICAgICAgICBkb2MuY29udGVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBfdGhpcy5wdXNoKG5vZGUpOyB9KTtcbiAgICB9O1xuICAgIFRvV3dDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY2xvc2VVbm1hdGNoZWRIVE1MSW5saW5lID0gZnVuY3Rpb24gKG5vZGUsIGVudGVyaW5nKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFlbnRlcmluZyAmJiBub2RlLnR5cGUgIT09ICdodG1sSW5saW5lJykge1xuICAgICAgICAgICAgdmFyIGxlbmd0aF8xID0gdGhpcy5zdGFjay5sZW5ndGggLSAxO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxlbmd0aF8xOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlSW5mbyA9IHRoaXMuc3RhY2tbaV07XG4gICAgICAgICAgICAgICAgaWYgKChfYSA9IG5vZGVJbmZvLmF0dHJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmF3SFRNTCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZUluZm8uY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHBvcCB1c2VsZXNzIHVubWF0Y2hlZCBodG1sIGlubGluZSBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvV3dDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChtZE5vZGUsIGluZm9Gb3JQb3NTeW5jKSB7XG4gICAgICAgIHZhciB3YWxrZXIgPSBtZE5vZGUud2Fsa2VyKCk7XG4gICAgICAgIHZhciBldmVudCA9IHdhbGtlci5uZXh0KCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBldmVudC5ub2RlLCBlbnRlcmluZyA9IGV2ZW50LmVudGVyaW5nO1xuICAgICAgICAgICAgdmFyIGNvbnZlcnRvciA9IHRoaXNfMS5jb252ZXJ0b3JzW25vZGUudHlwZV07XG4gICAgICAgICAgICB2YXIgc2tpcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNvbnZlcnRvcikge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBlbnRlcmluZzogZW50ZXJpbmcsXG4gICAgICAgICAgICAgICAgICAgIGxlYWY6ICFpc0NvbnRhaW5lciQyKG5vZGUpLFxuICAgICAgICAgICAgICAgICAgICBnZXRDaGlsZHJlblRleHQ6IGdldENoaWxkcmVuVGV4dCQxLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7IGdmbTogdHJ1ZSwgbm9kZUlkOiBmYWxzZSwgdGFnRmlsdGVyOiBmYWxzZSwgc29mdGJyZWFrOiAnXFxuJyB9LFxuICAgICAgICAgICAgICAgICAgICBza2lwQ2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpc18xLmNsb3NlVW5tYXRjaGVkSFRNTElubGluZShub2RlLCBlbnRlcmluZyk7XG4gICAgICAgICAgICAgICAgY29udmVydG9yKHRoaXNfMSwgbm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKChpbmZvRm9yUG9zU3luYyA9PT0gbnVsbCB8fCBpbmZvRm9yUG9zU3luYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5mb0ZvclBvc1N5bmMubm9kZSkgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXNfMS5zdGFjay5yZWR1Y2UoZnVuY3Rpb24gKG5vZGVTaXplLCBzdGFja0l0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlU2l6ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tJdGVtLmNvbnRlbnQucmVkdWNlKGZ1bmN0aW9uIChjb250ZW50U2l6ZSwgcG1Ob2RlKSB7IHJldHVybiBjb250ZW50U2l6ZSArIHBtTm9kZS5ub2RlU2l6ZTsgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaW5mb0ZvclBvc1N5bmMuc2V0TWFwcGVkUG9zKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICAgICAgICB3YWxrZXIucmVzdW1lQXQobm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHdhbGtlci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudCA9IHdhbGtlci5uZXh0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoZXZlbnQpIHtcbiAgICAgICAgICAgIF9sb29wXzEoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9Xd0NvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5jb252ZXJ0Tm9kZSA9IGZ1bmN0aW9uIChtZE5vZGUsIGluZm9Gb3JQb3NTeW5jKSB7XG4gICAgICAgIHRoaXMuY29udmVydChtZE5vZGUsIGluZm9Gb3JQb3NTeW5jKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBUb1d3Q29udmVydG9yU3RhdGU7XG59KCkpO1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9SYXdIVE1MSGF2aW5nSW5saW5lcyhzdGF0ZSwgbm9kZSwgX2EpIHtcbiAgICB2YXIgb3BlblRhZyA9IF9hWzBdLCBjbG9zZVRhZyA9IF9hWzFdO1xuICAgIHN0YXRlLndyaXRlKG9wZW5UYWcpO1xuICAgIHN0YXRlLmNvbnZlcnRJbmxpbmUobm9kZSk7XG4gICAgc3RhdGUud3JpdGUoY2xvc2VUYWcpO1xufVxuZnVuY3Rpb24gY29udmVydFRvUmF3SFRNTEhhdmluZ0Jsb2NrcyhzdGF0ZSwgX2EsIF9iKSB7XG4gICAgdmFyIG5vZGUgPSBfYS5ub2RlLCBwYXJlbnQgPSBfYS5wYXJlbnQ7XG4gICAgdmFyIG9wZW5UYWcgPSBfYlswXSwgY2xvc2VUYWcgPSBfYlsxXTtcbiAgICBzdGF0ZS5zdG9wTmV3bGluZSA9IHRydWU7XG4gICAgc3RhdGUud3JpdGUob3BlblRhZyk7XG4gICAgc3RhdGUuY29udmVydE5vZGUobm9kZSk7XG4gICAgc3RhdGUud3JpdGUoY2xvc2VUYWcpO1xuICAgIGlmICgocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LnR5cGUubmFtZSkgPT09ICdkb2MnKSB7XG4gICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgICAgIHN0YXRlLnN0b3BOZXdsaW5lID0gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVGFibGVIZWFkRGVsaW0odGV4dENvbnRlbnQsIGNvbHVtbkFsaWduKSB7XG4gICAgdmFyIHRleHRMZW4gPSB0ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgdmFyIGxlZnREZWxpbSA9ICcnO1xuICAgIHZhciByaWdodERlbGltID0gJyc7XG4gICAgaWYgKGNvbHVtbkFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgbGVmdERlbGltID0gJzonO1xuICAgICAgICB0ZXh0TGVuIC09IDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbHVtbkFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHJpZ2h0RGVsaW0gPSAnOic7XG4gICAgICAgIHRleHRMZW4gLT0gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29sdW1uQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGxlZnREZWxpbSA9ICc6JztcbiAgICAgICAgcmlnaHREZWxpbSA9ICc6JztcbiAgICAgICAgdGV4dExlbiAtPSAyO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIiArIGxlZnREZWxpbSArIHJlcGVhdCQxKCctJywgTWF0aC5tYXgodGV4dExlbiwgMykpICsgcmlnaHREZWxpbTtcbn1cbnZhciBub2RlVHlwZVdyaXRlcnMgPSB7XG4gICAgdGV4dDogZnVuY3Rpb24gKHN0YXRlLCBfYSkge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIHRleHQgPSAoX2IgPSBub2RlLnRleHQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgICAgICBpZiAoKG5vZGUubWFya3MgfHwgW10pLnNvbWUoZnVuY3Rpb24gKG1hcmspIHsgcmV0dXJuIG1hcmsudHlwZS5uYW1lID09PSAnbGluayc7IH0pKSB7XG4gICAgICAgICAgICBzdGF0ZS50ZXh0KGVzY2FwZVRleHRGb3JMaW5rKHRleHQpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS50ZXh0KHRleHQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwYXJhZ3JhcGg6IGZ1bmN0aW9uIChzdGF0ZSwgX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlLCBwYXJlbnQgPSBfYS5wYXJlbnQsIF9iID0gX2EuaW5kZXgsIGluZGV4ID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYjtcbiAgICAgICAgaWYgKHN0YXRlLnN0b3BOZXdsaW5lKSB7XG4gICAgICAgICAgICBzdGF0ZS5jb252ZXJ0SW5saW5lKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZpcnN0Q2hpbGROb2RlID0gaW5kZXggPT09IDA7XG4gICAgICAgICAgICB2YXIgcHJldk5vZGUgPSAhZmlyc3RDaGlsZE5vZGUgJiYgcGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgICB2YXIgcHJldkVtcHR5Tm9kZSA9IHByZXZOb2RlICYmIHByZXZOb2RlLmNoaWxkQ291bnQgPT09IDA7XG4gICAgICAgICAgICB2YXIgbmV4dE5vZGUgPSBpbmRleCA8IHBhcmVudC5jaGlsZENvdW50IC0gMSAmJiBwYXJlbnQuY2hpbGQoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIHZhciBuZXh0UGFyYU5vZGUgPSBuZXh0Tm9kZSAmJiBuZXh0Tm9kZS50eXBlLm5hbWUgPT09ICdwYXJhZ3JhcGgnO1xuICAgICAgICAgICAgdmFyIGVtcHR5Tm9kZSA9IG5vZGUuY2hpbGRDb3VudCA9PT0gMDtcbiAgICAgICAgICAgIGlmIChlbXB0eU5vZGUgJiYgcHJldkVtcHR5Tm9kZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLndyaXRlKCc8YnI+XFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbXB0eU5vZGUgJiYgIXByZXZFbXB0eU5vZGUgJiYgIWZpcnN0Q2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQudHlwZS5uYW1lKSA9PT0gJ2xpc3RJdGVtJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldkRlbGltID0gc3RhdGUuZ2V0RGVsaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2V0RGVsaW0oJycpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS53cml0ZSgnPGJyPicpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zZXREZWxpbShwcmV2RGVsaW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS53cml0ZSgnXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jb252ZXJ0SW5saW5lKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0UGFyYU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUud3JpdGUoJ1xcbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VCbG9jayhub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhlYWRpbmc6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGRlbGltID0gX2IuZGVsaW07XG4gICAgICAgIHZhciBoZWFkaW5nVHlwZSA9IG5vZGUuYXR0cnMuaGVhZGluZ1R5cGU7XG4gICAgICAgIGlmIChoZWFkaW5nVHlwZSA9PT0gJ2F0eCcpIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKGRlbGltICsgXCIgXCIpO1xuICAgICAgICAgICAgc3RhdGUuY29udmVydElubGluZShub2RlKTtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jb252ZXJ0SW5saW5lKG5vZGUpO1xuICAgICAgICAgICAgc3RhdGUuZW5zdXJlTmV3TGluZSgpO1xuICAgICAgICAgICAgc3RhdGUud3JpdGUoZGVsaW0pO1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VCbG9jayhub2RlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29kZUJsb2NrOiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBkZWxpbSA9IF9iLmRlbGltLCB0ZXh0ID0gX2IudGV4dDtcbiAgICAgICAgdmFyIF9jID0gZGVsaW0sIG9wZW5EZWxpbSA9IF9jWzBdLCBjbG9zZURlbGltID0gX2NbMV07XG4gICAgICAgIHN0YXRlLndyaXRlKG9wZW5EZWxpbSk7XG4gICAgICAgIHN0YXRlLmVuc3VyZU5ld0xpbmUoKTtcbiAgICAgICAgc3RhdGUudGV4dCh0ZXh0LCBmYWxzZSk7XG4gICAgICAgIHN0YXRlLmVuc3VyZU5ld0xpbmUoKTtcbiAgICAgICAgc3RhdGUud3JpdGUoY2xvc2VEZWxpbSk7XG4gICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgfSxcbiAgICBibG9ja1F1b3RlOiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGUsIHBhcmVudCA9IF9hLnBhcmVudDtcbiAgICAgICAgdmFyIGRlbGltID0gX2IuZGVsaW07XG4gICAgICAgIGlmICgocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LnR5cGUubmFtZSkgPT09IG5vZGUudHlwZS5uYW1lKSB7XG4gICAgICAgICAgICBzdGF0ZS5mbHVzaENsb3NlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLndyYXBCbG9jayhkZWxpbSwgbnVsbCwgbm9kZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdGUuY29udmVydE5vZGUobm9kZSk7IH0pO1xuICAgIH0sXG4gICAgYnVsbGV0TGlzdDogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgZGVsaW0gPSBfYi5kZWxpbTtcbiAgICAgICAgLy8gc29mdC10YWIoNClcbiAgICAgICAgc3RhdGUuY29udmVydExpc3Qobm9kZSwgcmVwZWF0JDEoJyAnLCA0KSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVsaW0gKyBcIiBcIjsgfSk7XG4gICAgfSxcbiAgICBvcmRlcmVkTGlzdDogZnVuY3Rpb24gKHN0YXRlLCBfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBzdGFydCA9IG5vZGUuYXR0cnMub3JkZXIgfHwgMTtcbiAgICAgICAgLy8gc29mdC10YWIoNClcbiAgICAgICAgc3RhdGUuY29udmVydExpc3Qobm9kZSwgcmVwZWF0JDEoJyAnLCA0KSwgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgb3JkZXJlZE51bSA9IFN0cmluZyhzdGFydCArIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBvcmRlcmVkTnVtICsgXCIuIFwiO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGxpc3RJdGVtOiBmdW5jdGlvbiAoc3RhdGUsIF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIF9iID0gbm9kZS5hdHRycywgdGFzayA9IF9iLnRhc2ssIGNoZWNrZWQgPSBfYi5jaGVja2VkO1xuICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgc3RhdGUud3JpdGUoXCJbXCIgKyAoY2hlY2tlZCA/ICd4JyA6ICcgJykgKyBcIl0gXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmNvbnZlcnROb2RlKG5vZGUpO1xuICAgIH0sXG4gICAgaW1hZ2U6IGZ1bmN0aW9uIChzdGF0ZSwgXywgX2EpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgIHN0YXRlLndyaXRlKFwiIVtcIiArIChhdHRycyA9PT0gbnVsbCB8fCBhdHRycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXR0cnMuYWx0VGV4dCkgKyBcIl0oXCIgKyAoYXR0cnMgPT09IG51bGwgfHwgYXR0cnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF0dHJzLmltYWdlVXJsKSArIFwiKVwiKTtcbiAgICB9LFxuICAgIHRoZW1hdGljQnJlYWs6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGRlbGltID0gX2IuZGVsaW07XG4gICAgICAgIHN0YXRlLndyaXRlKGRlbGltKTtcbiAgICAgICAgc3RhdGUuY2xvc2VCbG9jayhub2RlKTtcbiAgICB9LFxuICAgIHRhYmxlOiBmdW5jdGlvbiAoc3RhdGUsIF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgc3RhdGUuY29udmVydE5vZGUobm9kZSk7XG4gICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgfSxcbiAgICB0YWJsZUhlYWQ6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGRlbGltID0gX2IuZGVsaW07XG4gICAgICAgIHZhciByb3cgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHN0YXRlLmNvbnZlcnROb2RlKG5vZGUpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZGVsaW0gIT09IG51bGwgJiYgZGVsaW0gIT09IHZvaWQgMCA/IGRlbGltIDogJyc7XG4gICAgICAgIGlmICghZGVsaW0gJiYgcm93KSB7XG4gICAgICAgICAgICByb3cuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSBfYS50ZXh0Q29udGVudCwgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICB2YXIgaGVhZERlbGltID0gY3JlYXRlVGFibGVIZWFkRGVsaW0odGV4dENvbnRlbnQsIGF0dHJzLmFsaWduKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJ8IFwiICsgaGVhZERlbGltICsgXCIgXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS53cml0ZShyZXN1bHQgKyBcInxcIik7XG4gICAgICAgIHN0YXRlLmVuc3VyZU5ld0xpbmUoKTtcbiAgICB9LFxuICAgIHRhYmxlQm9keTogZnVuY3Rpb24gKHN0YXRlLCBfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHN0YXRlLmNvbnZlcnROb2RlKG5vZGUpO1xuICAgIH0sXG4gICAgdGFibGVSb3c6IGZ1bmN0aW9uIChzdGF0ZSwgX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICBzdGF0ZS5jb252ZXJ0Tm9kZShub2RlKTtcbiAgICAgICAgc3RhdGUud3JpdGUoJ3wnKTtcbiAgICAgICAgc3RhdGUuZW5zdXJlTmV3TGluZSgpO1xuICAgIH0sXG4gICAgdGFibGVIZWFkQ2VsbDogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgX2MgPSBfYi5kZWxpbSwgZGVsaW0gPSBfYyA9PT0gdm9pZCAwID8gJ3wgJyA6IF9jO1xuICAgICAgICBzdGF0ZS53cml0ZShkZWxpbSk7XG4gICAgICAgIHN0YXRlLmNvbnZlcnRUYWJsZUNlbGwobm9kZSk7XG4gICAgICAgIHN0YXRlLndyaXRlKCcgJyk7XG4gICAgfSxcbiAgICB0YWJsZUJvZHlDZWxsOiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBfYyA9IF9iLmRlbGltLCBkZWxpbSA9IF9jID09PSB2b2lkIDAgPyAnfCAnIDogX2M7XG4gICAgICAgIHN0YXRlLndyaXRlKGRlbGltKTtcbiAgICAgICAgc3RhdGUuY29udmVydFRhYmxlQ2VsbChub2RlKTtcbiAgICAgICAgc3RhdGUud3JpdGUoJyAnKTtcbiAgICB9LFxuICAgIGN1c3RvbUJsb2NrOiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBkZWxpbSA9IF9iLmRlbGltLCB0ZXh0ID0gX2IudGV4dDtcbiAgICAgICAgdmFyIF9jID0gZGVsaW0sIG9wZW5EZWxpbSA9IF9jWzBdLCBjbG9zZURlbGltID0gX2NbMV07XG4gICAgICAgIHN0YXRlLndyaXRlKG9wZW5EZWxpbSk7XG4gICAgICAgIHN0YXRlLmVuc3VyZU5ld0xpbmUoKTtcbiAgICAgICAgc3RhdGUudGV4dCh0ZXh0LCBmYWxzZSk7XG4gICAgICAgIHN0YXRlLmVuc3VyZU5ld0xpbmUoKTtcbiAgICAgICAgc3RhdGUud3JpdGUoY2xvc2VEZWxpbSk7XG4gICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgfSxcbiAgICBmcm9udE1hdHRlcjogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgdGV4dCA9IF9iLnRleHQ7XG4gICAgICAgIHN0YXRlLnRleHQodGV4dCwgZmFsc2UpO1xuICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgIH0sXG4gICAgd2lkZ2V0OiBmdW5jdGlvbiAoc3RhdGUsIF8sIF9hKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gX2EudGV4dDtcbiAgICAgICAgc3RhdGUud3JpdGUodGV4dCk7XG4gICAgfSxcbiAgICBodG1sOiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciB0ZXh0ID0gX2IudGV4dDtcbiAgICAgICAgc3RhdGUud3JpdGUodGV4dCk7XG4gICAgICAgIGlmIChub2RlLmF0dHJzLmh0bWxCbG9jaykge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VCbG9jayhub2RlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaHRtbENvbW1lbnQ6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIHRleHQgPSBfYi50ZXh0O1xuICAgICAgICBzdGF0ZS53cml0ZSh0ZXh0KTtcbiAgICAgICAgc3RhdGUuY2xvc2VCbG9jayhub2RlKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHdyaXRlKHR5cGUsIF9hKSB7XG4gICAgdmFyIHN0YXRlID0gX2Euc3RhdGUsIG5vZGVJbmZvID0gX2Eubm9kZUluZm8sIHBhcmFtcyA9IF9hLnBhcmFtcztcbiAgICB2YXIgcmF3SFRNTCA9IHBhcmFtcy5yYXdIVE1MO1xuICAgIGlmIChyYXdIVE1MKSB7XG4gICAgICAgIGlmIChpbkFycmF5XzEodHlwZSwgWydoZWFkaW5nJywgJ2NvZGVCbG9jayddKSA+IC0xKSB7XG4gICAgICAgICAgICBjb252ZXJ0VG9SYXdIVE1MSGF2aW5nSW5saW5lcyhzdGF0ZSwgbm9kZUluZm8ubm9kZSwgcmF3SFRNTCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5BcnJheV8xKHR5cGUsIFsnaW1hZ2UnLCAndGhlbWF0aWNCcmVhayddKSA+IC0xKSB7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZShyYXdIVE1MKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnZlcnRUb1Jhd0hUTUxIYXZpbmdCbG9ja3Moc3RhdGUsIG5vZGVJbmZvLCByYXdIVE1MKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZVR5cGVXcml0ZXJzW3R5cGVdKHN0YXRlLCBub2RlSW5mbywgcGFyYW1zKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZEJhY2t0aWNrcyhub2RlLCBzaWRlKSB7XG4gICAgdmFyIHRleHQgPSBub2RlLnRleHQ7XG4gICAgdmFyIHRpY2tzID0gL2ArL2c7XG4gICAgdmFyIGxlbiA9IDA7XG4gICAgaWYgKG5vZGUuaXNUZXh0ICYmIHRleHQpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSB0aWNrcy5leGVjKHRleHQpO1xuICAgICAgICB3aGlsZSAobWF0Y2hlZCkge1xuICAgICAgICAgICAgbGVuID0gTWF0aC5tYXgobGVuLCBtYXRjaGVkWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBtYXRjaGVkID0gdGlja3MuZXhlYyh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gbGVuID4gMCAmJiBzaWRlID4gMCA/ICcgYCcgOiAnYCc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZXN1bHQgKz0gJ2AnO1xuICAgIH1cbiAgICBpZiAobGVuID4gMCAmJiBzaWRlIDwgMCkge1xuICAgICAgICByZXN1bHQgKz0gJyAnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0UGFpclJhd0hUTUwocmF3SFRNTCkge1xuICAgIHJldHVybiByYXdIVE1MID8gW1wiPFwiICsgcmF3SFRNTCArIFwiPlwiLCBcIjwvXCIgKyByYXdIVE1MICsgXCI+XCJdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldE9wZW5SYXdIVE1MKHJhd0hUTUwpIHtcbiAgICByZXR1cm4gcmF3SFRNTCA/IFwiPFwiICsgcmF3SFRNTCArIFwiPlwiIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldENsb3NlUmF3SFRNTChyYXdIVE1MKSB7XG4gICAgcmV0dXJuIHJhd0hUTUwgPyBcIjwvXCIgKyByYXdIVE1MICsgXCI+XCIgOiBudWxsO1xufVxudmFyIHRvTWRDb252ZXJ0b3JzID0ge1xuICAgIGhlYWRpbmc6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBhdHRycyA9IG5vZGUuYXR0cnM7XG4gICAgICAgIHZhciBsZXZlbCA9IGF0dHJzLmxldmVsO1xuICAgICAgICB2YXIgZGVsaW0gPSByZXBlYXQkMSgnIycsIGxldmVsKTtcbiAgICAgICAgaWYgKGF0dHJzLmhlYWRpbmdUeXBlID09PSAnc2V0ZXh0Jykge1xuICAgICAgICAgICAgZGVsaW0gPSBsZXZlbCA9PT0gMSA/ICc9PT0nIDogJy0tLSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiBkZWxpbSxcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldFBhaXJSYXdIVE1MKGF0dHJzLnJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29kZUJsb2NrOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgX2IgPSBub2RlLCBhdHRycyA9IF9iLmF0dHJzLCB0ZXh0Q29udGVudCA9IF9iLnRleHRDb250ZW50O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsaW06IFtcImBgYFwiICsgKGF0dHJzLmxhbmd1YWdlIHx8ICcnKSwgJ2BgYCddLFxuICAgICAgICAgICAgcmF3SFRNTDogZ2V0UGFpclJhd0hUTUwoYXR0cnMucmF3SFRNTCksXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0Q29udGVudCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGJsb2NrUXVvdGU6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxpbTogJz4gJyxcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldFBhaXJSYXdIVE1MKG5vZGUuYXR0cnMucmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBidWxsZXRMaXN0OiBmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGluVGFibGUgPSBfYi5pblRhYmxlO1xuICAgICAgICB2YXIgcmF3SFRNTCA9IG5vZGUuYXR0cnMucmF3SFRNTDtcbiAgICAgICAgaWYgKGluVGFibGUpIHtcbiAgICAgICAgICAgIHJhd0hUTUwgPSByYXdIVE1MIHx8ICd1bCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiAnKicsXG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChyYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9yZGVyZWRMaXN0OiBmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGluVGFibGUgPSBfYi5pblRhYmxlO1xuICAgICAgICB2YXIgcmF3SFRNTCA9IG5vZGUuYXR0cnMucmF3SFRNTDtcbiAgICAgICAgaWYgKGluVGFibGUpIHtcbiAgICAgICAgICAgIHJhd0hUTUwgPSByYXdIVE1MIHx8ICdvbCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldFBhaXJSYXdIVE1MKHJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbGlzdEl0ZW06IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgaW5UYWJsZSA9IF9iLmluVGFibGU7XG4gICAgICAgIHZhciBfYyA9IG5vZGUuYXR0cnMsIHRhc2sgPSBfYy50YXNrLCBjaGVja2VkID0gX2MuY2hlY2tlZDtcbiAgICAgICAgdmFyIHJhd0hUTUwgPSBub2RlLmF0dHJzLnJhd0hUTUw7XG4gICAgICAgIGlmIChpblRhYmxlKSB7XG4gICAgICAgICAgICByYXdIVE1MID0gcmF3SFRNTCB8fCAnbGknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB0YXNrID8gXCIgY2xhc3M9XFxcInRhc2stbGlzdC1pdGVtXCIgKyAoY2hlY2tlZCA/ICcgY2hlY2tlZCcgOiAnJykgKyBcIlxcXCJcIiA6ICcnO1xuICAgICAgICB2YXIgZGF0YXNldCA9IHRhc2sgPyBcIiBkYXRhLXRhc2tcIiArIChjaGVja2VkID8gXCIgZGF0YS10YXNrLWNoZWNrZWRcIiA6ICcnKSA6ICcnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3SFRNTDogcmF3SFRNTCA/IFtcIjxcIiArIHJhd0hUTUwgKyBjbGFzc05hbWUgKyBkYXRhc2V0ICsgXCI+XCIsIFwiPC9cIiArIHJhd0hUTUwgKyBcIj5cIl0gOiBudWxsLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGFibGU6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChub2RlLmF0dHJzLnJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGFibGVIZWFkOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3SFRNTDogZ2V0UGFpclJhd0hUTUwobm9kZS5hdHRycy5yYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlQm9keTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldFBhaXJSYXdIVE1MKG5vZGUuYXR0cnMucmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0YWJsZVJvdzogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldFBhaXJSYXdIVE1MKG5vZGUuYXR0cnMucmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0YWJsZUhlYWRDZWxsOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3SFRNTDogZ2V0UGFpclJhd0hUTUwobm9kZS5hdHRycy5yYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlQm9keUNlbGw6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChub2RlLmF0dHJzLnJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgaW1hZ2U6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBhdHRycyA9IG5vZGUuYXR0cnM7XG4gICAgICAgIHZhciByYXdIVE1MID0gYXR0cnMucmF3SFRNTCwgYWx0VGV4dCA9IGF0dHJzLmFsdFRleHQ7XG4gICAgICAgIHZhciBpbWFnZVVybCA9IGF0dHJzLmltYWdlVXJsLnJlcGxhY2UoLyZhbXA7L2csICcmJyk7XG4gICAgICAgIHZhciBhbHRBdHRyID0gYWx0VGV4dCA/IFwiIGFsdD1cXFwiXCIgKyBlc2NhcGVYbWwkMShhbHRUZXh0KSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdIVE1MOiByYXdIVE1MID8gXCI8XCIgKyByYXdIVE1MICsgXCIgc3JjPVxcXCJcIiArIGVzY2FwZVhtbCQxKGltYWdlVXJsKSArIFwiXFxcIlwiICsgYWx0QXR0ciArIFwiPlwiIDogbnVsbCxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgYWx0VGV4dDogZXNjYXBlVGV4dEZvckxpbmsoYWx0VGV4dCB8fCAnJyksXG4gICAgICAgICAgICAgICAgaW1hZ2VVcmw6IGltYWdlVXJsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRoZW1hdGljQnJlYWs6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxpbTogJyoqKicsXG4gICAgICAgICAgICByYXdIVE1MOiBnZXRPcGVuUmF3SFRNTChub2RlLmF0dHJzLnJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY3VzdG9tQmxvY2s6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBfYiA9IG5vZGUsIGF0dHJzID0gX2IuYXR0cnMsIHRleHRDb250ZW50ID0gX2IudGV4dENvbnRlbnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxpbTogW1wiJCRcIiArIGF0dHJzLmluZm8sICckJCddLFxuICAgICAgICAgICAgdGV4dDogdGV4dENvbnRlbnQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBmcm9udE1hdHRlcjogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IG5vZGUudGV4dENvbnRlbnQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB3aWRnZXQ6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBub2RlLnRleHRDb250ZW50LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgc3Ryb25nOiBmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2IuZW50ZXJpbmc7XG4gICAgICAgIHZhciByYXdIVE1MID0gbm9kZS5hdHRycy5yYXdIVE1MO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsaW06ICcqKicsXG4gICAgICAgICAgICByYXdIVE1MOiBlbnRlcmluZyA/IGdldE9wZW5SYXdIVE1MKHJhd0hUTUwpIDogZ2V0Q2xvc2VSYXdIVE1MKHJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZW1waDogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9iLmVudGVyaW5nO1xuICAgICAgICB2YXIgcmF3SFRNTCA9IG5vZGUuYXR0cnMucmF3SFRNTDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiAnKicsXG4gICAgICAgICAgICByYXdIVE1MOiBlbnRlcmluZyA/IGdldE9wZW5SYXdIVE1MKHJhd0hUTUwpIDogZ2V0Q2xvc2VSYXdIVE1MKHJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgc3RyaWtlOiBmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2IuZW50ZXJpbmc7XG4gICAgICAgIHZhciByYXdIVE1MID0gbm9kZS5hdHRycy5yYXdIVE1MO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsaW06ICd+ficsXG4gICAgICAgICAgICByYXdIVE1MOiBlbnRlcmluZyA/IGdldE9wZW5SYXdIVE1MKHJhd0hUTUwpIDogZ2V0Q2xvc2VSYXdIVE1MKHJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9iLmVudGVyaW5nO1xuICAgICAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJzO1xuICAgICAgICB2YXIgdGl0bGUgPSBhdHRycy50aXRsZSwgcmF3SFRNTCA9IGF0dHJzLnJhd0hUTUw7XG4gICAgICAgIHZhciBsaW5rVXJsID0gYXR0cnMubGlua1VybC5yZXBsYWNlKC8mYW1wOy9nLCAnJicpO1xuICAgICAgICB2YXIgdGl0bGVBdHRyID0gdGl0bGUgPyBcIiB0aXRsZT1cXFwiXCIgKyBlc2NhcGVYbWwkMSh0aXRsZSkgKyBcIlxcXCJcIiA6ICcnO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGVsaW06ICdbJyxcbiAgICAgICAgICAgICAgICByYXdIVE1MOiByYXdIVE1MID8gXCI8XCIgKyByYXdIVE1MICsgXCIgaHJlZj1cXFwiXCIgKyBlc2NhcGVYbWwkMShsaW5rVXJsKSArIFwiXFxcIlwiICsgdGl0bGVBdHRyICsgXCI+XCIgOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsaW06IFwiXShcIiArIGxpbmtVcmwgKyAodGl0bGUgPyBcIiBcIiArIHF1b3RlKGVzY2FwZVRleHRGb3JMaW5rKHRpdGxlKSkgOiAnJykgKyBcIilcIixcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldENsb3NlUmF3SFRNTChyYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvZGU6IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlLCBwYXJlbnQgPSBfYS5wYXJlbnQsIF9jID0gX2EuaW5kZXgsIGluZGV4ID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYztcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2IuZW50ZXJpbmc7XG4gICAgICAgIHZhciBkZWxpbSA9IGVudGVyaW5nXG4gICAgICAgICAgICA/IGFkZEJhY2t0aWNrcyhwYXJlbnQuY2hpbGQoaW5kZXgpLCAtMSlcbiAgICAgICAgICAgIDogYWRkQmFja3RpY2tzKHBhcmVudC5jaGlsZChpbmRleCAtIDEpLCAxKTtcbiAgICAgICAgdmFyIHJhd0hUTUwgPSBlbnRlcmluZ1xuICAgICAgICAgICAgPyBnZXRPcGVuUmF3SFRNTChub2RlLmF0dHJzLnJhd0hUTUwpXG4gICAgICAgICAgICA6IGdldENsb3NlUmF3SFRNTChub2RlLmF0dHJzLnJhd0hUTUwpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsaW06IGRlbGltLFxuICAgICAgICAgICAgcmF3SFRNTDogcmF3SFRNTCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGh0bWxDb21tZW50OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogbm9kZS50ZXh0Q29udGVudCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIC8vIGh0bWwgaW5saW5lIG5vZGUsIGh0bWwgYmxvY2sgbm9kZVxuICAgIGh0bWw6IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYi5lbnRlcmluZztcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBub2RlLnR5cGUubmFtZTtcbiAgICAgICAgdmFyIGF0dHJzID0gbm9kZS5hdHRycy5odG1sQXR0cnM7XG4gICAgICAgIHZhciBvcGVuVGFnID0gXCI8XCIgKyB0YWdOYW1lO1xuICAgICAgICB2YXIgY2xvc2VUYWcgPSBcIjwvXCIgKyB0YWdOYW1lICsgXCI+XCI7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICAgICAgLy8gVG8gcHJldmVudCBicm9rZW4gY29udmVydGluZyB3aGVuIGF0dHJpYnV0ZXMgaGFzIGRvdWJsZSBxdW90ZSBzdHJpbmdcbiAgICAgICAgICAgIG9wZW5UYWcgKz0gXCIgXCIgKyBhdHRyTmFtZSArIFwiPVxcXCJcIiArIGF0dHJzW2F0dHJOYW1lXS5yZXBsYWNlKC9cIi9nLCBcIidcIikgKyBcIlxcXCJcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIG9wZW5UYWcgKz0gJz4nO1xuICAgICAgICBpZiAobm9kZS5hdHRycy5odG1sSW5saW5lKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJhd0hUTUw6IGVudGVyaW5nID8gb3BlblRhZyA6IGNsb3NlVGFnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogXCJcIiArIG9wZW5UYWcgKyBub2RlLmF0dHJzLmNoaWxkcmVuSFRNTCArIGNsb3NlVGFnLFxuICAgICAgICB9O1xuICAgIH0sXG59O1xudmFyIG1hcmtUeXBlT3B0aW9ucyA9IHtcbiAgICBzdHJvbmc6IHtcbiAgICAgICAgbWl4YWJsZTogdHJ1ZSxcbiAgICAgICAgcmVtb3ZlZEVuY2xvc2luZ1doaXRlc3BhY2U6IHRydWUsXG4gICAgfSxcbiAgICBlbXBoOiB7XG4gICAgICAgIG1peGFibGU6IHRydWUsXG4gICAgICAgIHJlbW92ZWRFbmNsb3NpbmdXaGl0ZXNwYWNlOiB0cnVlLFxuICAgIH0sXG4gICAgc3RyaWtlOiB7XG4gICAgICAgIG1peGFibGU6IHRydWUsXG4gICAgICAgIHJlbW92ZWRFbmNsb3NpbmdXaGl0ZXNwYWNlOiB0cnVlLFxuICAgIH0sXG4gICAgY29kZToge1xuICAgICAgICBlc2NhcGU6IGZhbHNlLFxuICAgIH0sXG4gICAgbGluazogbnVsbCxcbiAgICBodG1sOiBudWxsLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZU5vZGVUeXBlQ29udmVydG9ycyhjb252ZXJ0b3JzKSB7XG4gICAgdmFyIG5vZGVUeXBlQ29udmVydG9ycyA9IHt9O1xuICAgIHZhciBub2RlVHlwZXMgPSBPYmplY3Qua2V5cyhub2RlVHlwZVdyaXRlcnMpO1xuICAgIG5vZGVUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIG5vZGVUeXBlQ29udmVydG9yc1t0eXBlXSA9IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZUluZm8pIHtcbiAgICAgICAgICAgIHZhciB3cml0ZXIgPSBub2RlVHlwZVdyaXRlcnNbdHlwZV07XG4gICAgICAgICAgICBpZiAod3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRvciA9IGNvbnZlcnRvcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IGNvbnZlcnRvclxuICAgICAgICAgICAgICAgICAgICA/IGNvbnZlcnRvcihub2RlSW5mbywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5UYWJsZTogc3RhdGUuaW5UYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgICAgICAgICB3cml0ZSh0eXBlLCB7IHN0YXRlOiBzdGF0ZSwgbm9kZUluZm86IG5vZGVJbmZvLCBwYXJhbXM6IHBhcmFtcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZVR5cGVDb252ZXJ0b3JzO1xufVxuZnVuY3Rpb24gY3JlYXRlTWFya1R5cGVDb252ZXJ0b3JzKGNvbnZlcnRvcnMpIHtcbiAgICB2YXIgbWFya1R5cGVDb252ZXJ0b3JzID0ge307XG4gICAgdmFyIG1hcmtUeXBlcyA9IE9iamVjdC5rZXlzKG1hcmtUeXBlT3B0aW9ucyk7XG4gICAgbWFya1R5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgbWFya1R5cGVDb252ZXJ0b3JzW3R5cGVdID0gZnVuY3Rpb24gKG5vZGVJbmZvLCBlbnRlcmluZykge1xuICAgICAgICAgICAgdmFyIG1hcmtPcHRpb24gPSBtYXJrVHlwZU9wdGlvbnNbdHlwZV07XG4gICAgICAgICAgICB2YXIgY29udmVydG9yID0gY29udmVydG9yc1t0eXBlXTtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSB0d28gd2F5cyB0byBjYWxsIHRoZSBtYXJrIHR5cGUgY29udmVydGVyXG4gICAgICAgICAgICAvLyBpbiB0aGUgYHRvTWRDb252ZXJ0b3JTdGF0ZWAgbW9kdWxlLlxuICAgICAgICAgICAgLy8gV2hlbiBjYWxsaW5nIHRoZSBjb252ZXJ0ZXIgd2l0aG91dCB1c2luZyBgZGVsaW1gIGFuZCBgcmF3SFRNTGAgdmFsdWVzLFxuICAgICAgICAgICAgLy8gdGhlIGNvbnZlcnRlciBpcyBjYWxsZWQgd2l0aG91dCBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgdmFyIHJ1bkNvbnZlcnRvciA9IGNvbnZlcnRvciAmJiBub2RlSW5mbyAmJiAhaXNVbmRlZmluZWRfMShlbnRlcmluZyk7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gcnVuQ29udmVydG9yID8gY29udmVydG9yKG5vZGVJbmZvLCB7IGVudGVyaW5nOiBlbnRlcmluZyB9KSA6IHt9O1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgcGFyYW1zKSwgbWFya09wdGlvbik7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcmtUeXBlQ29udmVydG9ycztcbn1cbi8vIFN0ZXAgMTogQ3JlYXRlIHRoZSBjb252ZXJ0ZXIgYnkgb3ZlcnJpZGluZyB0aGUgY3VzdG9tIGNvbnZlcnRlclxuLy8gICAgICAgICB0byB0aGUgb3JpZ2luYWwgY29udmVydGVyIGRlZmluZWQgaW4gdGhlIGB0b01kQ29udmVydG9yc2AgbW9kdWxlLlxuLy8gICAgICAgICBJZiB0aGUgbm9kZSB0eXBlIGlzIGRlZmluZWQgaW4gdGhlIG9yaWdpbmFsIGNvbnZlcnRlcixcbi8vICAgICAgICAgdGhlIGBvcmlnaW4oKWAgZnVuY3Rpb24gaXMgZXhwb3J0ZWQgdG8gdGhlIHBhcmFtdGVyIG9mIHRoZSBjb252ZXJ0ZXIuXG4vLyBTdGVwIDI6IENyZWF0ZSBhIGNvbnZlcnRlciBmb3IgdGhlIG5vZGUgdHlwZSBvZiBQcm9zZU1pcnJvciBieSBjb21iaW5pbmcgdGhlIGNvbnZlcnRlclxuLy8gICAgICAgICBjcmVhdGVkIGluIFN0ZXAgMSB3aXRoIHRoZSB3cml0ZXJzIGRlZmluZWQgaW4gdGhlYHRvTWROb2RlVHlwZVdyaXRlcnNgIG1vZHVsZS5cbi8vICAgICAgICAgRWFjaCB3cml0ZXIgY29udmVydHMgdGhlIFByb3NlTWlycm9yJ3Mgbm9kZSB0byBhIHN0cmluZyB3aXRoIHRoZSB2YWx1ZSByZXR1cm5lZFxuLy8gICAgICAgICBieSB0aGUgY29udmVydGVyLCBhbmQgdGhlbiBzdG9yZXMgdGhlIHN0YXRlIGluIHRoZWB0b01kQ29udmVydGVyU3RhdGVgIGNsYXNzLlxuLy8gU3RlcCAzOiBDcmVhdGUgYSBjb252ZXJ0ZXIgZm9yIHRoZSBtYXJrIHR5cGUgb2YgUHJvc2VNaXJyb3IgYnkgY29tYmluaW5nIHRoZSBjb252ZXJ0ZXJcbi8vICAgICAgICAgY3JlYXRlZCBpbiBTdGVwIDEgd2l0aCBgbWFya1R5cGVPcHRpb25zYC5cbi8vIFN0ZXAgNDogVGhlIGNyZWF0ZWQgbm9kZSB0eXBlIGNvbnZlcnRlciBhbmQgbWFyayB0eXBlIGNvbnZlcnRlciBhcmUgaW5qZWN0ZWRcbi8vICAgICAgICAgd2hlbiBjcmVhdGluZyBhbiBpbnN0YW5jZSBvZiB0aGVgdG9NZENvbnZlcnRlclN0YXRlYCBjbGFzcy5cbmZ1bmN0aW9uIGNyZWF0ZU1kQ29udmVydG9ycyhjdXN0b21Db252ZXJ0b3JzKSB7XG4gICAgdmFyIGN1c3RvbUNvbnZlcnRvclR5cGVzID0gT2JqZWN0LmtleXMoY3VzdG9tQ29udmVydG9ycyk7XG4gICAgY3VzdG9tQ29udmVydG9yVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgYmFzZUNvbnZlcnRvciA9IHRvTWRDb252ZXJ0b3JzW3R5cGVdO1xuICAgICAgICB2YXIgY3VzdG9tQ29udmVydG9yID0gY3VzdG9tQ29udmVydG9yc1t0eXBlXTtcbiAgICAgICAgaWYgKGJhc2VDb252ZXJ0b3IpIHtcbiAgICAgICAgICAgIHRvTWRDb252ZXJ0b3JzW3R5cGVdID0gZnVuY3Rpb24gKG5vZGVJbmZvLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5vcmlnaW4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlQ29udmVydG9yKG5vZGVJbmZvLCBjb250ZXh0KTsgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tQ29udmVydG9yKG5vZGVJbmZvLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b01kQ29udmVydG9yc1t0eXBlXSA9IGN1c3RvbUNvbnZlcnRvcjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgY3VzdG9tQ29udmVydG9yc1t0eXBlXTtcbiAgICB9KTtcbiAgICB2YXIgbm9kZVR5cGVDb252ZXJ0b3JzID0gY3JlYXRlTm9kZVR5cGVDb252ZXJ0b3JzKHRvTWRDb252ZXJ0b3JzKTtcbiAgICB2YXIgbWFya1R5cGVDb252ZXJ0b3JzID0gY3JlYXRlTWFya1R5cGVDb252ZXJ0b3JzKHRvTWRDb252ZXJ0b3JzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZUNvbnZlcnRvcnM6IG5vZGVUeXBlQ29udmVydG9ycyxcbiAgICAgICAgbWFya1R5cGVDb252ZXJ0b3JzOiBtYXJrVHlwZUNvbnZlcnRvcnMsXG4gICAgfTtcbn1cblxudmFyIFRvTWRDb252ZXJ0b3JTdGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb01kQ29udmVydG9yU3RhdGUoX2EpIHtcbiAgICAgICAgdmFyIG5vZGVUeXBlQ29udmVydG9ycyA9IF9hLm5vZGVUeXBlQ29udmVydG9ycywgbWFya1R5cGVDb252ZXJ0b3JzID0gX2EubWFya1R5cGVDb252ZXJ0b3JzO1xuICAgICAgICB0aGlzLm5vZGVUeXBlQ29udmVydG9ycyA9IG5vZGVUeXBlQ29udmVydG9ycztcbiAgICAgICAgdGhpcy5tYXJrVHlwZUNvbnZlcnRvcnMgPSBtYXJrVHlwZUNvbnZlcnRvcnM7XG4gICAgICAgIHRoaXMuZGVsaW0gPSAnJztcbiAgICAgICAgdGhpcy5yZXN1bHQgPSAnJztcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aWdodExpc3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdG9wTmV3bGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluVGFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5nZXRNYXJrQ29udmVydG9yID0gZnVuY3Rpb24gKG1hcmspIHtcbiAgICAgICAgdmFyIHR5cGUgPSBtYXJrLmF0dHJzLmh0bWxJbmxpbmUgPyAnaHRtbCcgOiBtYXJrLnR5cGUubmFtZTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya1R5cGVDb252ZXJ0b3JzW3R5cGVdO1xuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5pc0luQmxhbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAvKF58XFxuKSQvLnRlc3QodGhpcy5yZXN1bHQpO1xuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5tYXJrVGV4dCA9IGZ1bmN0aW9uIChtYXJrLCBlbnRlcmluZywgcGFyZW50LCBpbmRleCkge1xuICAgICAgICB2YXIgY29udmVydG9yID0gdGhpcy5nZXRNYXJrQ29udmVydG9yKG1hcmspO1xuICAgICAgICBpZiAoY29udmVydG9yKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBjb252ZXJ0b3IoeyBub2RlOiBtYXJrLCBwYXJlbnQ6IHBhcmVudCwgaW5kZXg6IGluZGV4IH0sIGVudGVyaW5nKSwgZGVsaW0gPSBfYS5kZWxpbSwgcmF3SFRNTCA9IF9hLnJhd0hUTUw7XG4gICAgICAgICAgICByZXR1cm4gcmF3SFRNTCB8fCBkZWxpbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLnNldERlbGltID0gZnVuY3Rpb24gKGRlbGltKSB7XG4gICAgICAgIHRoaXMuZGVsaW0gPSBkZWxpbTtcbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuZ2V0RGVsaW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGltO1xuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5mbHVzaENsb3NlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0b3BOZXdsaW5lICYmIHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNJbkJsYW5rKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNpemUgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGltTWluID0gdGhpcy5kZWxpbTtcbiAgICAgICAgICAgICAgICB2YXIgdHJpbSA9IC9cXHMrJC8uZXhlYyhkZWxpbU1pbik7XG4gICAgICAgICAgICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsaW1NaW4gPSBkZWxpbU1pbi5zbGljZSgwLCBkZWxpbU1pbi5sZW5ndGggLSB0cmltWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2l6ZTsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ICs9IGRlbGltTWluICsgXCJcXG5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLndyYXBCbG9jayA9IGZ1bmN0aW9uIChkZWxpbSwgZmlyc3REZWxpbSwgbm9kZSwgZm4pIHtcbiAgICAgICAgdmFyIG9sZCA9IHRoaXMuZ2V0RGVsaW0oKTtcbiAgICAgICAgdGhpcy53cml0ZShmaXJzdERlbGltIHx8IGRlbGltKTtcbiAgICAgICAgdGhpcy5zZXREZWxpbSh0aGlzLmdldERlbGltKCkgKyBkZWxpbSk7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHRoaXMuc2V0RGVsaW0ob2xkKTtcbiAgICAgICAgdGhpcy5jbG9zZUJsb2NrKG5vZGUpO1xuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5lbnN1cmVOZXdMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNJbkJsYW5rKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09IHZvaWQgMCkgeyBjb250ZW50ID0gJyc7IH1cbiAgICAgICAgdGhpcy5mbHVzaENsb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLmRlbGltICYmIHRoaXMuaXNJbkJsYW5rKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ICs9IHRoaXMuZGVsaW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ICs9IGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY2xvc2VCbG9jayA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gbm9kZTtcbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBlc2NhcGVkKSB7XG4gICAgICAgIGlmIChlc2NhcGVkID09PSB2b2lkIDApIHsgZXNjYXBlZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGUoKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ICs9IGVzY2FwZWQgPyBlc2NhcGUkMShsaW5lc1tpXSkgOiBsaW5lc1tpXTtcbiAgICAgICAgICAgIGlmIChpICE9PSBsaW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY29udmVydEJsb2NrID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGUubmFtZTtcbiAgICAgICAgdmFyIGNvbnZlcnRvciA9IHRoaXMubm9kZVR5cGVDb252ZXJ0b3JzW3R5cGVdO1xuICAgICAgICB2YXIgbm9kZUluZm8gPSB7IG5vZGU6IG5vZGUsIHBhcmVudDogcGFyZW50LCBpbmRleDogaW5kZXggfTtcbiAgICAgICAgaWYgKG5vZGUuYXR0cnMuaHRtbEJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVUeXBlQ29udmVydG9ycy5odG1sKHRoaXMsIG5vZGVJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb252ZXJ0b3IpIHtcbiAgICAgICAgICAgIGNvbnZlcnRvcih0aGlzLCBub2RlSW5mbyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY29udmVydElubGluZSA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFjdGl2ZSA9IFtdO1xuICAgICAgICB2YXIgdHJhaWxpbmcgPSAnJztcbiAgICAgICAgdmFyIHByb2dyZXNzID0gZnVuY3Rpb24gKG5vZGUsIF8sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbWFya3MgPSBub2RlID8gbm9kZS5tYXJrcyA6IFtdO1xuICAgICAgICAgICAgdmFyIGxlYWRpbmcgPSB0cmFpbGluZztcbiAgICAgICAgICAgIHRyYWlsaW5nID0gJyc7XG4gICAgICAgICAgICAvLyBJZiB3aGl0ZXNwYWNlIGhhcyB0byBiZSBleHBlbGxlZCBmcm9tIHRoZSBub2RlLCBhZGp1c3RcbiAgICAgICAgICAgIC8vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIGFjY29yZGluZ2x5LlxuICAgICAgICAgICAgdmFyIHJlbW92ZWRXaGl0ZXNwYWNlID0gbm9kZSAmJlxuICAgICAgICAgICAgICAgIG5vZGUuaXNUZXh0ICYmXG4gICAgICAgICAgICAgICAgbWFya3Muc29tZShmdW5jdGlvbiAobWFyaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFya0NvbnZlcnRvciA9IF90aGlzLmdldE1hcmtDb252ZXJ0b3IobWFyayk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmZvID0gbWFya0NvbnZlcnRvciAmJiBtYXJrQ29udmVydG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmZvICYmIGluZm8ucmVtb3ZlZEVuY2xvc2luZ1doaXRlc3BhY2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZFdoaXRlc3BhY2UgJiYgbm9kZSAmJiBub2RlLnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSAvXihcXHMqKSguKj8pKFxccyopJC9tLmV4ZWMobm9kZS50ZXh0KSwgbGVhZCA9IF9hWzFdLCBtYXJrID0gX2FbMl0sIHRyYWlsID0gX2FbM107XG4gICAgICAgICAgICAgICAgbGVhZGluZyArPSBsZWFkO1xuICAgICAgICAgICAgICAgIHRyYWlsaW5nID0gdHJhaWw7XG4gICAgICAgICAgICAgICAgaWYgKGxlYWQgfHwgdHJhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAvLyB0eXBlIGlzIG5vdCBkZWZpbmVkIGZvciBcIndpdGhUZXh0XCIgaW4gcHJvc2VtaXJyb3ItbW9kZWxcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG1hcmsgPyBub2RlLndpdGhUZXh0KG1hcmspIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrcyA9IGFjdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsYXN0TWFyayA9IG1hcmtzLmxlbmd0aCAmJiBsYXN0JDEobWFya3MpO1xuICAgICAgICAgICAgdmFyIG1hcmtDb252ZXJ0b3IgPSBsYXN0TWFyayAmJiBfdGhpcy5nZXRNYXJrQ29udmVydG9yKGxhc3RNYXJrKTtcbiAgICAgICAgICAgIHZhciBtYXJrVHlwZSA9IG1hcmtDb252ZXJ0b3IgJiYgbWFya0NvbnZlcnRvcigpO1xuICAgICAgICAgICAgdmFyIG5vRXNjYXBlID0gbWFya1R5cGUgJiYgbWFya1R5cGUuZXNjYXBlID09PSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBtYXJrcy5sZW5ndGggLSAobm9Fc2NhcGUgPyAxIDogMCk7XG4gICAgICAgICAgICAvLyBUcnkgdG8gcmVvcmRlciAnbWl4YWJsZScgbWFya3MsIHN1Y2ggYXMgZW0gYW5kIHN0cm9uZywgd2hpY2hcbiAgICAgICAgICAgIC8vIGluIE1hcmtkb3duIG1heSBiZSBvcGVuZWQgYW5kIGNsb3NlZCBpbiBkaWZmZXJlbnQgb3JkZXIsIHNvXG4gICAgICAgICAgICAvLyB0aGF0IG9yZGVyIG9mIHRoZSBtYXJrcyBmb3IgdGhlIHRva2VuIG1hdGNoZXMgdGhlIG9yZGVyIGluXG4gICAgICAgICAgICAvLyBhY3RpdmUuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmsgPSBtYXJrc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUgJiYgIW1hcmtUeXBlLm1peGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWN0aXZlLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGFjdGl2ZVtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlICYmICFtYXJrVHlwZS5taXhhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWFyay5lcShvdGhlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIGopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQobWFyaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChtYXJrcy5zbGljZShqLCBpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChtYXJrcy5zbGljZShpICsgMSwgbGVuKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIGkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQobWFya3Muc2xpY2UoaSArIDEsIGopKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG1hcmspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQobWFya3Muc2xpY2UoaiwgbGVuKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHByZWZpeCBvZiB0aGUgbWFyayBzZXQgdGhhdCBkaWRuJ3QgY2hhbmdlXG4gICAgICAgICAgICB2YXIga2VlcCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoa2VlcCA8IE1hdGgubWluKGFjdGl2ZS5sZW5ndGgsIGxlbikgJiYgbWFya3Nba2VlcF0uZXEoYWN0aXZlW2tlZXBdKSkge1xuICAgICAgICAgICAgICAgIGtlZXAgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENsb3NlIHRoZSBtYXJrcyB0aGF0IG5lZWQgdG8gYmUgY2xvc2VkXG4gICAgICAgICAgICB3aGlsZSAoa2VlcCA8IGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlZE1hcmsgPSBhY3RpdmUucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZWRNYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRleHQoX3RoaXMubWFya1RleHQoYWN0aXZlZE1hcmssIGZhbHNlLCBwYXJlbnQsIGluZGV4KSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE91dHB1dCBhbnkgcHJldmlvdXNseSBleHBlbGxlZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG91dHNpZGUgdGhlIG1hcmtzXG4gICAgICAgICAgICBpZiAobGVhZGluZykge1xuICAgICAgICAgICAgICAgIF90aGlzLnRleHQobGVhZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPcGVuIHRoZSBtYXJrcyB0aGF0IG5lZWQgdG8gYmUgb3BlbmVkXG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChhY3RpdmUubGVuZ3RoIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXJrID0gbWFya3NbYWN0aXZlLmxlbmd0aF07XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKG1hcmspO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXh0KF90aGlzLm1hcmtUZXh0KG1hcmssIHRydWUsIHBhcmVudCwgaW5kZXgpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgbm9kZS4gU3BlY2lhbCBjYXNlIGNvZGUgbWFya3MsIHNpbmNlIHRoZWlyIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAvLyBtYXkgbm90IGJlIGVzY2FwZWQuXG4gICAgICAgICAgICAgICAgaWYgKG5vRXNjYXBlICYmIG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRleHQoX3RoaXMubWFya1RleHQobGFzdE1hcmssIHRydWUsIHBhcmVudCwgaW5kZXgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGV4dCArXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXJrVGV4dChsYXN0TWFyaywgZmFsc2UsIHBhcmVudCwgaW5kZXggKyAxKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29udmVydEJsb2NrKG5vZGUsIHBhcmVudCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcGFyZW50LmZvckVhY2gocHJvZ3Jlc3MpO1xuICAgICAgICBwcm9ncmVzcyhudWxsLCBudWxsLCBwYXJlbnQuY2hpbGRDb3VudCk7XG4gICAgfTtcbiAgICAvLyBSZW5kZXIgYSBub2RlJ3MgY29udGVudCBhcyBhIGxpc3QuIGBkZWxpbWAgc2hvdWxkIGJlIHRoZSBleHRyYVxuICAgIC8vIGluZGVudGF0aW9uIGFkZGVkIHRvIGFsbCBsaW5lcyBleGNlcHQgdGhlIGZpcnN0IGluIGFuIGl0ZW0sXG4gICAgLy8gYGZpcnN0RGVsaW1GbmAgaXMgYSBmdW5jdGlvbiBnb2luZyBmcm9tIGFuIGl0ZW0gaW5kZXggdG8gYVxuICAgIC8vIGRlbGltaXRlciBmb3IgdGhlIGZpcnN0IGxpbmUgb2YgdGhlIGl0ZW0uXG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5jb252ZXJ0TGlzdCA9IGZ1bmN0aW9uIChub2RlLCBkZWxpbSwgZmlyc3REZWxpbUZuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkICYmIHRoaXMuY2xvc2VkLnR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaENsb3NlKDMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudGlnaHRMaXN0KSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQ2xvc2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRpZ2h0ID0gKF9hID0gbm9kZS5hdHRycy50aWdodCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcbiAgICAgICAgdmFyIHByZXZUaWdodCA9IHRoaXMudGlnaHRMaXN0O1xuICAgICAgICB0aGlzLnRpZ2h0TGlzdCA9IHRpZ2h0O1xuICAgICAgICBub2RlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBfLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ICYmIHRpZ2h0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZmx1c2hDbG9zZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLndyYXBCbG9jayhkZWxpbSwgZmlyc3REZWxpbUZuKGluZGV4KSwgbm9kZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29udmVydEJsb2NrKGNoaWxkLCBub2RlLCBpbmRleCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50aWdodExpc3QgPSBwcmV2VGlnaHQ7XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLmNvbnZlcnRUYWJsZUNlbGwgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0b3BOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pblRhYmxlID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgXywgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlcyhbJ2J1bGxldExpc3QnLCAnb3JkZXJlZExpc3QnXSwgY2hpbGQudHlwZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnZlcnRCbG9jayhjaGlsZCwgbm9kZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udmVydElubGluZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbm9kZS5jaGlsZENvdW50IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENoaWxkID0gbm9kZS5jaGlsZChpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoaWxkLnR5cGUubmFtZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLndyaXRlKCc8YnI+Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0b3BOZXdsaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5UYWJsZSA9IGZhbHNlO1xuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5jb252ZXJ0Tm9kZSA9IGZ1bmN0aW9uIChwYXJlbnQsIGluZm9Gb3JQb3NTeW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBfLCBpbmRleCkge1xuICAgICAgICAgICAgX3RoaXMuY29udmVydEJsb2NrKG5vZGUsIHBhcmVudCwgaW5kZXgpO1xuICAgICAgICAgICAgaWYgKChpbmZvRm9yUG9zU3luYyA9PT0gbnVsbCB8fCBpbmZvRm9yUG9zU3luYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5mb0ZvclBvc1N5bmMubm9kZSkgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZVRleHRzID0gX3RoaXMucmVzdWx0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBpbmZvRm9yUG9zU3luYy5zZXRNYXBwZWRQb3MoW2xpbmVUZXh0cy5sZW5ndGgsIGxhc3QkMShsaW5lVGV4dHMpLmxlbmd0aCArIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBUb01kQ29udmVydG9yU3RhdGU7XG59KCkpO1xuXG52YXIgQ29udmVydG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnZlcnRvcihzY2hlbWEsIHRvTWRDb252ZXJ0b3JzLCB0b0hUTUxDb252ZXJ0b3JzLCBldmVudEVtaXR0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zZXRNYXBwZWRQb3MgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgICBfdGhpcy5tYXBwZWRQb3NXaGVuQ29udmVydGluZyA9IHBvcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gZXZlbnRFbWl0dGVyO1xuICAgICAgICB0aGlzLmZvY3VzZWROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXBwZWRQb3NXaGVuQ29udmVydGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMudG9Xd0NvbnZlcnRvcnMgPSBjcmVhdGVXd0NvbnZlcnRvcnModG9IVE1MQ29udmVydG9ycyk7XG4gICAgICAgIHRoaXMudG9NZENvbnZlcnRvcnMgPSBjcmVhdGVNZENvbnZlcnRvcnModG9NZENvbnZlcnRvcnMgfHwge30pO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ3NldEZvY3VzZWROb2RlJywgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIChfdGhpcy5mb2N1c2VkTm9kZSA9IG5vZGUpOyB9KTtcbiAgICB9XG4gICAgQ29udmVydG9yLnByb3RvdHlwZS5nZXRNYXBwZWRQb3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcHBlZFBvc1doZW5Db252ZXJ0aW5nO1xuICAgIH07XG4gICAgQ29udmVydG9yLnByb3RvdHlwZS5nZXRJbmZvRm9yUG9zU3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5mb2N1c2VkTm9kZSwgc2V0TWFwcGVkUG9zOiB0aGlzLnNldE1hcHBlZFBvcyB9O1xuICAgIH07XG4gICAgQ29udmVydG9yLnByb3RvdHlwZS50b1d5c2l3eWdNb2RlbCA9IGZ1bmN0aW9uIChtZE5vZGUpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gbmV3IFRvV3dDb252ZXJ0b3JTdGF0ZSh0aGlzLnNjaGVtYSwgdGhpcy50b1d3Q29udmVydG9ycyk7XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb252ZXJ0Tm9kZShtZE5vZGUsIHRoaXMuZ2V0SW5mb0ZvclBvc1N5bmMoKSk7XG4gICAgfTtcbiAgICBDb252ZXJ0b3IucHJvdG90eXBlLnRvTWFya2Rvd25UZXh0ID0gZnVuY3Rpb24gKHd3Tm9kZSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBuZXcgVG9NZENvbnZlcnRvclN0YXRlKHRoaXMudG9NZENvbnZlcnRvcnMpO1xuICAgICAgICB2YXIgbWFya2Rvd25UZXh0ID0gc3RhdGUuY29udmVydE5vZGUod3dOb2RlLCB0aGlzLmdldEluZm9Gb3JQb3NTeW5jKCkpO1xuICAgICAgICBtYXJrZG93blRleHQgPSB0aGlzLmV2ZW50RW1pdHRlci5lbWl0UmVkdWNlKCdiZWZvcmVDb252ZXJ0V3lzaXd5Z1RvTWFya2Rvd24nLCBtYXJrZG93blRleHQpO1xuICAgICAgICByZXR1cm4gbWFya2Rvd25UZXh0O1xuICAgIH07XG4gICAgcmV0dXJuIENvbnZlcnRvcjtcbn0oKSk7XG5cbmZ1bmN0aW9uIGV4ZWNQbHVnaW4ocGx1Z2luSW5mbykge1xuICAgIHZhciBwbHVnaW4gPSBwbHVnaW5JbmZvLnBsdWdpbiwgZXZlbnRFbWl0dGVyID0gcGx1Z2luSW5mby5ldmVudEVtaXR0ZXIsIHVzYWdlU3RhdGlzdGljcyA9IHBsdWdpbkluZm8udXNhZ2VTdGF0aXN0aWNzLCBpbnN0YW5jZSA9IHBsdWdpbkluZm8uaW5zdGFuY2U7XG4gICAgdmFyIHBtU3RhdGUgPSB7IFBsdWdpbjogUGx1Z2luLCBQbHVnaW5LZXk6IFBsdWdpbktleSwgU2VsZWN0aW9uOiBTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb246IFRleHRTZWxlY3Rpb24gfTtcbiAgICB2YXIgcG1WaWV3ID0geyBEZWNvcmF0aW9uOiBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0OiBEZWNvcmF0aW9uU2V0IH07XG4gICAgdmFyIHBtTW9kZWwgPSB7IEZyYWdtZW50OiBGcmFnbWVudCB9O1xuICAgIHZhciBwbVJ1bGVzID0geyBJbnB1dFJ1bGU6IElucHV0UnVsZSwgaW5wdXRSdWxlczogaW5wdXRSdWxlcywgdW5kb0lucHV0UnVsZTogdW5kb0lucHV0UnVsZSB9O1xuICAgIHZhciBwbUtleW1hcCA9IHsga2V5bWFwOiBrZXltYXAgfTtcbiAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgZXZlbnRFbWl0dGVyOiBldmVudEVtaXR0ZXIsXG4gICAgICAgIHVzYWdlU3RhdGlzdGljczogdXNhZ2VTdGF0aXN0aWNzLFxuICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgIHBtU3RhdGU6IHBtU3RhdGUsXG4gICAgICAgIHBtVmlldzogcG1WaWV3LFxuICAgICAgICBwbU1vZGVsOiBwbU1vZGVsLFxuICAgICAgICBwbVJ1bGVzOiBwbVJ1bGVzLFxuICAgICAgICBwbUtleW1hcDogcG1LZXltYXAsXG4gICAgICAgIGkxOG46IGkxOG4sXG4gICAgfTtcbiAgICBpZiAoaXNBcnJheV8xKHBsdWdpbikpIHtcbiAgICAgICAgdmFyIHBsdWdpbkZuID0gcGx1Z2luWzBdLCBfYSA9IHBsdWdpblsxXSwgb3B0aW9ucyA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hO1xuICAgICAgICByZXR1cm4gcGx1Z2luRm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBwbHVnaW4oY29udGV4dCk7XG59XG5mdW5jdGlvbiBnZXRQbHVnaW5JbmZvKHBsdWdpbnNJbmZvKSB7XG4gICAgdmFyIHBsdWdpbnMgPSBwbHVnaW5zSW5mby5wbHVnaW5zLCBldmVudEVtaXR0ZXIgPSBwbHVnaW5zSW5mby5ldmVudEVtaXR0ZXIsIHVzYWdlU3RhdGlzdGljcyA9IHBsdWdpbnNJbmZvLnVzYWdlU3RhdGlzdGljcywgaW5zdGFuY2UgPSBwbHVnaW5zSW5mby5pbnN0YW5jZTtcbiAgICBldmVudEVtaXR0ZXIubGlzdGVuKCdtaXhpblRhYmxlT2Zmc2V0TWFwUHJvdG90eXBlJywgbWl4aW5UYWJsZU9mZnNldE1hcFByb3RvdHlwZSk7XG4gICAgcmV0dXJuIChwbHVnaW5zICE9PSBudWxsICYmIHBsdWdpbnMgIT09IHZvaWQgMCA/IHBsdWdpbnMgOiBbXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsdWdpbikge1xuICAgICAgICB2YXIgcGx1Z2luSW5mb1Jlc3VsdCA9IGV4ZWNQbHVnaW4oe1xuICAgICAgICAgICAgcGx1Z2luOiBwbHVnaW4sXG4gICAgICAgICAgICBldmVudEVtaXR0ZXI6IGV2ZW50RW1pdHRlcixcbiAgICAgICAgICAgIHVzYWdlU3RhdGlzdGljczogdXNhZ2VTdGF0aXN0aWNzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwbHVnaW5JbmZvUmVzdWx0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGV4ZWN1dGVkIHBsdWdpbiBpcyBlbXB0eS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFya2Rvd25QYXJzZXJzID0gcGx1Z2luSW5mb1Jlc3VsdC5tYXJrZG93blBhcnNlcnMsIHRvSFRNTFJlbmRlcmVycyA9IHBsdWdpbkluZm9SZXN1bHQudG9IVE1MUmVuZGVyZXJzLCB0b01hcmtkb3duUmVuZGVyZXJzID0gcGx1Z2luSW5mb1Jlc3VsdC50b01hcmtkb3duUmVuZGVyZXJzLCBtYXJrZG93blBsdWdpbnMgPSBwbHVnaW5JbmZvUmVzdWx0Lm1hcmtkb3duUGx1Z2lucywgd3lzaXd5Z1BsdWdpbnMgPSBwbHVnaW5JbmZvUmVzdWx0Lnd5c2l3eWdQbHVnaW5zLCB3eXNpd3lnTm9kZVZpZXdzID0gcGx1Z2luSW5mb1Jlc3VsdC53eXNpd3lnTm9kZVZpZXdzLCBtYXJrZG93bkNvbW1hbmRzID0gcGx1Z2luSW5mb1Jlc3VsdC5tYXJrZG93bkNvbW1hbmRzLCB3eXNpd3lnQ29tbWFuZHMgPSBwbHVnaW5JbmZvUmVzdWx0Lnd5c2l3eWdDb21tYW5kcywgdG9vbGJhckl0ZW1zID0gcGx1Z2luSW5mb1Jlc3VsdC50b29sYmFySXRlbXM7XG4gICAgICAgIGlmICh0b0hUTUxSZW5kZXJlcnMpIHtcbiAgICAgICAgICAgIGFjYy50b0hUTUxSZW5kZXJlcnMgPSBkZWVwTWVyZ2VkQ29weShhY2MudG9IVE1MUmVuZGVyZXJzLCB0b0hUTUxSZW5kZXJlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b01hcmtkb3duUmVuZGVyZXJzKSB7XG4gICAgICAgICAgICBhY2MudG9NYXJrZG93blJlbmRlcmVycyA9IGRlZXBNZXJnZWRDb3B5KGFjYy50b01hcmtkb3duUmVuZGVyZXJzLCB0b01hcmtkb3duUmVuZGVyZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2Rvd25QbHVnaW5zKSB7XG4gICAgICAgICAgICBhY2MubWRQbHVnaW5zID0gYWNjLm1kUGx1Z2lucy5jb25jYXQobWFya2Rvd25QbHVnaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3lzaXd5Z1BsdWdpbnMpIHtcbiAgICAgICAgICAgIGFjYy53d1BsdWdpbnMgPSBhY2Mud3dQbHVnaW5zLmNvbmNhdCh3eXNpd3lnUGx1Z2lucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHd5c2l3eWdOb2RlVmlld3MpIHtcbiAgICAgICAgICAgIGFjYy53d05vZGVWaWV3cyA9IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgYWNjLnd3Tm9kZVZpZXdzKSwgd3lzaXd5Z05vZGVWaWV3cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtkb3duQ29tbWFuZHMpIHtcbiAgICAgICAgICAgIGFjYy5tZENvbW1hbmRzID0gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBhY2MubWRDb21tYW5kcyksIG1hcmtkb3duQ29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3eXNpd3lnQ29tbWFuZHMpIHtcbiAgICAgICAgICAgIGFjYy53d0NvbW1hbmRzID0gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBhY2Mud3dDb21tYW5kcyksIHd5c2l3eWdDb21tYW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvb2xiYXJJdGVtcykge1xuICAgICAgICAgICAgYWNjLnRvb2xiYXJJdGVtcyA9IGFjYy50b29sYmFySXRlbXMuY29uY2F0KHRvb2xiYXJJdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtkb3duUGFyc2Vycykge1xuICAgICAgICAgICAgYWNjLm1hcmtkb3duUGFyc2VycyA9IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgYWNjLm1hcmtkb3duUGFyc2VycyksIG1hcmtkb3duUGFyc2Vycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7XG4gICAgICAgIHRvSFRNTFJlbmRlcmVyczoge30sXG4gICAgICAgIHRvTWFya2Rvd25SZW5kZXJlcnM6IHt9LFxuICAgICAgICBtZFBsdWdpbnM6IFtdLFxuICAgICAgICB3d1BsdWdpbnM6IFtdLFxuICAgICAgICB3d05vZGVWaWV3czoge30sXG4gICAgICAgIG1kQ29tbWFuZHM6IHt9LFxuICAgICAgICB3d0NvbW1hbmRzOiB7fSxcbiAgICAgICAgdG9vbGJhckl0ZW1zOiBbXSxcbiAgICAgICAgbWFya2Rvd25QYXJzZXJzOiB7fSxcbiAgICB9KTtcbn1cblxudmFyIFRBU0tfQVRUUl9OQU1FID0gJ2RhdGEtdGFzayc7XG52YXIgRElTQUJMRURfVEFTS19BVFRSX05BTUUgPSAnZGF0YS10YXNrLWRpc2FibGVkJztcbnZhciBUQVNLX0NIRUNLRURfQ0xBU1NfTkFNRSA9ICdjaGVja2VkJztcbmZ1bmN0aW9uIHJlZ2lzdGVySFRNTFRhZ1RvV2hpdGVsaXN0KGNvbnZlcnRvck1hcCkge1xuICAgIFsnaHRtbEJsb2NrJywgJ2h0bWxJbmxpbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChodG1sVHlwZSkge1xuICAgICAgICBpZiAoY29udmVydG9yTWFwW2h0bWxUeXBlXSkge1xuICAgICAgICAgICAgLy8gcmVnaXN0ZXIgdGFnIHdoaXRlIGxpc3QgZm9yIHByZXZlbnRpbmcgdG8gcmVtb3ZlIHRoZSBodG1sIGluIHNhbml0aXplclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udmVydG9yTWFwW2h0bWxUeXBlXSkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gcmVnaXN0ZXJUYWdXaGl0ZWxpc3RJZlBvc3NpYmxlKHR5cGUpOyB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBDbGFzcyBUb2FzdFVJRWRpdG9yVmlld2VyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPcHRpb24gb2JqZWN0XG4gKiAgICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5lbCAtIGNvbnRhaW5lciBlbGVtZW50XG4gKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmluaXRpYWxWYWx1ZV0gRWRpdG9yJ3MgaW5pdGlhbCB2YWx1ZVxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5ldmVudHNdIC0gRXZlbnRzXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5sb2FkXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBlZGl0b3IgZnVsbHkgbG9hZFxuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuY2hhbmdlXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBjb250ZW50IGNoYW5nZWRcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmNhcmV0Q2hhbmdlXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBmb3JtYXQgY2hhbmdlIGJ5IGN1cnNvciBwb3NpdGlvblxuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuZm9jdXNdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGVkaXRvciBnZXQgZm9jdXNcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmJsdXJdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGVkaXRvciBsb29zZSBmb2N1c1xuICogICAgIEBwYXJhbSB7QXJyYXkuPGZ1bmN0aW9ufEFycmF5Pn0gW29wdGlvbnMucGx1Z2luc10gLSBBcnJheSBvZiBwbHVnaW5zLiBBIHBsdWdpbiBjYW4gYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkgaW4gdGhlIGZvcm0gb2YgW2Z1bmN0aW9uLCBvcHRpb25zXS5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZXh0ZW5kZWRBdXRvbGlua3NdIC0gVXNpbmcgZXh0ZW5kZWQgQXV0b2xpbmtzIHNwZWNpZmllZCBpbiBHRk0gc3BlY1xuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5saW5rQXR0cmlidXRlc10gLSBBdHRyaWJ1dGVzIG9mIGFuY2hvciBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHJlbCwgdGFyZ2V0LCBocmVmbGFuZywgdHlwZVxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jdXN0b21IVE1MUmVuZGVyZXI9bnVsbF0gLSBPYmplY3QgY29udGFpbmluZyBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb25zIGNvcnJlc3BvbmQgdG8gY2hhbmdlIG1hcmtkb3duIG5vZGUgdG8gcHJldmlldyBIVE1MIG9yIHd5c2l3eWcgbm9kZVxuICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVmZXJlbmNlRGVmaW5pdGlvbj1mYWxzZV0gLSB3aGV0aGVyIHVzZSB0aGUgc3BlY2lmaWNhdGlvbiBvZiBsaW5rIHJlZmVyZW5jZSBkZWZpbml0aW9uXG4gKiAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuY3VzdG9tSFRNTFNhbml0aXplcj1udWxsXSAtIGN1c3RvbSBIVE1MIHNhbml0aXplclxuICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZnJvbnRNYXR0ZXI9ZmFsc2VdIC0gd2hldGhlciB1c2UgdGhlIGZyb250IG1hdHRlclxuICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50aGVtZV0gLSBUaGUgdGhlbWUgdG8gc3R5bGUgdGhlIHZpZXdlciB3aXRoLiBUaGUgZGVmYXVsdCBpcyBpbmNsdWRlZCBpbiB0b2FzdHVpLWVkaXRvci5jc3MuXG4gKi9cbnZhciBUb2FzdFVJRWRpdG9yVmlld2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvYXN0VUlFZGl0b3JWaWV3ZXIob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmRfMSh7XG4gICAgICAgICAgICBsaW5rQXR0cmlidXRlczogbnVsbCxcbiAgICAgICAgICAgIGV4dGVuZGVkQXV0b2xpbmtzOiBmYWxzZSxcbiAgICAgICAgICAgIGN1c3RvbUhUTUxSZW5kZXJlcjogbnVsbCxcbiAgICAgICAgICAgIHJlZmVyZW5jZURlZmluaXRpb246IGZhbHNlLFxuICAgICAgICAgICAgY3VzdG9tSFRNTFNhbml0aXplcjogbnVsbCxcbiAgICAgICAgICAgIGZyb250TWF0dGVyOiBmYWxzZSxcbiAgICAgICAgICAgIHVzYWdlU3RhdGlzdGljczogdHJ1ZSxcbiAgICAgICAgICAgIHRoZW1lOiAnbGlnaHQnLFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHZhciBsaW5rQXR0cmlidXRlcyA9IHNhbml0aXplTGlua0F0dHJpYnV0ZSh0aGlzLm9wdGlvbnMubGlua0F0dHJpYnV0ZXMpO1xuICAgICAgICB2YXIgX2EgPSBnZXRQbHVnaW5JbmZvKHtcbiAgICAgICAgICAgIHBsdWdpbnM6IHRoaXMub3B0aW9ucy5wbHVnaW5zLFxuICAgICAgICAgICAgZXZlbnRFbWl0dGVyOiB0aGlzLmV2ZW50RW1pdHRlcixcbiAgICAgICAgICAgIHVzYWdlU3RhdGlzdGljczogdGhpcy5vcHRpb25zLnVzYWdlU3RhdGlzdGljcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLFxuICAgICAgICB9KSB8fCB7fSwgdG9IVE1MUmVuZGVyZXJzID0gX2EudG9IVE1MUmVuZGVyZXJzLCBtYXJrZG93blBhcnNlcnMgPSBfYS5tYXJrZG93blBhcnNlcnM7XG4gICAgICAgIHZhciBfYiA9IHRoaXMub3B0aW9ucywgY3VzdG9tSFRNTFJlbmRlcmVyID0gX2IuY3VzdG9tSFRNTFJlbmRlcmVyLCBleHRlbmRlZEF1dG9saW5rcyA9IF9iLmV4dGVuZGVkQXV0b2xpbmtzLCByZWZlcmVuY2VEZWZpbml0aW9uID0gX2IucmVmZXJlbmNlRGVmaW5pdGlvbiwgZnJvbnRNYXR0ZXIgPSBfYi5mcm9udE1hdHRlciwgY3VzdG9tSFRNTFNhbml0aXplciA9IF9iLmN1c3RvbUhUTUxTYW5pdGl6ZXI7XG4gICAgICAgIHZhciByZW5kZXJlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBsaW5rQXR0cmlidXRlczogbGlua0F0dHJpYnV0ZXMsXG4gICAgICAgICAgICBjdXN0b21IVE1MUmVuZGVyZXI6IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgdG9IVE1MUmVuZGVyZXJzKSwgY3VzdG9tSFRNTFJlbmRlcmVyKSxcbiAgICAgICAgICAgIGV4dGVuZGVkQXV0b2xpbmtzOiBleHRlbmRlZEF1dG9saW5rcyxcbiAgICAgICAgICAgIHJlZmVyZW5jZURlZmluaXRpb246IHJlZmVyZW5jZURlZmluaXRpb24sXG4gICAgICAgICAgICBmcm9udE1hdHRlcjogZnJvbnRNYXR0ZXIsXG4gICAgICAgICAgICBzYW5pdGl6ZXI6IGN1c3RvbUhUTUxTYW5pdGl6ZXIgfHwgc2FuaXRpemVIVE1MLFxuICAgICAgICB9O1xuICAgICAgICByZWdpc3RlckhUTUxUYWdUb1doaXRlbGlzdChyZW5kZXJlck9wdGlvbnMuY3VzdG9tSFRNTFJlbmRlcmVyKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ldmVudHMpIHtcbiAgICAgICAgICAgIGZvckVhY2hPd25Qcm9wZXJ0aWVzXzEodGhpcy5vcHRpb25zLmV2ZW50cywgZnVuY3Rpb24gKGZuLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbihrZXksIGZuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYyA9IHRoaXMub3B0aW9ucywgZWwgPSBfYy5lbCwgaW5pdGlhbFZhbHVlID0gX2MuaW5pdGlhbFZhbHVlLCB0aGVtZSA9IF9jLnRoZW1lO1xuICAgICAgICB2YXIgZXhpc3RpbmdIVE1MID0gZWwuaW5uZXJIVE1MO1xuICAgICAgICBpZiAodGhlbWUgIT09ICdsaWdodCcpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKHRoZW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHRoaXMudG9hc3RNYXJrID0gbmV3IFRvYXN0TWFyaygnJywge1xuICAgICAgICAgICAgZGlzYWxsb3dlZEh0bWxCbG9ja1RhZ3M6IFsnYnInLCAnaW1nJ10sXG4gICAgICAgICAgICBleHRlbmRlZEF1dG9saW5rczogZXh0ZW5kZWRBdXRvbGlua3MsXG4gICAgICAgICAgICByZWZlcmVuY2VEZWZpbml0aW9uOiByZWZlcmVuY2VEZWZpbml0aW9uLFxuICAgICAgICAgICAgZGlzYWxsb3dEZWVwSGVhZGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGZyb250TWF0dGVyOiBmcm9udE1hdHRlcixcbiAgICAgICAgICAgIGN1c3RvbVBhcnNlcjogbWFya2Rvd25QYXJzZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcmV2aWV3ID0gbmV3IE1hcmtkb3duUHJldmlldyh0aGlzLmV2ZW50RW1pdHRlciwgX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCByZW5kZXJlck9wdGlvbnMpLCB7IGlzVmlld2VyOiB0cnVlIH0pKTtcbiAgICAgICAgb25fMSh0aGlzLnByZXZpZXcucHJldmlld0NvbnRlbnQsICdtb3VzZWRvd24nLCB0aGlzLnRvZ2dsZVRhc2suYmluZCh0aGlzKSk7XG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TWFya2Rvd24oaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleGlzdGluZ0hUTUwpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlldy5zZXRIVE1MKGV4aXN0aW5nSFRNTCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5wcmV2aWV3LnByZXZpZXdDb250ZW50KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnbG9hZCcsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGFzayBieSBkZXRlY3RpbmcgbW91c2Vkb3duIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXYgLSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUudG9nZ2xlVGFzayA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB2YXIgZWxlbWVudCA9IGV2LnRhcmdldDtcbiAgICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnOmJlZm9yZScpO1xuICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKERJU0FCTEVEX1RBU0tfQVRUUl9OQU1FKSAmJlxuICAgICAgICAgICAgZWxlbWVudC5oYXNBdHRyaWJ1dGUoVEFTS19BVFRSX05BTUUpICYmXG4gICAgICAgICAgICBpc1Bvc2l0aW9uSW5Cb3goc3R5bGUsIGV2Lm9mZnNldFgsIGV2Lm9mZnNldFkpKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhlbGVtZW50LCBUQVNLX0NIRUNLRURfQ0xBU1NfTkFNRSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgc291cmNlOiAndmlld2VyJyxcbiAgICAgICAgICAgICAgICBkYXRlOiBldixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgY29udGVudCBmb3IgcHJldmlld1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZG93biBNYXJrZG93biB0ZXh0XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuc2V0TWFya2Rvd24gPSBmdW5jdGlvbiAobWFya2Rvd24pIHtcbiAgICAgICAgdmFyIGxpbmVUZXh0cyA9IHRoaXMudG9hc3RNYXJrLmdldExpbmVUZXh0cygpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGluZVRleHRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGxhc3RMaW5lID0gbGFzdCQxKGxpbmVUZXh0cyk7XG4gICAgICAgIHZhciBlbmRTb3VyY2Vwb3MgPSBbbGVuZ3RoLCBsYXN0TGluZS5sZW5ndGggKyAxXTtcbiAgICAgICAgdmFyIGVkaXRSZXN1bHQgPSB0aGlzLnRvYXN0TWFyay5lZGl0TWFya2Rvd24oWzEsIDFdLCBlbmRTb3VyY2Vwb3MsIG1hcmtkb3duIHx8ICcnKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgndXBkYXRlUHJldmlldycsIGVkaXRSZXN1bHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQmluZCBldmVudEhhbmRsZXIgdG8gZXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIEV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3Rlbih0eXBlLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuYmluZCBldmVudEhhbmRsZXIgZnJvbSBldmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50SGFuZGxlcih0eXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBob29rIHRvIFRVSUVkaXRvciBldmVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIEV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS5hZGRIb29rID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRIYW5kbGVyKHR5cGUpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4odHlwZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgVmlld2VyIHByZXZpZXcgZnJvbSBkb2N1bWVudFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9mZl8xKHRoaXMucHJldmlldy5lbCwgJ21vdXNlZG93bicsIHRoaXMudG9nZ2xlVGFzay5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5wcmV2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnZGVzdHJveScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS5pc1ZpZXdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS5pc01hcmtkb3duTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGZhbHNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuaXNXeXNpd3lnTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIFRvYXN0VUlFZGl0b3JWaWV3ZXI7XG59KCkpO1xuXG5mdW5jdGlvbiBpc1BtTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBOb2RlJDM7XG59XG5mdW5jdGlvbiBpc0NvbnRhaW5lcih0eXBlKSB7XG4gICAgdmFyIGNvbnRhaW5lclR5cGVzID0gW1xuICAgICAgICAnZG9jdW1lbnQnLFxuICAgICAgICAnYmxvY2tRdW90ZScsXG4gICAgICAgICdidWxsZXRMaXN0JyxcbiAgICAgICAgJ29yZGVyZWRMaXN0JyxcbiAgICAgICAgJ2xpc3RJdGVtJyxcbiAgICAgICAgJ3BhcmFncmFwaCcsXG4gICAgICAgICdoZWFkaW5nJyxcbiAgICAgICAgJ2VtcGgnLFxuICAgICAgICAnc3Ryb25nJyxcbiAgICAgICAgJ3N0cmlrZScsXG4gICAgICAgICdsaW5rJyxcbiAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgJ3RhYmxlJyxcbiAgICAgICAgJ3RhYmxlSGVhZCcsXG4gICAgICAgICd0YWJsZUJvZHknLFxuICAgICAgICAndGFibGVSb3cnLFxuICAgICAgICAndGFibGVIZWFkQ2VsbCcsXG4gICAgICAgICd0YWJsZUJvZHlDZWxsJyxcbiAgICBdO1xuICAgIHJldHVybiBpbmNsdWRlcyhjb250YWluZXJUeXBlcywgdHlwZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVNZExpa2VOb2RlKG5vZGUpIHtcbiAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJzLCB0eXBlID0gbm9kZS50eXBlO1xuICAgIHZhciBub2RlVHlwZSA9IHR5cGUubmFtZTtcbiAgICB2YXIgbWRMaWtlTm9kZSA9IHtcbiAgICAgICAgdHlwZTogbm9kZVR5cGUsXG4gICAgICAgIHd5c2l3eWdOb2RlOiB0cnVlLFxuICAgICAgICBsaXRlcmFsOiAhaXNDb250YWluZXIobm9kZVR5cGUpICYmIGlzUG1Ob2RlKG5vZGUpID8gbm9kZS50ZXh0Q29udGVudCA6IG51bGwsXG4gICAgfTtcbiAgICB2YXIgbm9kZVR5cGVNYXAgPSB7XG4gICAgICAgIGhlYWRpbmc6IHsgbGV2ZWw6IGF0dHJzLmxldmVsIH0sXG4gICAgICAgIGxpbms6IHsgZGVzdGluYXRpb246IGF0dHJzLmxpbmtVcmwsIHRpdGxlOiBhdHRycy50aXRsZSB9LFxuICAgICAgICBpbWFnZTogeyBkZXN0aW5hdGlvbjogYXR0cnMuaW1hZ2VVcmwgfSxcbiAgICAgICAgY29kZUJsb2NrOiB7IGluZm86IGF0dHJzLmxhbmd1YWdlIH0sXG4gICAgICAgIGJ1bGxldExpc3Q6IHsgdHlwZTogJ2xpc3QnLCBsaXN0RGF0YTogeyB0eXBlOiAnYnVsbGV0JyB9IH0sXG4gICAgICAgIG9yZGVyZWRMaXN0OiB7IHR5cGU6ICdsaXN0JywgbGlzdERhdGE6IHsgdHlwZTogJ29yZGVyZWQnLCBzdGFydDogYXR0cnMub3JkZXIgfSB9LFxuICAgICAgICBsaXN0SXRlbTogeyB0eXBlOiAnaXRlbScsIGxpc3REYXRhOiB7IHRhc2s6IGF0dHJzLnRhc2ssIGNoZWNrZWQ6IGF0dHJzLmNoZWNrZWQgfSB9LFxuICAgICAgICB0YWJsZUhlYWRDZWxsOiB7IHR5cGU6ICd0YWJsZUNlbGwnLCBjZWxsVHlwZTogJ2hlYWQnLCBhbGlnbjogYXR0cnMuYWxpZ24gfSxcbiAgICAgICAgdGFibGVCb2R5Q2VsbDogeyB0eXBlOiAndGFibGVDZWxsJywgY2VsbFR5cGU6ICdib2R5JywgYWxpZ246IGF0dHJzLmFsaWduIH0sXG4gICAgICAgIGN1c3RvbUJsb2NrOiB7IGluZm86IGF0dHJzLmluZm8gfSxcbiAgICB9O1xuICAgIHZhciBub2RlSW5mbyA9IG5vZGVUeXBlTWFwW25vZGVUeXBlXTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgbWRMaWtlTm9kZSksIG5vZGVJbmZvKTtcbiAgICAvLyBodG1sIGJsb2NrLCBpbmxpbmUgbm9kZVxuICAgIHZhciBfYSA9IG5vZGUuYXR0cnMsIGh0bWxBdHRycyA9IF9hLmh0bWxBdHRycywgY2hpbGRyZW5IVE1MID0gX2EuY2hpbGRyZW5IVE1MO1xuICAgIGlmIChodG1sQXR0cnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgYXR0cmlidXRlcyksIHsgYXR0cnM6IGh0bWxBdHRycywgY2hpbGRyZW5IVE1MOiBjaGlsZHJlbkhUTUwgfSk7XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xufVxuXG52YXIgdG9rZW5Ub0RPTU5vZGUgPSB7XG4gICAgb3BlblRhZzogZnVuY3Rpb24gKHRva2VuLCBzdGFjaykge1xuICAgICAgICB2YXIgX2EgPSB0b2tlbiwgdGFnTmFtZSA9IF9hLnRhZ05hbWUsIGNsYXNzTmFtZXMgPSBfYS5jbGFzc05hbWVzLCBhdHRyaWJ1dGVzID0gX2EuYXR0cmlidXRlcztcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICAgIGlmIChjbGFzc05hbWVzKSB7XG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWVzLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgYXR0cnMgPSBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGF0dHJzKSwgYXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0QXR0cmlidXRlcyhhdHRycywgZWwpO1xuICAgICAgICBzdGFjay5wdXNoKGVsKTtcbiAgICB9LFxuICAgIGNsb3NlVGFnOiBmdW5jdGlvbiAoXywgc3RhY2spIHtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgbGFzdCQxKHN0YWNrKS5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGh0bWw6IGZ1bmN0aW9uICh0b2tlbiwgc3RhY2spIHtcbiAgICAgICAgbGFzdCQxKHN0YWNrKS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIHRva2VuLmNvbnRlbnQpO1xuICAgIH0sXG4gICAgdGV4dDogZnVuY3Rpb24gKHRva2VuLCBzdGFjaykge1xuICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0b2tlbi5jb250ZW50KTtcbiAgICAgICAgbGFzdCQxKHN0YWNrKS5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgfSxcbn07XG52YXIgV3dUb0RPTUFkYXB0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV3dUb0RPTUFkYXB0b3IobGlua0F0dHJpYnV0ZXMsIGN1c3RvbVJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBjb252ZXJ0b3JzID0gZ2V0SFRNTFJlbmRlckNvbnZlcnRvcnMobGlua0F0dHJpYnV0ZXMsIGN1c3RvbVJlbmRlcmVyKTtcbiAgICAgICAgdmFyIGN1c3RvbUhUTUxDb252ZXJ0b3IgPSBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGN1c3RvbVJlbmRlcmVyLmh0bWxCbG9jayksIGN1c3RvbVJlbmRlcmVyLmh0bWxJbmxpbmUpO1xuICAgICAgICAvLyBmbGF0dGVuIHRoZSBodG1sIGJsb2NrLCBpbmxpbmUgY29udmVydG9yIHRvIG90aGVyIGN1c3RvbSBjb252ZXJ0b3JzXG4gICAgICAgIHRoaXMuY3VzdG9tQ29udmVydG9yS2V5cyA9IE9iamVjdC5rZXlzKGN1c3RvbVJlbmRlcmVyKS5jb25jYXQoT2JqZWN0LmtleXMoY3VzdG9tSFRNTENvbnZlcnRvcikpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKHtcbiAgICAgICAgICAgIGdmbTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnZlcnRvcnM6IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgY29udmVydG9ycyksIGN1c3RvbUhUTUxDb252ZXJ0b3IpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb252ZXJ0b3JzID0gdGhpcy5yZW5kZXJlci5nZXRDb252ZXJ0b3JzKCk7XG4gICAgfVxuICAgIFd3VG9ET01BZGFwdG9yLnByb3RvdHlwZS5nZW5lcmF0ZVRva2VucyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBtZExpa2VOb2RlID0gY3JlYXRlTWRMaWtlTm9kZShub2RlKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICBlbnRlcmluZzogdHJ1ZSxcbiAgICAgICAgICAgIGxlYWY6IGlzUG1Ob2RlKG5vZGUpID8gbm9kZS5pc0xlYWYgOiBmYWxzZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMucmVuZGVyZXIuZ2V0T3B0aW9ucygpLFxuICAgICAgICAgICAgZ2V0Q2hpbGRyZW5UZXh0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAoaXNQbU5vZGUobm9kZSkgPyBub2RlLnRleHRDb250ZW50IDogJycpOyB9LFxuICAgICAgICAgICAgc2tpcENoaWxkcmVuOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbnZlcnRvciA9IHRoaXMuY29udmVydG9yc1tub2RlLnR5cGUubmFtZV07XG4gICAgICAgIHZhciBjb252ZXJ0ZWQgPSBjb252ZXJ0b3IobWRMaWtlTm9kZSwgY29udGV4dCwgdGhpcy5jb252ZXJ0b3JzKTtcbiAgICAgICAgdmFyIHRva2VucyA9IGlzQXJyYXlfMShjb252ZXJ0ZWQpID8gY29udmVydGVkIDogW2NvbnZlcnRlZF07XG4gICAgICAgIGlmIChpc0NvbnRhaW5lcihub2RlLnR5cGUubmFtZSkgfHwgbm9kZS5hdHRycy5odG1sSW5saW5lKSB7XG4gICAgICAgICAgICBjb250ZXh0LmVudGVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICd0ZXh0JywgY29udGVudDogaXNQbU5vZGUobm9kZSkgPyBub2RlLnRleHRDb250ZW50IDogJycgfSk7XG4gICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KGNvbnZlcnRvcihtZExpa2VOb2RlLCBjb250ZXh0LCB0aGlzLmNvbnZlcnRvcnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH07XG4gICAgV3dUb0RPTUFkYXB0b3IucHJvdG90eXBlLnRvRE9NTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLmdlbmVyYXRlVG9rZW5zKG5vZGUpO1xuICAgICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgICAgdG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlblRvRE9NTm9kZVt0b2tlbi50eXBlXSh0b2tlbiwgc3RhY2spOyB9KTtcbiAgICAgICAgcmV0dXJuIHN0YWNrWzBdO1xuICAgIH07XG4gICAgV3dUb0RPTUFkYXB0b3IucHJvdG90eXBlLmdldFRvRE9NTm9kZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChpbmNsdWRlcyh0aGlzLmN1c3RvbUNvbnZlcnRvcktleXMsIG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0RPTU5vZGUuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBXd1RvRE9NQWRhcHRvcjtcbn0oKSk7XG5cbnZhciBBTklNQVRJT05fVElNRSA9IDEwMDtcbnZhciBTQ1JPTExfQkxPQ0tJTkdfUkVTRVRfREVMQVkgPSAxNTtcbnZhciBjdXJyZW50VGltZW91dElkID0gbnVsbDtcbnZhciByZWxlYXNlVGltZXIgPSBudWxsO1xuZnVuY3Rpb24gcnVuKGRlbHRhU2Nyb2xsVG9wLCBfYSkge1xuICAgIHZhciBzeW5jU2Nyb2xsVG9wID0gX2Euc3luY1Njcm9sbFRvcCwgcmVsZWFzZUV2ZW50QmxvY2sgPSBfYS5yZWxlYXNlRXZlbnRCbG9jaztcbiAgICBpZiAocmVsZWFzZVRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChyZWxlYXNlVGltZXIpO1xuICAgIH1cbiAgICBzeW5jU2Nyb2xsVG9wKGRlbHRhU2Nyb2xsVG9wKTtcbiAgICByZWxlYXNlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVsZWFzZUV2ZW50QmxvY2soKTtcbiAgICB9LCBTQ1JPTExfQkxPQ0tJTkdfUkVTRVRfREVMQVkpO1xufVxuZnVuY3Rpb24gYW5pbWF0ZShjdXJTY3JvbGxUb3AsIHRhcmdldFNjcm9sbFRvcCwgc3luY0NhbGxiYWNrcykge1xuICAgIHZhciBkaWZmID0gdGFyZ2V0U2Nyb2xsVG9wIC0gY3VyU2Nyb2xsVG9wO1xuICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHZhciBzdGVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RlcFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSAoc3RlcFRpbWUgLSBzdGFydFRpbWUpIC8gQU5JTUFUSU9OX1RJTUU7XG4gICAgICAgIHZhciBkZWx0YVZhbHVlO1xuICAgICAgICBpZiAoY3VycmVudFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGN1cnJlbnRUaW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmVzcyA8IDEpIHtcbiAgICAgICAgICAgIGRlbHRhVmFsdWUgPSBjdXJTY3JvbGxUb3AgKyBkaWZmICogTWF0aC5jb3MoKCgxIC0gcHJvZ3Jlc3MpICogTWF0aC5QSSkgLyAyKTtcbiAgICAgICAgICAgIHJ1bihNYXRoLmNlaWwoZGVsdGFWYWx1ZSksIHN5bmNDYWxsYmFja3MpO1xuICAgICAgICAgICAgY3VycmVudFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoc3RlcCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBydW4odGFyZ2V0U2Nyb2xsVG9wLCBzeW5jQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzdGVwKCk7XG59XG5cbnZhciBFRElUT1JfQk9UVE9NX1BBRERJTkcgPSAxODtcbnZhciBTY3JvbGxTeW5jID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcm9sbFN5bmMobWRFZGl0b3IsIHByZXZpZXcsIGV2ZW50RW1pdHRlcikge1xuICAgICAgICB0aGlzLmxhdGVzdEVkaXRvclNjcm9sbFRvcCA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0UHJldmlld1Njcm9sbFRvcCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmxvY2tlZFNjcm9sbCA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIHZhciBwcmV2aWV3Um9vdCA9IHByZXZpZXcucHJldmlld0NvbnRlbnQsIHByZXZpZXdFbCA9IHByZXZpZXcuZWw7XG4gICAgICAgIHRoaXMucHJldmlld1Jvb3QgPSBwcmV2aWV3Um9vdDtcbiAgICAgICAgdGhpcy5wcmV2aWV3RWwgPSBwcmV2aWV3RWw7XG4gICAgICAgIHRoaXMubWRFZGl0b3IgPSBtZEVkaXRvcjtcbiAgICAgICAgdGhpcy5lZGl0b3JWaWV3ID0gbWRFZGl0b3IudmlldztcbiAgICAgICAgdGhpcy50b2FzdE1hcmsgPSBtZEVkaXRvci5nZXRUb2FzdE1hcmsoKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBldmVudEVtaXR0ZXI7XG4gICAgICAgIHRoaXMuYWRkU2Nyb2xsU3luY0V2ZW50KCk7XG4gICAgfVxuICAgIFNjcm9sbFN5bmMucHJvdG90eXBlLmFkZFNjcm9sbFN5bmNFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdhZnRlclByZXZpZXdSZW5kZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgICAgICAvLyBJbW1lZGlhdGVseSBhZnRlciB0aGUgJ2FmdGVyUHJldmlld1JlbmRlcicgZXZlbnQgaGFzIG9jY3VycmVkLFxuICAgICAgICAgICAgLy8gYnJvd3NlciByZW5kZXJpbmcgaXMgbm90IHlldCBjb21wbGV0ZS5cbiAgICAgICAgICAgIC8vIFNvIHRoZSBzaXplIG9mIGVsZW1lbnRzIGNhbiBub3QgYmUgYWNjdXJhdGVseSBtZWFzdXJlZC5cbiAgICAgICAgICAgIF90aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3luY1ByZXZpZXdTY3JvbGxUb3AodHJ1ZSk7XG4gICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdzY3JvbGwnLCBmdW5jdGlvbiAodHlwZSwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZWRpdG9yJyAmJiBfdGhpcy5ibG9ja2VkU2Nyb2xsICE9PSAnZWRpdG9yJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zeW5jUHJldmlld1Njcm9sbFRvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAncHJldmlldycgJiYgX3RoaXMuYmxvY2tlZFNjcm9sbCAhPT0gJ3ByZXZpZXcnKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN5bmNFZGl0b3JTY3JvbGxUb3AoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCd0b2dnbGVTY3JvbGxTeW5jJywgZnVuY3Rpb24gKGFjdGl2ZSkge1xuICAgICAgICAgICAgX3RoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNjcm9sbFN5bmMucHJvdG90eXBlLmdldE1kTm9kZUF0UG9zID0gZnVuY3Rpb24gKGRvYywgcG9zSW5mbykge1xuICAgICAgICB2YXIgaW5kZXhJbmZvID0gZG9jLmNvbnRlbnQuZmluZEluZGV4KHBvc0luZm8ucG9zKTtcbiAgICAgICAgdmFyIGxpbmUgPSBpbmRleEluZm8uaW5kZXg7XG4gICAgICAgIHJldHVybiB0aGlzLnRvYXN0TWFyay5maW5kRmlyc3ROb2RlQXRMaW5lKGxpbmUgKyAxKTtcbiAgICB9O1xuICAgIFNjcm9sbFN5bmMucHJvdG90eXBlLmdldFNjcm9sbFRvcEJ5Q2FyZXRQb3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLm1kRWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgICAgICB2YXIgZmlyc3RNZE5vZGUgPSB0aGlzLnRvYXN0TWFyay5maW5kRmlyc3ROb2RlQXRMaW5lKHBvc1swXVswXSk7XG4gICAgICAgIHZhciBwcmV2aWV3SGVpZ2h0ID0gdGhpcy5wcmV2aWV3RWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgZWwgPSBnZXRQYXJlbnROb2RlT2JqKHRoaXMucHJldmlld1Jvb3QsIGZpcnN0TWROb2RlKS5lbDtcbiAgICAgICAgdmFyIHRvdGFsT2Zmc2V0VG9wID0gZ2V0VG90YWxPZmZzZXRUb3AoZWwsIHRoaXMucHJldmlld1Jvb3QpIHx8IGVsLm9mZnNldFRvcDtcbiAgICAgICAgdmFyIG5vZGVIZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIC8vIG11bHRpcGx5IDAuNSBmb3IgY2FsY3VsYXRpbmcgdGhlIHBvc2l0aW9uIGluIHRoZSBtaWRkbGUgb2YgcHJldmlldyBhcmVhXG4gICAgICAgIHZhciB0YXJnZXRTY3JvbGxUb3AgPSB0b3RhbE9mZnNldFRvcCArIG5vZGVIZWlnaHQgLSBwcmV2aWV3SGVpZ2h0ICogMC41O1xuICAgICAgICB0aGlzLmxhdGVzdEVkaXRvclNjcm9sbFRvcCA9IG51bGw7XG4gICAgICAgIHZhciBkaWZmID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gdGhpcy5wcmV2aWV3RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICByZXR1cm4gZGlmZiA8IHByZXZpZXdIZWlnaHQgPyBudWxsIDogdGFyZ2V0U2Nyb2xsVG9wO1xuICAgIH07XG4gICAgU2Nyb2xsU3luYy5wcm90b3R5cGUuc3luY1ByZXZpZXdTY3JvbGxUb3AgPSBmdW5jdGlvbiAoZWRpdGluZykge1xuICAgICAgICBpZiAoZWRpdGluZyA9PT0gdm9pZCAwKSB7IGVkaXRpbmcgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlZGl0b3JWaWV3ID0gX2EuZWRpdG9yVmlldywgcHJldmlld0VsID0gX2EucHJldmlld0VsLCBwcmV2aWV3Um9vdCA9IF9hLnByZXZpZXdSb290O1xuICAgICAgICB2YXIgX2IgPSBlZGl0b3JWaWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbGVmdCA9IF9iLmxlZnQsIHRvcCA9IF9iLnRvcDtcbiAgICAgICAgdmFyIHBvc0luZm8gPSBlZGl0b3JWaWV3LnBvc0F0Q29vcmRzKHsgbGVmdDogbGVmdCwgdG9wOiB0b3AgfSk7XG4gICAgICAgIHZhciBkb2MgPSBlZGl0b3JWaWV3LnN0YXRlLmRvYztcbiAgICAgICAgdmFyIGZpcnN0TWROb2RlID0gdGhpcy5nZXRNZE5vZGVBdFBvcyhkb2MsIHBvc0luZm8pO1xuICAgICAgICBpZiAoIWZpcnN0TWROb2RlIHx8IGlzSFRNTE5vZGUoZmlyc3RNZE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1clNjcm9sbFRvcCA9IHByZXZpZXdFbC5zY3JvbGxUb3A7XG4gICAgICAgIHZhciBfYyA9IGVkaXRvclZpZXcuZG9tLCBzY3JvbGxUb3AgPSBfYy5zY3JvbGxUb3AsIHNjcm9sbEhlaWdodCA9IF9jLnNjcm9sbEhlaWdodCwgY2xpZW50SGVpZ2h0ID0gX2MuY2xpZW50SGVpZ2h0LCBjaGlsZHJlbiA9IF9jLmNoaWxkcmVuO1xuICAgICAgICB2YXIgaXNCb3R0b21Qb3MgPSBzY3JvbGxIZWlnaHQgLSBzY3JvbGxUb3AgPD0gY2xpZW50SGVpZ2h0ICsgRURJVE9SX0JPVFRPTV9QQURESU5HO1xuICAgICAgICB2YXIgdGFyZ2V0U2Nyb2xsVG9wID0gaXNCb3R0b21Qb3MgPyBwcmV2aWV3RWwuc2Nyb2xsSGVpZ2h0IDogMDtcbiAgICAgICAgaWYgKHNjcm9sbFRvcCAmJiAhaXNCb3R0b21Qb3MpIHtcbiAgICAgICAgICAgIGlmIChlZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbFRvcEJ5RWRpdGluZyA9IHRoaXMuZ2V0U2Nyb2xsVG9wQnlDYXJldFBvcygpO1xuICAgICAgICAgICAgICAgIGlmICghc2Nyb2xsVG9wQnlFZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2Nyb2xsVG9wID0gc2Nyb2xsVG9wQnlFZGl0aW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIF9kID0gZ2V0UGFyZW50Tm9kZU9iaih0aGlzLnByZXZpZXdSb290LCBmaXJzdE1kTm9kZSksIGVsID0gX2QuZWwsIG1kTm9kZSA9IF9kLm1kTm9kZTtcbiAgICAgICAgICAgICAgICB2YXIgX2UgPSBnZXRFZGl0b3JSYW5nZUhlaWdodEluZm8oZG9jLCBtZE5vZGUsIGNoaWxkcmVuKSwgaGVpZ2h0ID0gX2UuaGVpZ2h0LCByZWN0ID0gX2UucmVjdDtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxPZmZzZXRUb3AgPSBnZXRUb3RhbE9mZnNldFRvcChlbCwgcHJldmlld1Jvb3QpIHx8IGVsLm9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSB0b3AgPiByZWN0LnRvcCA/IE1hdGgubWluKCh0b3AgLSByZWN0LnRvcCkgLyBoZWlnaHQsIDEpIDogMDtcbiAgICAgICAgICAgICAgICB0YXJnZXRTY3JvbGxUb3AgPSB0b3RhbE9mZnNldFRvcCArIG5vZGVIZWlnaHQgKiByYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFNjcm9sbFRvcCA9IHRoaXMuZ2V0UmVzb2x2ZWRTY3JvbGxUb3AoJ2VkaXRvcicsIHNjcm9sbFRvcCwgdGFyZ2V0U2Nyb2xsVG9wLCBjdXJTY3JvbGxUb3ApO1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RFZGl0b3JTY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldFNjcm9sbFRvcCAhPT0gY3VyU2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bignZWRpdG9yJywgdGFyZ2V0U2Nyb2xsVG9wLCBjdXJTY3JvbGxUb3ApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY3JvbGxTeW5jLnByb3RvdHlwZS5zeW5jRWRpdG9yU2Nyb2xsVG9wID0gZnVuY3Rpb24gKHRhcmdldE5vZGUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgdG9hc3RNYXJrID0gX2EudG9hc3RNYXJrLCBlZGl0b3JWaWV3ID0gX2EuZWRpdG9yVmlldywgcHJldmlld1Jvb3QgPSBfYS5wcmV2aWV3Um9vdCwgcHJldmlld0VsID0gX2EucHJldmlld0VsO1xuICAgICAgICB2YXIgZG9tID0gZWRpdG9yVmlldy5kb20sIHN0YXRlID0gZWRpdG9yVmlldy5zdGF0ZTtcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHByZXZpZXdFbC5zY3JvbGxUb3AsIGNsaWVudEhlaWdodCA9IHByZXZpZXdFbC5jbGllbnRIZWlnaHQsIHNjcm9sbEhlaWdodCA9IHByZXZpZXdFbC5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIHZhciBpc0JvdHRvbVBvcyA9IHNjcm9sbEhlaWdodCAtIHNjcm9sbFRvcCA8PSBjbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciBjdXJTY3JvbGxUb3AgPSBkb20uc2Nyb2xsVG9wO1xuICAgICAgICB2YXIgdGFyZ2V0U2Nyb2xsVG9wID0gaXNCb3R0b21Qb3MgPyBkb20uc2Nyb2xsSGVpZ2h0IDogMDtcbiAgICAgICAgaWYgKHNjcm9sbFRvcCAmJiB0YXJnZXROb2RlICYmICFpc0JvdHRvbVBvcykge1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGZpbmRBbmNlc3RvckhhdmluZ0lkKHRhcmdldE5vZGUsIHByZXZpZXdSb290KTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbm9kZWlkJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBkb20uY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgbWROb2RlSWQgPSBOdW1iZXIodGFyZ2V0Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbm9kZWlkJykpO1xuICAgICAgICAgICAgdmFyIF9iID0gZ2V0UGFyZW50Tm9kZU9iaih0aGlzLnByZXZpZXdSb290LCB0b2FzdE1hcmsuZmluZE5vZGVCeUlkKG1kTm9kZUlkKSksIG1kTm9kZSA9IF9iLm1kTm9kZSwgZWwgPSBfYi5lbDtcbiAgICAgICAgICAgIHZhciBtZE5vZGVTdGFydExpbmUgPSBnZXRNZFN0YXJ0TGluZShtZE5vZGUpO1xuICAgICAgICAgICAgdGFyZ2V0U2Nyb2xsVG9wID0gY2hpbGRyZW5bbWROb2RlU3RhcnRMaW5lIC0gMV0ub2Zmc2V0VG9wO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGdldEVkaXRvclJhbmdlSGVpZ2h0SW5mbyhzdGF0ZS5kb2MsIG1kTm9kZSwgY2hpbGRyZW4pLmhlaWdodDtcbiAgICAgICAgICAgIHZhciBfYyA9IGdldEFuZFNhdmVPZmZzZXRJbmZvKGVsLCBwcmV2aWV3Um9vdCwgbWROb2RlSWQpLCBub2RlSGVpZ2h0ID0gX2Mubm9kZUhlaWdodCwgb2Zmc2V0VG9wID0gX2Mub2Zmc2V0VG9wO1xuICAgICAgICAgICAgdGFyZ2V0U2Nyb2xsVG9wICs9IGdldEFkZGl0aW9uYWxQb3Moc2Nyb2xsVG9wLCBvZmZzZXRUb3AsIG5vZGVIZWlnaHQsIGhlaWdodCk7XG4gICAgICAgICAgICB0YXJnZXRTY3JvbGxUb3AgPSB0aGlzLmdldFJlc29sdmVkU2Nyb2xsVG9wKCdwcmV2aWV3Jywgc2Nyb2xsVG9wLCB0YXJnZXRTY3JvbGxUb3AsIGN1clNjcm9sbFRvcCk7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdFByZXZpZXdTY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldFNjcm9sbFRvcCAhPT0gY3VyU2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bigncHJldmlldycsIHRhcmdldFNjcm9sbFRvcCwgY3VyU2Nyb2xsVG9wKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsU3luYy5wcm90b3R5cGUuZ2V0UmVzb2x2ZWRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoZnJvbSwgc2Nyb2xsVG9wLCB0YXJnZXRTY3JvbGxUb3AsIGN1clNjcm9sbFRvcCkge1xuICAgICAgICB2YXIgbGF0ZXN0U2Nyb2xsVG9wID0gZnJvbSA9PT0gJ2VkaXRvcicgPyB0aGlzLmxhdGVzdEVkaXRvclNjcm9sbFRvcCA6IHRoaXMubGF0ZXN0UHJldmlld1Njcm9sbFRvcDtcbiAgICAgICAgaWYgKGxhdGVzdFNjcm9sbFRvcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF0ZXN0U2Nyb2xsVG9wIDwgc2Nyb2xsVG9wXG4gICAgICAgICAgICA/IE1hdGgubWF4KHRhcmdldFNjcm9sbFRvcCwgY3VyU2Nyb2xsVG9wKVxuICAgICAgICAgICAgOiBNYXRoLm1pbih0YXJnZXRTY3JvbGxUb3AsIGN1clNjcm9sbFRvcCk7XG4gICAgfTtcbiAgICBTY3JvbGxTeW5jLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZnJvbSwgdGFyZ2V0U2Nyb2xsVG9wLCBjdXJTY3JvbGxUb3ApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNjcm9sbFRhcmdldDtcbiAgICAgICAgaWYgKGZyb20gPT09ICdlZGl0b3InKSB7XG4gICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSB0aGlzLnByZXZpZXdFbDtcbiAgICAgICAgICAgIHRoaXMuYmxvY2tlZFNjcm9sbCA9ICdwcmV2aWV3JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IHRoaXMuZWRpdG9yVmlldy5kb207XG4gICAgICAgICAgICB0aGlzLmJsb2NrZWRTY3JvbGwgPSAnZWRpdG9yJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3luY0NhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIHN5bmNTY3JvbGxUb3A6IGZ1bmN0aW9uIChzY3JvbGxUb3ApIHsgcmV0dXJuIChzY3JvbGxUYXJnZXQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wKTsgfSxcbiAgICAgICAgICAgIHJlbGVhc2VFdmVudEJsb2NrOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoX3RoaXMuYmxvY2tlZFNjcm9sbCA9IG51bGwpOyB9LFxuICAgICAgICB9O1xuICAgICAgICBhbmltYXRlKGN1clNjcm9sbFRvcCwgdGFyZ2V0U2Nyb2xsVG9wLCBzeW5jQ2FsbGJhY2tzKTtcbiAgICB9O1xuICAgIFNjcm9sbFN5bmMucHJvdG90eXBlLmNsZWFyVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsU3luYy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50SGFuZGxlcignc2Nyb2xsJyk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50SGFuZGxlcignYWZ0ZXJQcmV2aWV3UmVuZGVyJyk7XG4gICAgfTtcbiAgICByZXR1cm4gU2Nyb2xsU3luYztcbn0oKSk7XG5cbnZhciBxdWVyeU1hcCA9IHtcbiAgICBnZXRQb3B1cEluaXRpYWxWYWx1ZXM6IGZ1bmN0aW9uIChlZGl0b3IsIHBheWxvYWQpIHtcbiAgICAgICAgdmFyIHBvcHVwTmFtZSA9IHBheWxvYWQucG9wdXBOYW1lO1xuICAgICAgICByZXR1cm4gcG9wdXBOYW1lID09PSAnbGluaycgPyB7IGxpbmtUZXh0OiBlZGl0b3IuZ2V0U2VsZWN0ZWRUZXh0KCkgfSA6IHt9O1xuICAgIH0sXG59O1xuZnVuY3Rpb24gYnVpbGRRdWVyeShlZGl0b3IpIHtcbiAgICBlZGl0b3IuZXZlbnRFbWl0dGVyLmxpc3RlbigncXVlcnknLCBmdW5jdGlvbiAocXVlcnksIHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5TWFwW3F1ZXJ5XShlZGl0b3IsIHBheWxvYWQpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFRvYXN0VUlFZGl0b3JDb3JlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb24gb2JqZWN0XG4gKiAgICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5lbCAtIGNvbnRhaW5lciBlbGVtZW50XG4gKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmhlaWdodD0nMzAwcHgnXSAtIEVkaXRvcidzIGhlaWdodCBzdHlsZSB2YWx1ZS4gSGVpZ2h0IGlzIGFwcGxpZWQgYXMgYm9yZGVyLWJveCBleCkgJzMwMHB4JywgJzEwMCUnLCAnYXV0bydcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWluSGVpZ2h0PScyMDBweCddIC0gRWRpdG9yJ3MgbWluLWhlaWdodCBzdHlsZSB2YWx1ZSBpbiBwaXhlbCBleCkgJzMwMHB4J1xuICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pbml0aWFsVmFsdWVdIC0gRWRpdG9yJ3MgaW5pdGlhbCB2YWx1ZVxuICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wcmV2aWV3U3R5bGVdIC0gTWFya2Rvd24gZWRpdG9yJ3MgcHJldmlldyBzdHlsZSAodGFiLCB2ZXJ0aWNhbClcbiAqICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByZXZpZXdIaWdobGlnaHQgPSB0cnVlXSAtIEhpZ2hsaWdodCBhIHByZXZpZXcgZWxlbWVudCBjb3JyZXNwb25kcyB0byB0aGUgY3Vyc29yIHBvc2l0aW9uIGluIHRoZSBtYXJrZG93biBlZGl0b3JcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaW5pdGlhbEVkaXRUeXBlXSAtIEluaXRpYWwgZWRpdG9yIHR5cGUgKG1hcmtkb3duLCB3eXNpd3lnKVxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5ldmVudHNdIC0gRXZlbnRzXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5sb2FkXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBlZGl0b3IgZnVsbHkgbG9hZFxuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuY2hhbmdlXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBjb250ZW50IGNoYW5nZWRcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmNhcmV0Q2hhbmdlXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBmb3JtYXQgY2hhbmdlIGJ5IGN1cnNvciBwb3NpdGlvblxuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuZm9jdXNdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGVkaXRvciBnZXQgZm9jdXNcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmJsdXJdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGVkaXRvciBsb29zZSBmb2N1c1xuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMua2V5ZG93bl0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gdGhlIGtleSBpcyBwcmVzc2VkIGluIGVkaXRvclxuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMua2V5dXBdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIHRoZSBrZXkgaXMgcmVsZWFzZWQgaW4gZWRpdG9yXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5iZWZvcmVQcmV2aWV3UmVuZGVyXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgYmVmb3JlIHJlbmRlcmluZyB0aGUgbWFya2Rvd24gcHJldmlldyB3aXRoIGh0bWwgc3RyaW5nXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5iZWZvcmVDb252ZXJ0V3lzaXd5Z1RvTWFya2Rvd25dIC0gSXQgd291bGQgYmUgZW1pdHRlZCBiZWZvcmUgY29udmVydGluZyB3eXNpd3lnIHRvIG1hcmtkb3duIHdpdGggbWFya2Rvd24gdGV4dFxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5ob29rc10gLSBIb29rc1xuICogICAgICAgICBAcGFyYW0ge2FkZEltYWdlQmxvYkhvb2t9IFtvcHRpb25zLmhvb2tzLmFkZEltYWdlQmxvYkhvb2tdIC0gaG9vayBmb3IgaW1hZ2UgdXBsb2FkXG4gKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlPSdlbi1VUyddIC0gbGFuZ3VhZ2VcbiAqICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnVzZUNvbW1hbmRTaG9ydGN1dD10cnVlXSAtIHdoZXRoZXIgdXNlIGtleWJvYXJkIHNob3J0Y3V0cyB0byBwZXJmb3JtIGNvbW1hbmRzXG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51c2FnZVN0YXRpc3RpY3M9dHJ1ZV0gLSBzZW5kIGhvc3RuYW1lIHRvIGdvb2dsZSBhbmFseXRpY3NcbiAqICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmd8dG9vbGJhckl0ZW1zVmFsdWU+fSBbb3B0aW9ucy50b29sYmFySXRlbXNdIC0gdG9vbGJhciBpdGVtcy5cbiAqICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmhpZGVNb2RlU3dpdGNoPWZhbHNlXSAtIGhpZGUgbW9kZSBzd2l0Y2ggdGFiIGJhclxuICogICAgIEBwYXJhbSB7QXJyYXkuPGZ1bmN0aW9ufEFycmF5Pn0gW29wdGlvbnMucGx1Z2luc10gLSBBcnJheSBvZiBwbHVnaW5zLiBBIHBsdWdpbiBjYW4gYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkgaW4gdGhlIGZvcm0gb2YgW2Z1bmN0aW9uLCBvcHRpb25zXS5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZXh0ZW5kZWRBdXRvbGlua3NdIC0gVXNpbmcgZXh0ZW5kZWQgQXV0b2xpbmtzIHNwZWNpZmllZCBpbiBHRk0gc3BlY1xuICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wbGFjZWhvbGRlcl0gLSBUaGUgcGxhY2Vob2xkZXIgdGV4dCBvZiB0aGUgZWRpdGFibGUgZWxlbWVudC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGlua0F0dHJpYnV0ZXNdIC0gQXR0cmlidXRlcyBvZiBhbmNob3IgZWxlbWVudCB0aGF0IHNob3VsZCBiZSByZWwsIHRhcmdldCwgaHJlZmxhbmcsIHR5cGVcbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY3VzdG9tSFRNTFJlbmRlcmVyPW51bGxdIC0gT2JqZWN0IGNvbnRhaW5pbmcgY3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9ucyBjb3JyZXNwb25kIHRvIGNoYW5nZSBtYXJrZG93biBub2RlIHRvIHByZXZpZXcgSFRNTCBvciB3eXNpd3lnIG5vZGVcbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY3VzdG9tTWFya2Rvd25SZW5kZXJlcj1udWxsXSAtIE9iamVjdCBjb250YWluaW5nIGN1c3RvbSByZW5kZXJlciBmdW5jdGlvbnMgY29ycmVzcG9uZCB0byBjaGFuZ2Ugd3lzaXd5ZyBub2RlIHRvIG1hcmtkb3duIHRleHRcbiAqICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlZmVyZW5jZURlZmluaXRpb249ZmFsc2VdIC0gd2hldGhlciB1c2UgdGhlIHNwZWNpZmljYXRpb24gb2YgbGluayByZWZlcmVuY2UgZGVmaW5pdGlvblxuICogICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmN1c3RvbUhUTUxTYW5pdGl6ZXI9bnVsbF0gLSBjdXN0b20gSFRNTCBzYW5pdGl6ZXJcbiAqICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByZXZpZXdIaWdobGlnaHQ9ZmFsc2VdIC0gd2hldGhlciBoaWdobGlnaHQgcHJldmlldyBhcmVhXG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mcm9udE1hdHRlcj1mYWxzZV0gLSB3aGV0aGVyIHVzZSB0aGUgZnJvbnQgbWF0dGVyXG4gKiAgICAgQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gW29wdGlvbnMud2lkZ2V0UnVsZXM9W11dIC0gVGhlIHJ1bGVzIGZvciByZXBsYWNpbmcgdGhlIHRleHQgd2l0aCB3aWRnZXQgbm9kZVxuICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50aGVtZV0gLSBUaGUgdGhlbWUgdG8gc3R5bGUgdGhlIGVkaXRvciB3aXRoLiBUaGUgZGVmYXVsdCBpcyBpbmNsdWRlZCBpbiB0b2FzdHVpLWVkaXRvci5jc3MuXG4gKiAgICAgQHBhcmFtIHthdXRvZm9jdXN9IFtvcHRpb25zLmF1dG9mb2N1cz10cnVlXSAtIGF1dG9tYXRpY2FsbHkgZm9jdXMgdGhlIGVkaXRvciBvbiBjcmVhdGlvbi5cbiAqL1xudmFyIFRvYXN0VUlFZGl0b3JDb3JlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvYXN0VUlFZGl0b3JDb3JlKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pbml0aWFsSFRNTCA9IG9wdGlvbnMuZWwuaW5uZXJIVE1MO1xuICAgICAgICBvcHRpb25zLmVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmRfMSh7XG4gICAgICAgICAgICBwcmV2aWV3U3R5bGU6ICd0YWInLFxuICAgICAgICAgICAgcHJldmlld0hpZ2hsaWdodDogdHJ1ZSxcbiAgICAgICAgICAgIGluaXRpYWxFZGl0VHlwZTogJ21hcmtkb3duJyxcbiAgICAgICAgICAgIGhlaWdodDogJzMwMHB4JyxcbiAgICAgICAgICAgIG1pbkhlaWdodDogJzIwMHB4JyxcbiAgICAgICAgICAgIGxhbmd1YWdlOiAnZW4tVVMnLFxuICAgICAgICAgICAgdXNlQ29tbWFuZFNob3J0Y3V0OiB0cnVlLFxuICAgICAgICAgICAgdXNhZ2VTdGF0aXN0aWNzOiB0cnVlLFxuICAgICAgICAgICAgdG9vbGJhckl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgWydoZWFkaW5nJywgJ2JvbGQnLCAnaXRhbGljJywgJ3N0cmlrZSddLFxuICAgICAgICAgICAgICAgIFsnaHInLCAncXVvdGUnXSxcbiAgICAgICAgICAgICAgICBbJ3VsJywgJ29sJywgJ3Rhc2snLCAnaW5kZW50JywgJ291dGRlbnQnXSxcbiAgICAgICAgICAgICAgICBbJ3RhYmxlJywgJ2ltYWdlJywgJ2xpbmsnXSxcbiAgICAgICAgICAgICAgICBbJ2NvZGUnLCAnY29kZWJsb2NrJ10sXG4gICAgICAgICAgICAgICAgWydzY3JvbGxTeW5jJ10sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaGlkZU1vZGVTd2l0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgbGlua0F0dHJpYnV0ZXM6IG51bGwsXG4gICAgICAgICAgICBleHRlbmRlZEF1dG9saW5rczogZmFsc2UsXG4gICAgICAgICAgICBjdXN0b21IVE1MUmVuZGVyZXI6IG51bGwsXG4gICAgICAgICAgICBjdXN0b21NYXJrZG93blJlbmRlcmVyOiBudWxsLFxuICAgICAgICAgICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBjdXN0b21IVE1MU2FuaXRpemVyOiBudWxsLFxuICAgICAgICAgICAgZnJvbnRNYXR0ZXI6IGZhbHNlLFxuICAgICAgICAgICAgd2lkZ2V0UnVsZXM6IFtdLFxuICAgICAgICAgICAgdGhlbWU6ICdsaWdodCcsXG4gICAgICAgICAgICBhdXRvZm9jdXM6IHRydWUsXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIGN1c3RvbUhUTUxSZW5kZXJlciA9IF9hLmN1c3RvbUhUTUxSZW5kZXJlciwgZXh0ZW5kZWRBdXRvbGlua3MgPSBfYS5leHRlbmRlZEF1dG9saW5rcywgcmVmZXJlbmNlRGVmaW5pdGlvbiA9IF9hLnJlZmVyZW5jZURlZmluaXRpb24sIGZyb250TWF0dGVyID0gX2EuZnJvbnRNYXR0ZXIsIGN1c3RvbU1hcmtkb3duUmVuZGVyZXIgPSBfYS5jdXN0b21NYXJrZG93blJlbmRlcmVyLCB1c2VDb21tYW5kU2hvcnRjdXQgPSBfYS51c2VDb21tYW5kU2hvcnRjdXQsIGluaXRpYWxFZGl0VHlwZSA9IF9hLmluaXRpYWxFZGl0VHlwZSwgd2lkZ2V0UnVsZXMgPSBfYS53aWRnZXRSdWxlcywgY3VzdG9tSFRNTFNhbml0aXplciA9IF9hLmN1c3RvbUhUTUxTYW5pdGl6ZXI7XG4gICAgICAgIHRoaXMubW9kZSA9IGluaXRpYWxFZGl0VHlwZSB8fCAnbWFya2Rvd24nO1xuICAgICAgICB0aGlzLm1kUHJldmlld1N0eWxlID0gdGhpcy5vcHRpb25zLnByZXZpZXdTdHlsZTtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICAgICAgdGhpcy5pMThuLnNldENvZGUodGhpcy5vcHRpb25zLmxhbmd1YWdlKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHNldFdpZGdldFJ1bGVzKHdpZGdldFJ1bGVzKTtcbiAgICAgICAgdmFyIGxpbmtBdHRyaWJ1dGVzID0gc2FuaXRpemVMaW5rQXR0cmlidXRlKHRoaXMub3B0aW9ucy5saW5rQXR0cmlidXRlcyk7XG4gICAgICAgIHRoaXMucGx1Z2luSW5mbyA9IGdldFBsdWdpbkluZm8oe1xuICAgICAgICAgICAgcGx1Z2luczogdGhpcy5vcHRpb25zLnBsdWdpbnMsXG4gICAgICAgICAgICBldmVudEVtaXR0ZXI6IHRoaXMuZXZlbnRFbWl0dGVyLFxuICAgICAgICAgICAgdXNhZ2VTdGF0aXN0aWNzOiB0aGlzLm9wdGlvbnMudXNhZ2VTdGF0aXN0aWNzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLnBsdWdpbkluZm8sIHRvSFRNTFJlbmRlcmVycyA9IF9iLnRvSFRNTFJlbmRlcmVycywgdG9NYXJrZG93blJlbmRlcmVycyA9IF9iLnRvTWFya2Rvd25SZW5kZXJlcnMsIG1kUGx1Z2lucyA9IF9iLm1kUGx1Z2lucywgd3dQbHVnaW5zID0gX2Iud3dQbHVnaW5zLCB3d05vZGVWaWV3cyA9IF9iLnd3Tm9kZVZpZXdzLCBtZENvbW1hbmRzID0gX2IubWRDb21tYW5kcywgd3dDb21tYW5kcyA9IF9iLnd3Q29tbWFuZHMsIG1hcmtkb3duUGFyc2VycyA9IF9iLm1hcmtkb3duUGFyc2VycztcbiAgICAgICAgdmFyIHJlbmRlcmVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGxpbmtBdHRyaWJ1dGVzOiBsaW5rQXR0cmlidXRlcyxcbiAgICAgICAgICAgIGN1c3RvbUhUTUxSZW5kZXJlcjogZGVlcE1lcmdlZENvcHkodG9IVE1MUmVuZGVyZXJzLCBjdXN0b21IVE1MUmVuZGVyZXIpLFxuICAgICAgICAgICAgZXh0ZW5kZWRBdXRvbGlua3M6IGV4dGVuZGVkQXV0b2xpbmtzLFxuICAgICAgICAgICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogcmVmZXJlbmNlRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGZyb250TWF0dGVyOiBmcm9udE1hdHRlcixcbiAgICAgICAgICAgIHNhbml0aXplcjogY3VzdG9tSFRNTFNhbml0aXplciB8fCBzYW5pdGl6ZUhUTUwsXG4gICAgICAgIH07XG4gICAgICAgIHZhciB3d1RvRE9NQWRhcHRvciA9IG5ldyBXd1RvRE9NQWRhcHRvcihsaW5rQXR0cmlidXRlcywgcmVuZGVyZXJPcHRpb25zLmN1c3RvbUhUTUxSZW5kZXJlcik7XG4gICAgICAgIHZhciBodG1sU2NoZW1hTWFwID0gY3JlYXRlSFRNTFNjaGVtYU1hcChyZW5kZXJlck9wdGlvbnMuY3VzdG9tSFRNTFJlbmRlcmVyLCByZW5kZXJlck9wdGlvbnMuc2FuaXRpemVyLCB3d1RvRE9NQWRhcHRvcik7XG4gICAgICAgIHRoaXMudG9hc3RNYXJrID0gbmV3IFRvYXN0TWFyaygnJywge1xuICAgICAgICAgICAgZGlzYWxsb3dlZEh0bWxCbG9ja1RhZ3M6IFsnYnInLCAnaW1nJ10sXG4gICAgICAgICAgICBleHRlbmRlZEF1dG9saW5rczogZXh0ZW5kZWRBdXRvbGlua3MsXG4gICAgICAgICAgICByZWZlcmVuY2VEZWZpbml0aW9uOiByZWZlcmVuY2VEZWZpbml0aW9uLFxuICAgICAgICAgICAgZGlzYWxsb3dEZWVwSGVhZGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGZyb250TWF0dGVyOiBmcm9udE1hdHRlcixcbiAgICAgICAgICAgIGN1c3RvbVBhcnNlcjogbWFya2Rvd25QYXJzZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tZEVkaXRvciA9IG5ldyBNZEVkaXRvcih0aGlzLmV2ZW50RW1pdHRlciwge1xuICAgICAgICAgICAgdG9hc3RNYXJrOiB0aGlzLnRvYXN0TWFyayxcbiAgICAgICAgICAgIHVzZUNvbW1hbmRTaG9ydGN1dDogdXNlQ29tbWFuZFNob3J0Y3V0LFxuICAgICAgICAgICAgbWRQbHVnaW5zOiBtZFBsdWdpbnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByZXZpZXcgPSBuZXcgTWFya2Rvd25QcmV2aWV3KHRoaXMuZXZlbnRFbWl0dGVyLCBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIHJlbmRlcmVyT3B0aW9ucyksIHsgaXNWaWV3ZXI6IGZhbHNlLCBoaWdobGlnaHQ6IHRoaXMub3B0aW9ucy5wcmV2aWV3SGlnaGxpZ2h0IH0pKTtcbiAgICAgICAgdGhpcy53d0VkaXRvciA9IG5ldyBXeXNpd3lnRWRpdG9yKHRoaXMuZXZlbnRFbWl0dGVyLCB7XG4gICAgICAgICAgICB0b0RPTUFkYXB0b3I6IHd3VG9ET01BZGFwdG9yLFxuICAgICAgICAgICAgdXNlQ29tbWFuZFNob3J0Y3V0OiB1c2VDb21tYW5kU2hvcnRjdXQsXG4gICAgICAgICAgICBodG1sU2NoZW1hTWFwOiBodG1sU2NoZW1hTWFwLFxuICAgICAgICAgICAgbGlua0F0dHJpYnV0ZXM6IGxpbmtBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgd3dQbHVnaW5zOiB3d1BsdWdpbnMsXG4gICAgICAgICAgICB3d05vZGVWaWV3czogd3dOb2RlVmlld3MsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbnZlcnRvciA9IG5ldyBDb252ZXJ0b3IodGhpcy53d0VkaXRvci5nZXRTY2hlbWEoKSwgX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCB0b01hcmtkb3duUmVuZGVyZXJzKSwgY3VzdG9tTWFya2Rvd25SZW5kZXJlciksIGdldEhUTUxSZW5kZXJDb252ZXJ0b3JzKGxpbmtBdHRyaWJ1dGVzLCByZW5kZXJlck9wdGlvbnMuY3VzdG9tSFRNTFJlbmRlcmVyKSwgdGhpcy5ldmVudEVtaXR0ZXIpO1xuICAgICAgICB0aGlzLnNldE1pbkhlaWdodCh0aGlzLm9wdGlvbnMubWluSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5zZXRIZWlnaHQodGhpcy5vcHRpb25zLmhlaWdodCk7XG4gICAgICAgIHRoaXMuc2V0TWFya2Rvd24odGhpcy5vcHRpb25zLmluaXRpYWxWYWx1ZSwgZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBsYWNlaG9sZGVyKHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhUTUwodGhpcy5pbml0aWFsSFRNTCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tbWFuZE1hbmFnZXIgPSBuZXcgQ29tbWFuZE1hbmFnZXIodGhpcy5ldmVudEVtaXR0ZXIsIHRoaXMubWRFZGl0b3IuY29tbWFuZHMsIHRoaXMud3dFZGl0b3IuY29tbWFuZHMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm1vZGU7IH0pO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVzYWdlU3RhdGlzdGljcykge1xuICAgICAgICAgICAgc2VuZEhvc3ROYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY3JvbGxTeW5jID0gbmV3IFNjcm9sbFN5bmModGhpcy5tZEVkaXRvciwgdGhpcy5wcmV2aWV3LCB0aGlzLmV2ZW50RW1pdHRlcik7XG4gICAgICAgIHRoaXMuYWRkSW5pdEV2ZW50KCk7XG4gICAgICAgIHRoaXMuYWRkSW5pdENvbW1hbmQobWRDb21tYW5kcywgd3dDb21tYW5kcyk7XG4gICAgICAgIGJ1aWxkUXVlcnkodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG9va3MpIHtcbiAgICAgICAgICAgIGZvckVhY2hPd25Qcm9wZXJ0aWVzXzEodGhpcy5vcHRpb25zLmhvb2tzLCBmdW5jdGlvbiAoZm4sIGtleSkgeyByZXR1cm4gX3RoaXMuYWRkSG9vayhrZXksIGZuKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ldmVudHMpIHtcbiAgICAgICAgICAgIGZvckVhY2hPd25Qcm9wZXJ0aWVzXzEodGhpcy5vcHRpb25zLmV2ZW50cywgZnVuY3Rpb24gKGZuLCBrZXkpIHsgcmV0dXJuIF90aGlzLm9uKGtleSwgZm4pOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdsb2FkJywgdGhpcyk7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvU3RhcnQodGhpcy5vcHRpb25zLmF1dG9mb2N1cyk7XG4gICAgfVxuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5hZGRJbml0RXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMub24oJ25lZWRDaGFuZ2VNb2RlJywgdGhpcy5jaGFuZ2VNb2RlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm9uKCdsb2FkVUknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaGVpZ2h0ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAvLyA3NXB4IGVxdWFscyBkZWZhdWx0IGVkaXRvciB1aSBoZWlnaHQgLSB0aGUgZWRpdGluZyBhcmVhIGhlaWdodFxuICAgICAgICAgICAgICAgIHZhciBtaW5IZWlnaHQgPSBNYXRoLm1pbihwYXJzZUludChfdGhpcy5taW5IZWlnaHQsIDEwKSwgcGFyc2VJbnQoX3RoaXMuaGVpZ2h0LCAxMCkgLSA3NSkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0TWluSGVpZ2h0KG1pbkhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhZGREZWZhdWx0SW1hZ2VCbG9iSG9vayh0aGlzLmV2ZW50RW1pdHRlcik7XG4gICAgfTtcbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuYWRkSW5pdENvbW1hbmQgPSBmdW5jdGlvbiAobWRDb21tYW5kcywgd3dDb21tYW5kcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYWRkUGx1Z2luQ29tbWFuZHMgPSBmdW5jdGlvbiAodHlwZSwgY29tbWFuZE1hcCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29tbWFuZE1hcCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFkZENvbW1hbmQodHlwZSwgbmFtZSwgY29tbWFuZE1hcFtuYW1lXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKCdtYXJrZG93bicsICd0b2dnbGVTY3JvbGxTeW5jJywgZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5lbWl0KCd0b2dnbGVTY3JvbGxTeW5jJywgcGF5bG9hZC5hY3RpdmUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBhZGRQbHVnaW5Db21tYW5kcygnbWFya2Rvd24nLCBtZENvbW1hbmRzKTtcbiAgICAgICAgYWRkUGx1Z2luQ29tbWFuZHMoJ3d5c2l3eWcnLCB3d0NvbW1hbmRzKTtcbiAgICB9O1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5nZXRDdXJyZW50TW9kZUVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzTWFya2Rvd25Nb2RlKCkgPyB0aGlzLm1kRWRpdG9yIDogdGhpcy53d0VkaXRvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGYWN0b3J5IG1ldGhvZCBmb3IgRWRpdG9yXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT3B0aW9uIGZvciBpbml0aWFsaXplIFRVSUVkaXRvclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRvYXN0VUlFZGl0b3JDb3JlIG9yIFRvYXN0VUlFZGl0b3JWaWV3ZXJcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5mYWN0b3J5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMudmlld2VyID8gbmV3IFRvYXN0VUlFZGl0b3JWaWV3ZXIob3B0aW9ucykgOiBuZXcgVG9hc3RVSUVkaXRvckNvcmUob3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgbGFuZ3VhZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gY29kZSAtIGNvZGUgZm9yIEkxOE4gbGFuZ3VhZ2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIGxhbmd1YWdlIHNldFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnNldExhbmd1YWdlID0gZnVuY3Rpb24gKGNvZGUsIGRhdGEpIHtcbiAgICAgICAgaTE4bi5zZXRMYW5ndWFnZShjb2RlLCBkYXRhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNoYW5nZSBwcmV2aWV3IHN0eWxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlIC0gJ3RhYid8J3ZlcnRpY2FsJ1xuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5jaGFuZ2VQcmV2aWV3U3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgaWYgKHRoaXMubWRQcmV2aWV3U3R5bGUgIT09IHN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLm1kUHJldmlld1N0eWxlID0gc3R5bGU7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2VQcmV2aWV3U3R5bGUnLCBzdHlsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGV4ZWN1dGUgZWRpdG9yIGNvbW1hbmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIGNvbW1hbmQgbmFtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcGF5bG9hZF0gLSBwYXlsb2FkIGZvciBjb21tYW5kXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAobmFtZSwgcGF5bG9hZCkge1xuICAgICAgICB0aGlzLmNvbW1hbmRNYW5hZ2VyLmV4ZWMobmFtZSwgcGF5bG9hZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGVkaXRvciB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBjb21tYW5kIG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21tYW5kIC0gY29tbWFuZCBoYW5kbGVyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmFkZENvbW1hbmQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgY29tbWFuZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29tbWFuZEhvYyA9IGZ1bmN0aW9uIChwYXlsYW9kKSB7XG4gICAgICAgICAgICBpZiAocGF5bGFvZCA9PT0gdm9pZCAwKSB7IHBheWxhb2QgPSB7fTsgfVxuICAgICAgICAgICAgdmFyIHZpZXcgPSAodHlwZSA9PT0gJ21hcmtkb3duJyA/IF90aGlzLm1kRWRpdG9yIDogX3RoaXMud3dFZGl0b3IpLnZpZXc7XG4gICAgICAgICAgICBjb21tYW5kKHBheWxhb2QsIHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbW1hbmRNYW5hZ2VyLmFkZENvbW1hbmQodHlwZSwgbmFtZSwgY29tbWFuZEhvYyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCaW5kIGV2ZW50SGFuZGxlciB0byBldmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3Rlbih0eXBlLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuYmluZCBldmVudEhhbmRsZXIgZnJvbSBldmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVFdmVudEhhbmRsZXIodHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgaG9vayB0byBUVUlFZGl0b3IgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBFdmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmFkZEhvb2sgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVFdmVudEhhbmRsZXIodHlwZSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3Rlbih0eXBlLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBob29rIGZyb20gVFVJRWRpdG9yIGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5yZW1vdmVIb29rID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRIYW5kbGVyKHR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGZvY3VzIHRvIGN1cnJlbnQgRWRpdG9yXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkuZm9jdXMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBmb2N1cyBvZiBjdXJyZW50IEVkaXRvclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkuYmx1cigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGN1cnNvciBwb3NpdGlvbiB0byBlbmRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb2N1c10gLSBhdXRvbWF0aWNhbGx5IGZvY3VzIHRoZSBlZGl0b3JcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUubW92ZUN1cnNvclRvRW5kID0gZnVuY3Rpb24gKGZvY3VzKSB7XG4gICAgICAgIGlmIChmb2N1cyA9PT0gdm9pZCAwKSB7IGZvY3VzID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkubW92ZUN1cnNvclRvRW5kKGZvY3VzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBjdXJzb3IgcG9zaXRpb24gdG8gc3RhcnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb2N1c10gLSBhdXRvbWF0aWNhbGx5IGZvY3VzIHRoZSBlZGl0b3JcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUubW92ZUN1cnNvclRvU3RhcnQgPSBmdW5jdGlvbiAoZm9jdXMpIHtcbiAgICAgICAgaWYgKGZvY3VzID09PSB2b2lkIDApIHsgZm9jdXMgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5tb3ZlQ3Vyc29yVG9TdGFydChmb2N1cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgbWFya2Rvd24gc3ludGF4IHRleHQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmtkb3duIC0gbWFya2Rvd24gc3ludGF4IHRleHQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY3Vyc29yVG9FbmQ9dHJ1ZV0gLSBtb3ZlIGN1cnNvciB0byBjb250ZW50cyBlbmRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuc2V0TWFya2Rvd24gPSBmdW5jdGlvbiAobWFya2Rvd24sIGN1cnNvclRvRW5kKSB7XG4gICAgICAgIGlmIChtYXJrZG93biA9PT0gdm9pZCAwKSB7IG1hcmtkb3duID0gJyc7IH1cbiAgICAgICAgaWYgKGN1cnNvclRvRW5kID09PSB2b2lkIDApIHsgY3Vyc29yVG9FbmQgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMubWRFZGl0b3Iuc2V0TWFya2Rvd24obWFya2Rvd24sIGN1cnNvclRvRW5kKTtcbiAgICAgICAgaWYgKHRoaXMuaXNXeXNpd3lnTW9kZSgpKSB7XG4gICAgICAgICAgICB2YXIgbWROb2RlID0gdGhpcy50b2FzdE1hcmsuZ2V0Um9vdE5vZGUoKTtcbiAgICAgICAgICAgIHZhciB3d05vZGUgPSB0aGlzLmNvbnZlcnRvci50b1d5c2l3eWdNb2RlbChtZE5vZGUpO1xuICAgICAgICAgICAgdGhpcy53d0VkaXRvci5zZXRNb2RlbCh3d05vZGUsIGN1cnNvclRvRW5kKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGh0bWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgLSBodG1sIHN5bnRheCB0ZXh0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY3Vyc29yVG9FbmQ9dHJ1ZV0gLSBtb3ZlIGN1cnNvciB0byBjb250ZW50cyBlbmRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuc2V0SFRNTCA9IGZ1bmN0aW9uIChodG1sLCBjdXJzb3JUb0VuZCkge1xuICAgICAgICBpZiAoaHRtbCA9PT0gdm9pZCAwKSB7IGh0bWwgPSAnJzsgfVxuICAgICAgICBpZiAoY3Vyc29yVG9FbmQgPT09IHZvaWQgMCkgeyBjdXJzb3JUb0VuZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAvLyB0aGUgYGJyYCB0YWcgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggZW1wdHkgYmxvY2sgdG8gc2VwYXJhdGUgYmV0d2VlbiBibG9ja3NcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IHJlcGxhY2VCUldpdGhFbXB0eUJsb2NrKGh0bWwpO1xuICAgICAgICB2YXIgd3dOb2RlID0gRE9NUGFyc2VyLmZyb21TY2hlbWEodGhpcy53d0VkaXRvci5zY2hlbWEpLnBhcnNlKGNvbnRhaW5lcik7XG4gICAgICAgIGlmICh0aGlzLmlzTWFya2Rvd25Nb2RlKCkpIHtcbiAgICAgICAgICAgIHRoaXMubWRFZGl0b3Iuc2V0TWFya2Rvd24odGhpcy5jb252ZXJ0b3IudG9NYXJrZG93blRleHQod3dOb2RlKSwgY3Vyc29yVG9FbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53d0VkaXRvci5zZXRNb2RlbCh3d05vZGUsIGN1cnNvclRvRW5kKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGNvbnRlbnQgdG8gbWFya2Rvd25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBtYXJrZG93biB0ZXh0XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldE1hcmtkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc01hcmtkb3duTW9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZEVkaXRvci5nZXRNYXJrZG93bigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRvci50b01hcmtkb3duVGV4dCh0aGlzLnd3RWRpdG9yLmdldE1vZGVsKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGNvbnRlbnQgdG8gaHRtbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGh0bWwgc3RyaW5nXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldEhUTUwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmhvbGRFdmVudEludm9rZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNNYXJrZG93bk1vZGUoKSkge1xuICAgICAgICAgICAgICAgIHZhciBtZE5vZGUgPSBfdGhpcy50b2FzdE1hcmsuZ2V0Um9vdE5vZGUoKTtcbiAgICAgICAgICAgICAgICB2YXIgd3dOb2RlID0gX3RoaXMuY29udmVydG9yLnRvV3lzaXd5Z01vZGVsKG1kTm9kZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMud3dFZGl0b3Iuc2V0TW9kZWwod3dOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBodG1sID0gcmVtb3ZlUHJvc2VNaXJyb3JIYWNrTm9kZXModGhpcy53d0VkaXRvci52aWV3LmRvbS5pbm5lckhUTUwpO1xuICAgICAgICBpZiAodGhpcy5wbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgdmFyIHJlUGxhY2Vob2xkZXIgPSBuZXcgUmVnRXhwKFwiPHNwYW4gY2xhc3M9XFxcInBsYWNlaG9sZGVyW14+XSs+XCIgKyB0aGlzLnBsYWNlaG9sZGVyICsgXCI8L3NwYW4+XCIsICdpJyk7XG4gICAgICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKHJlUGxhY2Vob2xkZXIsICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluc2VydCB0ZXh0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IGNvbnRlbnRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuaW5zZXJ0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5yZXBsYWNlU2VsZWN0aW9uKHRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHNlbGVjdGlvbiByYW5nZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBzdGFydCAtIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IGVuZCAtIGVuZCBwb3NpdGlvblxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkuc2V0U2VsZWN0aW9uKHN0YXJ0LCBlbmQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBzZWxlY3Rpb24gcmFuZ2Ugd2l0aCBnaXZlbiB0ZXh0IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgY29udGVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBbc3RhcnRdIC0gc3RhcnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gW2VuZF0gLSBlbmQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUucmVwbGFjZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5yZXBsYWNlU2VsZWN0aW9uKHRleHQsIHN0YXJ0LCBlbmQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRoZSBjb250ZW50IG9mIHNlbGVjdGlvbiByYW5nZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBbc3RhcnRdIC0gc3RhcnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gW2VuZF0gLSBlbmQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZGVsZXRlU2VsZWN0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLmRlbGV0ZVNlbGVjdGlvbihzdGFydCwgZW5kKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBzZWxlY3RlZCB0ZXh0IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gW3N0YXJ0XSAtIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtlbmRdIC0gZW5kIHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSBzZWxlY3RlZCB0ZXh0IGNvbnRlbnRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRUZXh0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5nZXRTZWxlY3RlZFRleHQoc3RhcnQsIGVuZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgcmFuZ2Ugb2YgdGhlIG5vZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gW3Bvc10gLSBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyW10+fEFycmF5LjxudW1iZXI+fSAtIG5vZGUgW3N0YXJ0LCBlbmRdIHJhbmdlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBNYXJrZG93biBtb2RlXG4gICAgICogY29uc3QgcmFuZ2VJbmZvID0gZWRpdG9yLmdldFJhbmdlSW5mb09mTm9kZSgpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cocmFuZ2VJbmZvKTsgLy8geyByYW5nZTogW1tzdGFydExpbmVPZmZzZXQsIHN0YXJ0Q3Vyb3JPZmZzZXRdLCBbZW5kTGluZU9mZnNldCwgZW5kQ3Vyb3JPZmZzZXRdXSwgdHlwZTogJ2VtcGgnIH1cbiAgICAgKlxuICAgICAqIC8vIFdZU0lXWUcgbW9kZVxuICAgICAqIGNvbnN0IHJhbmdlSW5mbyA9IGVkaXRvci5nZXRSYW5nZUluZm9PZk5vZGUoKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHJhbmdlSW5mbyk7IC8vIHsgcmFuZ2U6IFtzdGFydEN1cnNvck9mZnNldCwgZW5kQ3Vyc29yT2Zmc2V0XSwgdHlwZTogJ2VtcGgnIH1cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZ2V0UmFuZ2VJbmZvT2ZOb2RlID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLmdldFJhbmdlSW5mb09mTm9kZShwb3MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIHdpZGdldCB0byBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSB3aWRnZXQgbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZSAtIEFkZGluZyBzdHlsZSBcInRvcFwiIG9yIFwiYm90dG9tXCJcbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gW3Bvc10gLSBwb3NpdGlvblxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5hZGRXaWRnZXQgPSBmdW5jdGlvbiAobm9kZSwgc3R5bGUsIHBvcykge1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkuYWRkV2lkZ2V0KG5vZGUsIHN0eWxlLCBwb3MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBub2RlIHdpdGggd2lkZ2V0IHRvIHJhbmdlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHN0YXJ0IC0gc3RhcnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gZW5kIC0gZW5kIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB3aWRnZXQgdGV4dCBjb250ZW50XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnJlcGxhY2VXaXRoV2lkZ2V0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHRleHQpIHtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLnJlcGxhY2VXaXRoV2lkZ2V0KHN0YXJ0LCBlbmQsIHRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGVkaXRvciBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGVpZ2h0IC0gZWRpdG9yIGhlaWdodCBpbiBwaXhlbFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMub3B0aW9ucy5lbDtcbiAgICAgICAgaWYgKGlzU3RyaW5nXzEoaGVpZ2h0KSkge1xuICAgICAgICAgICAgaWYgKGhlaWdodCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3NfMShlbCwgJ2F1dG8taGVpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzc18xKGVsLCAnYXV0by1oZWlnaHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0TWluSGVpZ2h0KHRoaXMuZ2V0TWluSGVpZ2h0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGNzc18xKGVsLCB7IGhlaWdodDogaGVpZ2h0IH0pO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBlZGl0b3IgaGVpZ2h0XG4gICAgICogQHJldHVybnMge3N0cmluZ30gZWRpdG9yIGhlaWdodCBpbiBwaXhlbFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBtaW5pbXVtIGhlaWdodCB0byBlZGl0b3IgY29udGVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtaW5IZWlnaHQgLSBtaW4gY29udGVudCBoZWlnaHQgaW4gcGl4ZWxcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuc2V0TWluSGVpZ2h0ID0gZnVuY3Rpb24gKG1pbkhlaWdodCkge1xuICAgICAgICBpZiAobWluSGVpZ2h0ICE9PSB0aGlzLm1pbkhlaWdodCkge1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0IHx8IHRoaXMub3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoaGVpZ2h0ICE9PSAnYXV0bycgJiYgdGhpcy5vcHRpb25zLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBjbHMoJ21haW4nKSkpIHtcbiAgICAgICAgICAgICAgICAvLyA3NXB4IGVxdWFscyBkZWZhdWx0IGVkaXRvciB1aSBoZWlnaHQgLSB0aGUgZWRpdGluZyBhcmVhIGhlaWdodFxuICAgICAgICAgICAgICAgIG1pbkhlaWdodCA9IE1hdGgubWluKHBhcnNlSW50KG1pbkhlaWdodCwgMTApLCBwYXJzZUludChoZWlnaHQsIDEwKSAtIDc1KSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaW5IZWlnaHROdW0gPSBwYXJzZUludChtaW5IZWlnaHQsIDEwKTtcbiAgICAgICAgICAgIHRoaXMubWluSGVpZ2h0ID0gbWluSGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy53d0VkaXRvci5zZXRNaW5IZWlnaHQobWluSGVpZ2h0TnVtKTtcbiAgICAgICAgICAgIHRoaXMubWRFZGl0b3Iuc2V0TWluSGVpZ2h0KG1pbkhlaWdodE51bSk7XG4gICAgICAgICAgICB0aGlzLnByZXZpZXcuc2V0TWluSGVpZ2h0KG1pbkhlaWdodE51bSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBtaW5pbXVtIGhlaWdodCBvZiBlZGl0b3IgY29udGVudFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IG1pbiBoZWlnaHQgaW4gcGl4ZWxcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZ2V0TWluSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5IZWlnaHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiBjdXJyZW50IGVkaXRvciBtb2RlIGlzIE1hcmtkb3duXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmlzTWFya2Rvd25Nb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSAnbWFya2Rvd24nO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgY3VycmVudCBlZGl0b3IgbW9kZSBpcyBXWVNJV1lHXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmlzV3lzaXd5Z01vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT09ICd3eXNpd3lnJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBmYWxzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5pc1ZpZXdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgTWFya2Rvd24gZWRpdG9yJ3MgcHJldmlldyBzdHlsZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldEN1cnJlbnRQcmV2aWV3U3R5bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1kUHJldmlld1N0eWxlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGVkaXRvcidzIG1vZGUgdG8gZ2l2ZW4gbW9kZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAtIEVkaXRvciBtb2RlIG5hbWUgb2Ygd2FudCB0byBjaGFuZ2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt3aXRob3V0Rm9jdXNdIC0gQ2hhbmdlIG1vZGUgd2l0aG91dCBmb2N1c1xuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5jaGFuZ2VNb2RlID0gZnVuY3Rpb24gKG1vZGUsIHdpdGhvdXRGb2N1cykge1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSBtb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgaWYgKHRoaXMuaXNXeXNpd3lnTW9kZSgpKSB7XG4gICAgICAgICAgICB2YXIgbWROb2RlID0gdGhpcy50b2FzdE1hcmsuZ2V0Um9vdE5vZGUoKTtcbiAgICAgICAgICAgIHZhciB3d05vZGUgPSB0aGlzLmNvbnZlcnRvci50b1d5c2l3eWdNb2RlbChtZE5vZGUpO1xuICAgICAgICAgICAgdGhpcy53d0VkaXRvci5zZXRNb2RlbCh3d05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHd3Tm9kZSA9IHRoaXMud3dFZGl0b3IuZ2V0TW9kZWwoKTtcbiAgICAgICAgICAgIHRoaXMubWRFZGl0b3Iuc2V0TWFya2Rvd24odGhpcy5jb252ZXJ0b3IudG9NYXJrZG93blRleHQod3dOb2RlKSwgIXdpdGhvdXRGb2N1cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgncmVtb3ZlUG9wdXBXaWRnZXQnKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnY2hhbmdlTW9kZScsIG1vZGUpO1xuICAgICAgICBpZiAoIXdpdGhvdXRGb2N1cykge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuY29udmVydG9yLmdldE1hcHBlZFBvcygpO1xuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNXeXNpd3lnTW9kZSgpICYmIGlzTnVtYmVyXzEocG9zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMud3dFZGl0b3Iuc2V0U2VsZWN0aW9uKHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBvcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1kRWRpdG9yLnNldFNlbGVjdGlvbihwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95IFRVSUVkaXRvciBmcm9tIGRvY3VtZW50XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMud3dFZGl0b3IuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1kRWRpdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wcmV2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zY3JvbGxTeW5jLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnZGVzdHJveScpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5nZXRFdmVudHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChfLCB0eXBlKSB7IHJldHVybiBfdGhpcy5vZmYodHlwZSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGlkZSBUVUlFZGl0b3JcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnaGlkZScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hvdyBUVUlFZGl0b3JcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnc2hvdycpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTW92ZSBvbiBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGVkaXRvciBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgc2Nyb2xsVG9wIHZhbHVlIG9mIGVkaXRvciBjb250YWluZXJcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5zZXRTY3JvbGxUb3AodmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHNjcm9sbCBwb3NpdGlvbiB2YWx1ZSBvZiBlZGl0b3IgY29udGFpbmVyXG4gICAgICogQHJldHVybnMge251bWJlcn0gc2Nyb2xsVG9wIHZhbHVlIG9mIGVkaXRvciBjb250YWluZXJcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLmdldFNjcm9sbFRvcCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXQgVFVJRWRpdG9yXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnd3RWRpdG9yLnNldE1vZGVsKFtdKTtcbiAgICAgICAgdGhpcy5tZEVkaXRvci5zZXRNYXJrZG93bignJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcltdPnxBcnJheS48bnVtYmVyPn0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgdGhlIHNlbGVjdGlvbiBkZXBlbmRpbmcgb24gdGhlIGVkaXRvciBtb2RlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBNYXJrZG93biBtb2RlXG4gICAgICogY29uc3QgbWRTZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhtZFNlbGVjdGlvbik7IC8vIFtbc3RhcnRMaW5lT2Zmc2V0LCBzdGFydEN1cm9yT2Zmc2V0XSwgW2VuZExpbmVPZmZzZXQsIGVuZEN1cm9yT2Zmc2V0XV1cbiAgICAgKlxuICAgICAqIC8vIFdZU0lXWUcgbW9kZVxuICAgICAqIGNvbnN0IHd3U2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cod3dTZWxlY3Rpb24pOyAvLyBbc3RhcnRDdXJzb3JPZmZzZXQsIGVuZEN1cnNvck9mZnNldF1cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLmdldFNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwbGFjZWhvbGRlciBvbiBhbGwgZWRpdG9yc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwbGFjZWhvbGRlciAtIHBsYWNlaG9sZGVyIHRvIHNldFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5zZXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwbGFjZWhvbGRlcikge1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICAgIHRoaXMubWRFZGl0b3Iuc2V0UGxhY2Vob2xkZXIocGxhY2Vob2xkZXIpO1xuICAgICAgICB0aGlzLnd3RWRpdG9yLnNldFBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBtYXJrZG93biBlZGl0b3IsIHByZXZpZXcsIHd5c2l3eWcgZWRpdG9yIERPTSBlbGVtZW50c1xuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5nZXRFZGl0b3JFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1kRWRpdG9yOiB0aGlzLm1kRWRpdG9yLmdldEVsZW1lbnQoKSxcbiAgICAgICAgICAgIG1kUHJldmlldzogdGhpcy5wcmV2aWV3LmdldEVsZW1lbnQoKSxcbiAgICAgICAgICAgIHd3RWRpdG9yOiB0aGlzLnd3RWRpdG9yLmdldEVsZW1lbnQoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgcG9zaXRpb24gdG8gbWF0Y2ggZWRpdG9yIG1vZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gc3RhcnQgLSBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBlbmQgLSBlbmQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAtIEVkaXRvciBtb2RlIG5hbWUgb2Ygd2FudCB0byBtYXRjaCBjb252ZXJ0ZWQgcG9zaXRpb24gdG9cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuY29udmVydFBvc1RvTWF0Y2hFZGl0b3JNb2RlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIG1vZGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IHN0YXJ0OyB9XG4gICAgICAgIGlmIChtb2RlID09PSB2b2lkIDApIHsgbW9kZSA9IHRoaXMubW9kZTsgfVxuICAgICAgICB2YXIgZG9jID0gdGhpcy5tZEVkaXRvci52aWV3LnN0YXRlLmRvYztcbiAgICAgICAgdmFyIGlzRnJvbUFycmF5ID0gQXJyYXkuaXNBcnJheShzdGFydCk7XG4gICAgICAgIHZhciBpc1RvQXJyYXkgPSBBcnJheS5pc0FycmF5KGVuZCk7XG4gICAgICAgIHZhciBjb252ZXJ0ZWRGcm9tID0gc3RhcnQ7XG4gICAgICAgIHZhciBjb252ZXJ0ZWRUbyA9IGVuZDtcbiAgICAgICAgaWYgKGlzRnJvbUFycmF5ICE9PSBpc1RvQXJyYXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHlwZXMgb2YgYXJndW1lbnRzIG11c3QgYmUgc2FtZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RlID09PSAnbWFya2Rvd24nICYmICFpc0Zyb21BcnJheSAmJiAhaXNUb0FycmF5KSB7XG4gICAgICAgICAgICBfYSA9IGdldEVkaXRvclRvTWRQb3MoZG9jLCBzdGFydCwgZW5kKSwgY29udmVydGVkRnJvbSA9IF9hWzBdLCBjb252ZXJ0ZWRUbyA9IF9hWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICd3eXNpd3lnJyAmJiBpc0Zyb21BcnJheSAmJiBpc1RvQXJyYXkpIHtcbiAgICAgICAgICAgIF9iID0gZ2V0TWRUb0VkaXRvclBvcyhkb2MsIHN0YXJ0LCBlbmQpLCBjb252ZXJ0ZWRGcm9tID0gX2JbMF0sIGNvbnZlcnRlZFRvID0gX2JbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtjb252ZXJ0ZWRGcm9tLCBjb252ZXJ0ZWRUb107XG4gICAgfTtcbiAgICByZXR1cm4gVG9hc3RVSUVkaXRvckNvcmU7XG59KCkpO1xuXG4vLyBAVE9ETzogY2hhbmdlIHN5bnRheCB3aXRoIG91ciBjb252ZW50aW9uXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuZnVuY3Rpb24gaHRtbCQxIChuKSB7XG4gIGZvciAoXG4gICAgdmFyIGwsXG4gICAgICBlLFxuICAgICAgcyA9IGFyZ3VtZW50cyxcbiAgICAgIHQgPSAxLFxuICAgICAgciA9ICcnLFxuICAgICAgdSA9ICcnLFxuICAgICAgYSA9IFswXSxcbiAgICAgIGMgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB0ID09PSAxICYmIChuIHx8IChyID0gci5yZXBsYWNlKC9eXFxzKlxcblxccyp8XFxzKlxcblxccyokL2csICcnKSkpXG4gICAgICAgICAgPyBhLnB1c2gobiA/IHNbbl0gOiByKVxuICAgICAgICAgIDogdCA9PT0gMyAmJiAobiB8fCByKVxuICAgICAgICAgID8gKChhWzFdID0gbiA/IHNbbl0gOiByKSwgKHQgPSAyKSlcbiAgICAgICAgICA6IHQgPT09IDIgJiYgciA9PT0gJy4uLicgJiYgblxuICAgICAgICAgID8gKGFbMl0gPSBhc3NpZ24oYVsyXSB8fCB7fSwgc1tuXSkpXG4gICAgICAgICAgOiB0ID09PSAyICYmIHIgJiYgIW5cbiAgICAgICAgICA/ICgoYVsyXSA9IGFbMl0gfHwge30pW3JdID0gITApXG4gICAgICAgICAgOiB0ID49IDUgJiZcbiAgICAgICAgICAgICh0ID09PSA1XG4gICAgICAgICAgICAgID8gKCgoYVsyXSA9IGFbMl0gfHwge30pW2VdID0gbiA/IChyID8gciArIHNbbl0gOiBzW25dKSA6IHIpLCAodCA9IDYpKVxuICAgICAgICAgICAgICA6IChuIHx8IHIpICYmIChhWzJdW2VdICs9IG4gPyByICsgc1tuXSA6IHIpKSxcbiAgICAgICAgICAociA9ICcnKTtcbiAgICAgIH0sXG4gICAgICBoID0gMDtcbiAgICBoIDwgbi5sZW5ndGg7XG4gICAgaCsrXG4gICkge1xuICAgIGggJiYgKHQgPT09IDEgJiYgYygpLCBjKGgpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5baF0ubGVuZ3RoOyBpKyspXG4gICAgICAobCA9IG5baF1baV0pLFxuICAgICAgICB0ID09PSAxXG4gICAgICAgICAgPyBsID09PSAnPCdcbiAgICAgICAgICAgID8gKGMoKSwgKGEgPSBbYSwgJycsIG51bGxdKSwgKHQgPSAzKSlcbiAgICAgICAgICAgIDogKHIgKz0gbClcbiAgICAgICAgICA6IHQgPT09IDRcbiAgICAgICAgICA/IHIgPT09ICctLScgJiYgbCA9PT0gJz4nXG4gICAgICAgICAgICA/ICgodCA9IDEpLCAociA9ICcnKSlcbiAgICAgICAgICAgIDogKHIgPSBsICsgclswXSlcbiAgICAgICAgICA6IHVcbiAgICAgICAgICA/IGwgPT09IHVcbiAgICAgICAgICAgID8gKHUgPSAnJylcbiAgICAgICAgICAgIDogKHIgKz0gbClcbiAgICAgICAgICA6IGwgPT09ICdcIicgfHwgbCA9PT0gXCInXCJcbiAgICAgICAgICA/ICh1ID0gbClcbiAgICAgICAgICA6IGwgPT09ICc+J1xuICAgICAgICAgID8gKGMoKSwgKHQgPSAxKSlcbiAgICAgICAgICA6IHQgJiZcbiAgICAgICAgICAgIChsID09PSAnPSdcbiAgICAgICAgICAgICAgPyAoKHQgPSA1KSwgKGUgPSByKSwgKHIgPSAnJykpXG4gICAgICAgICAgICAgIDogbCA9PT0gJy8nICYmICh0IDwgNSB8fCBuW2hdW2kgKyAxXSA9PT0gJz4nKVxuICAgICAgICAgICAgICA/IChjKCksXG4gICAgICAgICAgICAgICAgdCA9PT0gMyAmJiAoYSA9IGFbMF0pLFxuICAgICAgICAgICAgICAgICh0ID0gYSksXG4gICAgICAgICAgICAgICAgKGEgPSBhWzBdKS5wdXNoKHRoaXMuYXBwbHkobnVsbCwgdC5zbGljZSgxKSkpLFxuICAgICAgICAgICAgICAgICh0ID0gMCkpXG4gICAgICAgICAgICAgIDogbCA9PT0gJyAnIHx8IGwgPT09ICdcXHQnIHx8IGwgPT09ICdcXG4nIHx8IGwgPT09ICdcXHInXG4gICAgICAgICAgICAgID8gKGMoKSwgKHQgPSAyKSlcbiAgICAgICAgICAgICAgOiAociArPSBsKSksXG4gICAgICAgIHQgPT09IDMgJiYgciA9PT0gJyEtLScgJiYgKCh0ID0gNCksIChhID0gYVswXSkpO1xuICB9XG4gIHJldHVybiBjKCksIGEubGVuZ3RoID4gMiA/IGEuc2xpY2UoMSkgOiBhWzFdO1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBzdHJpbmcgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGJvb2xlYW4gb3Igbm90LlxuICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGJvb2xlYW4sIHJldHVybiB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgYm9vbGVhbj9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnYm9vbGVhbicgfHwgb2JqIGluc3RhbmNlb2YgQm9vbGVhbjtcbn1cblxudmFyIGlzQm9vbGVhbl8xID0gaXNCb29sZWFuO1xuXG52YXIgVk5vZGVXYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVk5vZGVXYWxrZXIoY3VycmVudCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLnJvb3QgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLmVudGVyaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgVk5vZGVXYWxrZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGVudGVyaW5nID0gX2EuZW50ZXJpbmcsIGN1ciA9IF9hLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY3VyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIGlmIChjdXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGN1ci5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ciA9PT0gdGhpcy5yb290KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXIubmV4dDtcbiAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2bm9kZTogY3VyLCBlbnRlcmluZzogZW50ZXJpbmcgfTtcbiAgICB9O1xuICAgIHJldHVybiBWTm9kZVdhbGtlcjtcbn0oKSk7XG52YXIgVk5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVk5vZGUodHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbGQgPSBudWxsO1xuICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICB0aGlzLnNraXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgaWYgKHByb3BzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5yZWYgPSBwcm9wcy5yZWY7XG4gICAgICAgICAgICBkZWxldGUgcHJvcHMucmVmO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcy5rZXkpIHtcbiAgICAgICAgICAgIHRoaXMua2V5ID0gcHJvcHMua2V5O1xuICAgICAgICAgICAgZGVsZXRlIHByb3BzLmtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBWTm9kZS5wcm90b3R5cGUud2Fsa2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZOb2RlV2Fsa2VyKHRoaXMpO1xuICAgIH07XG4gICAgVk5vZGUucmVtb3ZhbE5vZGVzID0gW107XG4gICAgcmV0dXJuIFZOb2RlO1xufSgpKTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUodGV4dCkge1xuICAgIHJldHVybiBuZXcgVk5vZGUoJ1RFWFRfTk9ERScsIHsgbm9kZVZhbHVlOiB0ZXh0IH0sIFtdKTtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVVbm5lY2Vzc2FyeUNoaWxkKGNoaWxkLCBmbGF0dGVkKSB7XG4gICAgdmFyIHZub2RlID0gY2hpbGQ7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgaWYgKGlzQm9vbGVhbl8xKGNoaWxkKSB8fCBjaGlsZCA9PSBudWxsKSB7XG4gICAgICAgIHZub2RlID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdHJpbmdfMShjaGlsZCkgfHwgaXNOdW1iZXJfMShjaGlsZCkpIHtcbiAgICAgICAgdm5vZGUgPSBjcmVhdGVUZXh0Tm9kZShTdHJpbmcoY2hpbGQpKTtcbiAgICB9XG4gICAgaWYgKHZub2RlKSB7XG4gICAgICAgIGZsYXR0ZWQucHVzaCh2bm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaCh0eXBlLCBwcm9wcykge1xuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGNoaWxkcmVuW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgZmxhdHRlZCA9IFtdO1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAgICAgY2hpbGQuZm9yRWFjaChmdW5jdGlvbiAodm5vZGUpIHtcbiAgICAgICAgICAgICAgICBleGNsdWRlVW5uZWNlc3NhcnlDaGlsZCh2bm9kZSwgZmxhdHRlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4Y2x1ZGVVbm5lY2Vzc2FyeUNoaWxkKGNoaWxkLCBmbGF0dGVkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVk5vZGUodHlwZSwgcHJvcHMgfHwge30sIGZsYXR0ZWQpO1xufVxuLy8gQHRzLWlnbm9yZVxudmFyIGh0bWwgPSBodG1sJDEuYmluZChoKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIG9iamVjdCBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIG9iamVjdCBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYW4gb2JqZWN0LCByZXR1cm4gdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIG9iamVjdD9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG59XG5cbnZhciBpc09iamVjdF8xID0gaXNPYmplY3Q7XG5cbi8vIEBUT0RPOiBjbGVhcmZ5IHRoZSB0eXBlIGRlZmluaXRpb24gZm9yIENTU0RlY2xhcmF0aW9uXG5mdW5jdGlvbiBjcmVhdGVOb2RlKHZub2RlKSB7XG4gICAgdmFyIG5vZGU7XG4gICAgaWYgKHZub2RlLnR5cGUgPT09ICdURVhUX05PREUnKSB7XG4gICAgICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2bm9kZS5wcm9wcy5ub2RlVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodm5vZGUudHlwZSk7XG4gICAgICAgIHNldFByb3BzKG5vZGUsIHt9LCB2bm9kZS5wcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcmVtb3ZlTm9kZSh2bm9kZSwgcGFyZW50Tm9kZSkge1xuICAgIGlmICh2bm9kZS5ub2RlKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodm5vZGUubm9kZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZW1vdmVOb2RlKHZub2RlLmZpcnN0Q2hpbGQsIHBhcmVudE5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlubmVyRGlmZihub2RlLCBwcmV2UHJvcHMsIG5leHRQcm9wcykge1xuICAgIE9iamVjdC5rZXlzKHByZXZQcm9wcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgaWYgKC9eb24vLnRlc3QocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoIW5leHRQcm9wc1twcm9wTmFtZV0gfHwgcHJldlByb3BzW3Byb3BOYW1lXSAhPT0gbmV4dFByb3BzW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBwcm9wTmFtZS5zbGljZSgyKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHByZXZQcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3BOYW1lICE9PSAnY2hpbGRyZW4nICYmICFuZXh0UHJvcHNbcHJvcE5hbWVdICYmICFpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wTmFtZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBzZXRQcm9wcyhub2RlLCBwcmV2UHJvcHMsIG5leHRQcm9wcywgZnVuY3Rpb24gKHByb3BOYW1lKSB7IHJldHVybiAhc2hhbGxvd0VxdWFsKHByZXZQcm9wc1twcm9wTmFtZV0sIG5leHRQcm9wc1twcm9wTmFtZV0pOyB9KTtcbn1cbnZhciByZU5vbkRpbWVuc2lvbiA9IC9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZC9pO1xuZnVuY3Rpb24gc2V0UHJvcHMobm9kZSwgcHJldlByb3BzLCBwcm9wcywgY29uZGl0aW9uKSB7XG4gICAgT2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgIGlmICghY29uZGl0aW9uIHx8IGNvbmRpdGlvbihwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgIGlmICgvXm9uLy50ZXN0KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBwcm9wTmFtZS5zbGljZSgyKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wTmFtZSA9PT0gJ25vZGVWYWx1ZScpIHtcbiAgICAgICAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BOYW1lID09PSAnc3R5bGUnICYmIGlzT2JqZWN0XzEocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICAgICAgICAgIHNldFN0eWxlUHJvcHMobm9kZSwgcHJldlByb3BzW3Byb3BOYW1lXSwgcHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BOYW1lICE9PSAnY2hpbGRyZW4nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUocHJvcE5hbWUsIHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRTdHlsZVByb3BzKG5vZGUsIHByZXZTdHlsZVByb3BzLCBzdHlsZVByb3BzKSB7XG4gICAgaWYgKHByZXZTdHlsZVByb3BzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHByZXZTdHlsZVByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZVByb3ApIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIG5vZGUuc3R5bGVbc3R5bGVQcm9wXSA9ICcnO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoc3R5bGVQcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVQcm9wKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlUHJvcHNbc3R5bGVQcm9wXTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBub2RlLnN0eWxlW3N0eWxlUHJvcF0gPVxuICAgICAgICAgICAgaXNOdW1iZXJfMSh2YWx1ZSkgJiYgIXJlTm9uRGltZW5zaW9uLnRlc3Qoc3R5bGVQcm9wKSA/IHZhbHVlICsgXCJweFwiIDogdmFsdWU7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdCh2bm9kZSkge1xuICAgIFZOb2RlLnJlbW92YWxOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZW1vdmFsTm9kZSkgeyByZXR1cm4gZGlmZihyZW1vdmFsTm9kZSk7IH0pO1xuICAgIGlmICh2bm9kZSkge1xuICAgICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHdhbGtlciA9IHZub2RlLndhbGtlcigpO1xuICAgICAgICB3aGlsZSAoKG5leHQgPSB3YWxrZXIud2FsaygpKSkge1xuICAgICAgICAgICAgdm5vZGUgPSBuZXh0LnZub2RlO1xuICAgICAgICAgICAgaWYgKG5leHQuZW50ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICBkaWZmKHZub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb25fMSh2bm9kZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgICAgICAgICAgIC8vIGxpZmVjeWNsZSBtZXRob2RcbiAgICAgICAgICAgICAgICBpZiAoIXZub2RlLm9sZCAmJiBjb21wLm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcC5tb3VudGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2bm9kZS5vbGQgJiYgY29tcC51cGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSBjb21wLnByZXZQcm9wcyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgY29tcC51cGRhdGVkKHByZXZQcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZSh2bm9kZSkge1xuICAgIHZhciBwYXJlbnQgPSB2bm9kZS5wYXJlbnQ7XG4gICAgd2hpbGUgKCFwYXJlbnQubm9kZSkge1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Lm5vZGU7XG59XG5mdW5jdGlvbiBkaWZmKHZub2RlKSB7XG4gICAgaWYgKCF2bm9kZSB8fCAhdm5vZGUucGFyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZub2RlLm5vZGUpIHtcbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKHZub2RlKTtcbiAgICAgICAgaWYgKHZub2RlLmVmZmVjdCA9PT0gJ0EnKSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKHZub2RlLm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZub2RlLmVmZmVjdCA9PT0gJ1UnKSB7XG4gICAgICAgICAgICBpbm5lckRpZmYodm5vZGUubm9kZSwgdm5vZGUub2xkLnByb3BzLCB2bm9kZS5wcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZub2RlLmVmZmVjdCA9PT0gJ0QnKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdm9pZCAwO1xuICAgICAgICB2YXIgd2Fsa2VyID0gdm5vZGUud2Fsa2VyKCk7XG4gICAgICAgIHdoaWxlICgobmV4dCA9IHdhbGtlci53YWxrKCkpKSB7XG4gICAgICAgICAgICB2bm9kZSA9IG5leHQudm5vZGU7XG4gICAgICAgICAgICBpZiAoIW5leHQuZW50ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbl8xKHZub2RlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICAvLyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wLmJlZm9yZURlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXAuYmVmb3JlRGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUodm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKHZub2RlLCBwYXJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYXBwbHkgcmVmXG4gICAgaWYgKHZub2RlLnJlZikge1xuICAgICAgICBpZiAodm5vZGUuY29tcG9uZW50KSB7XG4gICAgICAgICAgICB2bm9kZS5yZWYodm5vZGUuY29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2bm9kZS5ub2RlKSB7XG4gICAgICAgICAgICB2bm9kZS5yZWYodm5vZGUubm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudChDb21wLCB2bm9kZSkge1xuICAgIHZhciBwcm9wcyA9IHZub2RlLnByb3BzLCBjb21wb25lbnQgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICBjb21wb25lbnQucHJldlByb3BzID0gY29tcG9uZW50LnByb3BzO1xuICAgICAgICBjb21wb25lbnQucHJvcHMgPSB2bm9kZS5wcm9wcztcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb21wKHByb3BzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVk5vZGUodm5vZGUpIHtcbiAgICB2YXIgcm9vdCA9IHZub2RlO1xuICAgIHdoaWxlICh2bm9kZSAmJiAhdm5vZGUuc2tpcCkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbl8xKHZub2RlLnR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnQodm5vZGUudHlwZSwgdm5vZGUpO1xuICAgICAgICAgICAgaW5zdGFuY2Uudm5vZGUgPSB2bm9kZTtcbiAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgdm5vZGUucHJvcHMuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbiA9IFtpbnN0YW5jZS5yZW5kZXIoKV07XG4gICAgICAgICAgICBidWlsZENoaWxkcmVuVk5vZGUodm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF2bm9kZS5ub2RlKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUubm9kZSA9IGNyZWF0ZU5vZGUodm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVpbGRDaGlsZHJlblZOb2RlKHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bm9kZS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKHZub2RlICYmIHZub2RlLnBhcmVudCAmJiAhdm5vZGUubmV4dCkge1xuICAgICAgICAgICAgICAgIHZub2RlID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgIGlmICh2bm9kZSA9PT0gcm9vdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2bm9kZSA9IHZub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1NhbWVUeXBlKG9sZCwgdm5vZGUpIHtcbiAgICByZXR1cm4gb2xkICYmIHZub2RlICYmIHZub2RlLnR5cGUgPT09IG9sZC50eXBlICYmICghdm5vZGUua2V5IHx8IHZub2RlLmtleSA9PT0gb2xkLmtleSk7XG59XG4vLyBAVE9ETzogYWRkIGtleSBkaWZmIGFsZ29yaXRobVxuZnVuY3Rpb24gYnVpbGRDaGlsZHJlblZOb2RlKHBhcmVudCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICB2YXIgb2xkID0gcGFyZW50Lm9sZCA/IHBhcmVudC5vbGQuZmlyc3RDaGlsZCA6IG51bGw7XG4gICAgdmFyIHByZXYgPSBudWxsO1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKHZub2RlLCBpbmRleCkge1xuICAgICAgICB2YXIgc2FtZVR5cGUgPSBpc1NhbWVUeXBlKG9sZCwgdm5vZGUpO1xuICAgICAgICBpZiAoc2FtZVR5cGUpIHtcbiAgICAgICAgICAgIHZub2RlLm9sZCA9IG9sZDtcbiAgICAgICAgICAgIHZub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHZub2RlLm5vZGUgPSBvbGQubm9kZTtcbiAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudCA9IG9sZC5jb21wb25lbnQ7XG4gICAgICAgICAgICB2bm9kZS5lZmZlY3QgPSAnVSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlICYmICFzYW1lVHlwZSkge1xuICAgICAgICAgICAgdm5vZGUub2xkID0gbnVsbDtcbiAgICAgICAgICAgIHZub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHZub2RlLm5vZGUgPSBudWxsO1xuICAgICAgICAgICAgdm5vZGUuZWZmZWN0ID0gJ0EnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGQgJiYgIXNhbWVUeXBlKSB7XG4gICAgICAgICAgICBWTm9kZS5yZW1vdmFsTm9kZXMucHVzaChvbGQpO1xuICAgICAgICAgICAgb2xkLmVmZmVjdCA9ICdEJztcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkKSB7XG4gICAgICAgICAgICBvbGQgPSBvbGQubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHBhcmVudC5maXJzdENoaWxkID0gdm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodm5vZGUpIHtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICAgIHByZXYgPSB2bm9kZTtcbiAgICB9KTtcbiAgICB2YXIgbGFzdENoaWxkID0gbGFzdCQxKGNoaWxkcmVuKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB3aGlsZSAob2xkKSB7XG4gICAgICAgICAgICBWTm9kZS5yZW1vdmFsTm9kZXMucHVzaChvbGQpO1xuICAgICAgICAgICAgb2xkLmVmZmVjdCA9ICdEJztcbiAgICAgICAgICAgIG9sZCA9IG9sZC5uZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChvbGQgJiYgbGFzdENoaWxkKSB7XG4gICAgICAgIGlmIChvbGQgJiYgbGFzdENoaWxkLm9sZCAhPT0gb2xkKSB7XG4gICAgICAgICAgICBWTm9kZS5yZW1vdmFsTm9kZXMucHVzaChvbGQpO1xuICAgICAgICAgICAgb2xkLmVmZmVjdCA9ICdEJztcbiAgICAgICAgICAgIG9sZCA9IG9sZC5uZXh0O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZXN0cm95KHZub2RlKSB7XG4gICAgdm5vZGUuZWZmZWN0ID0gJ0QnO1xuICAgIFZOb2RlLnJlbW92YWxOb2RlcyA9IFt2bm9kZV07XG4gICAgY29tbWl0KCk7XG4gICAgVk5vZGUucmVtb3ZhbE5vZGVzID0gW107XG59XG5mdW5jdGlvbiByZXJlbmRlcihjb21wKSB7XG4gICAgdmFyIHJvb3QgPSBjb21wLnZub2RlO1xuICAgIHJvb3QuZWZmZWN0ID0gJ1UnO1xuICAgIHJvb3Qub2xkID0gcm9vdDtcbiAgICAvLyBza2lwIGZvciB1bm5lY2Vzc2FyeSByZWNvbmNpbGlhdGlvblxuICAgIGlmIChyb290Lm5leHQpIHtcbiAgICAgICAgcm9vdC5uZXh0LnNraXAgPSB0cnVlO1xuICAgIH1cbiAgICBWTm9kZS5yZW1vdmFsTm9kZXMgPSBbXTtcbiAgICBidWlsZFZOb2RlKHJvb3QpO1xuICAgIGNvbW1pdChyb290KTtcbiAgICBpZiAocm9vdC5uZXh0KSB7XG4gICAgICAgIHJvb3QubmV4dC5za2lwID0gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyKGNvbnRhaW5lciwgdm5vZGUpIHtcbiAgICB2YXIgcm9vdCA9IG5ldyBWTm9kZShjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpLCB7fSwgW3Zub2RlXSk7XG4gICAgcm9vdC5ub2RlID0gY29udGFpbmVyO1xuICAgIFZOb2RlLnJlbW92YWxOb2RlcyA9IFtdO1xuICAgIGJ1aWxkVk5vZGUocm9vdCk7XG4gICAgY29tbWl0KHJvb3QpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZXN0cm95KHJvb3QuZmlyc3RDaGlsZCk7IH07XG59XG5cbnZhciBDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzKSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICB9XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIHRoaXMuc3RhdGUpLCBzdGF0ZSk7XG4gICAgICAgIGlmICghc2hhbGxvd0VxdWFsKHRoaXMuc3RhdGUsIG5ld1N0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgcmVyZW5kZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb21wb25lbnQ7XG59KCkpO1xuXG52YXIgU3dpdGNoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFN3aXRjaCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2gocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaGlkZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3dpdGNoLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgaGlkZTogZmFsc2UgfSk7XG4gICAgfTtcbiAgICBTd2l0Y2gucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBoaWRlOiB0cnVlIH0pO1xuICAgIH07XG4gICAgU3dpdGNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGVkaXRvclR5cGUgPSBfYS5lZGl0b3JUeXBlLCBldmVudEVtaXR0ZXIgPSBfYS5ldmVudEVtaXR0ZXI7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkaCB8fCAodGVtcGxhdGVPYmplY3RfMSRoID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogXCIsIFwiXFxcIj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcInRhYi1pdGVtXCIsIFwiXFxcIlxcbiAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwidGFiLWl0ZW1cIiwgXCJcXFwiXFxuICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogXCIsIFwiXFxcIj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcInRhYi1pdGVtXCIsIFwiXFxcIlxcbiAgICAgICAgICBvbkNsaWNrPVwiLFxuICAgICAgICAgICAgXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcInRhYi1pdGVtXCIsIFwiXFxcIlxcbiAgICAgICAgICBvbkNsaWNrPVwiLFxuICAgICAgICAgICAgXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdKSksIGNscygnbW9kZS1zd2l0Y2gnKSwgdGhpcy5zdGF0ZS5oaWRlID8gJ25vbmUnIDogJ2Jsb2NrJywgZWRpdG9yVHlwZSA9PT0gJ21hcmtkb3duJyA/ICcgYWN0aXZlJyA6ICcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBldmVudEVtaXR0ZXIuZW1pdCgnbmVlZENoYW5nZU1vZGUnLCAnbWFya2Rvd24nKTtcbiAgICAgICAgfSwgaTE4bi5nZXQoJ01hcmtkb3duJyksIGVkaXRvclR5cGUgPT09ICd3eXNpd3lnJyA/ICcgYWN0aXZlJyA6ICcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBldmVudEVtaXR0ZXIuZW1pdCgnbmVlZENoYW5nZU1vZGUnLCAnd3lzaXd5ZycpO1xuICAgICAgICB9LCBpMThuLmdldCgnV1lTSVdZRycpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2g7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkaDtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgZm4gdW50aWwgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91Y2VkIGZ1bmN0aW9uIHdhcyBpbnZva2VkLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0Lm5obi5jb20+XG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIHRyaWNrc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBmbiB1bnRpbCBhZnRlciBkZWxheSBtaWxsaXNlY29uZHMgaGFzIGVsYXBzZWRcbiAqIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91Y2VkIGZ1bmN0aW9uIHdhcyBpbnZva2VkLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheVxuICogQHJldHVybnMge2Z1bmN0aW9ufSBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnRyaWNrc1xuICogQGV4YW1wbGVcbiAqIC8vIEVTNlxuICogaW1wb3J0IGRlYm91bmNlIGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvdHJpY2tzL2RlYm91bmNlJztcbiAqIFxuICogLy8gQ29tbW9uSlNcbiAqIGNvbnN0IGRlYm91bmNlID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC90cmlja3MvZGVib3VuY2UnKTtcbiAqXG4gKiBmdW5jdGlvbiBzb21lTWV0aG9kVG9JbnZva2VEZWJvdW5jZWQoKSB7fVxuICpcbiAqIGNvbnN0IGRlYm91bmNlZCA9IGRlYm91bmNlKHNvbWVNZXRob2RUb0ludm9rZURlYm91bmNlZCwgMzAwKTtcbiAqXG4gKiAvLyBpbnZva2UgcmVwZWF0ZWRseVxuICogZGVib3VuY2VkKCk7XG4gKiBkZWJvdW5jZWQoKTtcbiAqIGRlYm91bmNlZCgpO1xuICogZGVib3VuY2VkKCk7XG4gKiBkZWJvdW5jZWQoKTtcbiAqIGRlYm91bmNlZCgpOyAgICAvLyBsYXN0IGludm9rZSBvZiBkZWJvdW5jZWQoKVxuICpcbiAqIC8vIGludm9rZSBzb21lTWV0aG9kVG9JbnZva2VEZWJvdW5jZWQoKSBhZnRlciAzMDAgbWlsbGlzZWNvbmRzLlxuICovXG5mdW5jdGlvbiBkZWJvdW5jZSQxKGZuLCBkZWxheSkge1xuICB2YXIgdGltZXIsIGFyZ3M7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZGVsYXkgPSBkZWxheSB8fCAwO1xuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgZGVsYXkpO1xuICB9XG5cbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxudmFyIGRlYm91bmNlXzEgPSBkZWJvdW5jZSQxO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBmbiBhdCBtb3N0IG9uY2UgcGVyIGV2ZXJ5IGludGVydmFsIG1pbGxpc2Vjb25kcy5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdC5uaG4uY29tPlxuICovXG5cbnZhciBkZWJvdW5jZSA9IGRlYm91bmNlXzE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBmbiBhdCBtb3N0IG9uY2UgcGVyIGV2ZXJ5IGludGVydmFsIG1pbGxpc2Vjb25kcy5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgdGhyb3R0bGUgc2hvcnQgdGltZSByZXBlYXRlZGx5IGludm9raW5nIGZ1bmN0aW9ucy4gKGUuZyBNb3VzZU1vdmUsIFJlc2l6ZSAuLi4pXG4gKiBpZiB5b3UgbmVlZCByZXVzZSB0aHJvdHRsZWQgbWV0aG9kLiB5b3UgbXVzdCByZW1vdmUgc2x1Z3MgKGUuZy4gZmxhZyB2YXJpYWJsZSkgcmVsYXRlZCB3aXRoIHRocm90dGxpbmcuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBmdW5jdGlvbiB0byB0aHJvdHRsZVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbnRlcnZhbD0wXSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnRyaWNrc1xuICogQGV4YW1wbGVcbiAqIC8vIEVTNlxuICogaW1wb3J0IHRocm90dGxlIGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvdHJpY2tzL3Rocm90dGxlJztcbiAqIFxuICogLy8gQ29tbW9uSlNcbiAqIGNvbnN0IHRocm90dGxlID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC90cmlja3MvdGhyb3R0bGUnKTtcbiAqXG4gKiBmdW5jdGlvbiBzb21lTWV0aG9kVG9JbnZva2VUaHJvdHRsZWQoKSB7fVxuICpcbiAqIGNvbnN0IHRocm90dGxlZCA9IHRocm90dGxlKHNvbWVNZXRob2RUb0ludm9rZVRocm90dGxlZCwgMzAwKTtcbiAqXG4gKiAvLyBpbnZva2UgcmVwZWF0ZWRseVxuICogdGhyb3R0bGVkKCk7ICAgIC8vIGludm9rZSAobGVhZGluZylcbiAqIHRocm90dGxlZCgpO1xuICogdGhyb3R0bGVkKCk7ICAgIC8vIGludm9rZSAobmVhciAzMDAgbWlsbGlzZWNvbmRzKVxuICogdGhyb3R0bGVkKCk7XG4gKiB0aHJvdHRsZWQoKTtcbiAqIHRocm90dGxlZCgpOyAgICAvLyBpbnZva2UgKG5lYXIgNjAwIG1pbGxpc2Vjb25kcylcbiAqIC8vIC4uLlxuICogLy8gaW52b2tlICh0cmFpbGluZylcbiAqXG4gKiAvLyBpZiB5b3UgbmVlZCByZXVzZSB0aHJvdHRsZWQgbWV0aG9kLiB0aGVuIGludm9rZSByZXNldCgpXG4gKiB0aHJvdHRsZWQucmVzZXQoKTtcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUkMShmbiwgaW50ZXJ2YWwpIHtcbiAgdmFyIGJhc2U7XG4gIHZhciBpc0xlYWRpbmcgPSB0cnVlO1xuICB2YXIgdGljayA9IGZ1bmN0aW9uKF9hcmdzKSB7XG4gICAgZm4uYXBwbHkobnVsbCwgX2FyZ3MpO1xuICAgIGJhc2UgPSBudWxsO1xuICB9O1xuICB2YXIgZGVib3VuY2VkLCBzdGFtcCwgYXJncztcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpbnRlcnZhbCA9IGludGVydmFsIHx8IDA7XG5cbiAgZGVib3VuY2VkID0gZGVib3VuY2UodGljaywgaW50ZXJ2YWwpO1xuXG4gIGZ1bmN0aW9uIHRocm90dGxlZCgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBpZiAoaXNMZWFkaW5nKSB7XG4gICAgICB0aWNrKGFyZ3MpO1xuICAgICAgaXNMZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGFtcCA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblxuICAgIGJhc2UgPSBiYXNlIHx8IHN0YW1wO1xuXG4gICAgLy8gcGFzcyBhcnJheSBkaXJlY3RseSBiZWNhdXNlIGBkZWJvdW5jZSgpYCwgYHRpY2soKWAgYXJlIGFscmVhZHkgdXNlXG4gICAgLy8gYGFwcGx5KClgIG1ldGhvZCB0byBpbnZva2UgZGV2ZWxvcGVyJ3MgYGZuYCBoYW5kbGVyLlxuICAgIC8vXG4gICAgLy8gYWxzbywgdGhpcyBgZGVib3VuY2VkYCBsaW5lIGludm9rZWQgZXZlcnkgdGltZSBmb3IgaW1wbGVtZW50c1xuICAgIC8vIGB0cmFpbGluZ2AgZmVhdHVyZXMuXG4gICAgZGVib3VuY2VkKGFyZ3MpO1xuXG4gICAgaWYgKChzdGFtcCAtIGJhc2UpID49IGludGVydmFsKSB7XG4gICAgICB0aWNrKGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0KCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICBpc0xlYWRpbmcgPSB0cnVlO1xuICAgIGJhc2UgPSBudWxsO1xuICB9XG5cbiAgdGhyb3R0bGVkLnJlc2V0ID0gcmVzZXQ7XG5cbiAgcmV0dXJuIHRocm90dGxlZDtcbn1cblxudmFyIHRocm90dGxlXzEgPSB0aHJvdHRsZSQxO1xuXG4vKipcclxuICogQSBjb2xsZWN0aW9uIG9mIHNoaW1zIHRoYXQgcHJvdmlkZSBtaW5pbWFsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIEVTNiBjb2xsZWN0aW9ucy5cclxuICpcclxuICogVGhlc2UgaW1wbGVtZW50YXRpb25zIGFyZSBub3QgbWVhbnQgdG8gYmUgdXNlZCBvdXRzaWRlIG9mIHRoZSBSZXNpemVPYnNlcnZlclxyXG4gKiBtb2R1bGVzIGFzIHRoZXkgY292ZXIgb25seSBhIGxpbWl0ZWQgcmFuZ2Ugb2YgdXNlIGNhc2VzLlxyXG4gKi9cclxuLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1qc2RvYywgdmFsaWQtanNkb2MgKi9cclxudmFyIE1hcFNoaW0gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hcDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbmRleCBpbiBwcm92aWRlZCBhcnJheSB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxBcnJheT59IGFyclxyXG4gICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEluZGV4KGFyciwga2V5KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IC0xO1xyXG4gICAgICAgIGFyci5zb21lKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKGVudHJ5WzBdID09PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcInNpemVcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZW50cmllc19fLmxlbmd0aDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX19lbnRyaWVzX19baW5kZXhdO1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMV07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fW2luZGV4XVsxXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5wdXNoKFtrZXksIHZhbHVlXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuX19lbnRyaWVzX187XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KGVudHJpZXMsIGtleSk7XHJcbiAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIX5nZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18uc3BsaWNlKDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtjdHg9bnVsbF1cclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjdHgpIHtcclxuICAgICAgICAgICAgaWYgKGN0eCA9PT0gdm9pZCAwKSB7IGN0eCA9IG51bGw7IH1cclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX19lbnRyaWVzX187IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZW50cnlbMV0sIGVudHJ5WzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XHJcbiAgICB9KCkpO1xyXG59KSgpO1xuXG4vKipcclxuICogRGV0ZWN0cyB3aGV0aGVyIHdpbmRvdyBhbmQgZG9jdW1lbnQgb2JqZWN0cyBhcmUgYXZhaWxhYmxlIGluIGN1cnJlbnQgZW52aXJvbm1lbnQuXHJcbiAqL1xyXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgPT09IGRvY3VtZW50O1xuXG4vLyBSZXR1cm5zIGdsb2JhbCBvYmplY3Qgb2YgYSBjdXJyZW50IGVudmlyb25tZW50LlxyXG52YXIgZ2xvYmFsJDEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXHJcbiAgICByZXR1cm4gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxufSkoKTtcblxuLyoqXHJcbiAqIEEgc2hpbSBmb3IgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3aGljaCBmYWxscyBiYWNrIHRvIHRoZSBzZXRUaW1lb3V0IGlmXHJcbiAqIGZpcnN0IG9uZSBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXF1ZXN0cycgaWRlbnRpZmllci5cclxuICovXHJcbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIEl0J3MgcmVxdWlyZWQgdG8gdXNlIGEgYm91bmRlZCBmdW5jdGlvbiBiZWNhdXNlIElFIHNvbWV0aW1lcyB0aHJvd3NcclxuICAgICAgICAvLyBhbiBcIkludmFsaWQgY2FsbGluZyBvYmplY3RcIiBlcnJvciBpZiByQUYgaXMgaW52b2tlZCB3aXRob3V0IHRoZSBnbG9iYWxcclxuICAgICAgICAvLyBvYmplY3Qgb24gdGhlIGxlZnQgaGFuZCBzaWRlLlxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChnbG9iYWwkMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKERhdGUubm93KCkpOyB9LCAxMDAwIC8gNjApOyB9O1xyXG59KSgpO1xuXG4vLyBEZWZpbmVzIG1pbmltdW0gdGltZW91dCBiZWZvcmUgYWRkaW5nIGEgdHJhaWxpbmcgY2FsbC5cclxudmFyIHRyYWlsaW5nVGltZW91dCA9IDI7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgd3JhcHBlciBmdW5jdGlvbiB3aGljaCBlbnN1cmVzIHRoYXQgcHJvdmlkZWQgY2FsbGJhY2sgd2lsbCBiZVxyXG4gKiBpbnZva2VkIG9ubHkgb25jZSBkdXJpbmcgdGhlIHNwZWNpZmllZCBkZWxheSBwZXJpb2QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgZGVsYXkgcGVyaW9kLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgLSBEZWxheSBhZnRlciB3aGljaCB0byBpbnZva2UgY2FsbGJhY2suXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICovXHJcbmZ1bmN0aW9uIHRocm90dGxlIChjYWxsYmFjaywgZGVsYXkpIHtcclxuICAgIHZhciBsZWFkaW5nQ2FsbCA9IGZhbHNlLCB0cmFpbGluZ0NhbGwgPSBmYWxzZSwgbGFzdENhbGxUaW1lID0gMDtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyB0aGUgb3JpZ2luYWwgY2FsbGJhY2sgZnVuY3Rpb24gYW5kIHNjaGVkdWxlcyBuZXcgaW52b2NhdGlvbiBpZlxyXG4gICAgICogdGhlIFwicHJveHlcIiB3YXMgY2FsbGVkIGR1cmluZyBjdXJyZW50IHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlc29sdmVQZW5kaW5nKCkge1xyXG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICBsZWFkaW5nQ2FsbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhaWxpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIHByb3h5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBpbnZva2VkIGFmdGVyIHRoZSBzcGVjaWZpZWQgZGVsYXkuIEl0IHdpbGwgZnVydGhlciBwb3N0cG9uZVxyXG4gICAgICogaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gZGVsZWdhdGluZyBpdCB0byB0aGVcclxuICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGltZW91dENhbGxiYWNrKCkge1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxKHJlc29sdmVQZW5kaW5nKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2NoZWR1bGVzIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwcm94eSgpIHtcclxuICAgICAgICB2YXIgdGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgLy8gUmVqZWN0IGltbWVkaWF0ZWx5IGZvbGxvd2luZyBjYWxscy5cclxuICAgICAgICAgICAgaWYgKHRpbWVTdGFtcCAtIGxhc3RDYWxsVGltZSA8IHRyYWlsaW5nVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIG5ldyBjYWxsIHRvIGJlIGluIGludm9rZWQgd2hlbiB0aGUgcGVuZGluZyBvbmUgaXMgcmVzb2x2ZWQuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciBcInRyYW5zaXRpb25zXCIgd2hpY2ggbmV2ZXIgYWN0dWFsbHkgc3RhcnRcclxuICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHkgc28gdGhlcmUgaXMgYSBjaGFuY2UgdGhhdCB3ZSBtaWdodCBtaXNzIG9uZSBpZiBjaGFuZ2VcclxuICAgICAgICAgICAgLy8gaGFwcGVucyBhbWlkcyB0aGUgcGVuZGluZyBpbnZvY2F0aW9uLlxyXG4gICAgICAgICAgICB0cmFpbGluZ0NhbGwgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGVhZGluZ0NhbGwgPSB0cnVlO1xyXG4gICAgICAgICAgICB0cmFpbGluZ0NhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aW1lb3V0Q2FsbGJhY2ssIGRlbGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGFzdENhbGxUaW1lID0gdGltZVN0YW1wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3h5O1xyXG59XG5cbi8vIE1pbmltdW0gZGVsYXkgYmVmb3JlIGludm9raW5nIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLlxyXG52YXIgUkVGUkVTSF9ERUxBWSA9IDIwO1xyXG4vLyBBIGxpc3Qgb2Ygc3Vic3RyaW5ncyBvZiBDU1MgcHJvcGVydGllcyB1c2VkIHRvIGZpbmQgdHJhbnNpdGlvbiBldmVudHMgdGhhdFxyXG4vLyBtaWdodCBhZmZlY3QgZGltZW5zaW9ucyBvZiBvYnNlcnZlZCBlbGVtZW50cy5cclxudmFyIHRyYW5zaXRpb25LZXlzID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ3NpemUnLCAnd2VpZ2h0J107XHJcbi8vIENoZWNrIGlmIE11dGF0aW9uT2JzZXJ2ZXIgaXMgYXZhaWxhYmxlLlxyXG52YXIgbXV0YXRpb25PYnNlcnZlclN1cHBvcnRlZCA9IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcclxuLyoqXHJcbiAqIFNpbmdsZXRvbiBjb250cm9sbGVyIGNsYXNzIHdoaWNoIGhhbmRsZXMgdXBkYXRlcyBvZiBSZXNpemVPYnNlcnZlciBpbnN0YW5jZXMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgRE9NIGxpc3RlbmVycyBoYXZlIGJlZW4gYWRkZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZWxscyB0aGF0IGNvbnRyb2xsZXIgaGFzIHN1YnNjcmliZWQgZm9yIE11dGF0aW9uIEV2ZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBLZWVwcyByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9mIE11dGF0aW9uT2JzZXJ2ZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7TXV0YXRpb25PYnNlcnZlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBsaXN0IG9mIGNvbm5lY3RlZCBvYnNlcnZlcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2ZXJTUEk+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMub25UcmFuc2l0aW9uRW5kXyA9IHRoaXMub25UcmFuc2l0aW9uRW5kXy5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaCA9IHRocm90dGxlKHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpLCBSRUZSRVNIX0RFTEFZKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBvYnNlcnZlciB0byBvYnNlcnZlcnMgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIGFkZGVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuYWRkT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICBpZiAoIX50aGlzLm9ic2VydmVyc18uaW5kZXhPZihvYnNlcnZlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnNfLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgbGlzdGVuZXJzIGlmIHRoZXkgaGF2ZW4ndCBiZWVuIGFkZGVkIHlldC5cclxuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZU9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXztcclxuICAgICAgICB2YXIgaW5kZXggPSBvYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XHJcbiAgICAgICAgLy8gUmVtb3ZlIG9ic2VydmVyIGlmIGl0J3MgcHJlc2VudCBpbiByZWdpc3RyeS5cclxuICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgbGlzdGVuZXJzIGlmIGNvbnRyb2xsZXIgaGFzIG5vIGNvbm5lY3RlZCBvYnNlcnZlcnMuXHJcbiAgICAgICAgaWYgKCFvYnNlcnZlcnMubGVuZ3RoICYmIHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy4gSXQgd2lsbCBjb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaW5zb2ZhclxyXG4gICAgICogaXQgZGV0ZWN0cyBjaGFuZ2VzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNoYW5nZXNEZXRlY3RlZCA9IHRoaXMudXBkYXRlT2JzZXJ2ZXJzXygpO1xyXG4gICAgICAgIC8vIENvbnRpbnVlIHJ1bm5pbmcgdXBkYXRlcyBpZiBjaGFuZ2VzIGhhdmUgYmVlbiBkZXRlY3RlZCBhcyB0aGVyZSBtaWdodFxyXG4gICAgICAgIC8vIGJlIGZ1dHVyZSBvbmVzIGNhdXNlZCBieSBDU1MgdHJhbnNpdGlvbnMuXHJcbiAgICAgICAgaWYgKGNoYW5nZXNEZXRlY3RlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGV2ZXJ5IG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QgYW5kIG5vdGlmaWVzIHRoZW0gb2YgcXVldWVkXHJcbiAgICAgKiBlbnRyaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBcInRydWVcIiBpZiBhbnkgb2JzZXJ2ZXIgaGFzIGRldGVjdGVkIGNoYW5nZXMgaW5cclxuICAgICAqICAgICAgZGltZW5zaW9ucyBvZiBpdCdzIGVsZW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZU9ic2VydmVyc18gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gQ29sbGVjdCBvYnNlcnZlcnMgdGhhdCBoYXZlIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgdmFyIGFjdGl2ZU9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXy5maWx0ZXIoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5nYXRoZXJBY3RpdmUoKSwgb2JzZXJ2ZXIuaGFzQWN0aXZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gRGVsaXZlciBub3RpZmljYXRpb25zIGluIGEgc2VwYXJhdGUgY3ljbGUgaW4gb3JkZXIgdG8gYXZvaWQgYW55XHJcbiAgICAgICAgLy8gY29sbGlzaW9ucyBiZXR3ZWVuIG9ic2VydmVycywgZS5nLiB3aGVuIG11bHRpcGxlIGluc3RhbmNlcyBvZlxyXG4gICAgICAgIC8vIFJlc2l6ZU9ic2VydmVyIGFyZSB0cmFja2luZyB0aGUgc2FtZSBlbGVtZW50IGFuZCB0aGUgY2FsbGJhY2sgb2Ygb25lXHJcbiAgICAgICAgLy8gb2YgdGhlbSBjaGFuZ2VzIGNvbnRlbnQgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgdGFyZ2V0LiBTb21ldGltZXNcclxuICAgICAgICAvLyB0aGlzIG1heSByZXN1bHQgaW4gbm90aWZpY2F0aW9ucyBiZWluZyBibG9ja2VkIGZvciB0aGUgcmVzdCBvZiBvYnNlcnZlcnMuXHJcbiAgICAgICAgYWN0aXZlT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyKSB7IHJldHVybiBvYnNlcnZlci5icm9hZGNhc3RBY3RpdmUoKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFjdGl2ZU9ic2VydmVycy5sZW5ndGggPiAwO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXHJcbiAgICAgICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgYWRkZWQuXHJcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIgfHwgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3Vic2NyaXB0aW9uIHRvIHRoZSBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBpcyB1c2VkIGFzIGEgd29ya2Fyb3VuZCBmb3JcclxuICAgICAgICAvLyBkZWxheWVkIHRyYW5zaXRpb25zLiBUaGlzIHdheSBpdCdzIHBvc3NpYmxlIHRvIGNhcHR1cmUgYXQgbGVhc3QgdGhlXHJcbiAgICAgICAgLy8gZmluYWwgc3RhdGUgb2YgYW4gZWxlbWVudC5cclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb25FbmRfKTtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICBpZiAobXV0YXRpb25PYnNlcnZlclN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLm9ic2VydmUoZG9jdW1lbnQsIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc3VidHJlZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBET00gbGlzdGVuZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5kaXNjb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCBvciBpZiBsaXN0ZW5lcnNcclxuICAgICAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSByZW1vdmVkLlxyXG4gICAgICAgIGlmICghaXNCcm93c2VyIHx8ICF0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb25FbmRfKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICBpZiAodGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8pIHtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8uZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXykge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaGFuZGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtUcmFuc2l0aW9uRXZlbnR9IGV2ZW50XHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5vblRyYW5zaXRpb25FbmRfID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWUgPSBfYiA9PT0gdm9pZCAwID8gJycgOiBfYjtcclxuICAgICAgICAvLyBEZXRlY3Qgd2hldGhlciB0cmFuc2l0aW9uIG1heSBhZmZlY3QgZGltZW5zaW9ucyBvZiBhbiBlbGVtZW50LlxyXG4gICAgICAgIHZhciBpc1JlZmxvd1Byb3BlcnR5ID0gdHJhbnNpdGlvbktleXMuc29tZShmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIX5wcm9wZXJ0eU5hbWUuaW5kZXhPZihrZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpc1JlZmxvd1Byb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaW5zdGFuY2Ugb2YgdGhlIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlXykge1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlXyA9IG5ldyBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VfO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSG9sZHMgcmVmZXJlbmNlIHRvIHRoZSBjb250cm9sbGVyJ3MgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmluc3RhbmNlXyA9IG51bGw7XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyO1xyXG59KCkpO1xuXG4vKipcclxuICogRGVmaW5lcyBub24td3JpdGFibGUvZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBwcm92aWRlZCB0YXJnZXQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gT2JqZWN0IGZvciB3aGljaCB0byBkZWZpbmUgcHJvcGVydGllcy5cclxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gUHJvcGVydGllcyB0byBiZSBkZWZpbmVkLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUYXJnZXQgb2JqZWN0LlxyXG4gKi9cclxudmFyIGRlZmluZUNvbmZpZ3VyYWJsZSA9IChmdW5jdGlvbiAodGFyZ2V0LCBwcm9wcykge1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHByb3BzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xyXG4gICAgICAgICAgICB2YWx1ZTogcHJvcHNba2V5XSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59KTtcblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGdsb2JhbCBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcclxuICogQHJldHVybnMge09iamVjdH1cclxuICovXHJcbnZhciBnZXRXaW5kb3dPZiA9IChmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAvLyBBc3N1bWUgdGhhdCB0aGUgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiBOb2RlLCB3aGljaCBtZWFucyB0aGF0IGl0XHJcbiAgICAvLyBoYXMgdGhlIFwib3duZXJEb2N1bWVudFwiIHByb3BlcnR5IGZyb20gd2hpY2ggd2UgY2FuIHJldHJpZXZlIGFcclxuICAgIC8vIGNvcnJlc3BvbmRpbmcgZ2xvYmFsIG9iamVjdC5cclxuICAgIHZhciBvd25lckdsb2JhbCA9IHRhcmdldCAmJiB0YXJnZXQub3duZXJEb2N1bWVudCAmJiB0YXJnZXQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcclxuICAgIC8vIFJldHVybiB0aGUgbG9jYWwgZ2xvYmFsIG9iamVjdCBpZiBpdCdzIG5vdCBwb3NzaWJsZSBleHRyYWN0IG9uZSBmcm9tXHJcbiAgICAvLyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgcmV0dXJuIG93bmVyR2xvYmFsIHx8IGdsb2JhbCQxO1xyXG59KTtcblxuLy8gUGxhY2Vob2xkZXIgb2YgYW4gZW1wdHkgY29udGVudCByZWN0YW5nbGUuXHJcbnZhciBlbXB0eVJlY3QgPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcclxuLyoqXHJcbiAqIENvbnZlcnRzIHByb3ZpZGVkIHN0cmluZyB0byBhIG51bWJlci5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gdG9GbG9hdCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIHx8IDA7XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3RzIGJvcmRlcnMgc2l6ZSBmcm9tIHByb3ZpZGVkIHN0eWxlcy5cclxuICpcclxuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuICogQHBhcmFtIHsuLi5zdHJpbmd9IHBvc2l0aW9ucyAtIEJvcmRlcnMgcG9zaXRpb25zICh0b3AsIHJpZ2h0LCAuLi4pXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMpIHtcclxuICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgcG9zaXRpb25zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHNpemUsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzWydib3JkZXItJyArIHBvc2l0aW9uICsgJy13aWR0aCddO1xyXG4gICAgICAgIHJldHVybiBzaXplICsgdG9GbG9hdCh2YWx1ZSk7XHJcbiAgICB9LCAwKTtcclxufVxyXG4vKipcclxuICogRXh0cmFjdHMgcGFkZGluZ3Mgc2l6ZXMgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFBhZGRpbmdzIGJveC5cclxuICovXHJcbmZ1bmN0aW9uIGdldFBhZGRpbmdzKHN0eWxlcykge1xyXG4gICAgdmFyIHBvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XHJcbiAgICB2YXIgcGFkZGluZ3MgPSB7fTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgcG9zaXRpb25zXzEgPSBwb3NpdGlvbnM7IF9pIDwgcG9zaXRpb25zXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gcG9zaXRpb25zXzFbX2ldO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1sncGFkZGluZy0nICsgcG9zaXRpb25dO1xyXG4gICAgICAgIHBhZGRpbmdzW3Bvc2l0aW9uXSA9IHRvRmxvYXQodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhZGRpbmdzO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHByb3ZpZGVkIFNWRyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NWR0dyYXBoaWNzRWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkc1xyXG4gKiAgICAgIHRvIGJlIGNhbGN1bGF0ZWQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgdmFyIGJib3ggPSB0YXJnZXQuZ2V0QkJveCgpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlY3RJbml0KDAsIDAsIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBIVE1MRWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBjb250ZW50IHJlY3RhbmdsZS5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIC8vIENsaWVudCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGNhbid0IGJlXHJcbiAgICAvLyB1c2VkIGV4Y2x1c2l2ZWx5IGFzIHRoZXkgcHJvdmlkZSByb3VuZGVkIHZhbHVlcy5cclxuICAgIHZhciBjbGllbnRXaWR0aCA9IHRhcmdldC5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0ID0gdGFyZ2V0LmNsaWVudEhlaWdodDtcclxuICAgIC8vIEJ5IHRoaXMgY29uZGl0aW9uIHdlIGNhbiBjYXRjaCBhbGwgbm9uLXJlcGxhY2VkIGlubGluZSwgaGlkZGVuIGFuZFxyXG4gICAgLy8gZGV0YWNoZWQgZWxlbWVudHMuIFRob3VnaCBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgbGVzc1xyXG4gICAgLy8gdGhhbiAwLjUgd2lsbCBiZSBkaXNjYXJkZWQgYXMgd2VsbC5cclxuICAgIC8vXHJcbiAgICAvLyBXaXRob3V0IGl0IHdlIHdvdWxkIG5lZWQgdG8gaW1wbGVtZW50IHNlcGFyYXRlIG1ldGhvZHMgZm9yIGVhY2ggb2ZcclxuICAgIC8vIHRob3NlIGNhc2VzIGFuZCBpdCdzIG5vdCBwb3NzaWJsZSB0byBwZXJmb3JtIGEgcHJlY2lzZSBhbmQgcGVyZm9ybWFuY2VcclxuICAgIC8vIGVmZmVjdGl2ZSB0ZXN0IGZvciBoaWRkZW4gZWxlbWVudHMuIEUuZy4gZXZlbiBqUXVlcnkncyAnOnZpc2libGUnIGZpbHRlclxyXG4gICAgLy8gZ2l2ZXMgd3JvbmcgcmVzdWx0cyBmb3IgZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBsZXNzIHRoYW4gMC41LlxyXG4gICAgaWYgKCFjbGllbnRXaWR0aCAmJiAhY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVjdDtcclxuICAgIH1cclxuICAgIHZhciBzdHlsZXMgPSBnZXRXaW5kb3dPZih0YXJnZXQpLmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcclxuICAgIHZhciBwYWRkaW5ncyA9IGdldFBhZGRpbmdzKHN0eWxlcyk7XHJcbiAgICB2YXIgaG9yaXpQYWQgPSBwYWRkaW5ncy5sZWZ0ICsgcGFkZGluZ3MucmlnaHQ7XHJcbiAgICB2YXIgdmVydFBhZCA9IHBhZGRpbmdzLnRvcCArIHBhZGRpbmdzLmJvdHRvbTtcclxuICAgIC8vIENvbXB1dGVkIHN0eWxlcyBvZiB3aWR0aCAmIGhlaWdodCBhcmUgYmVpbmcgdXNlZCBiZWNhdXNlIHRoZXkgYXJlIHRoZVxyXG4gICAgLy8gb25seSBkaW1lbnNpb25zIGF2YWlsYWJsZSB0byBKUyB0aGF0IGNvbnRhaW4gbm9uLXJvdW5kZWQgdmFsdWVzLiBJdCBjb3VsZFxyXG4gICAgLy8gYmUgcG9zc2libGUgdG8gdXRpbGl6ZSB0aGUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlmIG9ubHkgaXQncyBkYXRhIHdhc24ndFxyXG4gICAgLy8gYWZmZWN0ZWQgYnkgQ1NTIHRyYW5zZm9ybWF0aW9ucyBsZXQgYWxvbmUgcGFkZGluZ3MsIGJvcmRlcnMgYW5kIHNjcm9sbCBiYXJzLlxyXG4gICAgdmFyIHdpZHRoID0gdG9GbG9hdChzdHlsZXMud2lkdGgpLCBoZWlnaHQgPSB0b0Zsb2F0KHN0eWxlcy5oZWlnaHQpO1xyXG4gICAgLy8gV2lkdGggJiBoZWlnaHQgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB3aGVuIHRoZSAnYm9yZGVyLWJveCcgYm94XHJcbiAgICAvLyBtb2RlbCBpcyBhcHBsaWVkIChleGNlcHQgZm9yIElFKS5cclxuICAgIGlmIChzdHlsZXMuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCcpIHtcclxuICAgICAgICAvLyBGb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgcmVxdWlyZWQgdG8gaGFuZGxlIEludGVybmV0IEV4cGxvcmVyIHdoaWNoXHJcbiAgICAgICAgLy8gZG9lc24ndCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHRvIGNvbXB1dGVkIENTUyBkaW1lbnNpb25zLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gV2UgY2FuIHNheSB0aGF0IGlmIENTUyBkaW1lbnNpb25zICsgcGFkZGluZ3MgYXJlIGVxdWFsIHRvIHRoZSBcImNsaWVudFwiXHJcbiAgICAgICAgLy8gcHJvcGVydGllcyB0aGVuIGl0J3MgZWl0aGVyIElFLCBhbmQgdGh1cyB3ZSBkb24ndCBuZWVkIHRvIHN1YnRyYWN0XHJcbiAgICAgICAgLy8gYW55dGhpbmcsIG9yIGFuIGVsZW1lbnQgbWVyZWx5IGRvZXNuJ3QgaGF2ZSBwYWRkaW5ncy9ib3JkZXJzIHN0eWxlcy5cclxuICAgICAgICBpZiAoTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAhPT0gY2xpZW50V2lkdGgpIHtcclxuICAgICAgICAgICAgd2lkdGggLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAnbGVmdCcsICdyaWdodCcpICsgaG9yaXpQYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLnJvdW5kKGhlaWdodCArIHZlcnRQYWQpICE9PSBjbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgaGVpZ2h0IC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3RvcCcsICdib3R0b20nKSArIHZlcnRQYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRm9sbG93aW5nIHN0ZXBzIGNhbid0IGJlIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50J3Mgcm9vdCBlbGVtZW50IGFzIGl0c1xyXG4gICAgLy8gY2xpZW50W1dpZHRoL0hlaWdodF0gcHJvcGVydGllcyByZXByZXNlbnQgdmlld3BvcnQgYXJlYSBvZiB0aGUgd2luZG93LlxyXG4gICAgLy8gQmVzaWRlcywgaXQncyBhcyB3ZWxsIG5vdCBuZWNlc3NhcnkgYXMgdGhlIDxodG1sPiBpdHNlbGYgbmVpdGhlciBoYXNcclxuICAgIC8vIHJlbmRlcmVkIHNjcm9sbCBiYXJzIG5vciBpdCBjYW4gYmUgY2xpcHBlZC5cclxuICAgIGlmICghaXNEb2N1bWVudEVsZW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMgKG9ubHkgaW4gRmlyZWZveCwgYWN0dWFsbHkpIENTUyB3aWR0aCAmIGhlaWdodFxyXG4gICAgICAgIC8vIGluY2x1ZGUgc2Nyb2xsIGJhcnMgc2l6ZSB3aGljaCBjYW4gYmUgcmVtb3ZlZCBhdCB0aGlzIHN0ZXAgYXMgc2Nyb2xsXHJcbiAgICAgICAgLy8gYmFycyBhcmUgdGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIHJvdW5kZWQgZGltZW5zaW9ucyArIHBhZGRpbmdzXHJcbiAgICAgICAgLy8gYW5kIFwiY2xpZW50XCIgcHJvcGVydGllcywgdGhvdWdoIHRoYXQgaXMgbm90IGFsd2F5cyB0cnVlIGluIENocm9tZS5cclxuICAgICAgICB2YXIgdmVydFNjcm9sbGJhciA9IE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgLSBjbGllbnRXaWR0aDtcclxuICAgICAgICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKGhlaWdodCArIHZlcnRQYWQpIC0gY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIC8vIENocm9tZSBoYXMgYSByYXRoZXIgd2VpcmQgcm91bmRpbmcgb2YgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLlxyXG4gICAgICAgIC8vIEUuZy4gZm9yIGFuIGVsZW1lbnQgd2l0aCBjb250ZW50IHdpZHRoIG9mIDMxNC4ycHggaXQgc29tZXRpbWVzIGdpdmVzXHJcbiAgICAgICAgLy8gdGhlIGNsaWVudCB3aWR0aCBvZiAzMTVweCBhbmQgZm9yIHRoZSB3aWR0aCBvZiAzMTQuN3B4IGl0IG1heSBnaXZlXHJcbiAgICAgICAgLy8gMzE0cHguIEFuZCBpdCBkb2Vzbid0IGhhcHBlbiBhbGwgdGhlIHRpbWUuIFNvIGp1c3QgaWdub3JlIHRoaXMgZGVsdGFcclxuICAgICAgICAvLyBhcyBhIG5vbi1yZWxldmFudC5cclxuICAgICAgICBpZiAoTWF0aC5hYnModmVydFNjcm9sbGJhcikgIT09IDEpIHtcclxuICAgICAgICAgICAgd2lkdGggLT0gdmVydFNjcm9sbGJhcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGhvcml6U2Nyb2xsYmFyKSAhPT0gMSkge1xyXG4gICAgICAgICAgICBoZWlnaHQgLT0gaG9yaXpTY3JvbGxiYXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZVJlY3RJbml0KHBhZGRpbmdzLmxlZnQsIHBhZGRpbmdzLnRvcCwgd2lkdGgsIGhlaWdodCk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIFNWR0dyYXBoaWNzRWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxudmFyIGlzU1ZHR3JhcGhpY3NFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFNvbWUgYnJvd3NlcnMsIG5hbWVseSBJRSBhbmQgRWRnZSwgZG9uJ3QgaGF2ZSB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50XHJcbiAgICAvLyBpbnRlcmZhY2UuXHJcbiAgICBpZiAodHlwZW9mIFNWR0dyYXBoaWNzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdHcmFwaGljc0VsZW1lbnQ7IH07XHJcbiAgICB9XHJcbiAgICAvLyBJZiBpdCdzIHNvLCB0aGVuIGNoZWNrIHRoYXQgZWxlbWVudCBpcyBhdCBsZWFzdCBhbiBpbnN0YW5jZSBvZiB0aGVcclxuICAgIC8vIFNWR0VsZW1lbnQgYW5kIHRoYXQgaXQgaGFzIHRoZSBcImdldEJCb3hcIiBtZXRob2QuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHRWxlbWVudCAmJlxyXG4gICAgICAgIHR5cGVvZiB0YXJnZXQuZ2V0QkJveCA9PT0gJ2Z1bmN0aW9uJyk7IH07XHJcbn0pKCk7XHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGEgZG9jdW1lbnQgZWxlbWVudCAoPGh0bWw+KS5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNEb2N1bWVudEVsZW1lbnQodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gdGFyZ2V0ID09PSBnZXRXaW5kb3dPZih0YXJnZXQpLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBhbiBhcHByb3ByaWF0ZSBjb250ZW50IHJlY3RhbmdsZSBmb3IgcHJvdmlkZWQgaHRtbCBvciBzdmcgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldENvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgaWYgKCFpc0Jyb3dzZXIpIHtcclxuICAgICAgICByZXR1cm4gZW1wdHlSZWN0O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU1ZHR3JhcGhpY3NFbGVtZW50KHRhcmdldCkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgcmVjdGFuZ2xlIHdpdGggYW4gaW50ZXJmYWNlIG9mIHRoZSBET01SZWN0UmVhZE9ubHkuXHJcbiAqIFNwZWM6IGh0dHBzOi8vZHJhZnRzLmZ4dGYub3JnL2dlb21ldHJ5LyNkb21yZWN0cmVhZG9ubHlcclxuICpcclxuICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBPYmplY3Qgd2l0aCByZWN0YW5nbGUncyB4L3kgY29vcmRpbmF0ZXMgYW5kIGRpbWVuc2lvbnMuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0UmVhZE9ubHl9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZWFkT25seVJlY3QoX2EpIHtcclxuICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgIC8vIElmIERPTVJlY3RSZWFkT25seSBpcyBhdmFpbGFibGUgdXNlIGl0IGFzIGEgcHJvdG90eXBlIGZvciB0aGUgcmVjdGFuZ2xlLlxyXG4gICAgdmFyIENvbnN0ciA9IHR5cGVvZiBET01SZWN0UmVhZE9ubHkgIT09ICd1bmRlZmluZWQnID8gRE9NUmVjdFJlYWRPbmx5IDogT2JqZWN0O1xyXG4gICAgdmFyIHJlY3QgPSBPYmplY3QuY3JlYXRlKENvbnN0ci5wcm90b3R5cGUpO1xyXG4gICAgLy8gUmVjdGFuZ2xlJ3MgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZS5cclxuICAgIGRlZmluZUNvbmZpZ3VyYWJsZShyZWN0LCB7XHJcbiAgICAgICAgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICB0b3A6IHksXHJcbiAgICAgICAgcmlnaHQ6IHggKyB3aWR0aCxcclxuICAgICAgICBib3R0b206IGhlaWdodCArIHksXHJcbiAgICAgICAgbGVmdDogeFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVjdDtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBET01SZWN0SW5pdCBvYmplY3QgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGRpbWVuc2lvbnMgYW5kIHRoZSB4L3kgY29vcmRpbmF0ZXMuXHJcbiAqIFNwZWM6IGh0dHBzOi8vZHJhZnRzLmZ4dGYub3JnL2dlb21ldHJ5LyNkaWN0ZGVmLWRvbXJlY3Rpbml0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFkgY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gUmVjdGFuZ2xlJ3Mgd2lkdGguXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBSZWN0YW5nbGUncyBoZWlnaHQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlY3RJbml0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHJldHVybiB7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxufVxuXG4vKipcclxuICogQ2xhc3MgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgY29tcHV0YXRpb25zIG9mIHRoZSBjb250ZW50IHJlY3RhbmdsZSBvZlxyXG4gKiBwcm92aWRlZCBET00gZWxlbWVudCBhbmQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgaXQncyBjaGFuZ2VzLlxyXG4gKi9cclxudmFyIFJlc2l6ZU9ic2VydmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBvYnNlcnZlZC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnJvYWRjYXN0ZWQgd2lkdGggb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJyb2FkY2FzdGVkIGhlaWdodCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RIZWlnaHQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtET01SZWN0SW5pdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIGFuZCB0ZWxscyB3aGV0aGVyIGl0J3Mgd2lkdGggb3IgaGVpZ2h0IHByb3BlcnRpZXNcclxuICAgICAqIGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBicm9hZGNhc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmF0aW9uLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IGdldENvbnRlbnRSZWN0KHRoaXMudGFyZ2V0KTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IHJlY3Q7XHJcbiAgICAgICAgcmV0dXJuIChyZWN0LndpZHRoICE9PSB0aGlzLmJyb2FkY2FzdFdpZHRoIHx8XHJcbiAgICAgICAgICAgIHJlY3QuaGVpZ2h0ICE9PSB0aGlzLmJyb2FkY2FzdEhlaWdodCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzICdicm9hZGNhc3RXaWR0aCcgYW5kICdicm9hZGNhc3RIZWlnaHQnIHByb3BlcnRpZXMgd2l0aCBhIGRhdGFcclxuICAgICAqIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllcyBvZiB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9IExhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmF0aW9uLnByb3RvdHlwZS5icm9hZGNhc3RSZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jb250ZW50UmVjdF87XHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RIZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICByZXR1cm4gcmVjdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2YXRpb247XHJcbn0oKSk7XG5cbnZhciBSZXNpemVPYnNlcnZlckVudHJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyRW50cnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRoYXQgaXMgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIERhdGEgb2YgdGhlIGVsZW1lbnQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJFbnRyeSh0YXJnZXQsIHJlY3RJbml0KSB7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRSZWN0ID0gY3JlYXRlUmVhZE9ubHlSZWN0KHJlY3RJbml0KTtcclxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmljYXRpb24gZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZVxyXG4gICAgICAgIC8vIGFuZCBhcmUgYWxzbyBub3QgZW51bWVyYWJsZSBpbiB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gUHJvcGVydHkgYWNjZXNzb3JzIGFyZSBub3QgYmVpbmcgdXNlZCBhcyB0aGV5J2QgcmVxdWlyZSB0byBkZWZpbmUgYVxyXG4gICAgICAgIC8vIHByaXZhdGUgV2Vha01hcCBzdG9yYWdlIHdoaWNoIG1heSBjYXVzZSBtZW1vcnkgbGVha3MgaW4gYnJvd3NlcnMgdGhhdFxyXG4gICAgICAgIC8vIGRvbid0IHN1cHBvcnQgdGhpcyB0eXBlIG9mIGNvbGxlY3Rpb25zLlxyXG4gICAgICAgIGRlZmluZUNvbmZpZ3VyYWJsZSh0aGlzLCB7IHRhcmdldDogdGFyZ2V0LCBjb250ZW50UmVjdDogY29udGVudFJlY3QgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJFbnRyeTtcclxufSgpKTtcblxudmFyIFJlc2l6ZU9ic2VydmVyU1BJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGludm9rZWRcclxuICAgICAqICAgICAgd2hlbiBvbmUgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZXMgaXQncyBjb250ZW50IGRpbWVuc2lvbnMuXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn0gY29udHJvbGxlciAtIENvbnRyb2xsZXIgaW5zdGFuY2Ugd2hpY2hcclxuICAgICAqICAgICAgaXMgcmVzcG9uc2libGUgZm9yIHRoZSB1cGRhdGVzIG9mIG9ic2VydmVyLlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlcn0gY2FsbGJhY2tDdHggLSBSZWZlcmVuY2UgdG8gdGhlIHB1YmxpY1xyXG4gICAgICogICAgICBSZXNpemVPYnNlcnZlciBpbnN0YW5jZSB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIGNhbGxiYWNrQ3R4KSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiByZXNpemUgb2JzZXJ2YXRpb25zIHRoYXQgaGF2ZSBkZXRlY3RlZCBjaGFuZ2VzIGluIGRpbWVuc2lvbnNcclxuICAgICAgICAgKiBvZiBlbGVtZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVnaXN0cnkgb2YgdGhlIFJlc2l6ZU9ic2VydmF0aW9uIGluc3RhbmNlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtNYXA8RWxlbWVudCwgUmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXyA9IG5ldyBNYXBTaGltKCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2FsbGJhY2sgcHJvdmlkZWQgYXMgcGFyYW1ldGVyIDEgaXMgbm90IGEgZnVuY3Rpb24uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2s7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXyA9IGNvbnRyb2xsZXI7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja0N0eF8gPSBjYWxsYmFja0N0eDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBvYnNlcnZlZC5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHRoZSBFbGVtZW50IGludGVyZmFjZS5cclxuICAgICAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2JzZXJ2YXRpb25zID0gdGhpcy5vYnNlcnZhdGlvbnNfO1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgZWxlbWVudCBpcyBhbHJlYWR5IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgIGlmIChvYnNlcnZhdGlvbnMuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYnNlcnZhdGlvbnMuc2V0KHRhcmdldCwgbmV3IFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8uYWRkT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgLy8gRm9yY2UgdGhlIHVwZGF0ZSBvZiBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZWZyZXNoKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBvYnNlcnZpbmcgcHJvdmlkZWQgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gc3RvcCBvYnNlcnZpbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHRoZSBFbGVtZW50IGludGVyZmFjZS5cclxuICAgICAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2JzZXJ2YXRpb25zID0gdGhpcy5vYnNlcnZhdGlvbnNfO1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgZWxlbWVudCBpcyBub3QgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgaWYgKCFvYnNlcnZhdGlvbnMuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYnNlcnZhdGlvbnMuZGVsZXRlKHRhcmdldCk7XHJcbiAgICAgICAgaWYgKCFvYnNlcnZhdGlvbnMuc2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIG9ic2VydmluZyBhbGwgZWxlbWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18uY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdHMgb2JzZXJ2YXRpb24gaW5zdGFuY2VzIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQgb2Ygd2hpY2ggaGFzIGNoYW5nZWRcclxuICAgICAqIGl0J3MgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5nYXRoZXJBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChvYnNlcnZhdGlvbi5pc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLnB1c2gob2JzZXJ2YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIGluaXRpYWwgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhIGxpc3Qgb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeVxyXG4gICAgICogaW5zdGFuY2VzIGNvbGxlY3RlZCBmcm9tIGFjdGl2ZSByZXNpemUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuYnJvYWRjYXN0QWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgb2JzZXJ2ZXIgZG9lc24ndCBoYXZlIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgaWYgKCF0aGlzLmhhc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FsbGJhY2tDdHhfO1xyXG4gICAgICAgIC8vIENyZWF0ZSBSZXNpemVPYnNlcnZlckVudHJ5IGluc3RhbmNlIGZvciBldmVyeSBhY3RpdmUgb2JzZXJ2YXRpb24uXHJcbiAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubWFwKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZU9ic2VydmVyRW50cnkob2JzZXJ2YXRpb24udGFyZ2V0LCBvYnNlcnZhdGlvbi5icm9hZGNhc3RSZWN0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tfLmNhbGwoY3R4LCBlbnRyaWVzLCBjdHgpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgY29sbGVjdGlvbiBvZiBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuY2xlYXJBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLnNwbGljZSgwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHdoZXRoZXIgb2JzZXJ2ZXIgaGFzIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5oYXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5sZW5ndGggPiAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlclNQSTtcclxufSgpKTtcblxuLy8gUmVnaXN0cnkgb2YgaW50ZXJuYWwgb2JzZXJ2ZXJzLiBJZiBXZWFrTWFwIGlzIG5vdCBhdmFpbGFibGUgdXNlIGN1cnJlbnQgc2hpbVxyXG4vLyBmb3IgdGhlIE1hcCBjb2xsZWN0aW9uIGFzIGl0IGhhcyBhbGwgcmVxdWlyZWQgbWV0aG9kcyBhbmQgYmVjYXVzZSBXZWFrTWFwXHJcbi8vIGNhbid0IGJlIGZ1bGx5IHBvbHlmaWxsZWQgYW55d2F5LlxyXG52YXIgb2JzZXJ2ZXJzID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnID8gbmV3IFdlYWtNYXAoKSA6IG5ldyBNYXBTaGltKCk7XHJcbi8qKlxyXG4gKiBSZXNpemVPYnNlcnZlciBBUEkuIEVuY2Fwc3VsYXRlcyB0aGUgUmVzaXplT2JzZXJ2ZXIgU1BJIGltcGxlbWVudGF0aW9uXHJcbiAqIGV4cG9zaW5nIG9ubHkgdGhvc2UgbWV0aG9kcyBhbmQgcHJvcGVydGllcyB0aGF0IGFyZSBkZWZpbmVkIGluIHRoZSBzcGVjLlxyXG4gKi9cclxudmFyIFJlc2l6ZU9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGludm9rZWQgd2hlblxyXG4gICAgICogICAgICBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc2l6ZU9ic2VydmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb250cm9sbGVyID0gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCB0aGlzKTtcclxuICAgICAgICBvYnNlcnZlcnMuc2V0KHRoaXMsIG9ic2VydmVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlcjtcclxufSgpKTtcclxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG5bXHJcbiAgICAnb2JzZXJ2ZScsXHJcbiAgICAndW5vYnNlcnZlJyxcclxuICAgICdkaXNjb25uZWN0J1xyXG5dLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgUmVzaXplT2JzZXJ2ZXIucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSBvYnNlcnZlcnMuZ2V0KHRoaXMpKVttZXRob2RdLmFwcGx5KF9hLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxufSk7XG5cbnZhciBpbmRleCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBFeHBvcnQgZXhpc3RpbmcgaW1wbGVtZW50YXRpb24gaWYgYXZhaWxhYmxlLlxyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XHJcbn0pKCk7XG5cbnZhciBIZWFkaW5nUG9wdXBCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEhlYWRpbmdQb3B1cEJvZHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVhZGluZ1BvcHVwQm9keSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBIZWFkaW5nUG9wdXBCb2R5LnByb3RvdHlwZS5leGVjQ29tbWFuZCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB2YXIgZWwgPSBjbG9zZXN0KGV2LnRhcmdldCwgJ2xpJyk7XG4gICAgICAgIHRoaXMucHJvcHMuZXhlY0NvbW1hbmQoJ2hlYWRpbmcnLCB7XG4gICAgICAgICAgICBsZXZlbDogTnVtYmVyKGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1sZXZlbCcpKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWFkaW5nUG9wdXBCb2R5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzIkOCB8fCAodGVtcGxhdGVPYmplY3RfMiQ4ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPHVsXFxuICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgYXJpYS1yb2xlPVxcXCJtZW51XFxcIlxcbiAgICAgICAgYXJpYS1sYWJlbD1cXFwiXCIsIFwiXFxcIlxcbiAgICAgID5cXG4gICAgICAgIFwiLCBcIlxcbiAgICAgICAgPGxpIGRhdGEtdHlwZT1cXFwiUGFyYWdyYXBoXFxcIiBhcmlhLXJvbGU9XFxcIm1lbnVpdGVtXFxcIj5cXG4gICAgICAgICAgPGRpdj5cIiwgXCI8L2Rpdj5cXG4gICAgICAgIDwvbGk+XFxuICAgICAgPC91bD5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8dWxcXG4gICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICBhcmlhLXJvbGU9XFxcIm1lbnVcXFwiXFxuICAgICAgICBhcmlhLWxhYmVsPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgPlxcbiAgICAgICAgXCIsXG4gICAgICAgICAgICBcIlxcbiAgICAgICAgPGxpIGRhdGEtdHlwZT1cXFwiUGFyYWdyYXBoXFxcIiBhcmlhLXJvbGU9XFxcIm1lbnVpdGVtXFxcIj5cXG4gICAgICAgICAgPGRpdj5cIiwgXCI8L2Rpdj5cXG4gICAgICAgIDwvbGk+XFxuICAgICAgPC91bD5cXG4gICAgXCJdKSksIGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMuZXhlY0NvbW1hbmQoZXYpOyB9LCBpMThuLmdldCgnSGVhZGluZ3MnKSwgWzEsIDIsIDMsIDQsIDUsIDZdLm1hcChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkZyB8fCAodGVtcGxhdGVPYmplY3RfMSRnID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICAgICAgICA8bGkgZGF0YS1sZXZlbD1cXFwiXCIsIFwiXFxcIiBkYXRhLXR5cGU9XFxcIkhlYWRpbmdcXFwiIGFyaWEtcm9sZT1cXFwibWVudWl0ZW1cXFwiPlxcbiAgICAgICAgICAgICAgICA8XCIsIFwiPlwiLCBcIiBcIiwgXCI8LyQ+XFxuICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIFwiXSwgW1wiXFxuICAgICAgICAgICAgICA8bGkgZGF0YS1sZXZlbD1cXFwiXCIsIFwiXFxcIiBkYXRhLXR5cGU9XFxcIkhlYWRpbmdcXFwiIGFyaWEtcm9sZT1cXFwibWVudWl0ZW1cXFwiPlxcbiAgICAgICAgICAgICAgICA8XCIsIFwiPlwiLCBcIiBcIiwgXCI8LyQ+XFxuICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIFwiXSkpLCBsZXZlbCwgXCJoXCIgKyBsZXZlbCwgaTE4bi5nZXQoJ0hlYWRpbmcnKSwgbGV2ZWwpO1xuICAgICAgICB9KSwgaTE4bi5nZXQoJ1BhcmFncmFwaCcpKTtcbiAgICB9O1xuICAgIHJldHVybiBIZWFkaW5nUG9wdXBCb2R5O1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJGcsIHRlbXBsYXRlT2JqZWN0XzIkODtcblxudmFyIFRhYnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGFicywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJzKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRhYnMucHJvdG90eXBlLnRvZ2dsZVRhYiA9IGZ1bmN0aW9uIChldiwgYWN0aXZlVGFiKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25DbGljayhldiwgYWN0aXZlVGFiKTtcbiAgICB9O1xuICAgIFRhYnMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMiQ3IHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDcgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIGFyaWEtcm9sZT1cXFwidGFicGFuZWxcXFwiPlxcbiAgICAgICAgXCIsIFwiXFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBhcmlhLXJvbGU9XFxcInRhYnBhbmVsXFxcIj5cXG4gICAgICAgIFwiLFxuICAgICAgICAgICAgXCJcXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdKSksIGNscygndGFicycpLCB0aGlzLnByb3BzLnRhYnMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCB0ZXh0ID0gX2EudGV4dDtcbiAgICAgICAgICAgIHZhciBpc0FjdGl2ZSA9IF90aGlzLnByb3BzLmFjdGl2ZVRhYiA9PT0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkZiB8fCAodGVtcGxhdGVPYmplY3RfMSRmID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgY2xhc3M9XFxcInRhYi1pdGVtXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgICAgICAgIGFyaWEtcm9sZT1cXFwidGFiXFxcIlxcbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgYXJpYS1zZWxlY3RlZD1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgdGFiaW5kZXg9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgXCJdLCBbXCJcXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICBjbGFzcz1cXFwidGFiLWl0ZW1cIiwgXCJcXFwiXFxuICAgICAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgICAgICAgYXJpYS1yb2xlPVxcXCJ0YWJcXFwiXFxuICAgICAgICAgICAgICBhcmlhLWxhYmVsPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgICAgICBhcmlhLXNlbGVjdGVkPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgICAgICB0YWJpbmRleD1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICBcIl0pKSwgaXNBY3RpdmUgPyAnIGFjdGl2ZScgOiAnJywgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy50b2dnbGVUYWIoZXYsIG5hbWUpOyB9LCBpMThuLmdldCh0ZXh0KSwgaXNBY3RpdmUgPyAndHJ1ZScgOiAnZmFsc2UnLCBpc0FjdGl2ZSA/ICcwJyA6ICctMScsIGkxOG4uZ2V0KHRleHQpKTtcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYnM7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkZiwgdGVtcGxhdGVPYmplY3RfMiQ3O1xuXG52YXIgVFlQRV9VSSA9ICd1aSc7XG52YXIgSW1hZ2VQb3B1cEJvZHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoSW1hZ2VQb3B1cEJvZHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW1hZ2VQb3B1cEJvZHkocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYWN0aXZlVGFiKSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlVGFiID09PSB2b2lkIDApIHsgYWN0aXZlVGFiID0gJ2ZpbGUnOyB9XG4gICAgICAgICAgICB2YXIgdXJsRWwgPSBfdGhpcy5yZWZzLnVybDtcbiAgICAgICAgICAgIHVybEVsLnZhbHVlID0gJyc7XG4gICAgICAgICAgICBfdGhpcy5yZWZzLmFsdFRleHQudmFsdWUgPSAnJztcbiAgICAgICAgICAgIF90aGlzLnJlZnMuZmlsZS52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3NfMSh1cmxFbCwgJ3dyb25nJyk7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGFjdGl2ZVRhYjogYWN0aXZlVGFiLCBmaWxlOiBudWxsLCBmaWxlTmFtZUVsQ2xhc3NOYW1lOiAnJyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZXhlY0NvbW1hbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuYWN0aXZlVGFiID09PSAnZmlsZScpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0QWRkSW1hZ2VCbG9iKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0QWRkSW1hZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudG9nZ2xlVGFiID0gZnVuY3Rpb24gKF8sIGFjdGl2ZVRhYikge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZVRhYiAhPT0gX3RoaXMuc3RhdGUuYWN0aXZlVGFiKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5pdGlhbGl6ZShhY3RpdmVUYWIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zaG93RmlsZVNlbGVjdEJveCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnJlZnMuZmlsZS5jbGljaygpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jaGFuZ2VGaWxlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgZmlsZXMgPSBldi50YXJnZXQuZmlsZXM7XG4gICAgICAgICAgICBpZiAoZmlsZXMgPT09IG51bGwgfHwgZmlsZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgZmlsZTogZmlsZXNbMF0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnN0YXRlID0geyBhY3RpdmVUYWI6ICdmaWxlJywgZmlsZTogbnVsbCwgZmlsZU5hbWVFbENsYXNzTmFtZTogJycgfTtcbiAgICAgICAgX3RoaXMudGFicyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2ZpbGUnLCB0ZXh0OiAnRmlsZScgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3VybCcsIHRleHQ6ICdVUkwnIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW1hZ2VQb3B1cEJvZHkucHJvdG90eXBlLmVtaXRBZGRJbWFnZUJsb2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmaWxlcyA9IHRoaXMucmVmcy5maWxlLmZpbGVzO1xuICAgICAgICB2YXIgYWx0VGV4dEVsID0gdGhpcy5yZWZzLmFsdFRleHQ7XG4gICAgICAgIHZhciBmaWxlTmFtZUVsQ2xhc3NOYW1lID0gJyB3cm9uZyc7XG4gICAgICAgIGlmIChmaWxlcyA9PT0gbnVsbCB8fCBmaWxlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmaWxlTmFtZUVsQ2xhc3NOYW1lID0gJyc7XG4gICAgICAgICAgICB2YXIgaW1hZ2VGaWxlID0gZmlsZXMuaXRlbSgwKTtcbiAgICAgICAgICAgIHZhciBob29rQ2FsbGJhY2sgPSBmdW5jdGlvbiAodXJsLCB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmV4ZWNDb21tYW5kKCdhZGRJbWFnZScsIHsgaW1hZ2VVcmw6IHVybCwgYWx0VGV4dDogdGV4dCB8fCBhbHRUZXh0RWwudmFsdWUgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5ldmVudEVtaXR0ZXIuZW1pdCgnYWRkSW1hZ2VCbG9iSG9vaycsIGltYWdlRmlsZSwgaG9va0NhbGxiYWNrLCBUWVBFX1VJKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgZmlsZU5hbWVFbENsYXNzTmFtZTogZmlsZU5hbWVFbENsYXNzTmFtZSB9KTtcbiAgICB9O1xuICAgIEltYWdlUG9wdXBCb2R5LnByb3RvdHlwZS5lbWl0QWRkSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbWFnZVVybEVsID0gdGhpcy5yZWZzLnVybDtcbiAgICAgICAgdmFyIGFsdFRleHRFbCA9IHRoaXMucmVmcy5hbHRUZXh0O1xuICAgICAgICB2YXIgaW1hZ2VVcmwgPSBpbWFnZVVybEVsLnZhbHVlO1xuICAgICAgICB2YXIgYWx0VGV4dCA9IGFsdFRleHRFbC52YWx1ZSB8fCAnaW1hZ2UnO1xuICAgICAgICByZW1vdmVDbGFzc18xKGltYWdlVXJsRWwsICd3cm9uZycpO1xuICAgICAgICBpZiAoIWltYWdlVXJsLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkQ2xhc3NfMShpbWFnZVVybEVsLCAnd3JvbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1hZ2VVcmwpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZXhlY0NvbW1hbmQoJ2FkZEltYWdlJywgeyBpbWFnZVVybDogaW1hZ2VVcmwsIGFsdFRleHQ6IGFsdFRleHQgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEltYWdlUG9wdXBCb2R5LnByb3RvdHlwZS5wcmV2ZW50U2VsZWN0U3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIEltYWdlUG9wdXBCb2R5LnByb3RvdHlwZS51cGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMuc2hvdykge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEltYWdlUG9wdXBCb2R5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsIGFjdGl2ZVRhYiA9IF9hLmFjdGl2ZVRhYiwgZmlsZSA9IF9hLmZpbGUsIGZpbGVOYW1lRWxDbGFzc05hbWUgPSBfYS5maWxlTmFtZUVsQ2xhc3NOYW1lO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJGUgfHwgKHRlbXBsYXRlT2JqZWN0XzEkZSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDxkaXYgYXJpYS1sYWJlbD1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgIDxcIiwgXCIgdGFicz1cIiwgXCIgYWN0aXZlVGFiPVwiLCBcIiBvbkNsaWNrPVwiLCBcIiAvPlxcbiAgICAgICAgPGRpdiBzdHlsZT1cXFwiZGlzcGxheTpcIiwgXCJcXFwiPlxcbiAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0b2FzdHVpSW1hZ2VVcmxJbnB1dFxcXCI+XCIsIFwiPC9sYWJlbD5cXG4gICAgICAgICAgPGlucHV0XFxuICAgICAgICAgICAgaWQ9XFxcInRvYXN0dWlJbWFnZVVybElucHV0XFxcIlxcbiAgICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IHN0eWxlPVxcXCJkaXNwbGF5OlwiLCBcIjtwb3NpdGlvbjogcmVsYXRpdmU7XFxcIj5cXG4gICAgICAgICAgPGxhYmVsIGZvcj1cXFwidG9hc3R1aUltYWdlRmlsZUlucHV0XFxcIj5cIiwgXCI8L2xhYmVsPlxcbiAgICAgICAgICA8c3BhblxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcIiwgXCJcXFwiXFxuICAgICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgICAgICBvblNlbGVjdHN0YXJ0PVwiLCBcIlxcbiAgICAgICAgICA+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgPGJ1dHRvblxcbiAgICAgICAgICAgIHR5cGU9XFxcImJ1dHRvblxcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICAgID5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgIGlkPVxcXCJ0b2FzdHVpSW1hZ2VGaWxlSW5wdXRcXFwiXFxuICAgICAgICAgICAgdHlwZT1cXFwiZmlsZVxcXCJcXG4gICAgICAgICAgICBhY2NlcHQ9XFxcImltYWdlLypcXFwiXFxuICAgICAgICAgICAgb25DaGFuZ2U9XCIsIFwiXFxuICAgICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0b2FzdHVpQWx0VGV4dElucHV0XFxcIj5cIiwgXCI8L2xhYmVsPlxcbiAgICAgICAgPGlucHV0XFxuICAgICAgICAgIGlkPVxcXCJ0b2FzdHVpQWx0VGV4dElucHV0XFxcIlxcbiAgICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJcIiwgXCJcXFwiIG9uQ2xpY2s9XCIsIFwiPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJcIiwgXCJcXFwiIG9uQ2xpY2s9XCIsIFwiPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxkaXYgYXJpYS1sYWJlbD1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgIDxcIiwgXCIgdGFicz1cIiwgXCIgYWN0aXZlVGFiPVwiLCBcIiBvbkNsaWNrPVwiLCBcIiAvPlxcbiAgICAgICAgPGRpdiBzdHlsZT1cXFwiZGlzcGxheTpcIiwgXCJcXFwiPlxcbiAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0b2FzdHVpSW1hZ2VVcmxJbnB1dFxcXCI+XCIsIFwiPC9sYWJlbD5cXG4gICAgICAgICAgPGlucHV0XFxuICAgICAgICAgICAgaWQ9XFxcInRvYXN0dWlJbWFnZVVybElucHV0XFxcIlxcbiAgICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IHN0eWxlPVxcXCJkaXNwbGF5OlwiLCBcIjtwb3NpdGlvbjogcmVsYXRpdmU7XFxcIj5cXG4gICAgICAgICAgPGxhYmVsIGZvcj1cXFwidG9hc3R1aUltYWdlRmlsZUlucHV0XFxcIj5cIiwgXCI8L2xhYmVsPlxcbiAgICAgICAgICA8c3BhblxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcIiwgXCJcXFwiXFxuICAgICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgICAgICBvblNlbGVjdHN0YXJ0PVwiLCBcIlxcbiAgICAgICAgICA+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgPGJ1dHRvblxcbiAgICAgICAgICAgIHR5cGU9XFxcImJ1dHRvblxcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICAgID5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgIGlkPVxcXCJ0b2FzdHVpSW1hZ2VGaWxlSW5wdXRcXFwiXFxuICAgICAgICAgICAgdHlwZT1cXFwiZmlsZVxcXCJcXG4gICAgICAgICAgICBhY2NlcHQ9XFxcImltYWdlLypcXFwiXFxuICAgICAgICAgICAgb25DaGFuZ2U9XCIsIFwiXFxuICAgICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0b2FzdHVpQWx0VGV4dElucHV0XFxcIj5cIiwgXCI8L2xhYmVsPlxcbiAgICAgICAgPGlucHV0XFxuICAgICAgICAgIGlkPVxcXCJ0b2FzdHVpQWx0VGV4dElucHV0XFxcIlxcbiAgICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJcIiwgXCJcXFwiIG9uQ2xpY2s9XCIsIFwiPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJcIiwgXCJcXFwiIG9uQ2xpY2s9XCIsIFwiPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0pKSwgaTE4bi5nZXQoJ0luc2VydCBpbWFnZScpLCBUYWJzLCB0aGlzLnRhYnMsIGFjdGl2ZVRhYiwgdGhpcy50b2dnbGVUYWIsIGFjdGl2ZVRhYiA9PT0gJ3VybCcgPyAnYmxvY2snIDogJ25vbmUnLCBpMThuLmdldCgnSW1hZ2UgVVJMJyksIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMudXJsID0gZWwpOyB9LCBhY3RpdmVUYWIgPT09ICdmaWxlJyA/ICdibG9jaycgOiAnbm9uZScsIGkxOG4uZ2V0KCdTZWxlY3QgaW1hZ2UgZmlsZScpLCBjbHMoJ2ZpbGUtbmFtZScpLCBmaWxlID8gJyBoYXMtZmlsZScgOiBmaWxlTmFtZUVsQ2xhc3NOYW1lLCB0aGlzLnNob3dGaWxlU2VsZWN0Qm94LCB0aGlzLnByZXZlbnRTZWxlY3RTdGFydCwgZmlsZSA/IGZpbGUubmFtZSA6IGkxOG4uZ2V0KCdObyBmaWxlJyksIGNscygnZmlsZS1zZWxlY3QtYnV0dG9uJyksIHRoaXMuc2hvd0ZpbGVTZWxlY3RCb3gsIGkxOG4uZ2V0KCdDaG9vc2UgYSBmaWxlJyksIHRoaXMuY2hhbmdlRmlsZSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5maWxlID0gZWwpOyB9LCBpMThuLmdldCgnRGVzY3JpcHRpb24nKSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5hbHRUZXh0ID0gZWwpOyB9LCBjbHMoJ2J1dHRvbi1jb250YWluZXInKSwgY2xzKCdjbG9zZS1idXR0b24nKSwgdGhpcy5wcm9wcy5oaWRlUG9wdXAsIGkxOG4uZ2V0KCdDYW5jZWwnKSwgY2xzKCdvay1idXR0b24nKSwgdGhpcy5leGVjQ29tbWFuZCwgaTE4bi5nZXQoJ09LJykpO1xuICAgIH07XG4gICAgcmV0dXJuIEltYWdlUG9wdXBCb2R5O1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJGU7XG5cbnZhciBMaW5rUG9wdXBCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKExpbmtQb3B1cEJvZHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGlua1BvcHVwQm9keSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4ZWNDb21tYW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxpbmtVcmxFbCA9IF90aGlzLnJlZnMudXJsO1xuICAgICAgICAgICAgdmFyIGxpbmtUZXh0RWwgPSBfdGhpcy5yZWZzLnRleHQ7XG4gICAgICAgICAgICByZW1vdmVDbGFzc18xKGxpbmtVcmxFbCwgJ3dyb25nJyk7XG4gICAgICAgICAgICByZW1vdmVDbGFzc18xKGxpbmtUZXh0RWwsICd3cm9uZycpO1xuICAgICAgICAgICAgaWYgKGxpbmtVcmxFbC52YWx1ZS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3NfMShsaW5rVXJsRWwsICd3cm9uZycpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGVja0xpbmtUZXh0ID0gaXNVbmRlZmluZWRfMShfdGhpcy5wcm9wcy5pbml0aWFsVmFsdWVzLmxpbmtVcmwpO1xuICAgICAgICAgICAgaWYgKGNoZWNrTGlua1RleHQgJiYgbGlua1RleHRFbC52YWx1ZS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3NfMShsaW5rVGV4dEVsLCAnd3JvbmcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5leGVjQ29tbWFuZCgnYWRkTGluaycsIHtcbiAgICAgICAgICAgICAgICBsaW5rVXJsOiBsaW5rVXJsRWwudmFsdWUsXG4gICAgICAgICAgICAgICAgbGlua1RleHQ6IGxpbmtUZXh0RWwudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMaW5rUG9wdXBCb2R5LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLmluaXRpYWxWYWx1ZXMsIGxpbmtVcmwgPSBfYS5saW5rVXJsLCBsaW5rVGV4dCA9IF9hLmxpbmtUZXh0O1xuICAgICAgICB2YXIgbGlua1VybEVsID0gdGhpcy5yZWZzLnVybDtcbiAgICAgICAgdmFyIGxpbmtUZXh0RWwgPSB0aGlzLnJlZnMudGV4dDtcbiAgICAgICAgcmVtb3ZlQ2xhc3NfMShsaW5rVXJsRWwsICd3cm9uZycpO1xuICAgICAgICByZW1vdmVDbGFzc18xKGxpbmtUZXh0RWwsICd3cm9uZycsICdkaXNhYmxlZCcpO1xuICAgICAgICBsaW5rVGV4dEVsLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgaWYgKGxpbmtVcmwpIHtcbiAgICAgICAgICAgIGFkZENsYXNzXzEobGlua1RleHRFbCwgJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICBsaW5rVGV4dEVsLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5rVXJsRWwudmFsdWUgPSBsaW5rVXJsIHx8ICcnO1xuICAgICAgICBsaW5rVGV4dEVsLnZhbHVlID0gbGlua1RleHQgfHwgJyc7XG4gICAgfTtcbiAgICBMaW5rUG9wdXBCb2R5LnByb3RvdHlwZS5tb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9O1xuICAgIExpbmtQb3B1cEJvZHkucHJvdG90eXBlLnVwZGF0ZWQgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmICghcHJldlByb3BzLnNob3cgJiYgdGhpcy5wcm9wcy5zaG93KSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGlua1BvcHVwQm9keS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJGQgfHwgKHRlbXBsYXRlT2JqZWN0XzEkZCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDxkaXYgYXJpYS1sYWJlbD1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInRvYXN0dWlMaW5rVXJsSW5wdXRcXFwiPlwiLCBcIjwvbGFiZWw+XFxuICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgaWQ9XFxcInRvYXN0dWlMaW5rVXJsSW5wdXRcXFwiXFxuICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0b2FzdHVpTGlua1RleHRJbnB1dFxcXCI+XCIsIFwiPC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dFxcbiAgICAgICAgICBpZD1cXFwidG9hc3R1aUxpbmtUZXh0SW5wdXRcXFwiXFxuICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIlwiLCBcIlxcXCIgb25DbGljaz1cIiwgXCI+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIlwiLCBcIlxcXCIgb25DbGljaz1cIiwgXCI+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGRpdiBhcmlhLWxhYmVsPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidG9hc3R1aUxpbmtVcmxJbnB1dFxcXCI+XCIsIFwiPC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dFxcbiAgICAgICAgICBpZD1cXFwidG9hc3R1aUxpbmtVcmxJbnB1dFxcXCJcXG4gICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInRvYXN0dWlMaW5rVGV4dElucHV0XFxcIj5cIiwgXCI8L2xhYmVsPlxcbiAgICAgICAgPGlucHV0XFxuICAgICAgICAgIGlkPVxcXCJ0b2FzdHVpTGlua1RleHRJbnB1dFxcXCJcXG4gICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBvbkNsaWNrPVwiLCBcIj5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBvbkNsaWNrPVwiLCBcIj5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdKSksIGkxOG4uZ2V0KCdJbnNlcnQgbGluaycpLCBpMThuLmdldCgnVVJMJyksIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMudXJsID0gZWwpOyB9LCBpMThuLmdldCgnTGluayB0ZXh0JyksIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMudGV4dCA9IGVsKTsgfSwgY2xzKCdidXR0b24tY29udGFpbmVyJyksIGNscygnY2xvc2UtYnV0dG9uJyksIHRoaXMucHJvcHMuaGlkZVBvcHVwLCBpMThuLmdldCgnQ2FuY2VsJyksIGNscygnb2stYnV0dG9uJyksIHRoaXMuZXhlY0NvbW1hbmQsIGkxOG4uZ2V0KCdPSycpKTtcbiAgICB9O1xuICAgIHJldHVybiBMaW5rUG9wdXBCb2R5O1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJGQ7XG5cbnZhciBDRUxMX1dJRFRIID0gMjA7XG52YXIgQ0VMTF9IRUlHSFQgPSAyMDtcbnZhciBNSU5fUk9XX0lOREVYID0gNTtcbnZhciBNQVhfUk9XX0lOREVYID0gMTQ7XG52YXIgTUlOX0NPTF9JTkRFWCA9IDU7XG52YXIgTUFYX0NPTF9JTkRFWCA9IDk7XG52YXIgTUlOX1JPV19TRUxFQ1RJT05fSU5ERVggPSAxO1xudmFyIE1JTl9DT0xfU0VMRUNUSU9OX0lOREVYID0gMTtcbnZhciBCT1JERVJfV0lEVEggPSAxO1xudmFyIFRhYmxlUG9wdXBCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYmxlUG9wdXBCb2R5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlUG9wdXBCb2R5KHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5leHRlbmRTZWxlY3Rpb25SYW5nZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHBhZ2VYID0gX2EucGFnZVgsIHBhZ2VZID0gX2EucGFnZVk7XG4gICAgICAgICAgICB2YXIgeCA9IHBhZ2VYIC0gX3RoaXMub2Zmc2V0UmVjdC5sZWZ0O1xuICAgICAgICAgICAgdmFyIHkgPSBwYWdlWSAtIF90aGlzLm9mZnNldFJlY3QudG9wO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gX3RoaXMuZ2V0U2VsZWN0aW9uUmFuZ2VCeU9mZnNldCh4LCB5KTtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKF9fYXNzaWduJDEoe30sIHJhbmdlKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmV4ZWNDb21tYW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucHJvcHMuZXhlY0NvbW1hbmQoJ2FkZFRhYmxlJywge1xuICAgICAgICAgICAgICAgIHJvd0NvdW50OiBfdGhpcy5zdGF0ZS5yb3dJZHggKyAxLFxuICAgICAgICAgICAgICAgIGNvbHVtbkNvdW50OiBfdGhpcy5zdGF0ZS5jb2xJZHggKyAxLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcm93SWR4OiAtMSxcbiAgICAgICAgICAgIGNvbElkeDogLTEsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGFibGVQb3B1cEJvZHkucHJvdG90eXBlLmdldERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jb2xJZHggPT09IC0xID8gJycgOiB0aGlzLnN0YXRlLmNvbElkeCArIDEgKyBcIiB4IFwiICsgKHRoaXMuc3RhdGUucm93SWR4ICsgMSk7XG4gICAgfTtcbiAgICBUYWJsZVBvcHVwQm9keS5wcm90b3R5cGUuZ2V0Qm91bmRCeVJhbmdlID0gZnVuY3Rpb24gKGNvbElkeCwgcm93SWR4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogKGNvbElkeCArIDEpICogQ0VMTF9XSURUSCxcbiAgICAgICAgICAgIGhlaWdodDogKHJvd0lkeCArIDEpICogQ0VMTF9IRUlHSFQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZVBvcHVwQm9keS5wcm90b3R5cGUuZ2V0UmFuZ2VCeU9mZnNldCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2xJZHg6IE1hdGguZmxvb3IoeCAvIENFTExfV0lEVEgpLFxuICAgICAgICAgICAgcm93SWR4OiBNYXRoLmZsb29yKHkgLyBDRUxMX0hFSUdIVCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZVBvcHVwQm9keS5wcm90b3R5cGUuZ2V0VGFibGVSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5zdGF0ZSwgb3JnQ29sSWR4ID0gX2EuY29sSWR4LCBvcmdSb3dJZHggPSBfYS5yb3dJZHg7XG4gICAgICAgIHZhciBjb2xJZHggPSBNYXRoLm1heChvcmdDb2xJZHgsIE1JTl9DT0xfSU5ERVgpO1xuICAgICAgICB2YXIgcm93SWR4ID0gTWF0aC5tYXgob3JnUm93SWR4LCBNSU5fUk9XX0lOREVYKTtcbiAgICAgICAgaWYgKG9yZ0NvbElkeCA+PSBNSU5fQ09MX0lOREVYICYmIGNvbElkeCA8IE1BWF9DT0xfSU5ERVgpIHtcbiAgICAgICAgICAgIGNvbElkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmdSb3dJZHggPj0gTUlOX1JPV19JTkRFWCAmJiByb3dJZHggPCBNQVhfUk9XX0lOREVYKSB7XG4gICAgICAgICAgICByb3dJZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjb2xJZHg6IGNvbElkeCArIDEsIHJvd0lkeDogcm93SWR4ICsgMSB9O1xuICAgIH07XG4gICAgVGFibGVQb3B1cEJvZHkucHJvdG90eXBlLmdldFNlbGVjdGlvbkFyZWFCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRCb3VuZEJ5UmFuZ2UodGhpcy5zdGF0ZS5jb2xJZHgsIHRoaXMuc3RhdGUucm93SWR4KSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICBpZiAoIXdpZHRoICYmICFoZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3BsYXk6ICdub25lJyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCAtIEJPUkRFUl9XSURUSCwgaGVpZ2h0OiBoZWlnaHQgLSBCT1JERVJfV0lEVEgsIGRpc3BsYXk6ICdibG9jaycgfTtcbiAgICB9O1xuICAgIFRhYmxlUG9wdXBCb2R5LnByb3RvdHlwZS5nZXRTZWxlY3Rpb25SYW5nZUJ5T2Zmc2V0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRSYW5nZUJ5T2Zmc2V0KHgsIHkpO1xuICAgICAgICByYW5nZS5yb3dJZHggPSBNYXRoLm1pbihNYXRoLm1heChyYW5nZS5yb3dJZHgsIE1JTl9ST1dfU0VMRUNUSU9OX0lOREVYKSwgTUFYX1JPV19JTkRFWCk7XG4gICAgICAgIHJhbmdlLmNvbElkeCA9IE1hdGgubWluKE1hdGgubWF4KHJhbmdlLmNvbElkeCwgTUlOX0NPTF9TRUxFQ1RJT05fSU5ERVgpLCBNQVhfQ09MX0lOREVYKTtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG4gICAgVGFibGVQb3B1cEJvZHkucHJvdG90eXBlLnVwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5zaG93KSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgY29sSWR4OiAtMSwgcm93SWR4OiAtMSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlLmNvbElkeCA9PT0gLTEgJiYgdGhpcy5zdGF0ZS5yb3dJZHggPT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLnJlZnMudGFibGVFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbGVmdCA9IF9hLmxlZnQsIHRvcF8xID0gX2EudG9wO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXRSZWN0ID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHdpbmRvdy5wYWdlWE9mZnNldCArIGxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiB3aW5kb3cucGFnZVlPZmZzZXQgKyB0b3BfMSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYmxlUG9wdXBCb2R5LnByb3RvdHlwZS5jcmVhdGVUYWJsZUFyZWEgPSBmdW5jdGlvbiAodGFibGVSYW5nZSkge1xuICAgICAgICB2YXIgY29sSWR4ID0gdGFibGVSYW5nZS5jb2xJZHgsIHJvd0lkeCA9IHRhYmxlUmFuZ2Uucm93SWR4O1xuICAgICAgICB2YXIgcm93cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0lkeDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sSWR4OyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbENsYXNzTmFtZXMgPSBcIlwiICsgY2xzKCd0YWJsZS1jZWxsJykgKyAoaSA+IDAgPyAnJyA6ICcgaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgY2VsbHMucHVzaChodG1sKHRlbXBsYXRlT2JqZWN0XzEkYyB8fCAodGVtcGxhdGVPYmplY3RfMSRjID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj48L2Rpdj5cIl0sIFtcIjxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+PC9kaXY+XCJdKSksIGNlbGxDbGFzc05hbWVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dzLnB1c2goaHRtbCh0ZW1wbGF0ZU9iamVjdF8yJDYgfHwgKHRlbXBsYXRlT2JqZWN0XzIkNiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XCIsIFwiPC9kaXY+XCJdLCBbXCI8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlwiLCBcIjwvZGl2PlwiXSkpLCBjbHMoJ3RhYmxlLXJvdycpLCBjZWxscykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzMkMiB8fCAodGVtcGxhdGVPYmplY3RfMyQyID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cIiwgXCI8L2Rpdj5cIl0sIFtcIjxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XCIsIFwiPC9kaXY+XCJdKSksIGNscygndGFibGUnKSwgcm93cyk7XG4gICAgfTtcbiAgICBUYWJsZVBvcHVwQm9keS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdGFibGVSYW5nZSA9IHRoaXMuZ2V0VGFibGVSYW5nZSgpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uQXJlYUJvdW5kID0gdGhpcy5nZXRTZWxlY3Rpb25BcmVhQm91bmQoKTtcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfNCQxIHx8ICh0ZW1wbGF0ZU9iamVjdF80JDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8ZGl2IGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgb25Nb3VzZW1vdmU9XCIsIFwiXFxuICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVwiLCBcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPHAgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XCIsIFwiPC9wPlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxkaXYgYXJpYS1sYWJlbD1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICBvbk1vdXNlbW92ZT1cIiwgXCJcXG4gICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XCIsIFwiPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8cCBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cIiwgXCI8L3A+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSkpLCBpMThuLmdldCgnSW5zZXJ0IHRhYmxlJyksIGNscygndGFibGUtc2VsZWN0aW9uJyksIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMudGFibGVFbCA9IGVsKTsgfSwgdGhpcy5leHRlbmRTZWxlY3Rpb25SYW5nZSwgdGhpcy5leGVjQ29tbWFuZCwgdGhpcy5jcmVhdGVUYWJsZUFyZWEodGFibGVSYW5nZSksIGNscygndGFibGUtc2VsZWN0aW9uLWxheWVyJyksIHNlbGVjdGlvbkFyZWFCb3VuZCwgY2xzKCd0YWJsZS1kZXNjcmlwdGlvbicpLCB0aGlzLmdldERlc2NyaXB0aW9uKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlUG9wdXBCb2R5O1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJGMsIHRlbXBsYXRlT2JqZWN0XzIkNiwgdGVtcGxhdGVPYmplY3RfMyQyLCB0ZW1wbGF0ZU9iamVjdF80JDE7XG5cbnZhciBDdXN0b21Qb3B1cEJvZHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQ3VzdG9tUG9wdXBCb2R5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1c3RvbVBvcHVwQm9keSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDdXN0b21Qb3B1cEJvZHkucHJvdG90eXBlLm1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgY3VzdG9tIHBvcHVwIGJvZHkgZWxlbWVudFxuICAgICAgICB0aGlzLnJlZnMuZWwuYXBwZW5kQ2hpbGQodGhpcy5wcm9wcy5ib2R5KTtcbiAgICB9O1xuICAgIEN1c3RvbVBvcHVwQm9keS5wcm90b3R5cGUudXBkYXRlZCA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgLy8gdXBkYXRlIGN1c3RvbSBwb3B1cCBlbGVtZW50XG4gICAgICAgIHRoaXMucmVmcy5lbC5yZXBsYWNlQ2hpbGQodGhpcy5wcm9wcy5ib2R5LCBwcmV2UHJvcHMuYm9keSk7XG4gICAgfTtcbiAgICBDdXN0b21Qb3B1cEJvZHkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSRiIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJGIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8ZGl2IHJlZj1cIiwgXCI+PC9kaXY+XCJdLCBbXCI8ZGl2IHJlZj1cIiwgXCI+PC9kaXY+XCJdKSksIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMuZWwgPSBlbCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEN1c3RvbVBvcHVwQm9keTtcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSRiO1xuXG5mdW5jdGlvbiBjcmVhdGVUb29sYmFySXRlbUluZm8odHlwZSkge1xuICAgIHJldHVybiBpc1N0cmluZ18xKHR5cGUpID8gY3JlYXRlRGVmYXVsdFRvb2xiYXJJdGVtSW5mbyh0eXBlKSA6IHR5cGU7XG59XG5mdW5jdGlvbiBjcmVhdGVTY3JvbGxTeW5jVG9vbGJhckl0ZW0oKSB7XG4gICAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICB2YXIgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHZhciB0b2dnbGVTd2l0Y2ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgbGFiZWwuY2xhc3NOYW1lID0gJ3Njcm9sbC1zeW5jIGFjdGl2ZSc7XG4gICAgY2hlY2tib3gudHlwZSA9ICdjaGVja2JveCc7XG4gICAgY2hlY2tib3guY2hlY2tlZCA9IHRydWU7XG4gICAgdG9nZ2xlU3dpdGNoLmNsYXNzTmFtZSA9ICdzd2l0Y2gnO1xuICAgIHZhciBvbk1vdW50ZWQgPSBmdW5jdGlvbiAoZXhlY0NvbW1hbmQpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGNoZWNrZWQgPSBldi50YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgICAgIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3NfMShsYWJlbCwgJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NfMShsYWJlbCwgJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhlY0NvbW1hbmQoJ3RvZ2dsZVNjcm9sbFN5bmMnLCB7IGFjdGl2ZTogY2hlY2tlZCB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBsYWJlbC5hcHBlbmRDaGlsZChjaGVja2JveCk7XG4gICAgbGFiZWwuYXBwZW5kQ2hpbGQodG9nZ2xlU3dpdGNoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnc2Nyb2xsU3luYycsXG4gICAgICAgIGVsOiBsYWJlbCxcbiAgICAgICAgb25Nb3VudGVkOiBvbk1vdW50ZWQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRUb29sYmFySXRlbUluZm8odHlwZSkge1xuICAgIHZhciBpbmZvO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2hlYWRpbmcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2hlYWRpbmcnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdIZWFkaW5ncycpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnaGVhZGluZycsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvbGQnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnYm9sZCcsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnYm9sZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2JvbGQnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdCb2xkJyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdzdHJvbmcnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpdGFsaWMnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnaXRhbGljJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdpdGFsaWMnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdpdGFsaWMnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdJdGFsaWMnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2VtcGgnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdHJpa2UnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3RyaWtlJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdzdHJpa2UnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdzdHJpa2UnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdTdHJpa2UnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3N0cmlrZScsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2hyJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2hyJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdocmxpbmUnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdocicsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ0xpbmUnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3RoZW1hdGljQnJlYWsnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdxdW90ZSc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdxdW90ZScsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAncXVvdGUnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdibG9ja1F1b3RlJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnQmxvY2txdW90ZScpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnYmxvY2tRdW90ZScsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3VsJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3VsJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdidWxsZXQtbGlzdCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2J1bGxldExpc3QnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdVbm9yZGVyZWQgbGlzdCcpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnYnVsbGV0TGlzdCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ29sJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ29sJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdvcmRlcmVkLWxpc3QnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdvcmRlcmVkTGlzdCcsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ09yZGVyZWQgbGlzdCcpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnb3JkZXJlZExpc3QnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXNrJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3Rhc2snLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3Rhc2stbGlzdCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3Rhc2tMaXN0JyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnVGFzaycpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAndGFza0xpc3QnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0YWJsZScsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAndGFibGUnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdJbnNlcnQgdGFibGUnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3RhYmxlJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnSW5zZXJ0IGltYWdlJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnbGluaycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbGluaycsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ0luc2VydCBsaW5rJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NvZGUnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY29kZScsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnY29kZScsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdDb2RlJyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdjb2RlJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29kZWJsb2NrJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2NvZGVibG9jaycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnY29kZWJsb2NrJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnY29kZUJsb2NrJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnSW5zZXJ0IENvZGVCbG9jaycpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnY29kZUJsb2NrJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5kZW50JzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2luZGVudCcsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnaW5kZW50JyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnaW5kZW50JyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnSW5kZW50JyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdpbmRlbnQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvdXRkZW50JzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ291dGRlbnQnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ291dGRlbnQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdvdXRkZW50JyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnT3V0ZGVudCcpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnb3V0ZGVudCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Njcm9sbFN5bmMnOlxuICAgICAgICAgICAgaW5mbyA9IGNyZWF0ZVNjcm9sbFN5bmNUb29sYmFySXRlbSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21vcmUnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnbW9yZScsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbW9yZScsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ01vcmUnKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbiAgICBpZiAoaW5mby5uYW1lICE9PSAnc2Nyb2xsU3luYycpIHtcbiAgICAgICAgaW5mby5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbHMoJ3Rvb2xiYXItaWNvbnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm87XG59XG5mdW5jdGlvbiBjcmVhdGVQb3B1cEluZm8odHlwZSwgcGF5bG9hZCkge1xuICAgIHZhciBlbCA9IHBheWxvYWQuZWwsIHBvcyA9IHBheWxvYWQucG9zLCBwb3B1cCA9IHBheWxvYWQucG9wdXAsIGluaXRpYWxWYWx1ZXMgPSBwYXlsb2FkLmluaXRpYWxWYWx1ZXM7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2hlYWRpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJGEgfHwgKHRlbXBsYXRlT2JqZWN0XzEkYSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxcIiwgXCIgLi4uXCIsIFwiIC8+XCJdLCBbXCI8XCIsIFwiIC4uLlwiLCBcIiAvPlwiXSkpLCBIZWFkaW5nUG9wdXBCb2R5LCBwcm9wcyk7IH0sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbHMoJ3BvcHVwLWFkZC1oZWFkaW5nJyksXG4gICAgICAgICAgICAgICAgZnJvbUVsOiBlbCxcbiAgICAgICAgICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8yJDUgfHwgKHRlbXBsYXRlT2JqZWN0XzIkNSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxcIiwgXCIgLi4uXCIsIFwiIC8+XCJdLCBbXCI8XCIsIFwiIC4uLlwiLCBcIiAvPlwiXSkpLCBMaW5rUG9wdXBCb2R5LCBwcm9wcyk7IH0sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbHMoJ3BvcHVwLWFkZC1saW5rJyksXG4gICAgICAgICAgICAgICAgZnJvbUVsOiBlbCxcbiAgICAgICAgICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgICAgICAgICBpbml0aWFsVmFsdWVzOiBpbml0aWFsVmFsdWVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8zJDEgfHwgKHRlbXBsYXRlT2JqZWN0XzMkMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxcIiwgXCIgLi4uXCIsIFwiIC8+XCJdLCBbXCI8XCIsIFwiIC4uLlwiLCBcIiAvPlwiXSkpLCBJbWFnZVBvcHVwQm9keSwgcHJvcHMpOyB9LFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xzKCdwb3B1cC1hZGQtaW1hZ2UnKSxcbiAgICAgICAgICAgICAgICBmcm9tRWw6IGVsLFxuICAgICAgICAgICAgICAgIHBvczogcG9zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF80IHx8ICh0ZW1wbGF0ZU9iamVjdF80ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiPFwiLCBcIiAuLi5cIiwgXCIgLz5cIl0sIFtcIjxcIiwgXCIgLi4uXCIsIFwiIC8+XCJdKSksIFRhYmxlUG9wdXBCb2R5LCBwcm9wcyk7IH0sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbHMoJ3BvcHVwLWFkZC10YWJsZScpLFxuICAgICAgICAgICAgICAgIGZyb21FbDogZWwsXG4gICAgICAgICAgICAgICAgcG9zOiBwb3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdjdXN0b21Qb3B1cEJvZHknOlxuICAgICAgICAgICAgaWYgKCFwb3B1cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoeyByZW5kZXI6IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF81IHx8ICh0ZW1wbGF0ZU9iamVjdF81ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiPFwiLCBcIiAuLi5cIiwgXCIgYm9keT1cIiwgXCIgLz5cIl0sIFtcIjxcIiwgXCIgLi4uXCIsIFwiIGJvZHk9XCIsIFwiIC8+XCJdKSksIEN1c3RvbVBvcHVwQm9keSwgcHJvcHMsIHBvcHVwLmJvZHkpOyB9LCBmcm9tRWw6IGVsLCBwb3M6IHBvcyB9LCBwb3B1cCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRHcm91cFN0YXRlKGdyb3VwKSB7XG4gICAgZ3JvdXAuaGlkZGVuID0gZ3JvdXAubGVuZ3RoID09PSBncm91cC5maWx0ZXIoZnVuY3Rpb24gKGluZm8pIHsgcmV0dXJuIGluZm8uaGlkZGVuOyB9KS5sZW5ndGg7XG59XG5mdW5jdGlvbiBncm91cFRvb2xiYXJJdGVtcyh0b29sYmFySXRlbXMsIGhpZGRlblNjcm9sbFN5bmMpIHtcbiAgICB2YXIgdG9nZ2xlU2Nyb2xsU3luY1N0YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaXRlbS5oaWRkZW4gPSBpdGVtLm5hbWUgPT09ICdzY3JvbGxTeW5jJyAmJiBoaWRkZW5TY3JvbGxTeW5jO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuICAgIHJldHVybiB0b29sYmFySXRlbXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGl0ZW0pIHtcbiAgICAgICAgYWNjLnB1c2goaXRlbS5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHRvZ2dsZVNjcm9sbFN5bmNTdGF0ZShjcmVhdGVUb29sYmFySXRlbUluZm8odHlwZSkpOyB9KSk7XG4gICAgICAgIHZhciBncm91cCA9IGFjY1soYWNjLmxlbmd0aCB8fCAxKSAtIDFdO1xuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgIHNldEdyb3VwU3RhdGUoZ3JvdXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xufVxuZnVuY3Rpb24gdG9nZ2xlU2Nyb2xsU3luYyh0b29sYmFySXRlbXMsIGhpZGRlblNjcm9sbFN5bmMpIHtcbiAgICB0b29sYmFySXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgZ3JvdXAuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gKGl0ZW0uaGlkZGVuID0gaXRlbS5uYW1lID09PSAnc2Nyb2xsU3luYycgJiYgaGlkZGVuU2Nyb2xsU3luYyk7IH0pO1xuICAgICAgICBzZXRHcm91cFN0YXRlKGdyb3VwKTtcbiAgICB9KTtcbn1cbnZhciB0ZW1wbGF0ZU9iamVjdF8xJGEsIHRlbXBsYXRlT2JqZWN0XzIkNSwgdGVtcGxhdGVPYmplY3RfMyQxLCB0ZW1wbGF0ZU9iamVjdF80LCB0ZW1wbGF0ZU9iamVjdF81O1xuXG52YXIgTUFSR0lOX0ZST01fUklHSFRfU0lERSA9IDIwO1xudmFyIFBvcHVwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFBvcHVwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvcHVwKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFuZGxlTW91c2Vkb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoIWNsb3Nlc3QoZXYudGFyZ2V0LCBcIi5cIiArIGNscygncG9wdXAnKSkgJiZcbiAgICAgICAgICAgICAgICAhY2xvc2VzdChldi50YXJnZXQsIF90aGlzLnByb3BzLmluZm8uZnJvbUVsKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmhpZGVQb3B1cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBvcHVwLnByb3RvdHlwZS5tb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlZG93bik7XG4gICAgICAgIHRoaXMucHJvcHMuZXZlbnRFbWl0dGVyLmxpc3RlbignY2xvc2VQb3B1cCcsIHRoaXMucHJvcHMuaGlkZVBvcHVwKTtcbiAgICB9O1xuICAgIFBvcHVwLnByb3RvdHlwZS5iZWZvcmVEZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlZG93bik7XG4gICAgfTtcbiAgICBQb3B1cC5wcm90b3R5cGUudXBkYXRlZCA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgc2hvdyA9IF9hLnNob3csIGluZm8gPSBfYS5pbmZvO1xuICAgICAgICBpZiAoc2hvdyAmJiBpbmZvLnBvcyAmJiBwcmV2UHJvcHMuc2hvdyAhPT0gc2hvdykge1xuICAgICAgICAgICAgdmFyIHBvcHVwUG9zID0gX19hc3NpZ24kMSh7fSwgaW5mby5wb3MpO1xuICAgICAgICAgICAgdmFyIG9mZnNldFdpZHRoID0gdGhpcy5yZWZzLmVsLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgdmFyIHRvb2xiYXJFbCA9IGNsb3Nlc3QodGhpcy5yZWZzLmVsLCBcIi5cIiArIGNscygndG9vbGJhcicpKTtcbiAgICAgICAgICAgIHZhciB0b29sYmFyT2Zmc2V0V2lkdGggPSB0b29sYmFyRWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICBpZiAocG9wdXBQb3MubGVmdCArIG9mZnNldFdpZHRoID49IHRvb2xiYXJPZmZzZXRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHBvcHVwUG9zLmxlZnQgPSB0b29sYmFyT2Zmc2V0V2lkdGggLSBvZmZzZXRXaWR0aCAtIE1BUkdJTl9GUk9NX1JJR0hUX1NJREU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNoYWxsb3dFcXVhbCh0aGlzLnN0YXRlLnBvcHVwUG9zLCBwb3B1cFBvcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgcG9wdXBQb3M6IHBvcHVwUG9zIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBQb3B1cC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBpbmZvID0gX2EuaW5mbywgc2hvdyA9IF9hLnNob3csIGhpZGVQb3B1cCA9IF9hLmhpZGVQb3B1cCwgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyLCBleGVjQ29tbWFuZCA9IF9hLmV4ZWNDb21tYW5kO1xuICAgICAgICB2YXIgX2IgPSBpbmZvIHx8IHt9LCBfYyA9IF9iLmNsYXNzTmFtZSwgY2xhc3NOYW1lID0gX2MgPT09IHZvaWQgMCA/ICcnIDogX2MsIHN0eWxlID0gX2Iuc3R5bGUsIHJlbmRlciA9IF9iLnJlbmRlciwgX2QgPSBfYi5pbml0aWFsVmFsdWVzLCBpbml0aWFsVmFsdWVzID0gX2QgPT09IHZvaWQgMCA/IHt9IDogX2Q7XG4gICAgICAgIHZhciBwb3B1cFN0eWxlID0gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHsgZGlzcGxheTogc2hvdyA/ICdibG9jaycgOiAnbm9uZScgfSwgc3R5bGUpLCB0aGlzLnN0YXRlLnBvcHVwUG9zKTtcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSQ5IHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDkgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8ZGl2XFxuICAgICAgICBjbGFzcz1cXFwiXCIsIFwiIFwiLCBcIlxcXCJcXG4gICAgICAgIHN0eWxlPVwiLCBcIlxcbiAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgYXJpYS1yb2xlPVxcXCJkaWFsb2dcXFwiXFxuICAgICAgPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8ZGl2XFxuICAgICAgICBjbGFzcz1cXFwiXCIsIFwiIFwiLCBcIlxcXCJcXG4gICAgICAgIHN0eWxlPVwiLCBcIlxcbiAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgYXJpYS1yb2xlPVxcXCJkaWFsb2dcXFwiXFxuICAgICAgPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdKSksIGNscygncG9wdXAnKSwgY2xhc3NOYW1lLCBwb3B1cFN0eWxlLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLmVsID0gZWwpOyB9LCBjbHMoJ3BvcHVwLWJvZHknKSwgcmVuZGVyICYmIHJlbmRlcih7IGV2ZW50RW1pdHRlcjogZXZlbnRFbWl0dGVyLCBzaG93OiBzaG93LCBoaWRlUG9wdXA6IGhpZGVQb3B1cCwgZXhlY0NvbW1hbmQ6IGV4ZWNDb21tYW5kLCBpbml0aWFsVmFsdWVzOiBpbml0aWFsVmFsdWVzIH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBQb3B1cDtcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSQ5O1xuXG52YXIgVE9PTFRJUF9JTkRFTlQgPSA2O1xuZnVuY3Rpb24gY29ubmVjdEhPQyhXcmFwcGVkQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoQnV0dG9uSE9DLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBCdXR0b25IT0MocHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9vbHRpcCA9IF90aGlzLnByb3BzLml0ZW0udG9vbHRpcDtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnByb3BzLmRpc2FibGVkICYmIHRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kID0gX3RoaXMuZ2V0Qm91bmQoZWwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IGJvdW5kLmxlZnQgKyBUT09MVElQX0lOREVOVCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcF8xID0gYm91bmQudG9wICsgVE9PTFRJUF9JTkRFTlQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGNzc18xKF90aGlzLnByb3BzLnRvb2x0aXBSZWYuY3VycmVudCwgeyBkaXNwbGF5OiAnYmxvY2snLCBsZWZ0OiBsZWZ0LCB0b3A6IHRvcF8xIH0pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy50b29sdGlwUmVmLmN1cnJlbnQucXVlcnlTZWxlY3RvcignLnRleHQnKS50ZXh0Q29udGVudCA9IHRvb2x0aXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzLmhpZGVUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNzc18xKF90aGlzLnByb3BzLnRvb2x0aXBSZWYuY3VycmVudCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0geyBhY3RpdmU6IGZhbHNlLCBkaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQgfTtcbiAgICAgICAgICAgIF90aGlzLmFkZEV2ZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgQnV0dG9uSE9DLnByb3RvdHlwZS5hZGRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBpdGVtID0gX2EuaXRlbSwgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyO1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIubGlzdGVuKCdjaGFuZ2VUb29sYmFyU3RhdGUnLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9vbGJhclN0YXRlID0gX2EudG9vbGJhclN0YXRlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2MgPSAoX2IgPSB0b29sYmFyU3RhdGVbaXRlbS5zdGF0ZV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9LCBhY3RpdmUgPSBfYy5hY3RpdmUsIGRpc2FibGVkID0gX2MuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgYWN0aXZlOiAhIWFjdGl2ZSwgZGlzYWJsZWQ6IGRpc2FibGVkICE9PSBudWxsICYmIGRpc2FibGVkICE9PSB2b2lkIDAgPyBkaXNhYmxlZCA6IF90aGlzLnByb3BzLmRpc2FibGVkIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCdXR0b25IT0MucHJvdG90eXBlLmdldEJvdW5kID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRUb3RhbE9mZnNldChlbCwgY2xvc2VzdChlbCwgXCIuXCIgKyBjbHMoJ3Rvb2xiYXInKSkpLCBvZmZzZXRMZWZ0ID0gX2Eub2Zmc2V0TGVmdCwgb2Zmc2V0VG9wID0gX2Eub2Zmc2V0VG9wO1xuICAgICAgICAgICAgcmV0dXJuIHsgbGVmdDogb2Zmc2V0TGVmdCwgdG9wOiBlbC5vZmZzZXRIZWlnaHQgKyBvZmZzZXRUb3AgfTtcbiAgICAgICAgfTtcbiAgICAgICAgQnV0dG9uSE9DLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJDggfHwgKHRlbXBsYXRlT2JqZWN0XzEkOCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICAuLi5cIiwgXCJcXG4gICAgICAgICAgYWN0aXZlPVwiLCBcIlxcbiAgICAgICAgICBzaG93VG9vbHRpcD1cIiwgXCJcXG4gICAgICAgICAgaGlkZVRvb2x0aXA9XCIsIFwiXFxuICAgICAgICAgIGdldEJvdW5kPVwiLCBcIlxcbiAgICAgICAgICBkaXNhYmxlZD1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgXCJdLCBbXCJcXG4gICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgLi4uXCIsIFwiXFxuICAgICAgICAgIGFjdGl2ZT1cIiwgXCJcXG4gICAgICAgICAgc2hvd1Rvb2x0aXA9XCIsIFwiXFxuICAgICAgICAgIGhpZGVUb29sdGlwPVwiLCBcIlxcbiAgICAgICAgICBnZXRCb3VuZD1cIiwgXCJcXG4gICAgICAgICAgZGlzYWJsZWQ9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgIFwiXSkpLCBXcmFwcGVkQ29tcG9uZW50LCB0aGlzLnByb3BzLCB0aGlzLnN0YXRlLmFjdGl2ZSwgdGhpcy5zaG93VG9vbHRpcCwgdGhpcy5oaWRlVG9vbHRpcCwgdGhpcy5nZXRCb3VuZCwgdGhpcy5zdGF0ZS5kaXNhYmxlZCB8fCB0aGlzLnByb3BzLmRpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJ1dHRvbkhPQztcbiAgICB9KENvbXBvbmVudCkpO1xufVxudmFyIHRlbXBsYXRlT2JqZWN0XzEkODtcblxudmFyIERFRkFVTFRfV0lEVEggPSA4MDtcbnZhciBUb29sYmFyQnV0dG9uQ29tcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUb29sYmFyQnV0dG9uQ29tcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUb29sYmFyQnV0dG9uQ29tcCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNob3dUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucHJvcHMuc2hvd1Rvb2x0aXAoX3RoaXMucmVmcy5lbCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmV4ZWNDb21tYW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIGl0ZW0gPSBfYS5pdGVtLCBleGVjQ29tbWFuZCA9IF9hLmV4ZWNDb21tYW5kLCBzZXRQb3B1cEluZm8gPSBfYS5zZXRQb3B1cEluZm8sIGdldEJvdW5kID0gX2EuZ2V0Qm91bmQsIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlcjtcbiAgICAgICAgICAgIHZhciBjb21tYW5kID0gaXRlbS5jb21tYW5kLCBuYW1lID0gaXRlbS5uYW1lLCBwb3B1cCA9IGl0ZW0ucG9wdXA7XG4gICAgICAgICAgICBpZiAoY29tbWFuZCkge1xuICAgICAgICAgICAgICAgIGV4ZWNDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcHVwTmFtZSA9IHBvcHVwID8gJ2N1c3RvbVBvcHVwQm9keScgOiBuYW1lO1xuICAgICAgICAgICAgICAgIHZhciBpbml0aWFsVmFsdWVzID0gZXZlbnRFbWl0dGVyLmVtaXQoJ3F1ZXJ5JywgJ2dldFBvcHVwSW5pdGlhbFZhbHVlcycsIHsgcG9wdXBOYW1lOiBwb3B1cE5hbWUgfSlbMF07XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBjcmVhdGVQb3B1cEluZm8ocG9wdXBOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiBfdGhpcy5yZWZzLmVsLFxuICAgICAgICAgICAgICAgICAgICBwb3M6IGdldEJvdW5kKF90aGlzLnJlZnMuZWwpLFxuICAgICAgICAgICAgICAgICAgICBwb3B1cDogcG9wdXAsXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZXM6IGluaXRpYWxWYWx1ZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0UG9wdXBJbmZvKGluZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUb29sYmFyQnV0dG9uQ29tcC5wcm90b3R5cGUubW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRJdGVtV2lkdGgoKTtcbiAgICB9O1xuICAgIFRvb2xiYXJCdXR0b25Db21wLnByb3RvdHlwZS51cGRhdGVkID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICBpZiAocHJldlByb3BzLml0ZW0ubmFtZSAhPT0gdGhpcy5wcm9wcy5pdGVtLm5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SXRlbVdpZHRoKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2xiYXJCdXR0b25Db21wLnByb3RvdHlwZS5zZXRJdGVtV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHNldEl0ZW1XaWR0aCA9IF9hLnNldEl0ZW1XaWR0aCwgaXRlbSA9IF9hLml0ZW07XG4gICAgICAgIC8vIHNldCB3aWR0aCBvbmx5IGlmIGl0IGlzIG5vdCBhIGRyb3Bkb3duIHRvb2xiYXJcbiAgICAgICAgaWYgKHNldEl0ZW1XaWR0aCkge1xuICAgICAgICAgICAgc2V0SXRlbVdpZHRoKGl0ZW0ubmFtZSwgZ2V0T3V0ZXJXaWR0aCh0aGlzLnJlZnMuZWwpICsgKGl0ZW0uaGlkZGVuID8gREVGQVVMVF9XSURUSCA6IDApKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbGJhckJ1dHRvbkNvbXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgaGlkZVRvb2x0aXAgPSBfYS5oaWRlVG9vbHRpcCwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgaXRlbSA9IF9hLml0ZW0sIGFjdGl2ZSA9IF9hLmFjdGl2ZTtcbiAgICAgICAgdmFyIHN0eWxlID0gX19hc3NpZ24kMSh7IGRpc3BsYXk6IGl0ZW0uaGlkZGVuID8gJ25vbmUnIDogbnVsbCB9LCBpdGVtLnN0eWxlKTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBcIlwiICsgKGl0ZW0uY2xhc3NOYW1lIHx8ICcnKSArIChhY3RpdmUgPyAnIGFjdGl2ZScgOiAnJyk7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkNyB8fCAodGVtcGxhdGVPYmplY3RfMSQ3ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGJ1dHRvblxcbiAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgICAgICAgc3R5bGU9XCIsIFwiXFxuICAgICAgICBjbGFzcz1cIiwgXCJcXG4gICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICBvbk1vdXNlb3Zlcj1cIiwgXCJcXG4gICAgICAgIG9uTW91c2VvdXQ9XCIsIFwiXFxuICAgICAgICBkaXNhYmxlZD1cIiwgXCJcXG4gICAgICAgIGFyaWEtbGFiZWw9XCIsIFwiXFxuICAgICAgPlxcbiAgICAgICAgXCIsIFwiXFxuICAgICAgPC9idXR0b24+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGJ1dHRvblxcbiAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgICAgICAgc3R5bGU9XCIsIFwiXFxuICAgICAgICBjbGFzcz1cIiwgXCJcXG4gICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICBvbk1vdXNlb3Zlcj1cIiwgXCJcXG4gICAgICAgIG9uTW91c2VvdXQ9XCIsIFwiXFxuICAgICAgICBkaXNhYmxlZD1cIiwgXCJcXG4gICAgICAgIGFyaWEtbGFiZWw9XCIsIFwiXFxuICAgICAgPlxcbiAgICAgICAgXCIsIFwiXFxuICAgICAgPC9idXR0b24+XFxuICAgIFwiXSkpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLmVsID0gZWwpOyB9LCBzdHlsZSwgY2xhc3NOYW1lcywgdGhpcy5leGVjQ29tbWFuZCwgdGhpcy5zaG93VG9vbHRpcCwgaGlkZVRvb2x0aXAsICEhZGlzYWJsZWQsIGl0ZW0udGV4dCB8fCBpdGVtLnRvb2x0aXAgfHwgJycsIGl0ZW0udGV4dCB8fCAnJyk7XG4gICAgfTtcbiAgICByZXR1cm4gVG9vbGJhckJ1dHRvbkNvbXA7XG59KENvbXBvbmVudCkpO1xudmFyIFRvb2xiYXJCdXR0b24gPSBjb25uZWN0SE9DKFRvb2xiYXJCdXR0b25Db21wKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDc7XG5cbnZhciBDdXN0b21Ub29sYmFySXRlbUNvbXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQ3VzdG9tVG9vbGJhckl0ZW1Db21wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1c3RvbVRvb2xiYXJJdGVtQ29tcCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNob3dUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucHJvcHMuc2hvd1Rvb2x0aXAoX3RoaXMucmVmcy5lbCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNob3dQb3B1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbmZvID0gY3JlYXRlUG9wdXBJbmZvKCdjdXN0b21Qb3B1cEJvZHknLCB7XG4gICAgICAgICAgICAgICAgZWw6IF90aGlzLnJlZnMuZWwsXG4gICAgICAgICAgICAgICAgcG9zOiBfdGhpcy5wcm9wcy5nZXRCb3VuZChfdGhpcy5yZWZzLmVsKSxcbiAgICAgICAgICAgICAgICBwb3B1cDogX3RoaXMucHJvcHMuaXRlbS5wb3B1cCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zZXRQb3B1cEluZm8oaW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ3VzdG9tVG9vbGJhckl0ZW1Db21wLnByb3RvdHlwZS5tb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBzZXRJdGVtV2lkdGggPSBfYS5zZXRJdGVtV2lkdGgsIGl0ZW0gPSBfYS5pdGVtO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGN1c3RvbSBodG1sIGVsZW1lbnRcbiAgICAgICAgdGhpcy5yZWZzLmVsLmFwcGVuZENoaWxkKGl0ZW0uZWwpO1xuICAgICAgICAvLyBzZXQgd2lkdGggb25seSBpZiBpdCBpcyBub3QgYSBkcm9wZG93biB0b29sYmFyXG4gICAgICAgIGlmIChzZXRJdGVtV2lkdGgpIHtcbiAgICAgICAgICAgIHNldEl0ZW1XaWR0aChpdGVtLm5hbWUsIGdldE91dGVyV2lkdGgodGhpcy5yZWZzLmVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0ub25Nb3VudGVkKSB7XG4gICAgICAgICAgICBpdGVtLm9uTW91bnRlZCh0aGlzLnByb3BzLmV4ZWNDb21tYW5kKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ3VzdG9tVG9vbGJhckl0ZW1Db21wLnByb3RvdHlwZS51cGRhdGVkID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfYiA9IHRoaXMucHJvcHMsIGl0ZW0gPSBfYi5pdGVtLCBhY3RpdmUgPSBfYi5hY3RpdmUsIGRpc2FibGVkID0gX2IuZGlzYWJsZWQ7XG4gICAgICAgIGlmIChwcmV2UHJvcHMuYWN0aXZlICE9PSBhY3RpdmUgfHwgcHJldlByb3BzLmRpc2FibGVkICE9PSBkaXNhYmxlZCkge1xuICAgICAgICAgICAgKF9hID0gaXRlbS5vblVwZGF0ZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGl0ZW0sIHsgYWN0aXZlOiBhY3RpdmUsIGRpc2FibGVkOiBkaXNhYmxlZCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ3VzdG9tVG9vbGJhckl0ZW1Db21wLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIGl0ZW0gPSBfYS5pdGVtO1xuICAgICAgICB2YXIgc3R5bGUgPSB7IGRpc3BsYXk6IGl0ZW0uaGlkZGVuID8gJ25vbmUnIDogJ2lubGluZS1ibG9jaycgfTtcbiAgICAgICAgdmFyIGdldExpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiAoZGlzYWJsZWQgPyBudWxsIDogbGlzdGVuZXIpOyB9O1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJDYgfHwgKHRlbXBsYXRlT2JqZWN0XzEkNiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDxkaXZcXG4gICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIHN0eWxlPVwiLCBcIlxcbiAgICAgICAgY2xhc3M9XCIsIFwiXFxuICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgb25Nb3VzZW92ZXI9XCIsIFwiXFxuICAgICAgICBvbk1vdXNlb3V0PVwiLCBcIlxcbiAgICAgID48L2Rpdj5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8ZGl2XFxuICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICBzdHlsZT1cIiwgXCJcXG4gICAgICAgIGNsYXNzPVwiLCBcIlxcbiAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgIG9uTW91c2VvdmVyPVwiLCBcIlxcbiAgICAgICAgb25Nb3VzZW91dD1cIiwgXCJcXG4gICAgICA+PC9kaXY+XFxuICAgIFwiXSkpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLmVsID0gZWwpOyB9LCBzdHlsZSwgY2xzKCd0b29sYmFyLWl0ZW0td3JhcHBlcicpLCBnZXRMaXN0ZW5lcih0aGlzLnNob3dQb3B1cCksIGdldExpc3RlbmVyKHRoaXMuc2hvd1Rvb2x0aXApLCBnZXRMaXN0ZW5lcih0aGlzLnByb3BzLmhpZGVUb29sdGlwKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ3VzdG9tVG9vbGJhckl0ZW1Db21wO1xufShDb21wb25lbnQpKTtcbnZhciBDdXN0b21Ub29sYmFySXRlbSA9IGNvbm5lY3RIT0MoQ3VzdG9tVG9vbGJhckl0ZW1Db21wKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDY7XG5cbnZhciBUb29sYmFyR3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVG9vbGJhckdyb3VwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRvb2xiYXJHcm91cCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUb29sYmFyR3JvdXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZ3JvdXAgPSBfYS5ncm91cCwgaGlkZGVuRGl2aWRlciA9IF9hLmhpZGRlbkRpdmlkZXI7XG4gICAgICAgIHZhciBncm91cFN0eWxlID0gZ3JvdXAuaGlkZGVuID8geyBkaXNwbGF5OiAnbm9uZScgfSA6IG51bGw7XG4gICAgICAgIHZhciBkaXZpZGVyU3R5bGUgPSBoaWRkZW5EaXZpZGVyID8geyBkaXNwbGF5OiAnbm9uZScgfSA6IG51bGw7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzIkNCB8fCAodGVtcGxhdGVPYmplY3RfMiQ0ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBzdHlsZT1cIiwgXCI+XFxuICAgICAgICBcIiwgXCJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XCIsIFwiPjwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XCIsIFwiPlxcbiAgICAgICAgXCIsXG4gICAgICAgICAgICBcIlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBzdHlsZT1cIiwgXCI+PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSkpLCBjbHMoJ3Rvb2xiYXItZ3JvdXAnKSwgZ3JvdXBTdHlsZSwgZ3JvdXAubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgQ29tcCA9IGl0ZW0uZWwgPyBDdXN0b21Ub29sYmFySXRlbSA6IFRvb2xiYXJCdXR0b247XG4gICAgICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJDUgfHwgKHRlbXBsYXRlT2JqZWN0XzEkNSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxcIiwgXCIga2V5PVwiLCBcIiAuLi5cIiwgXCIgaXRlbT1cIiwgXCIgLz5cIl0sIFtcIjxcIiwgXCIga2V5PVwiLCBcIiAuLi5cIiwgXCIgaXRlbT1cIiwgXCIgLz5cIl0pKSwgQ29tcCwgaXRlbS5uYW1lLCBfdGhpcy5wcm9wcywgaXRlbSk7XG4gICAgICAgIH0pLCBjbHMoJ3Rvb2xiYXItZGl2aWRlcicpLCBkaXZpZGVyU3R5bGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFRvb2xiYXJHcm91cDtcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSQ1LCB0ZW1wbGF0ZU9iamVjdF8yJDQ7XG5cbnZhciBQT1BVUF9JTkRFTlQgPSA0O1xudmFyIERyb3Bkb3duVG9vbGJhckJ1dHRvbkNvbXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoRHJvcGRvd25Ub29sYmFyQnV0dG9uQ29tcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEcm9wZG93blRvb2xiYXJCdXR0b25Db21wKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYW5kbGVDbGlja0RvY3VtZW50ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gX2EudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKCFjbG9zZXN0KHRhcmdldCwgXCIuXCIgKyBjbHMoJ2Ryb3Bkb3duLXRvb2xiYXInKSkgJiZcbiAgICAgICAgICAgICAgICAhY2xvc2VzdCh0YXJnZXQsICcubW9yZScpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBzaG93RHJvcGRvd246IGZhbHNlLCBkcm9wZG93blBvczogbnVsbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93VG9vbHRpcChfdGhpcy5yZWZzLmVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7IHNob3dEcm9wZG93bjogZmFsc2UsIGRyb3Bkb3duUG9zOiBudWxsIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRHJvcGRvd25Ub29sYmFyQnV0dG9uQ29tcC5wcm90b3R5cGUuZ2V0Qm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5wcm9wcy5nZXRCb3VuZCh0aGlzLnJlZnMuZWwpO1xuICAgICAgICByZWN0LnRvcCArPSBQT1BVUF9JTkRFTlQ7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIHJlY3QpLCB7IGxlZnQ6IG51bGwsIHJpZ2h0OiAxMCB9KTtcbiAgICB9O1xuICAgIERyb3Bkb3duVG9vbGJhckJ1dHRvbkNvbXAucHJvdG90eXBlLm1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja0RvY3VtZW50KTtcbiAgICB9O1xuICAgIERyb3Bkb3duVG9vbGJhckJ1dHRvbkNvbXAucHJvdG90eXBlLnVwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNob3dEcm9wZG93biAmJiAhdGhpcy5zdGF0ZS5kcm9wZG93blBvcykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGRyb3Bkb3duUG9zOiB0aGlzLmdldEJvdW5kKCkgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyb3Bkb3duVG9vbGJhckJ1dHRvbkNvbXAucHJvdG90eXBlLmJlZm9yZURlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja0RvY3VtZW50KTtcbiAgICB9O1xuICAgIERyb3Bkb3duVG9vbGJhckJ1dHRvbkNvbXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5zdGF0ZSwgc2hvd0Ryb3Bkb3duID0gX2Euc2hvd0Ryb3Bkb3duLCBkcm9wZG93blBvcyA9IF9hLmRyb3Bkb3duUG9zO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLnByb3BzLCBkaXNhYmxlZCA9IF9iLmRpc2FibGVkLCBpdGVtID0gX2IuaXRlbSwgaXRlbXMgPSBfYi5pdGVtcywgaGlkZVRvb2x0aXAgPSBfYi5oaWRlVG9vbHRpcDtcbiAgICAgICAgdmFyIHZpc2libGVJdGVtcyA9IGl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoZHJvcGRvd25JdGVtKSB7IHJldHVybiAhZHJvcGRvd25JdGVtLmhpZGRlbjsgfSk7XG4gICAgICAgIHZhciBncm91cFN0eWxlID0gdmlzaWJsZUl0ZW1zLmxlbmd0aCA/IG51bGwgOiB7IGRpc3BsYXk6ICdub25lJyB9O1xuICAgICAgICB2YXIgZHJvcGRvd25TdHlsZSA9IHNob3dEcm9wZG93biA/IG51bGwgOiB7IGRpc3BsYXk6ICdub25lJyB9O1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8yJDMgfHwgKHRlbXBsYXRlT2JqZWN0XzIkMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XCIsIFwiPlxcbiAgICAgICAgPGJ1dHRvblxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIHR5cGU9XFxcImJ1dHRvblxcXCJcXG4gICAgICAgICAgY2xhc3M9XCIsIFwiXFxuICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICAgIG9uTW91c2VvdmVyPVwiLCBcIlxcbiAgICAgICAgICBvbk1vdXNlb3V0PVwiLCBcIlxcbiAgICAgICAgICBkaXNhYmxlZD1cIiwgXCJcXG4gICAgICAgID48L2J1dHRvbj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgc3R5bGU9XCIsIFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVwiLCBcIj5cXG4gICAgICAgIDxidXR0b25cXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICB0eXBlPVxcXCJidXR0b25cXFwiXFxuICAgICAgICAgIGNsYXNzPVwiLCBcIlxcbiAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgICBvbk1vdXNlb3Zlcj1cIiwgXCJcXG4gICAgICAgICAgb25Nb3VzZW91dD1cIiwgXCJcXG4gICAgICAgICAgZGlzYWJsZWQ9XCIsIFwiXFxuICAgICAgICA+PC9idXR0b24+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgIHN0eWxlPVwiLCBcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIFwiLFxuICAgICAgICAgICAgXCJcXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0pKSwgY2xzKCd0b29sYmFyLWdyb3VwJyksIGdyb3VwU3R5bGUsIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMuZWwgPSBlbCk7IH0sIGl0ZW0uY2xhc3NOYW1lLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZXRTdGF0ZSh7IHNob3dEcm9wZG93bjogdHJ1ZSB9KTsgfSwgdGhpcy5zaG93VG9vbHRpcCwgaGlkZVRvb2x0aXAsIGRpc2FibGVkLCBjbHMoJ2Ryb3Bkb3duLXRvb2xiYXInKSwgX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBkcm9wZG93blN0eWxlKSwgZHJvcGRvd25Qb3MpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLmRyb3Bkb3duRWwgPSBlbCk7IH0sIHZpc2libGVJdGVtcy5sZW5ndGhcbiAgICAgICAgICAgID8gdmlzaWJsZUl0ZW1zLm1hcChmdW5jdGlvbiAoZ3JvdXAsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkNCB8fCAodGVtcGxhdGVPYmplY3RfMSQ0ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICAgICAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA9XCIsIFwiXFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW5EaXZpZGVyPVwiLCBcIlxcbiAgICAgICAgICAgICAgICAgICAgLi4uXCIsIFwiXFxuICAgICAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICAgICAgXCJdLCBbXCJcXG4gICAgICAgICAgICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgICAgICAgICAgICBncm91cD1cIiwgXCJcXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbkRpdmlkZXI9XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICAuLi5cIiwgXCJcXG4gICAgICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgICAgICBcIl0pKSwgVG9vbGJhckdyb3VwLCBncm91cCwgaW5kZXggPT09IHZpc2libGVJdGVtcy5sZW5ndGggLSAxIHx8XG4gICAgICAgICAgICAgICAgICAgICgoX2EgPSB2aXNpYmxlSXRlbXNbaW5kZXggKyAxXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhpZGRlbiksIF90aGlzLnByb3BzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIERyb3Bkb3duVG9vbGJhckJ1dHRvbkNvbXA7XG59KENvbXBvbmVudCkpO1xudmFyIERyb3Bkb3duVG9vbGJhckJ1dHRvbiA9IGNvbm5lY3RIT0MoRHJvcGRvd25Ub29sYmFyQnV0dG9uQ29tcCk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSQ0LCB0ZW1wbGF0ZU9iamVjdF8yJDM7XG5cbnZhciBJTkxJTkVfUEFERElORyA9IDUwO1xudmFyIFRvb2xiYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVG9vbGJhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUb29sYmFyKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b2dnbGVUYWIgPSBmdW5jdGlvbiAoXywgYWN0aXZlVGFiKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRFbWl0dGVyID0gX3RoaXMucHJvcHMuZXZlbnRFbWl0dGVyO1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLmFjdGl2ZVRhYiAhPT0gYWN0aXZlVGFiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSBhY3RpdmVUYWIgPT09ICd3cml0ZScgPyAnY2hhbmdlUHJldmlld1RhYldyaXRlJyA6ICdjaGFuZ2VQcmV2aWV3VGFiUHJldmlldyc7XG4gICAgICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRfMSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBhY3RpdmVUYWI6IGFjdGl2ZVRhYiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0SXRlbVdpZHRoID0gZnVuY3Rpb24gKG5hbWUsIHdpZHRoKSB7XG4gICAgICAgICAgICBfdGhpcy5pdGVtV2lkdGhNYXBbbmFtZV0gPSB3aWR0aDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0UG9wdXBJbmZvID0gZnVuY3Rpb24gKHBvcHVwSW5mbykge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBzaG93UG9wdXA6IHRydWUsIHBvcHVwSW5mbzogcG9wdXBJbmZvIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vcGVuUG9wdXAgPSBmdW5jdGlvbiAocG9wdXBOYW1lLCBpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbFZhbHVlcyA9PT0gdm9pZCAwKSB7IGluaXRpYWxWYWx1ZXMgPSB7fTsgfVxuICAgICAgICAgICAgdmFyIGVsID0gX3RoaXMucmVmcy5lbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgY2xzKCd0b29sYmFyLWdyb3VwJykgKyBcIiAuXCIgKyBwb3B1cE5hbWUpO1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZ2V0VG90YWxPZmZzZXQoZWwsIGNsb3Nlc3QoZWwsIFwiLlwiICsgY2xzKCd0b29sYmFyJykpKSwgb2Zmc2V0TGVmdCA9IF9hLm9mZnNldExlZnQsIG9mZnNldFRvcCA9IF9hLm9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IGNyZWF0ZVBvcHVwSW5mbyhwb3B1cE5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IGVsLFxuICAgICAgICAgICAgICAgICAgICBwb3M6IHsgbGVmdDogb2Zmc2V0TGVmdCwgdG9wOiBlbC5vZmZzZXRIZWlnaHQgKyBvZmZzZXRUb3AgfSxcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlczogaW5pdGlhbFZhbHVlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRQb3B1cEluZm8oaW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oaWRlUG9wdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuc2hvd1BvcHVwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBzaG93UG9wdXA6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5leGVjQ29tbWFuZCA9IGZ1bmN0aW9uIChjb21tYW5kLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRFbWl0dGVyID0gX3RoaXMucHJvcHMuZXZlbnRFbWl0dGVyO1xuICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ2NvbW1hbmQnLCBjb21tYW5kLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIF90aGlzLmhpZGVQb3B1cCgpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy50YWJzID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAnd3JpdGUnLCB0ZXh0OiAnV3JpdGUnIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdwcmV2aWV3JywgdGV4dDogJ1ByZXZpZXcnIH0sXG4gICAgICAgIF07XG4gICAgICAgIF90aGlzLml0ZW1XaWR0aE1hcCA9IHt9O1xuICAgICAgICBfdGhpcy5pbml0aWFsSXRlbXMgPSBncm91cFRvb2xiYXJJdGVtcyhwcm9wcy50b29sYmFySXRlbXMgfHwgW10sIF90aGlzLmhpZGRlblNjcm9sbFN5bmMoKSk7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaXRlbXM6IF90aGlzLmluaXRpYWxJdGVtcyxcbiAgICAgICAgICAgIGRyb3Bkb3duSXRlbXM6IFtdLFxuICAgICAgICAgICAgc2hvd1BvcHVwOiBmYWxzZSxcbiAgICAgICAgICAgIHBvcHVwSW5mbzoge30sXG4gICAgICAgICAgICBhY3RpdmVUYWI6ICd3cml0ZScsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnRvb2x0aXBSZWYgPSB7IGN1cnJlbnQ6IG51bGwgfTtcbiAgICAgICAgX3RoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgaW5kZXgoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlUmVzaXplKCk7IH0pO1xuICAgICAgICBfdGhpcy5hZGRFdmVudCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRvb2xiYXIucHJvdG90eXBlLmluc2VydFRvb2xiYXJJdGVtID0gZnVuY3Rpb24gKGluZGV4TGlzdCwgaXRlbSkge1xuICAgICAgICB2YXIgZ3JvdXBJbmRleCA9IGluZGV4TGlzdC5ncm91cEluZGV4LCBpdGVtSW5kZXggPSBpbmRleExpc3QuaXRlbUluZGV4O1xuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmluaXRpYWxJdGVtc1tncm91cEluZGV4XTtcbiAgICAgICAgaXRlbSA9IGNyZWF0ZVRvb2xiYXJJdGVtSW5mbyhpdGVtKTtcbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBncm91cC5zcGxpY2UoaXRlbUluZGV4LCAwLCBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbEl0ZW1zLnB1c2goW2l0ZW1dKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFN0YXRlKHRoaXMuY2xhc3NpZnlUb29sYmFySXRlbXMoKSk7XG4gICAgfTtcbiAgICBUb29sYmFyLnByb3RvdHlwZS5yZW1vdmVUb29sYmFySXRlbSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGZvckVhY2hBcnJheV8xKHRoaXMuaW5pdGlhbEl0ZW1zLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yRWFjaEFycmF5XzEoZ3JvdXAsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBncm91cC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShfdGhpcy5jbGFzc2lmeVRvb2xiYXJJdGVtcygpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICFmb3VuZDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUb29sYmFyLnByb3RvdHlwZS5hZGRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV2ZW50RW1pdHRlciA9IHRoaXMucHJvcHMuZXZlbnRFbWl0dGVyO1xuICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZSA9IHRocm90dGxlXzEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gcmVzZXQgdG9vbGJhciBpdGVtcyB0byByZS1sYXlvdXQgdG9vbGJhciBpdGVtcyB3aXRoIGVhY2ggY2xpZW50V2lkdGhcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgaXRlbXM6IF90aGlzLmluaXRpYWxJdGVtcywgZHJvcGRvd25JdGVtczogW10gfSk7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShfdGhpcy5jbGFzc2lmeVRvb2xiYXJJdGVtcygpKTtcbiAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgZXZlbnRFbWl0dGVyLmxpc3Rlbignb3BlblBvcHVwJywgdGhpcy5vcGVuUG9wdXApO1xuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUuYXBwZW5kVG9vbHRpcFRvUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRvb2x0aXAgPSBcIjxkaXYgY2xhc3M9XFxcIlwiICsgY2xzKCd0b29sdGlwJykgKyBcIlxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJhcnJvd1xcXCI+PC9kaXY+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwidGV4dFxcXCI+PC9zcGFuPlxcbiAgICAgIDwvZGl2PlwiO1xuICAgICAgICB0aGlzLnRvb2x0aXBSZWYuY3VycmVudCA9IGNyZWF0ZUVsZW1lbnRXaXRoKHRvb2x0aXAsIHRoaXMucmVmcy5lbCk7XG4gICAgfTtcbiAgICBUb29sYmFyLnByb3RvdHlwZS5oaWRkZW5TY3JvbGxTeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5lZGl0b3JUeXBlID09PSAnd3lzaXd5ZycgfHwgdGhpcy5wcm9wcy5wcmV2aWV3U3R5bGUgPT09ICd0YWInO1xuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUubW92ZVByZXZJdGVtVG9Ecm9wZG93blRvb2xiYXIgPSBmdW5jdGlvbiAoaXRlbUluZGV4LCBpdGVtcywgZ3JvdXAsIGRyb3Bkb3duR3JvdXApIHtcbiAgICAgICAgdmFyIG1vdmVJdGVtID0gZnVuY3Rpb24gKHRhcmdldEdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRhcmdldEdyb3VwLnBvcCgpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBkcm9wZG93bkdyb3VwLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpdGVtSW5kZXggPiAxKSB7XG4gICAgICAgICAgICBtb3ZlSXRlbShncm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldkdyb3VwID0gbGFzdCQxKGl0ZW1zKTtcbiAgICAgICAgICAgIGlmIChwcmV2R3JvdXApIHtcbiAgICAgICAgICAgICAgICBtb3ZlSXRlbShwcmV2R3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sYmFyLnByb3RvdHlwZS5jbGFzc2lmeVRvb2xiYXJJdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRvdGFsV2lkdGggPSAwO1xuICAgICAgICB2YXIgY2xpZW50V2lkdGggPSB0aGlzLnJlZnMuZWwuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBkaXZpZGVyID0gdGhpcy5yZWZzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBjbHMoJ3Rvb2xiYXItZGl2aWRlcicpKTtcbiAgICAgICAgdmFyIGRpdmlkZXJXaWR0aCA9IGRpdmlkZXIgPyBnZXRPdXRlcldpZHRoKGRpdmlkZXIpIDogMDtcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgIHZhciBkcm9wZG93bkl0ZW1zID0gW107XG4gICAgICAgIHZhciBtb3ZlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXRpYWxJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpbml0aWFsR3JvdXAsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IFtdO1xuICAgICAgICAgICAgdmFyIGRyb3Bkb3duR3JvdXAgPSBbXTtcbiAgICAgICAgICAgIGluaXRpYWxHcm91cC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpdGVtSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsV2lkdGggKz0gX3RoaXMuaXRlbVdpZHRoTWFwW2l0ZW0ubmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbFdpZHRoID4gY2xpZW50V2lkdGggLSBJTkxJTkVfUEFERElORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIG1vdmUgdGhlIHByZXYgaXRlbSB0byBkcm9wZG93biB0b29sYmFyIGZvciBwbGFjaW5nIHRoZSBtb3JlIGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1vdmVQcmV2SXRlbVRvRHJvcGRvd25Ub29sYmFyKGl0ZW1JbmRleCwgaXRlbXMsIGdyb3VwLCBkcm9wZG93bkdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wZG93bkdyb3VwLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZ3JvdXAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2V0R3JvdXBTdGF0ZShncm91cCk7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChncm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHJvcGRvd25Hcm91cC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzZXRHcm91cFN0YXRlKGRyb3Bkb3duR3JvdXApO1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duSXRlbXMucHVzaChkcm9wZG93bkdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCBkaXZpZGVyIHdpZHRoXG4gICAgICAgICAgICBpZiAoZ3JvdXBJbmRleCA8IF90aGlzLnN0YXRlLml0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0b3RhbFdpZHRoICs9IGRpdmlkZXJXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGl0ZW1zOiBpdGVtcywgZHJvcGRvd25JdGVtczogZHJvcGRvd25JdGVtcyB9O1xuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUubW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMucHJldmlld1N0eWxlID09PSAndGFiJykge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5ldmVudEVtaXR0ZXIuZW1pdCgnY2hhbmdlUHJldmlld1RhYldyaXRlJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xhc3NpZnkgdG9vbGJhciBhbmQgZHJvcGRvd24gdG9vbGJhciBhZnRlciBET00gaGFzIGJlZW4gcmVuZGVyZWRcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmNsYXNzaWZ5VG9vbGJhckl0ZW1zKCkpO1xuICAgICAgICB0aGlzLmFwcGVuZFRvb2x0aXBUb1Jvb3QoKTtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMucmVmcy5lbCk7XG4gICAgfTtcbiAgICBUb29sYmFyLnByb3RvdHlwZS51cGRhdGVkID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBlZGl0b3JUeXBlID0gX2EuZWRpdG9yVHlwZSwgcHJldmlld1N0eWxlID0gX2EucHJldmlld1N0eWxlLCBldmVudEVtaXR0ZXIgPSBfYS5ldmVudEVtaXR0ZXI7XG4gICAgICAgIHZhciBjaGFuZ2VkU3R5bGUgPSBwcmV2aWV3U3R5bGUgIT09IHByZXZQcm9wcy5wcmV2aWV3U3R5bGU7XG4gICAgICAgIHZhciBjaGFuZ2VkVHlwZSA9IGVkaXRvclR5cGUgIT09IHByZXZQcm9wcy5lZGl0b3JUeXBlO1xuICAgICAgICBpZiAoY2hhbmdlZFN0eWxlIHx8IGNoYW5nZWRUeXBlKSB7XG4gICAgICAgICAgICAvLyBzaG93IG9yIGhpZGUgc2Nyb2xsU3luYyBidXR0b25cbiAgICAgICAgICAgIHRvZ2dsZVNjcm9sbFN5bmModGhpcy5pbml0aWFsSXRlbXMsIHRoaXMuaGlkZGVuU2Nyb2xsU3luYygpKTtcbiAgICAgICAgICAgIHZhciBuZXdTdGF0ZSA9IHRoaXMuY2xhc3NpZnlUb29sYmFySXRlbXMoKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkU3R5bGUgfHwgKHByZXZpZXdTdHlsZSA9PT0gJ3RhYicgJiYgZWRpdG9yVHlwZSA9PT0gJ21hcmtkb3duJykpIHtcbiAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIuZW1pdCgnY2hhbmdlUHJldmlld1RhYldyaXRlJyk7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUuYWN0aXZlVGFiID0gJ3dyaXRlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sYmFyLnByb3RvdHlwZS5iZWZvcmVEZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVSZXNpemUpO1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgcmVtb3ZlTm9kZSQxKHRoaXMudG9vbHRpcFJlZi5jdXJyZW50KTtcbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgcHJldmlld1N0eWxlID0gX2EucHJldmlld1N0eWxlLCBldmVudEVtaXR0ZXIgPSBfYS5ldmVudEVtaXR0ZXIsIGVkaXRvclR5cGUgPSBfYS5lZGl0b3JUeXBlO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLnN0YXRlLCBwb3B1cEluZm8gPSBfYi5wb3B1cEluZm8sIHNob3dQb3B1cCA9IF9iLnNob3dQb3B1cCwgYWN0aXZlVGFiID0gX2IuYWN0aXZlVGFiLCBpdGVtcyA9IF9iLml0ZW1zLCBkcm9wZG93bkl0ZW1zID0gX2IuZHJvcGRvd25JdGVtcztcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgICAgZXZlbnRFbWl0dGVyOiBldmVudEVtaXR0ZXIsXG4gICAgICAgICAgICB0b29sdGlwUmVmOiB0aGlzLnRvb2x0aXBSZWYsXG4gICAgICAgICAgICBkaXNhYmxlZDogZWRpdG9yVHlwZSA9PT0gJ21hcmtkb3duJyAmJiBwcmV2aWV3U3R5bGUgPT09ICd0YWInICYmIGFjdGl2ZVRhYiA9PT0gJ3ByZXZpZXcnLFxuICAgICAgICAgICAgZXhlY0NvbW1hbmQ6IHRoaXMuZXhlY0NvbW1hbmQsXG4gICAgICAgICAgICBzZXRQb3B1cEluZm86IHRoaXMuc2V0UG9wdXBJbmZvLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgdG9vbGJhclN0eWxlID0gcHJldmlld1N0eWxlID09PSAndGFiJyA/IHsgYm9yZGVyVG9wTGVmdFJhZGl1czogMCB9IDogbnVsbDtcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMiQyIHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICBzdHlsZT1cXFwiZGlzcGxheTogXCIsIFwiXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICA8XCIsIFwiIHRhYnM9XCIsIFwiIGFjdGl2ZVRhYj1cIiwgXCIgb25DbGljaz1cIiwgXCIgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIHN0eWxlPVwiLCBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICAgIGl0ZW09XCIsIFwiXFxuICAgICAgICAgICAgaXRlbXM9XCIsIFwiXFxuICAgICAgICAgICAgLi4uXCIsIFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgaW5mbz1cIiwgXCJcXG4gICAgICAgICAgc2hvdz1cIiwgXCJcXG4gICAgICAgICAgZXZlbnRFbWl0dGVyPVwiLCBcIlxcbiAgICAgICAgICBoaWRlUG9wdXA9XCIsIFwiXFxuICAgICAgICAgIGV4ZWNDb21tYW5kPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICBzdHlsZT1cXFwiZGlzcGxheTogXCIsXG4gICAgICAgICAgICBcIlxcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgPFwiLCBcIiB0YWJzPVwiLCBcIiBhY3RpdmVUYWI9XCIsIFwiIG9uQ2xpY2s9XCIsIFwiIC8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICBzdHlsZT1cIiwgXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgXCIsXG4gICAgICAgICAgICBcIlxcbiAgICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgICAgaXRlbT1cIiwgXCJcXG4gICAgICAgICAgICBpdGVtcz1cIiwgXCJcXG4gICAgICAgICAgICAuLi5cIiwgXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICBpbmZvPVwiLCBcIlxcbiAgICAgICAgICBzaG93PVwiLCBcIlxcbiAgICAgICAgICBldmVudEVtaXR0ZXI9XCIsIFwiXFxuICAgICAgICAgIGhpZGVQb3B1cD1cIiwgXCJcXG4gICAgICAgICAgZXhlY0NvbW1hbmQ9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0pKSwgY2xzKCd0b29sYmFyJyksIGNscygnbWQtdGFiLWNvbnRhaW5lcicpLCBlZGl0b3JUeXBlID09PSAnd3lzaXd5ZycgfHwgcHJldmlld1N0eWxlID09PSAndmVydGljYWwnXG4gICAgICAgICAgICA/ICdub25lJ1xuICAgICAgICAgICAgOiAnYmxvY2snLCBUYWJzLCB0aGlzLnRhYnMsIGFjdGl2ZVRhYiwgdGhpcy50b2dnbGVUYWIsIGNscygnZGVmYXVsdFVJLXRvb2xiYXInKSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5lbCA9IGVsKTsgfSwgdG9vbGJhclN0eWxlLCBpdGVtcy5tYXAoZnVuY3Rpb24gKGdyb3VwLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSQzIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgICAgICAgZ3JvdXA9XCIsIFwiXFxuICAgICAgICAgICAgICAgIGhpZGRlbkRpdmlkZXI9XCIsIFwiXFxuICAgICAgICAgICAgICAgIHNldEl0ZW1XaWR0aD1cIiwgXCJcXG4gICAgICAgICAgICAgICAgLi4uXCIsIFwiXFxuICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgIFwiXSwgW1wiXFxuICAgICAgICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgICAgICAgIGdyb3VwPVwiLCBcIlxcbiAgICAgICAgICAgICAgICBoaWRkZW5EaXZpZGVyPVwiLCBcIlxcbiAgICAgICAgICAgICAgICBzZXRJdGVtV2lkdGg9XCIsIFwiXFxuICAgICAgICAgICAgICAgIC4uLlwiLCBcIlxcbiAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICBcIl0pKSwgVG9vbGJhckdyb3VwLCBncm91cCwgaW5kZXggPT09IGl0ZW1zLmxlbmd0aCAtIDEgfHwgKChfYSA9IGl0ZW1zW2luZGV4ICsgMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oaWRkZW4pLCBfdGhpcy5zZXRJdGVtV2lkdGgsIHByb3BzKTtcbiAgICAgICAgfSksIERyb3Bkb3duVG9vbGJhckJ1dHRvbiwgY3JlYXRlVG9vbGJhckl0ZW1JbmZvKCdtb3JlJyksIGRyb3Bkb3duSXRlbXMsIHByb3BzLCBQb3B1cCwgcG9wdXBJbmZvLCBzaG93UG9wdXAsIGV2ZW50RW1pdHRlciwgdGhpcy5oaWRlUG9wdXAsIHRoaXMuZXhlY0NvbW1hbmQpO1xuICAgIH07XG4gICAgcmV0dXJuIFRvb2xiYXI7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkMywgdGVtcGxhdGVPYmplY3RfMiQyO1xuXG52YXIgQ29udGV4dE1lbnUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQ29udGV4dE1lbnUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29udGV4dE1lbnUocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhhbmRsZUNsaWNrRG9jdW1lbnQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmICghY2xvc2VzdChldi50YXJnZXQsIFwiLlwiICsgY2xzKCdjb250ZXh0LW1lbnUnKSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHBvczogbnVsbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBwb3M6IG51bGwsXG4gICAgICAgICAgICBtZW51R3JvdXBzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYWRkRXZlbnQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb250ZXh0TWVudS5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucHJvcHMuZXZlbnRFbWl0dGVyLmxpc3RlbignY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBfYS5wb3MsIG1lbnVHcm91cHMgPSBfYS5tZW51R3JvdXBzO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBwb3M6IHBvcywgbWVudUdyb3VwczogbWVudUdyb3VwcyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250ZXh0TWVudS5wcm90b3R5cGUubW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrRG9jdW1lbnQpO1xuICAgIH07XG4gICAgQ29udGV4dE1lbnUucHJvdG90eXBlLmJlZm9yZURlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja0RvY3VtZW50KTtcbiAgICB9O1xuICAgIENvbnRleHRNZW51LnByb3RvdHlwZS5nZXRNZW51R3JvdXBFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5zdGF0ZSwgcG9zID0gX2EucG9zLCBtZW51R3JvdXBzID0gX2EubWVudUdyb3VwcztcbiAgICAgICAgcmV0dXJuIHBvc1xuICAgICAgICAgICAgPyBtZW51R3JvdXBzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBncm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBtZW51SXRlbSA9IFtdO1xuICAgICAgICAgICAgICAgIGdyb3VwLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IF9hLmxhYmVsLCBfYiA9IF9hLmNsYXNzTmFtZSwgY2xhc3NOYW1lID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2IsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIG9uQ2xpY2sgPSBfYS5vbkNsaWNrO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgcG9zOiBudWxsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBtZW51SXRlbS5wdXNoKGh0bWwodGVtcGxhdGVPYmplY3RfMSQyIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgICAgICAgICAgPGxpXFxuICAgICAgICAgICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgICAgICAgICAgICBjbGFzcz1cXFwibWVudS1pdGVtXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgICAgIGFyaWEtcm9sZT1cXFwibWVudWl0ZW1cXFwiXFxuICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cIiwgXCI8L3NwYW4+XFxuICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICBcIl0sIFtcIlxcbiAgICAgICAgICAgICAgICA8bGlcXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJtZW51LWl0ZW1cIiwgXCJcXFwiXFxuICAgICAgICAgICAgICAgICAgYXJpYS1yb2xlPVxcXCJtZW51aXRlbVxcXCJcXG4gICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJcIiwgXCJcXFwiPlwiLCBcIjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgIFwiXSkpLCBoYW5kbGVDbGljaywgZGlzYWJsZWQgPyAnIGRpc2FibGVkJyA6ICcnLCBjbGFzc05hbWUsIGxhYmVsKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goaHRtbCh0ZW1wbGF0ZU9iamVjdF8yJDEgfHwgKHRlbXBsYXRlT2JqZWN0XzIkMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjx1bCBjbGFzcz1cXFwibWVudS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgICA8L3VsPlwiXSwgW1wiPHVsIGNsYXNzPVxcXCJtZW51LWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICAgIDwvdWw+XCJdKSksIG1lbnVJdGVtKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIFtdKVxuICAgICAgICAgICAgOiBbXTtcbiAgICB9O1xuICAgIENvbnRleHRNZW51LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IF9fYXNzaWduJDEoeyBkaXNwbGF5OiB0aGlzLnN0YXRlLnBvcyA/ICdibG9jaycgOiAnbm9uZScgfSwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8zIHx8ICh0ZW1wbGF0ZU9iamVjdF8zID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBzdHlsZT1cIiwgXCIgYXJpYS1yb2xlPVxcXCJtZW51XFxcIj5cXG4gICAgICBcIiwgXCJcXG4gICAgPC9kaXY+XCJdLCBbXCI8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVwiLCBcIiBhcmlhLXJvbGU9XFxcIm1lbnVcXFwiPlxcbiAgICAgIFwiLCBcIlxcbiAgICA8L2Rpdj5cIl0pKSwgY2xzKCdjb250ZXh0LW1lbnUnKSwgc3R5bGUsIHRoaXMuZ2V0TWVudUdyb3VwRWxlbWVudHMoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29udGV4dE1lbnU7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkMiwgdGVtcGxhdGVPYmplY3RfMiQxLCB0ZW1wbGF0ZU9iamVjdF8zO1xuXG52YXIgTGF5b3V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKExheW91dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYXlvdXQocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNoYW5nZU1vZGUgPSBmdW5jdGlvbiAoZWRpdG9yVHlwZSkge1xuICAgICAgICAgICAgaWYgKGVkaXRvclR5cGUgIT09IF90aGlzLnN0YXRlLmVkaXRvclR5cGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGVkaXRvclR5cGU6IGVkaXRvclR5cGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNoYW5nZVByZXZpZXdTdHlsZSA9IGZ1bmN0aW9uIChwcmV2aWV3U3R5bGUpIHtcbiAgICAgICAgICAgIGlmIChwcmV2aWV3U3R5bGUgIT09IF90aGlzLnN0YXRlLnByZXZpZXdTdHlsZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgcHJldmlld1N0eWxlOiBwcmV2aWV3U3R5bGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGhpZGU6IHRydWUgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGhpZGU6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZWRpdG9yVHlwZSA9IHByb3BzLmVkaXRvclR5cGUsIHByZXZpZXdTdHlsZSA9IHByb3BzLnByZXZpZXdTdHlsZTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBlZGl0b3JUeXBlOiBlZGl0b3JUeXBlLFxuICAgICAgICAgICAgcHJldmlld1N0eWxlOiBwcmV2aWV3U3R5bGUsXG4gICAgICAgICAgICBoaWRlOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYWRkRXZlbnQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMYXlvdXQucHJvdG90eXBlLm1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMuc2xvdHMsIHd3RWRpdG9yID0gX2Eud3dFZGl0b3IsIG1kRWRpdG9yID0gX2EubWRFZGl0b3IsIG1kUHJldmlldyA9IF9hLm1kUHJldmlldztcbiAgICAgICAgdGhpcy5yZWZzLnd3Q29udGFpbmVyLmFwcGVuZENoaWxkKHd3RWRpdG9yKTtcbiAgICAgICAgdGhpcy5yZWZzLm1kQ29udGFpbmVyLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJiZWdpbicsIG1kRWRpdG9yKTtcbiAgICAgICAgdGhpcy5yZWZzLm1kQ29udGFpbmVyLmFwcGVuZENoaWxkKG1kUHJldmlldyk7XG4gICAgfTtcbiAgICBMYXlvdXQucHJvdG90eXBlLmluc2VydFRvb2xiYXJJdGVtID0gZnVuY3Rpb24gKGluZGV4TGlzdCwgaXRlbSkge1xuICAgICAgICB0aGlzLnRvb2xiYXIuaW5zZXJ0VG9vbGJhckl0ZW0oaW5kZXhMaXN0LCBpdGVtKTtcbiAgICB9O1xuICAgIExheW91dC5wcm90b3R5cGUucmVtb3ZlVG9vbGJhckl0ZW0gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLnRvb2xiYXIucmVtb3ZlVG9vbGJhckl0ZW0obmFtZSk7XG4gICAgfTtcbiAgICBMYXlvdXQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyLCBoaWRlTW9kZVN3aXRjaCA9IF9hLmhpZGVNb2RlU3dpdGNoLCB0b29sYmFySXRlbXMgPSBfYS50b29sYmFySXRlbXMsIHRoZW1lID0gX2EudGhlbWU7XG4gICAgICAgIHZhciBfYiA9IHRoaXMuc3RhdGUsIGhpZGUgPSBfYi5oaWRlLCBwcmV2aWV3U3R5bGUgPSBfYi5wcmV2aWV3U3R5bGUsIGVkaXRvclR5cGUgPSBfYi5lZGl0b3JUeXBlO1xuICAgICAgICB2YXIgZGlzcGxheUNsYXNzTmFtZSA9IGhpZGUgPyAnIGhpZGRlbicgOiAnJztcbiAgICAgICAgdmFyIGVkaXRvclR5cGVDbGFzc05hbWUgPSBjbHMoZWRpdG9yVHlwZSA9PT0gJ21hcmtkb3duJyA/ICdtZC1tb2RlJyA6ICd3dy1tb2RlJyk7XG4gICAgICAgIHZhciBwcmV2aWV3Q2xhc3NOYW1lID0gY2xzKCdtZCcpICsgXCItXCIgKyBwcmV2aWV3U3R5bGUgKyBcIi1zdHlsZVwiO1xuICAgICAgICB2YXIgdGhlbWVDbGFzc05hbWUgPSBjbHMoW3RoZW1lICE9PSAnbGlnaHQnLCB0aGVtZSArIFwiIFwiXSk7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzIgfHwgKHRlbXBsYXRlT2JqZWN0XzIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8ZGl2XFxuICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXCIsIFwiXCIsIFwiXFxcIlxcbiAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgID5cXG4gICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICBldmVudEVtaXR0ZXI9XCIsIFwiXFxuICAgICAgICAgIHByZXZpZXdTdHlsZT1cIiwgXCJcXG4gICAgICAgICAgdG9vbGJhckl0ZW1zPVwiLCBcIlxcbiAgICAgICAgICBlZGl0b3JUeXBlPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIiBcIiwgXCJcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiIFwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgICAgLz5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIFwiLCBcIlxcbiAgICAgICAgPFwiLCBcIiBldmVudEVtaXR0ZXI9XCIsIFwiIC8+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlwiLCBcIlwiLCBcIlxcXCJcXG4gICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICA+XFxuICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgZXZlbnRFbWl0dGVyPVwiLCBcIlxcbiAgICAgICAgICBwcmV2aWV3U3R5bGU9XCIsIFwiXFxuICAgICAgICAgIHRvb2xiYXJJdGVtcz1cIiwgXCJcXG4gICAgICAgICAgZWRpdG9yVHlwZT1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCIgXCIsIFwiXFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIiBcIiwgXCJcXFwiXFxuICAgICAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICBcIixcbiAgICAgICAgICAgIFwiXFxuICAgICAgICA8XCIsIFwiIGV2ZW50RW1pdHRlcj1cIiwgXCIgLz5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdKSksIHRoZW1lQ2xhc3NOYW1lLCBjbHMoJ2RlZmF1bHRVSScpLCBkaXNwbGF5Q2xhc3NOYW1lLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLmVsID0gZWwpOyB9LCBUb29sYmFyLCBmdW5jdGlvbiAodG9vbGJhcikgeyByZXR1cm4gKF90aGlzLnRvb2xiYXIgPSB0b29sYmFyKTsgfSwgZXZlbnRFbWl0dGVyLCBwcmV2aWV3U3R5bGUsIHRvb2xiYXJJdGVtcywgZWRpdG9yVHlwZSwgY2xzKCdtYWluJyksIGVkaXRvclR5cGVDbGFzc05hbWUsIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMuZWRpdG9yU2VjdGlvbiA9IGVsKTsgfSwgY2xzKCdtYWluLWNvbnRhaW5lcicpLCBjbHMoJ21kLWNvbnRhaW5lcicpLCBwcmV2aWV3Q2xhc3NOYW1lLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLm1kQ29udGFpbmVyID0gZWwpOyB9LCBjbHMoJ21kLXNwbGl0dGVyJyksIGNscygnd3ctY29udGFpbmVyJyksIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMud3dDb250YWluZXIgPSBlbCk7IH0sICFoaWRlTW9kZVN3aXRjaCAmJiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkMSB8fCAodGVtcGxhdGVPYmplY3RfMSQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiPFwiLCBcIiBldmVudEVtaXR0ZXI9XCIsIFwiIGVkaXRvclR5cGU9XCIsIFwiIC8+XCJdLCBbXCI8XCIsIFwiIGV2ZW50RW1pdHRlcj1cIiwgXCIgZWRpdG9yVHlwZT1cIiwgXCIgLz5cIl0pKSwgU3dpdGNoLCBldmVudEVtaXR0ZXIsIGVkaXRvclR5cGUpLCBDb250ZXh0TWVudSwgZXZlbnRFbWl0dGVyKTtcbiAgICB9O1xuICAgIExheW91dC5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldmVudEVtaXR0ZXIgPSB0aGlzLnByb3BzLmV2ZW50RW1pdHRlcjtcbiAgICAgICAgZXZlbnRFbWl0dGVyLmxpc3RlbignaGlkZScsIHRoaXMuaGlkZSk7XG4gICAgICAgIGV2ZW50RW1pdHRlci5saXN0ZW4oJ3Nob3cnLCB0aGlzLnNob3cpO1xuICAgICAgICBldmVudEVtaXR0ZXIubGlzdGVuKCdjaGFuZ2VNb2RlJywgdGhpcy5jaGFuZ2VNb2RlKTtcbiAgICAgICAgZXZlbnRFbWl0dGVyLmxpc3RlbignY2hhbmdlUHJldmlld1N0eWxlJywgdGhpcy5jaGFuZ2VQcmV2aWV3U3R5bGUpO1xuICAgIH07XG4gICAgcmV0dXJuIExheW91dDtcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSQxLCB0ZW1wbGF0ZU9iamVjdF8yO1xuXG4vKipcbiAqIFRvYXN0VUkgRWRpdG9yXG4gKiBAZXh0ZW5kcyBUb2FzdFVJRWRpdG9yQ29yZVxuICovXG52YXIgVG9hc3RVSUVkaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUb2FzdFVJRWRpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRvYXN0VUlFZGl0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIHZhciBsYXlvdXRDb21wO1xuICAgICAgICB2YXIgZGVzdHJveSA9IHJlbmRlcihfdGhpcy5vcHRpb25zLmVsLCBodG1sKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICBldmVudEVtaXR0ZXI9XCIsIFwiXFxuICAgICAgICAgIHNsb3RzPVwiLCBcIlxcbiAgICAgICAgICBoaWRlTW9kZVN3aXRjaD1cIiwgXCJcXG4gICAgICAgICAgdG9vbGJhckl0ZW1zPVwiLCBcIlxcbiAgICAgICAgICBwcmV2aWV3U3R5bGU9XCIsIFwiXFxuICAgICAgICAgIGVkaXRvclR5cGU9XCIsIFwiXFxuICAgICAgICAgIHRoZW1lPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICBcIl0sIFtcIlxcbiAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIGV2ZW50RW1pdHRlcj1cIiwgXCJcXG4gICAgICAgICAgc2xvdHM9XCIsIFwiXFxuICAgICAgICAgIGhpZGVNb2RlU3dpdGNoPVwiLCBcIlxcbiAgICAgICAgICB0b29sYmFySXRlbXM9XCIsIFwiXFxuICAgICAgICAgIHByZXZpZXdTdHlsZT1cIiwgXCJcXG4gICAgICAgICAgZWRpdG9yVHlwZT1cIiwgXCJcXG4gICAgICAgICAgdGhlbWU9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgIFwiXSkpLCBMYXlvdXQsIGZ1bmN0aW9uIChsYXlvdXQpIHsgcmV0dXJuIChsYXlvdXRDb21wID0gbGF5b3V0KTsgfSwgX3RoaXMuZXZlbnRFbWl0dGVyLCBfdGhpcy5nZXRFZGl0b3JFbGVtZW50cygpLCBfdGhpcy5vcHRpb25zLmhpZGVNb2RlU3dpdGNoLCBfdGhpcy5vcHRpb25zLnRvb2xiYXJJdGVtcywgX3RoaXMub3B0aW9ucy5wcmV2aWV3U3R5bGUsIF90aGlzLm9wdGlvbnMuaW5pdGlhbEVkaXRUeXBlLCBfdGhpcy5vcHRpb25zLnRoZW1lKSk7XG4gICAgICAgIF90aGlzLnNldE1pbkhlaWdodChfdGhpcy5vcHRpb25zLm1pbkhlaWdodCk7XG4gICAgICAgIF90aGlzLnNldEhlaWdodChfdGhpcy5vcHRpb25zLmhlaWdodCk7XG4gICAgICAgIF90aGlzLmRlZmF1bHRVSSA9IHtcbiAgICAgICAgICAgIGluc2VydFRvb2xiYXJJdGVtOiBsYXlvdXRDb21wLmluc2VydFRvb2xiYXJJdGVtLmJpbmQobGF5b3V0Q29tcCksXG4gICAgICAgICAgICByZW1vdmVUb29sYmFySXRlbTogbGF5b3V0Q29tcC5yZW1vdmVUb29sYmFySXRlbS5iaW5kKGxheW91dENvbXApLFxuICAgICAgICAgICAgZGVzdHJveTogZGVzdHJveSxcbiAgICAgICAgfTtcbiAgICAgICAgKF9hID0gX3RoaXMucGx1Z2luSW5mby50b29sYmFySXRlbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKGZ1bmN0aW9uICh0b29sYmFySXRlbSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwSW5kZXggPSB0b29sYmFySXRlbS5ncm91cEluZGV4LCBpdGVtSW5kZXggPSB0b29sYmFySXRlbS5pdGVtSW5kZXgsIGl0ZW0gPSB0b29sYmFySXRlbS5pdGVtO1xuICAgICAgICAgICAgX3RoaXMuZGVmYXVsdFVJLmluc2VydFRvb2xiYXJJdGVtKHsgZ3JvdXBJbmRleDogZ3JvdXBJbmRleCwgaXRlbUluZGV4OiBpdGVtSW5kZXggfSwgaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnbG9hZFVJJywgX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZhY3RvcnkgbWV0aG9kIGZvciBFZGl0b3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPcHRpb24gZm9yIGluaXRpYWxpemUgVFVJRWRpdG9yXG4gICAgICogQHJldHVybnMge29iamVjdH0gVG9hc3RVSUVkaXRvciBvciBUb2FzdFVJRWRpdG9yVmlld2VyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvci5mYWN0b3J5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMudmlld2VyID8gbmV3IFRvYXN0VUlFZGl0b3JWaWV3ZXIob3B0aW9ucykgOiBuZXcgVG9hc3RVSUVkaXRvcihvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGFkZCB0b29sYmFyIGl0ZW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5kZXhJbmZvIGdyb3VwIGluZGV4IGFuZCBpdGVtIGluZGV4IG9mIHRoZSB0b29sYmFyIGl0ZW1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGl0ZW0gdG9vbGJhciBpdGVtXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvci5wcm90b3R5cGUuaW5zZXJ0VG9vbGJhckl0ZW0gPSBmdW5jdGlvbiAoaW5kZXhJbmZvLCBpdGVtKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdFVJLmluc2VydFRvb2xiYXJJdGVtKGluZGV4SW5mbywgaXRlbSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdG9vbGJhciBpdGVtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGl0ZW1OYW1lIHRvb2xiYXIgaXRlbSBuYW1lXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvci5wcm90b3R5cGUucmVtb3ZlVG9vbGJhckl0ZW0gPSBmdW5jdGlvbiAoaXRlbU5hbWUpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0VUkucmVtb3ZlVG9vbGJhckl0ZW0oaXRlbU5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBUVUlFZGl0b3IgZnJvbSBkb2N1bWVudFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmRlZmF1bHRVSS5kZXN0cm95KCk7XG4gICAgfTtcbiAgICByZXR1cm4gVG9hc3RVSUVkaXRvcjtcbn0oVG9hc3RVSUVkaXRvckNvcmUpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSTE4TiBmb3IgRW5nbGlzaFxuICogQGF1dGhvciBOSE4gQ2xvdWQgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblRvYXN0VUlFZGl0b3JDb3JlLnNldExhbmd1YWdlKFsnZW4nLCAnZW4tVVMnXSwge1xuICAgIE1hcmtkb3duOiAnTWFya2Rvd24nLFxuICAgIFdZU0lXWUc6ICdXWVNJV1lHJyxcbiAgICBXcml0ZTogJ1dyaXRlJyxcbiAgICBQcmV2aWV3OiAnUHJldmlldycsXG4gICAgSGVhZGluZ3M6ICdIZWFkaW5ncycsXG4gICAgUGFyYWdyYXBoOiAnUGFyYWdyYXBoJyxcbiAgICBCb2xkOiAnQm9sZCcsXG4gICAgSXRhbGljOiAnSXRhbGljJyxcbiAgICBTdHJpa2U6ICdTdHJpa2UnLFxuICAgIENvZGU6ICdJbmxpbmUgY29kZScsXG4gICAgTGluZTogJ0xpbmUnLFxuICAgIEJsb2NrcXVvdGU6ICdCbG9ja3F1b3RlJyxcbiAgICAnVW5vcmRlcmVkIGxpc3QnOiAnVW5vcmRlcmVkIGxpc3QnLFxuICAgICdPcmRlcmVkIGxpc3QnOiAnT3JkZXJlZCBsaXN0JyxcbiAgICBUYXNrOiAnVGFzaycsXG4gICAgSW5kZW50OiAnSW5kZW50JyxcbiAgICBPdXRkZW50OiAnT3V0ZGVudCcsXG4gICAgJ0luc2VydCBsaW5rJzogJ0luc2VydCBsaW5rJyxcbiAgICAnSW5zZXJ0IENvZGVCbG9jayc6ICdJbnNlcnQgY29kZUJsb2NrJyxcbiAgICAnSW5zZXJ0IHRhYmxlJzogJ0luc2VydCB0YWJsZScsXG4gICAgJ0luc2VydCBpbWFnZSc6ICdJbnNlcnQgaW1hZ2UnLFxuICAgIEhlYWRpbmc6ICdIZWFkaW5nJyxcbiAgICAnSW1hZ2UgVVJMJzogJ0ltYWdlIFVSTCcsXG4gICAgJ1NlbGVjdCBpbWFnZSBmaWxlJzogJ1NlbGVjdCBpbWFnZSBmaWxlJyxcbiAgICAnQ2hvb3NlIGEgZmlsZSc6ICdDaG9vc2UgYSBmaWxlJyxcbiAgICAnTm8gZmlsZSc6ICdObyBmaWxlJyxcbiAgICBEZXNjcmlwdGlvbjogJ0Rlc2NyaXB0aW9uJyxcbiAgICBPSzogJ09LJyxcbiAgICBNb3JlOiAnTW9yZScsXG4gICAgQ2FuY2VsOiAnQ2FuY2VsJyxcbiAgICBGaWxlOiAnRmlsZScsXG4gICAgVVJMOiAnVVJMJyxcbiAgICAnTGluayB0ZXh0JzogJ0xpbmsgdGV4dCcsXG4gICAgJ0FkZCByb3cgdG8gdXAnOiAnQWRkIHJvdyB0byB1cCcsXG4gICAgJ0FkZCByb3cgdG8gZG93bic6ICdBZGQgcm93IHRvIGRvd24nLFxuICAgICdBZGQgY29sdW1uIHRvIGxlZnQnOiAnQWRkIGNvbHVtbiB0byBsZWZ0JyxcbiAgICAnQWRkIGNvbHVtbiB0byByaWdodCc6ICdBZGQgY29sdW1uIHRvIHJpZ2h0JyxcbiAgICAnUmVtb3ZlIHJvdyc6ICdSZW1vdmUgcm93JyxcbiAgICAnUmVtb3ZlIGNvbHVtbic6ICdSZW1vdmUgY29sdW1uJyxcbiAgICAnQWxpZ24gY29sdW1uIHRvIGxlZnQnOiAnQWxpZ24gY29sdW1uIHRvIGxlZnQnLFxuICAgICdBbGlnbiBjb2x1bW4gdG8gY2VudGVyJzogJ0FsaWduIGNvbHVtbiB0byBjZW50ZXInLFxuICAgICdBbGlnbiBjb2x1bW4gdG8gcmlnaHQnOiAnQWxpZ24gY29sdW1uIHRvIHJpZ2h0JyxcbiAgICAnUmVtb3ZlIHRhYmxlJzogJ1JlbW92ZSB0YWJsZScsXG4gICAgJ1dvdWxkIHlvdSBsaWtlIHRvIHBhc3RlIGFzIHRhYmxlPyc6ICdXb3VsZCB5b3UgbGlrZSB0byBwYXN0ZSBhcyB0YWJsZT8nLFxuICAgICdUZXh0IGNvbG9yJzogJ1RleHQgY29sb3InLFxuICAgICdBdXRvIHNjcm9sbCBlbmFibGVkJzogJ0F1dG8gc2Nyb2xsIGVuYWJsZWQnLFxuICAgICdBdXRvIHNjcm9sbCBkaXNhYmxlZCc6ICdBdXRvIHNjcm9sbCBkaXNhYmxlZCcsXG4gICAgJ0Nob29zZSBsYW5ndWFnZSc6ICdDaG9vc2UgbGFuZ3VhZ2UnLFxufSk7XG5cbmV4cG9ydCB7IFRvYXN0VUlFZGl0b3IgYXMgRWRpdG9yLCBUb2FzdFVJRWRpdG9yQ29yZSBhcyBFZGl0b3JDb3JlLCBUb2FzdFVJRWRpdG9yIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toast-ui/editor/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toast-ui/editor/dist/toastui-editor-viewer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/editor/dist/toastui-editor-viewer.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * @toast-ui/editor\n * @version 3.2.2 | Fri Feb 17 2023\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n * @license MIT\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! prosemirror-inputrules */ \"(ssr)/./node_modules/prosemirror-inputrules/dist/index.cjs\"), __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.cjs\"), __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.cjs\"), __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.cjs\"), __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.cjs\"));\n\telse {}\n})(self, function(__WEBPACK_EXTERNAL_MODULE__479__, __WEBPACK_EXTERNAL_MODULE__481__, __WEBPACK_EXTERNAL_MODULE__43__, __WEBPACK_EXTERNAL_MODULE__814__, __WEBPACK_EXTERNAL_MODULE__311__) {\nreturn /******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 368:\n/***/ (function(module) {\n\n/*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */\n\n(function (global, factory) {\n    true ? module.exports = factory() :\n  0;\n}(this, function () { 'use strict';\n\n  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n  var hasOwnProperty = Object.hasOwnProperty,\n      setPrototypeOf = Object.setPrototypeOf,\n      isFrozen = Object.isFrozen,\n      getPrototypeOf = Object.getPrototypeOf,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  var freeze = Object.freeze,\n      seal = Object.seal,\n      create = Object.create; // eslint-disable-line import/no-mutable-exports\n\n  var _ref = typeof Reflect !== 'undefined' && Reflect,\n      apply = _ref.apply,\n      construct = _ref.construct;\n\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n    };\n  }\n\n  var arrayForEach = unapply(Array.prototype.forEach);\n  var arrayPop = unapply(Array.prototype.pop);\n  var arrayPush = unapply(Array.prototype.push);\n\n  var stringToLowerCase = unapply(String.prototype.toLowerCase);\n  var stringMatch = unapply(String.prototype.match);\n  var stringReplace = unapply(String.prototype.replace);\n  var stringIndexOf = unapply(String.prototype.indexOf);\n  var stringTrim = unapply(String.prototype.trim);\n\n  var regExpTest = unapply(RegExp.prototype.test);\n\n  var typeErrorCreate = unconstruct(TypeError);\n\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return apply(func, thisArg, args);\n    };\n  }\n\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return construct(func, args);\n    };\n  }\n\n  /* Add properties to a lookup table */\n  function addToSet(set, array) {\n    if (setPrototypeOf) {\n      // Make 'in' and truthy checks like Boolean(set.constructor)\n      // independent of any properties defined on Object.prototype.\n      // Prevent prototype setters from intercepting set as a this value.\n      setPrototypeOf(set, null);\n    }\n\n    var l = array.length;\n    while (l--) {\n      var element = array[l];\n      if (typeof element === 'string') {\n        var lcElement = stringToLowerCase(element);\n        if (lcElement !== element) {\n          // Config presets (e.g. tags.js, attrs.js) are immutable.\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n\n          element = lcElement;\n        }\n      }\n\n      set[element] = true;\n    }\n\n    return set;\n  }\n\n  /* Shallow clone an object */\n  function clone(object) {\n    var newObject = create(null);\n\n    var property = void 0;\n    for (property in object) {\n      if (apply(hasOwnProperty, object, [property])) {\n        newObject[property] = object[property];\n      }\n    }\n\n    return newObject;\n  }\n\n  /* IE10 doesn't support __lookupGetter__ so lets'\n   * simulate it. It also automatically checks\n   * if the prop is function or getter and behaves\n   * accordingly. */\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      var desc = getOwnPropertyDescriptor(object, prop);\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n\n      object = getPrototypeOf(object);\n    }\n\n    function fallbackValue(element) {\n      console.warn('fallback value for', element);\n      return null;\n    }\n\n    return fallbackValue;\n  }\n\n  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n  // SVG\n  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n\n  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\n  // List of SVG elements that are disallowed by default.\n  // We still need to know them so that we can do namespace\n  // checks properly in case one wants to add them to\n  // allow-list.\n  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n\n  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n\n  // Similarly to SVG, we want to know all MathML elements,\n  // even those that we disallow by default.\n  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n\n  var text = freeze(['#text']);\n\n  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n\n  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n\n  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n\n  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n  // eslint-disable-next-line unicorn/better-regex\n  var MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n  var ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\n  var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n  var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n  );\n  var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n  );\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n  function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n  var getGlobal = function getGlobal() {\n    return typeof window === 'undefined' ? null : window;\n  };\n\n  /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n   * @param {Document} document The document object (to determine policy name suffix)\n   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n   * are not supported).\n   */\n  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    }\n\n    // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n    var suffix = null;\n    var ATTR_NAME = 'data-tt-policy-suffix';\n    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n      suffix = document.currentScript.getAttribute(ATTR_NAME);\n    }\n\n    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML: function createHTML(html$$1) {\n          return html$$1;\n        }\n      });\n    } catch (_) {\n      // Policy creation failed (most likely another DOMPurify script has\n      // already run). Skip creating the policy, as this will only cause errors\n      // if TT are enforced.\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n\n  function createDOMPurify() {\n    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n    var DOMPurify = function DOMPurify(root) {\n      return createDOMPurify(root);\n    };\n\n    /**\n     * Version label, exposed for easier checks\n     * if DOMPurify is up to date or not\n     */\n    DOMPurify.version = '2.3.3';\n\n    /**\n     * Array of elements that DOMPurify removed during sanitation.\n     * Empty if nothing was removed.\n     */\n    DOMPurify.removed = [];\n\n    if (!window || !window.document || window.document.nodeType !== 9) {\n      // Not running in a browser, provide a factory function\n      // so that you can pass your own Window\n      DOMPurify.isSupported = false;\n\n      return DOMPurify;\n    }\n\n    var originalDocument = window.document;\n\n    var document = window.document;\n    var DocumentFragment = window.DocumentFragment,\n        HTMLTemplateElement = window.HTMLTemplateElement,\n        Node = window.Node,\n        Element = window.Element,\n        NodeFilter = window.NodeFilter,\n        _window$NamedNodeMap = window.NamedNodeMap,\n        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n        Text = window.Text,\n        Comment = window.Comment,\n        DOMParser = window.DOMParser,\n        trustedTypes = window.trustedTypes;\n\n\n    var ElementPrototype = Element.prototype;\n\n    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n    // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n    if (typeof HTMLTemplateElement === 'function') {\n      var template = document.createElement('template');\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n\n    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';\n\n    var _document = document,\n        implementation = _document.implementation,\n        createNodeIterator = _document.createNodeIterator,\n        createDocumentFragment = _document.createDocumentFragment,\n        getElementsByTagName = _document.getElementsByTagName;\n    var importNode = originalDocument.importNode;\n\n\n    var documentMode = {};\n    try {\n      documentMode = clone(document).documentMode ? document.documentMode : {};\n    } catch (_) {}\n\n    var hooks = {};\n\n    /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */\n    DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n\n    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n        ERB_EXPR$$1 = ERB_EXPR,\n        DATA_ATTR$$1 = DATA_ATTR,\n        ARIA_ATTR$$1 = ARIA_ATTR,\n        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n\n    /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */\n\n    /* allowed element names */\n\n    var ALLOWED_TAGS = null;\n    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n\n    /* Allowed attribute names */\n    var ALLOWED_ATTR = null;\n    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n    var FORBID_TAGS = null;\n\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n    var FORBID_ATTR = null;\n\n    /* Decide if ARIA attributes are okay */\n    var ALLOW_ARIA_ATTR = true;\n\n    /* Decide if custom data attributes are okay */\n    var ALLOW_DATA_ATTR = true;\n\n    /* Decide if unknown protocols are okay */\n    var ALLOW_UNKNOWN_PROTOCOLS = false;\n\n    /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */\n    var SAFE_FOR_TEMPLATES = false;\n\n    /* Decide if document with <html>... should be returned */\n    var WHOLE_DOCUMENT = false;\n\n    /* Track whether config is already set on this instance of DOMPurify. */\n    var SET_CONFIG = false;\n\n    /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */\n    var FORCE_BODY = false;\n\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */\n    var RETURN_DOM = false;\n\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */\n    var RETURN_DOM_FRAGMENT = false;\n\n    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n     * `Node` is imported into the current `Document`. If this flag is not enabled the\n     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n     * DOMPurify.\n     *\n     * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`\n     * might cause XSS from attacks hidden in closed shadowroots in case the browser\n     * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/\n     */\n    var RETURN_DOM_IMPORT = true;\n\n    /* Try to return a Trusted Type object instead of a string, return a string in\n     * case Trusted Types are not supported  */\n    var RETURN_TRUSTED_TYPE = false;\n\n    /* Output should be free from DOM clobbering attacks? */\n    var SANITIZE_DOM = true;\n\n    /* Keep element content when removing element? */\n    var KEEP_CONTENT = true;\n\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */\n    var IN_PLACE = false;\n\n    /* Allow usage of profiles like html, svg and mathMl */\n    var USE_PROFILES = {};\n\n    /* Tags to ignore content of when KEEP_CONTENT is true */\n    var FORBID_CONTENTS = null;\n    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n    /* Tags that are safe for data: URIs */\n    var DATA_URI_TAGS = null;\n    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n    /* Attributes safe for values like \"javascript:\" */\n    var URI_SAFE_ATTRIBUTES = null;\n    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n\n    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n    /* Document namespace */\n    var NAMESPACE = HTML_NAMESPACE;\n    var IS_EMPTY_INPUT = false;\n\n    /* Parsing of strict XHTML documents */\n    var PARSER_MEDIA_TYPE = void 0;\n    var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n    var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n    var transformCaseFunc = void 0;\n\n    /* Keep a reference to config to pass to hooks */\n    var CONFIG = null;\n\n    /* Ideally, do not touch anything below this line */\n    /* ______________________________________________ */\n\n    var formElement = document.createElement('form');\n\n    /**\n     * _parseConfig\n     *\n     * @param  {Object} cfg optional config literal\n     */\n    // eslint-disable-next-line complexity\n    var _parseConfig = function _parseConfig(cfg) {\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n\n      /* Shield configuration object from tampering */\n      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n        cfg = {};\n      }\n\n      /* Shield configuration object from prototype pollution */\n      cfg = clone(cfg);\n\n      /* Set configuration parameters */\n      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;\n      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n      RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n      FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n      IN_PLACE = cfg.IN_PLACE || false; // Default false\n      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n\n      PARSER_MEDIA_TYPE =\n      // eslint-disable-next-line unicorn/prefer-includes\n      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n\n      // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {\n        return x;\n      } : stringToLowerCase;\n\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n\n      /* Parse profile info */\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n        ALLOWED_ATTR = [];\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html);\n          addToSet(ALLOWED_ATTR, html$1);\n        }\n\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl);\n          addToSet(ALLOWED_ATTR, mathMl$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n\n      /* Merge configuration parameters */\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n      }\n\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n      }\n\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n      }\n\n      if (cfg.FORBID_CONTENTS) {\n        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n          FORBID_CONTENTS = clone(FORBID_CONTENTS);\n        }\n\n        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);\n      }\n\n      /* Add #text in case KEEP_CONTENT is set to true */\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n\n      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n\n      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      }\n\n      // Prevent further manipulation of configuration.\n      // Not available in IE8, Safari 5, etc.\n      if (freeze) {\n        freeze(cfg);\n      }\n\n      CONFIG = cfg;\n    };\n\n    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n\n    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);\n\n    /* Keep track of all possible SVG and MathML tags\n     * so that we can perform the namespace checks\n     * correctly. */\n    var ALL_SVG_TAGS = addToSet({}, svg);\n    addToSet(ALL_SVG_TAGS, svgFilters);\n    addToSet(ALL_SVG_TAGS, svgDisallowed);\n\n    var ALL_MATHML_TAGS = addToSet({}, mathMl);\n    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n\n    /**\n     *\n     *\n     * @param  {Element} element a DOM element whose namespace is being checked\n     * @returns {boolean} Return false if the element has a\n     *  namespace that a spec-compliant parser would never\n     *  return. Return true otherwise.\n     */\n    var _checkValidNamespace = function _checkValidNamespace(element) {\n      var parent = getParentNode(element);\n\n      // In JSDOM, if we're inside shadow DOM, then parentNode\n      // can be null. We just simulate parent in this case.\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: HTML_NAMESPACE,\n          tagName: 'template'\n        };\n      }\n\n      var tagName = stringToLowerCase(element.tagName);\n      var parentTagName = stringToLowerCase(parent.tagName);\n\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        // The only way to switch from HTML namespace to SVG\n        // is via <svg>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        }\n\n        // The only way to switch from MathML to SVG is via\n        // svg if parent is either <annotation-xml> or MathML\n        // text integration points.\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        }\n\n        // We only allow elements that are defined in SVG\n        // spec. All others are disallowed in SVG namespace.\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        // The only way to switch from HTML namespace to MathML\n        // is via <math>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        }\n\n        // The only way to switch from SVG to MathML is via\n        // <math> and HTML integration points\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        }\n\n        // We only allow elements that are defined in MathML\n        // spec. All others are disallowed in MathML namespace.\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        // The only way to switch from SVG to HTML is via\n        // HTML integration points, and from MathML to HTML\n        // is via MathML text integration points\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        // Certain elements are allowed in both SVG and HTML\n        // namespace. We need to specify them explicitly\n        // so that they don't get erronously deleted from\n        // HTML namespace.\n        var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n\n        // We disallow tags that are specific for MathML\n        // or SVG and should never appear in HTML namespace\n        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);\n      }\n\n      // The code should never reach this place (this means\n      // that the element somehow got namespace that is not\n      // HTML, SVG or MathML). Return false just in case.\n      return false;\n    };\n\n    /**\n     * _forceRemove\n     *\n     * @param  {Node} node a DOM node\n     */\n    var _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, { element: node });\n      try {\n        // eslint-disable-next-line unicorn/prefer-dom-node-remove\n        node.parentNode.removeChild(node);\n      } catch (_) {\n        try {\n          node.outerHTML = emptyHTML;\n        } catch (_) {\n          node.remove();\n        }\n      }\n    };\n\n    /**\n     * _removeAttribute\n     *\n     * @param  {String} name an Attribute name\n     * @param  {Node} node a DOM node\n     */\n    var _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n\n      node.removeAttribute(name);\n\n      // We void attribute values for unremovable \"is\"\" attributes\n      if (name === 'is' && !ALLOWED_ATTR[name]) {\n        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n          try {\n            _forceRemove(node);\n          } catch (_) {}\n        } else {\n          try {\n            node.setAttribute(name, '');\n          } catch (_) {}\n        }\n      }\n    };\n\n    /**\n     * _initDocument\n     *\n     * @param  {String} dirty a string of dirty markup\n     * @return {Document} a DOM, filled with the dirty markup\n     */\n    var _initDocument = function _initDocument(dirty) {\n      /* Create a HTML document */\n      var doc = void 0;\n      var leadingWhitespace = void 0;\n\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n        var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {\n        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n        dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n      }\n\n      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      /*\n       * Use the DOMParser API by default, fallback later if needs be\n       * DOMParser not work for svg when has multiple root element.\n       */\n      if (NAMESPACE === HTML_NAMESPACE) {\n        try {\n          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n        } catch (_) {}\n      }\n\n      /* Use createHTMLDocument in case DOMParser is not available */\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createDocument(NAMESPACE, 'template', null);\n        try {\n          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;\n        } catch (_) {\n          // Syntax error if dirtyPayload is invalid xml\n        }\n      }\n\n      var body = doc.body || doc.documentElement;\n\n      if (dirty && leadingWhitespace) {\n        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n      }\n\n      /* Work on whole document or just its body */\n      if (NAMESPACE === HTML_NAMESPACE) {\n        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n      }\n\n      return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n\n    /**\n     * _createIterator\n     *\n     * @param  {Document} root document/fragment to create iterator for\n     * @return {Iterator} iterator instance\n     */\n    var _createIterator = function _createIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n    };\n\n    /**\n     * _isClobbered\n     *\n     * @param  {Node} elm element to check for clobbering attacks\n     * @return {Boolean} true if clobbered, false if safe\n     */\n    var _isClobbered = function _isClobbered(elm) {\n      if (elm instanceof Text || elm instanceof Comment) {\n        return false;\n      }\n\n      if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * _isNode\n     *\n     * @param  {Node} obj object to check whether it's a DOM node\n     * @return {Boolean} true is object is a DOM node\n     */\n    var _isNode = function _isNode(object) {\n      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n    };\n\n    /**\n     * _executeHook\n     * Execute user configurable hooks\n     *\n     * @param  {String} entryPoint  Name of the hook's entry point\n     * @param  {Node} currentNode node to work on with the hook\n     * @param  {Object} data additional hook parameters\n     */\n    var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n\n      arrayForEach(hooks[entryPoint], function (hook) {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n\n    /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     *\n     * @param   {Node} currentNode to check for permission to exist\n     * @return  {Boolean} true if node was killed, false if left alive\n     */\n    var _sanitizeElements = function _sanitizeElements(currentNode) {\n      var content = void 0;\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeElements', currentNode, null);\n\n      /* Check if element is clobbered or can clobber */\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Check if tagname contains Unicode */\n      if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Now let's check the element's type and name */\n      var tagName = transformCaseFunc(currentNode.nodeName);\n\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName: tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n\n      /* Detect mXSS attempts abusing namespace confusion */\n      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Mitigate a problem with templates inside select */\n      if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Remove element if anything forbids its presence */\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        /* Keep content except for bad-listed elements */\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          var parentNode = getParentNode(currentNode) || currentNode.parentNode;\n          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n          if (childNodes && parentNode) {\n            var childCount = childNodes.length;\n\n            for (var i = childCount - 1; i >= 0; --i) {\n              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n            }\n          }\n        }\n\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Check whether element has a valid namespace */\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Sanitize element content to be template-safe */\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n        /* Get the element's text content */\n        content = currentNode.textContent;\n        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n        content = stringReplace(content, ERB_EXPR$$1, ' ');\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n          currentNode.textContent = content;\n        }\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeElements', currentNode, null);\n\n      return false;\n    };\n\n    /**\n     * _isValidAttribute\n     *\n     * @param  {string} lcTag Lowercase tag name of containing element.\n     * @param  {string} lcName Lowercase attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid, otherwise false.\n     */\n    // eslint-disable-next-line complexity\n    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      /* Make sure attribute cannot clobber */\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n\n      /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */\n      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        return false;\n\n        /* Check value is safe. First, is attr inert? If so, is safe */\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {\n        return false;\n      }\n\n      return true;\n    };\n\n    /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param  {Node} currentNode to sanitize\n     */\n    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      var attr = void 0;\n      var value = void 0;\n      var lcName = void 0;\n      var l = void 0;\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n      var attributes = currentNode.attributes;\n\n      /* Check if we have attributes; if not we might have a text node */\n\n      if (!attributes) {\n        return;\n      }\n\n      var hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      l = attributes.length;\n\n      /* Go backwards over all attributes; safely remove bad ones */\n      while (l--) {\n        attr = attributes[l];\n        var _attr = attr,\n            name = _attr.name,\n            namespaceURI = _attr.namespaceURI;\n\n        value = stringTrim(attr.value);\n        lcName = transformCaseFunc(name);\n\n        /* Execute a hook if present */\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n        value = hookEvent.attrValue;\n        /* Did the hooks approve of the attribute? */\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n\n        /* Remove attribute */\n        _removeAttribute(name, currentNode);\n\n        /* Did the hooks approve of the attribute? */\n        if (!hookEvent.keepAttr) {\n          continue;\n        }\n\n        /* Work around a security issue in jQuery 3.0 */\n        if (regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n          continue;\n        }\n\n        /* Sanitize attribute content to be template-safe */\n        if (SAFE_FOR_TEMPLATES) {\n          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n          value = stringReplace(value, ERB_EXPR$$1, ' ');\n        }\n\n        /* Is `value` valid for this attribute? */\n        var lcTag = transformCaseFunc(currentNode.nodeName);\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          continue;\n        }\n\n        /* Handle invalid data-* attribute set by try-catching it */\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n\n          arrayPop(DOMPurify.removed);\n        } catch (_) {}\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n\n    /**\n     * _sanitizeShadowDOM\n     *\n     * @param  {DocumentFragment} fragment to iterate over recursively\n     */\n    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      var shadowNode = void 0;\n      var shadowIterator = _createIterator(fragment);\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n      while (shadowNode = shadowIterator.nextNode()) {\n        /* Execute a hook if present */\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n\n        /* Deep shadow DOM detected */\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(shadowNode);\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n\n    /**\n     * Sanitize\n     * Public method providing core sanitation functionality\n     *\n     * @param {String|Node} dirty string or DOM node\n     * @param {Object} configuration object\n     */\n    // eslint-disable-next-line complexity\n    DOMPurify.sanitize = function (dirty, cfg) {\n      var body = void 0;\n      var importedNode = void 0;\n      var currentNode = void 0;\n      var oldNode = void 0;\n      var returnNode = void 0;\n      /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */\n      IS_EMPTY_INPUT = !dirty;\n      if (IS_EMPTY_INPUT) {\n        dirty = '<!-->';\n      }\n\n      /* Stringify, in case dirty is an object */\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        // eslint-disable-next-line no-negated-condition\n        if (typeof dirty.toString !== 'function') {\n          throw typeErrorCreate('toString is not a function');\n        } else {\n          dirty = dirty.toString();\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        }\n      }\n\n      /* Check we can run. Otherwise fall back or ignore */\n      if (!DOMPurify.isSupported) {\n        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n          if (typeof dirty === 'string') {\n            return window.toStaticHTML(dirty);\n          }\n\n          if (_isNode(dirty)) {\n            return window.toStaticHTML(dirty.outerHTML);\n          }\n        }\n\n        return dirty;\n      }\n\n      /* Assign config vars */\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n\n      /* Clean up removed elements */\n      DOMPurify.removed = [];\n\n      /* Check if dirty is correctly typed for IN_PLACE */\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n\n      if (IN_PLACE) ; else if (dirty instanceof Node) {\n        /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */\n        body = _initDocument('<!---->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n          /* Node is already a body, use as is */\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          body.appendChild(importedNode);\n        }\n      } else {\n        /* Exit directly if we have nothing to do */\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n        // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n\n        /* Initialize the document to work on */\n        body = _initDocument(dirty);\n\n        /* Check we have a DOM node from the data */\n        if (!body) {\n          return RETURN_DOM ? null : emptyHTML;\n        }\n      }\n\n      /* Remove first element node (ours) if FORCE_BODY is set */\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n\n      /* Get node iterator */\n      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n      /* Now start iterating over the created document */\n      while (currentNode = nodeIterator.nextNode()) {\n        /* Fix IE's strange behavior with manipulated textNodes #89 */\n        if (currentNode.nodeType === 3 && currentNode === oldNode) {\n          continue;\n        }\n\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n\n        /* Shadow DOM detected, sanitize it */\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(currentNode);\n\n        oldNode = currentNode;\n      }\n\n      oldNode = null;\n\n      /* If we sanitized `dirty` in-place, return it. */\n      if (IN_PLACE) {\n        return dirty;\n      }\n\n      /* Return sanitized string or DOM */\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n\n          while (body.firstChild) {\n            // eslint-disable-next-line unicorn/prefer-dom-node-append\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n\n        if (RETURN_DOM_IMPORT) {\n          /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n\n        return returnNode;\n      }\n\n      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n      /* Sanitize final string template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n      }\n\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n\n    /**\n     * Public method to set the configuration once\n     * setConfig\n     *\n     * @param {Object} cfg configuration object\n     */\n    DOMPurify.setConfig = function (cfg) {\n      _parseConfig(cfg);\n      SET_CONFIG = true;\n    };\n\n    /**\n     * Public method to remove the configuration\n     * clearConfig\n     *\n     */\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n\n    /**\n     * Public method to check if an attribute value is valid.\n     * Uses last set config, if any. Otherwise, uses config defaults.\n     * isValidAttribute\n     *\n     * @param  {string} tag Tag name of containing element.\n     * @param  {string} attr Attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n     */\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      /* Initialize shared config vars if necessary. */\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n\n      var lcTag = transformCaseFunc(tag);\n      var lcName = transformCaseFunc(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n\n    /**\n     * AddHook\n     * Public method to add DOMPurify hooks\n     *\n     * @param {String} entryPoint entry point for the hook to add\n     * @param {Function} hookFunction function to execute\n     */\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n\n    /**\n     * RemoveHook\n     * Public method to remove a DOMPurify hook at a given entryPoint\n     * (pops it from the stack of hooks if more are present)\n     *\n     * @param {String} entryPoint entry point for the hook to remove\n     */\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        arrayPop(hooks[entryPoint]);\n      }\n    };\n\n    /**\n     * RemoveHooks\n     * Public method to remove all DOMPurify hooks at a given entryPoint\n     *\n     * @param  {String} entryPoint entry point for the hooks to remove\n     */\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n\n    /**\n     * RemoveAllHooks\n     * Public method to remove all DOMPurify hooks\n     *\n     */\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n\n    return DOMPurify;\n  }\n\n  var purify = createDOMPurify();\n\n  return purify;\n\n}));\n//# sourceMappingURL=purify.js.map\n\n\n/***/ }),\n\n/***/ 928:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_57109__) {\n\n\"use strict\";\n/* eslint-disable complexity */\n/**\n * @fileoverview Returns the first index at which a given element can be found in the array.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isArray = __nested_webpack_require_57109__(322);\n\n/**\n * @module array\n */\n\n/**\n * Returns the first index at which a given element can be found in the array\n * from start index(default 0), or -1 if it is not present.\n * It compares searchElement to elements of the Array using strict equality\n * (the same method used by the ===, or triple-equals, operator).\n * @param {*} searchElement Element to locate in the array\n * @param {Array} array Array that will be traversed.\n * @param {number} startIndex Start index in array for searching (default 0)\n * @returns {number} the First index at which a given element, or -1 if it is not present\n * @memberof module:array\n * @example\n * // ES6\n * import inArray from 'tui-code-snippet/array/inArray';\n * \n * // CommonJS\n * const inArray = require('tui-code-snippet/array/inArray');\n *\n * const arr = ['one', 'two', 'three', 'four'];\n * const idx1 = inArray('one', arr, 3); // -1\n * const idx2 = inArray('one', arr); // 0\n */\nfunction inArray(searchElement, array, startIndex) {\n  var i;\n  var length;\n  startIndex = startIndex || 0;\n\n  if (!isArray(array)) {\n    return -1;\n  }\n\n  if (Array.prototype.indexOf) {\n    return Array.prototype.indexOf.call(array, searchElement, startIndex);\n  }\n\n  length = array.length;\n  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {\n    if (array[i] === searchElement) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nmodule.exports = inArray;\n\n\n/***/ }),\n\n/***/ 690:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_58838__) {\n\n\"use strict\";\n/**\n * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isArray = __nested_webpack_require_58838__(322);\nvar forEachArray = __nested_webpack_require_58838__(893);\nvar forEachOwnProperties = __nested_webpack_require_58838__(956);\n\n/**\n * @module collection\n */\n\n/**\n * Execute the provided callback once for each property of object(or element of array) which actually exist.\n * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the property(or The value of the element)\n *  2) The name of the property(or The index of the element)\n *  3) The object being traversed\n * @param {Object} obj The object that will be traversed\n * @param {function} iteratee Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEach from 'tui-code-snippet/collection/forEach'; \n * \n * // CommonJS\n * const forEach = require('tui-code-snippet/collection/forEach'); \n *\n * let sum = 0;\n *\n * forEach([1,2,3], function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n *\n * // In case of Array-like object\n * const array = Array.prototype.slice.call(arrayLike); // change to array\n * forEach(array, function(value){\n *   sum += value;\n * });\n */\nfunction forEach(obj, iteratee, context) {\n  if (isArray(obj)) {\n    forEachArray(obj, iteratee, context);\n  } else {\n    forEachOwnProperties(obj, iteratee, context);\n  }\n}\n\nmodule.exports = forEach;\n\n\n/***/ }),\n\n/***/ 893:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Execute the provided callback once for each element present\n * in the array(or Array-like object) in ascending order.\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the element\n *  2) The index of the element\n *  3) The array(or Array-like object) being traversed\n * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed\n * @param {function} iteratee Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEachArray from 'tui-code-snippet/collection/forEachArray';\n * \n * // CommonJS\n * const forEachArray = require('tui-code-snippet/collection/forEachArray'); \n *\n * let sum = 0;\n *\n * forEachArray([1,2,3], function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n */\nfunction forEachArray(arr, iteratee, context) {\n  var index = 0;\n  var len = arr.length;\n\n  context = context || null;\n\n  for (; index < len; index += 1) {\n    if (iteratee.call(context, arr[index], index, arr) === false) {\n      break;\n    }\n  }\n}\n\nmodule.exports = forEachArray;\n\n\n/***/ }),\n\n/***/ 956:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Execute the provided callback once for each property of object which actually exist.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Execute the provided callback once for each property of object which actually exist.\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the property\n *  2) The name of the property\n *  3) The object being traversed\n * @param {Object} obj The object that will be traversed\n * @param {function} iteratee  Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEachOwnProperties from 'tui-code-snippet/collection/forEachOwnProperties';\n * \n * // CommonJS\n * const forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); \n *\n * let sum = 0;\n *\n * forEachOwnProperties({a:1,b:2,c:3}, function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n */\nfunction forEachOwnProperties(obj, iteratee, context) {\n  var key;\n\n  context = context || null;\n\n  for (key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (iteratee.call(context, obj[key], key, obj) === false) {\n        break;\n      }\n    }\n  }\n}\n\nmodule.exports = forEachOwnProperties;\n\n\n/***/ }),\n\n/***/ 990:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_63561__) {\n\n\"use strict\";\n/**\n * @fileoverview Transform the Array-like object to Array.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar forEachArray = __nested_webpack_require_63561__(893);\n\n/**\n * Transform the Array-like object to Array.\n * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.\n * @param {*} arrayLike Array-like object\n * @returns {Array} Array\n * @memberof module:collection\n * @example\n * // ES6\n * import toArray from 'tui-code-snippet/collection/toArray'; \n * \n * // CommonJS\n * const toArray = require('tui-code-snippet/collection/toArray'); \n *\n * const arrayLike = {\n *   0: 'one',\n *   1: 'two',\n *   2: 'three',\n *   3: 'four',\n *   length: 4\n * };\n * const result = toArray(arrayLike);\n *\n * alert(result instanceof Array); // true\n * alert(result); // one,two,three,four\n */\nfunction toArray(arrayLike) {\n  var arr;\n  try {\n    arr = Array.prototype.slice.call(arrayLike);\n  } catch (e) {\n    arr = [];\n    forEachArray(arrayLike, function(value) {\n      arr.push(value);\n    });\n  }\n\n  return arr;\n}\n\nmodule.exports = toArray;\n\n\n/***/ }),\n\n/***/ 755:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Get event collection for specific HTML element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar EVENT_KEY = '_feEventKey';\n\n/**\n * Get event collection for specific HTML element\n * @param {HTMLElement} element - HTML element\n * @param {string} type - event type\n * @returns {array}\n * @private\n */\nfunction safeEvent(element, type) {\n  var events = element[EVENT_KEY];\n  var handlers;\n\n  if (!events) {\n    events = element[EVENT_KEY] = {};\n  }\n\n  handlers = events[type];\n  if (!handlers) {\n    handlers = events[type] = [];\n  }\n\n  return handlers;\n}\n\nmodule.exports = safeEvent;\n\n\n/***/ }),\n\n/***/ 349:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_65445__) {\n\n\"use strict\";\n/**\n * @fileoverview Unbind DOM events\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isString = __nested_webpack_require_65445__(758);\nvar forEach = __nested_webpack_require_65445__(690);\n\nvar safeEvent = __nested_webpack_require_65445__(755);\n\n/**\n * Unbind DOM events\n * If a handler function is not passed, remove all events of that type.\n * @param {HTMLElement} element - element to unbind events\n * @param {(string|object)} types - Space splitted events names or eventName:handler object\n * @param {function} [handler] - handler function\n * @memberof module:domEvent\n * @example\n * // Following the example of domEvent#on\n * \n * // Unbind one event from an element.\n * off(div, 'click', toggle);\n * \n * // Unbind multiple events with a same handler from multiple elements at once.\n * // Use event names splitted by a space.\n * off(element, 'mouseenter mouseleave', changeColor);\n * \n * // Unbind multiple events with different handlers from an element at once.\n * // Use an object which of key is an event name and value is a handler function.\n * off(div, {\n *   keydown: highlight,\n *   keyup: dehighlight\n * });\n * \n * // Unbind events without handlers.\n * off(div, 'drag');\n */\nfunction off(element, types, handler) {\n  if (isString(types)) {\n    forEach(types.split(/\\s+/g), function(type) {\n      unbindEvent(element, type, handler);\n    });\n\n    return;\n  }\n\n  forEach(types, function(func, type) {\n    unbindEvent(element, type, func);\n  });\n}\n\n/**\n * Unbind DOM events\n * If a handler function is not passed, remove all events of that type.\n * @param {HTMLElement} element - element to unbind events\n * @param {string} type - events name\n * @param {function} [handler] - handler function\n * @private\n */\nfunction unbindEvent(element, type, handler) {\n  var events = safeEvent(element, type);\n  var index;\n\n  if (!handler) {\n    forEach(events, function(item) {\n      removeHandler(element, type, item.wrappedHandler);\n    });\n    events.splice(0, events.length);\n  } else {\n    forEach(events, function(item, idx) {\n      if (handler === item.handler) {\n        removeHandler(element, type, item.wrappedHandler);\n        index = idx;\n\n        return false;\n      }\n\n      return true;\n    });\n    events.splice(index, 1);\n  }\n}\n\n/**\n * Remove an event handler\n * @param {HTMLElement} element - An element to remove an event\n * @param {string} type - event type\n * @param {function} handler - event handler\n * @private\n */\nfunction removeHandler(element, type, handler) {\n  if ('removeEventListener' in element) {\n    element.removeEventListener(type, handler);\n  } else if ('detachEvent' in element) {\n    element.detachEvent('on' + type, handler);\n  }\n}\n\nmodule.exports = off;\n\n\n/***/ }),\n\n/***/ 348:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_68232__) {\n\n\"use strict\";\n/**\n * @fileoverview Bind DOM events\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isString = __nested_webpack_require_68232__(758);\nvar forEach = __nested_webpack_require_68232__(690);\n\nvar safeEvent = __nested_webpack_require_68232__(755);\n\n/**\n * Bind DOM events.\n * @param {HTMLElement} element - element to bind events\n * @param {(string|object)} types - Space splitted events names or eventName:handler object\n * @param {(function|object)} handler - handler function or context for handler method\n * @param {object} [context] context - context for handler method.\n * @memberof module:domEvent\n * @example\n * const div = document.querySelector('div');\n * \n * // Bind one event to an element.\n * on(div, 'click', toggle);\n * \n * // Bind multiple events with a same handler to multiple elements at once.\n * // Use event names splitted by a space.\n * on(div, 'mouseenter mouseleave', changeColor);\n * \n * // Bind multiple events with different handlers to an element at once.\n * // Use an object which of key is an event name and value is a handler function.\n * on(div, {\n *   keydown: highlight,\n *   keyup: dehighlight\n * });\n * \n * // Set a context for handler method.\n * const name = 'global';\n * const repository = {name: 'CodeSnippet'};\n * on(div, 'drag', function() {\n *   console.log(this.name);\n * }, repository);\n * // Result when you drag a div: \"CodeSnippet\"\n */\nfunction on(element, types, handler, context) {\n  if (isString(types)) {\n    forEach(types.split(/\\s+/g), function(type) {\n      bindEvent(element, type, handler, context);\n    });\n\n    return;\n  }\n\n  forEach(types, function(func, type) {\n    bindEvent(element, type, func, handler);\n  });\n}\n\n/**\n * Bind DOM events\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} handler - handler function or context for handler method\n * @param {object} [context] context - context for handler method.\n * @private\n */\nfunction bindEvent(element, type, handler, context) {\n  /**\n     * Event handler\n     * @param {Event} e - event object\n     */\n  function eventHandler(e) {\n    handler.call(context || element, e || window.event);\n  }\n\n  if ('addEventListener' in element) {\n    element.addEventListener(type, eventHandler);\n  } else if ('attachEvent' in element) {\n    element.attachEvent('on' + type, eventHandler);\n  }\n  memorizeHandler(element, type, handler, eventHandler);\n}\n\n/**\n * Memorize DOM event handler for unbinding.\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} handler - handler function that user passed at on() use\n * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features\n * @private\n */\nfunction memorizeHandler(element, type, handler, wrappedHandler) {\n  var events = safeEvent(element, type);\n  var existInEvents = false;\n\n  forEach(events, function(obj) {\n    if (obj.handler === handler) {\n      existInEvents = true;\n\n      return false;\n    }\n\n    return true;\n  });\n\n  if (!existInEvents) {\n    events.push({\n      handler: handler,\n      wrappedHandler: wrappedHandler\n    });\n  }\n}\n\nmodule.exports = on;\n\n\n/***/ }),\n\n/***/ 24:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_71515__) {\n\n\"use strict\";\n/**\n * @fileoverview Set className value\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isArray = __nested_webpack_require_71515__(322);\nvar isUndefined = __nested_webpack_require_71515__(929);\n\n/**\n * Set className value\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {(string|string[])} cssClass - class names\n * @private\n */\nfunction setClassName(element, cssClass) {\n  cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;\n\n  cssClass = cssClass.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n  if (isUndefined(element.className.baseVal)) {\n    element.className = cssClass;\n\n    return;\n  }\n\n  element.className.baseVal = cssClass;\n}\n\nmodule.exports = setClassName;\n\n\n/***/ }),\n\n/***/ 204:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_72332__) {\n\n\"use strict\";\n/**\n * @fileoverview Add css class to element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar forEach = __nested_webpack_require_72332__(690);\nvar inArray = __nested_webpack_require_72332__(928);\nvar getClass = __nested_webpack_require_72332__(902);\nvar setClassName = __nested_webpack_require_72332__(24);\n\n/**\n * domUtil module\n * @module domUtil\n */\n\n/**\n * Add css class to element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to add\n * @memberof module:domUtil\n */\nfunction addClass(element) {\n  var cssClass = Array.prototype.slice.call(arguments, 1);\n  var classList = element.classList;\n  var newClass = [];\n  var origin;\n\n  if (classList) {\n    forEach(cssClass, function(name) {\n      element.classList.add(name);\n    });\n\n    return;\n  }\n\n  origin = getClass(element);\n\n  if (origin) {\n    cssClass = [].concat(origin.split(/\\s+/), cssClass);\n  }\n\n  forEach(cssClass, function(cls) {\n    if (inArray(cls, newClass) < 0) {\n      newClass.push(cls);\n    }\n  });\n\n  setClassName(element, newClass);\n}\n\nmodule.exports = addClass;\n\n\n/***/ }),\n\n/***/ 522:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_73512__) {\n\n\"use strict\";\n/**\n * @fileoverview Setting element style\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isString = __nested_webpack_require_73512__(758);\nvar forEach = __nested_webpack_require_73512__(690);\n\n/**\n * Setting element style\n * @param {(HTMLElement|SVGElement)} element - element to setting style\n * @param {(string|object)} key - style prop name or {prop: value} pair object\n * @param {string} [value] - style value\n * @memberof module:domUtil\n */\nfunction css(element, key, value) {\n  var style = element.style;\n\n  if (isString(key)) {\n    style[key] = value;\n\n    return;\n  }\n\n  forEach(key, function(v, k) {\n    style[k] = v;\n  });\n}\n\nmodule.exports = css;\n\n\n/***/ }),\n\n/***/ 902:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_74279__) {\n\n\"use strict\";\n/**\n * @fileoverview Get HTML element's design classes.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isUndefined = __nested_webpack_require_74279__(929);\n\n/**\n * Get HTML element's design classes.\n * @param {(HTMLElement|SVGElement)} element target element\n * @returns {string} element css class name\n * @memberof module:domUtil\n */\nfunction getClass(element) {\n  if (!element || !element.className) {\n    return '';\n  }\n\n  if (isUndefined(element.className.baseVal)) {\n    return element.className;\n  }\n\n  return element.className.baseVal;\n}\n\nmodule.exports = getClass;\n\n\n/***/ }),\n\n/***/ 714:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_74973__) {\n\n\"use strict\";\n/**\n * @fileoverview Check element has specific css class\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar inArray = __nested_webpack_require_74973__(928);\nvar getClass = __nested_webpack_require_74973__(902);\n\n/**\n * Check element has specific css class\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {string} cssClass - css class\n * @returns {boolean}\n * @memberof module:domUtil\n */\nfunction hasClass(element, cssClass) {\n  var origin;\n\n  if (element.classList) {\n    return element.classList.contains(cssClass);\n  }\n\n  origin = getClass(element).split(/\\s+/);\n\n  return inArray(cssClass, origin) > -1;\n}\n\nmodule.exports = hasClass;\n\n\n/***/ }),\n\n/***/ 471:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_75740__) {\n\n\"use strict\";\n/**\n * @fileoverview Check element match selector\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar inArray = __nested_webpack_require_75740__(928);\nvar toArray = __nested_webpack_require_75740__(990);\n\nvar elProto = Element.prototype;\nvar matchSelector = elProto.matches ||\n    elProto.webkitMatchesSelector ||\n    elProto.mozMatchesSelector ||\n    elProto.msMatchesSelector ||\n    function(selector) {\n      var doc = this.document || this.ownerDocument;\n\n      return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;\n    };\n\n/**\n * Check element match selector\n * @param {HTMLElement} element - element to check\n * @param {string} selector - selector to check\n * @returns {boolean} is selector matched to element?\n * @memberof module:domUtil\n */\nfunction matches(element, selector) {\n  return matchSelector.call(element, selector);\n}\n\nmodule.exports = matches;\n\n\n/***/ }),\n\n/***/ 462:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_76721__) {\n\n\"use strict\";\n/**\n * @fileoverview Remove css class from element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar forEachArray = __nested_webpack_require_76721__(893);\nvar inArray = __nested_webpack_require_76721__(928);\nvar getClass = __nested_webpack_require_76721__(902);\nvar setClassName = __nested_webpack_require_76721__(24);\n\n/**\n * Remove css class from element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to remove\n * @memberof module:domUtil\n */\nfunction removeClass(element) {\n  var cssClass = Array.prototype.slice.call(arguments, 1);\n  var classList = element.classList;\n  var origin, newClass;\n\n  if (classList) {\n    forEachArray(cssClass, function(name) {\n      classList.remove(name);\n    });\n\n    return;\n  }\n\n  origin = getClass(element).split(/\\s+/);\n  newClass = [];\n  forEachArray(origin, function(name) {\n    if (inArray(name, cssClass) < 0) {\n      newClass.push(name);\n    }\n  });\n\n  setClassName(element, newClass);\n}\n\nmodule.exports = removeClass;\n\n\n/***/ }),\n\n/***/ 969:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Extend the target object from other objects.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * @module object\n */\n\n/**\n * Extend the target object from other objects.\n * @param {object} target - Object that will be extended\n * @param {...object} objects - Objects as sources\n * @returns {object} Extended object\n * @memberof module:object\n */\nfunction extend(target, objects) { // eslint-disable-line no-unused-vars\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n  var source, prop, i, len;\n\n  for (i = 1, len = arguments.length; i < len; i += 1) {\n    source = arguments[i];\n    for (prop in source) {\n      if (hasOwnProp.call(source, prop)) {\n        target[prop] = source[prop];\n      }\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = extend;\n\n\n/***/ }),\n\n/***/ 254:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_78685__) {\n\n\"use strict\";\n/**\n * @fileoverview Request image ping.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar forEachOwnProperties = __nested_webpack_require_78685__(956);\n\n/**\n * @module request\n */\n\n/**\n * Request image ping.\n * @param {String} url url for ping request\n * @param {Object} trackingInfo infos for make query string\n * @returns {HTMLElement}\n * @memberof module:request\n * @example\n * // ES6\n * import imagePing from 'tui-code-snippet/request/imagePing';\n * \n * // CommonJS\n * const imagePing = require('tui-code-snippet/request/imagePing');\n *\n * imagePing('https://www.google-analytics.com/collect', {\n *   v: 1,\n *   t: 'event',\n *   tid: 'trackingid',\n *   cid: 'cid',\n *   dp: 'dp',\n *   dh: 'dh'\n * });\n */\nfunction imagePing(url, trackingInfo) {\n  var trackingElement = document.createElement('img');\n  var queryString = '';\n  forEachOwnProperties(trackingInfo, function(value, key) {\n    queryString += '&' + key + '=' + value;\n  });\n  queryString = queryString.substring(1);\n\n  trackingElement.src = url + '?' + queryString;\n\n  trackingElement.style.display = 'none';\n  document.body.appendChild(trackingElement);\n  document.body.removeChild(trackingElement);\n\n  return trackingElement;\n}\n\nmodule.exports = imagePing;\n\n\n/***/ }),\n\n/***/ 391:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_80027__) {\n\n\"use strict\";\n/**\n * @fileoverview Send hostname on DOMContentLoaded.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isUndefined = __nested_webpack_require_80027__(929);\nvar imagePing = __nested_webpack_require_80027__(254);\n\nvar ms7days = 7 * 24 * 60 * 60 * 1000;\n\n/**\n * Check if the date has passed 7 days\n * @param {number} date - milliseconds\n * @returns {boolean}\n * @private\n */\nfunction isExpired(date) {\n  var now = new Date().getTime();\n\n  return now - date > ms7days;\n}\n\n/**\n * Send hostname on DOMContentLoaded.\n * To prevent hostname set tui.usageStatistics to false.\n * @param {string} appName - application name\n * @param {string} trackingId - GA tracking ID\n * @ignore\n */\nfunction sendHostname(appName, trackingId) {\n  var url = 'https://www.google-analytics.com/collect';\n  var hostname = location.hostname;\n  var hitType = 'event';\n  var eventCategory = 'use';\n  var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';\n  var date = window.localStorage.getItem(applicationKeyForStorage);\n\n  // skip if the flag is defined and is set to false explicitly\n  if (!isUndefined(window.tui) && window.tui.usageStatistics === false) {\n    return;\n  }\n\n  // skip if not pass seven days old\n  if (date && !isExpired(date)) {\n    return;\n  }\n\n  window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());\n\n  setTimeout(function() {\n    if (document.readyState === 'interactive' || document.readyState === 'complete') {\n      imagePing(url, {\n        v: 1,\n        t: hitType,\n        tid: trackingId,\n        cid: hostname,\n        dp: hostname,\n        dh: appName,\n        el: appName,\n        ec: eventCategory\n      });\n    }\n  }, 1000);\n}\n\nmodule.exports = sendHostname;\n\n\n/***/ }),\n\n/***/ 322:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is an instance of Array or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Check whether the given variable is an instance of Array or not.\n * If the given variable is an instance of Array, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is array instance?\n * @memberof module:type\n */\nfunction isArray(obj) {\n  return obj instanceof Array;\n}\n\nmodule.exports = isArray;\n\n\n/***/ }),\n\n/***/ 65:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_82401__) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is existing or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isUndefined = __nested_webpack_require_82401__(929);\nvar isNull = __nested_webpack_require_82401__(934);\n\n/**\n * Check whether the given variable is existing or not.\n * If the given variable is not null and not undefined, returns true.\n * @param {*} param - Target for checking\n * @returns {boolean} Is existy?\n * @memberof module:type\n * @example\n * // ES6\n * import isExisty from 'tui-code-snippet/type/isExisty');\n * \n * // CommonJS\n * const isExisty = require('tui-code-snippet/type/isExisty');\n *\n * isExisty(''); //true\n * isExisty(0); //true\n * isExisty([]); //true\n * isExisty({}); //true\n * isExisty(null); //false\n * isExisty(undefined); //false\n*/\nfunction isExisty(param) {\n  return !isUndefined(param) && !isNull(param);\n}\n\nmodule.exports = isExisty;\n\n\n/***/ }),\n\n/***/ 404:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_83394__) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is falsy or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isTruthy = __nested_webpack_require_83394__(790);\n\n/**\n * Check whether the given variable is falsy or not.\n * If the given variable is null or undefined or false, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is falsy?\n * @memberof module:type\n */\nfunction isFalsy(obj) {\n  return !isTruthy(obj);\n}\n\nmodule.exports = isFalsy;\n\n\n/***/ }),\n\n/***/ 294:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is a function or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Check whether the given variable is a function or not.\n * If the given variable is a function, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is function?\n * @memberof module:type\n */\nfunction isFunction(obj) {\n  return obj instanceof Function;\n}\n\nmodule.exports = isFunction;\n\n\n/***/ }),\n\n/***/ 934:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is null or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Check whether the given variable is null or not.\n * If the given variable(arguments[0]) is null, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is null?\n * @memberof module:type\n */\nfunction isNull(obj) {\n  return obj === null;\n}\n\nmodule.exports = isNull;\n\n\n/***/ }),\n\n/***/ 758:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is a string or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Check whether the given variable is a string or not.\n * If the given variable is a string, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is string?\n * @memberof module:type\n */\nfunction isString(obj) {\n  return typeof obj === 'string' || obj instanceof String;\n}\n\nmodule.exports = isString;\n\n\n/***/ }),\n\n/***/ 790:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_85531__) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is truthy or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isExisty = __nested_webpack_require_85531__(65);\n\n/**\n * Check whether the given variable is truthy or not.\n * If the given variable is not null or not undefined or not false, returns true.\n * (It regards 0 as true)\n * @param {*} obj - Target for checking\n * @returns {boolean} Is truthy?\n * @memberof module:type\n */\nfunction isTruthy(obj) {\n  return isExisty(obj) && obj !== false;\n}\n\nmodule.exports = isTruthy;\n\n\n/***/ }),\n\n/***/ 929:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is undefined or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Check whether the given variable is undefined or not.\n * If the given variable is undefined, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is undefined?\n * @memberof module:type\n */\nfunction isUndefined(obj) {\n  return obj === undefined; // eslint-disable-line no-undefined\n}\n\nmodule.exports = isUndefined;\n\n\n/***/ }),\n\n/***/ 479:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__479__;\n\n/***/ }),\n\n/***/ 481:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__481__;\n\n/***/ }),\n\n/***/ 43:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__43__;\n\n/***/ }),\n\n/***/ 814:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__814__;\n\n/***/ }),\n\n/***/ 311:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__311__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_87464__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_87464__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t!function() {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__nested_webpack_require_87464__.n = function(module) {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\tfunction() { return module['default']; } :\n/******/ \t\t\t\tfunction() { return module; };\n/******/ \t\t\t__nested_webpack_require_87464__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t!function() {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_87464__.d = function(exports, definition) {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_87464__.o(definition, key) && !__nested_webpack_require_87464__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/global */\n/******/ \t!function() {\n/******/ \t\t__nested_webpack_require_87464__.g = (function() {\n/******/ \t\t\tif (typeof globalThis === 'object') return globalThis;\n/******/ \t\t\ttry {\n/******/ \t\t\t\treturn this || new Function('return this')();\n/******/ \t\t\t} catch (e) {\n/******/ \t\t\t\tif (typeof window === 'object') return window;\n/******/ \t\t\t}\n/******/ \t\t})();\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t!function() {\n/******/ \t\t__nested_webpack_require_87464__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }\n/******/ \t}();\n/******/ \t\n/************************************************************************/\nvar __nested_webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be in strict mode.\n!function() {\n\"use strict\";\n\n// EXPORTS\n__nested_webpack_require_87464__.d(__nested_webpack_exports__, {\n  \"default\": function() { return /* binding */ indexViewer; }\n});\n\n;// CONCATENATED MODULE: ../../node_modules/tslib/tslib.es6.js\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar tslib_es6_assign = function() {\r\n    tslib_es6_assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return tslib_es6_assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\n;// CONCATENATED MODULE: ../../libs/toastmark/dist/esm/index.js\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise */\nvar esm_extendStatics = function (d, b) {\n    esm_extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (Object.prototype.hasOwnProperty.call(b, p))\n                d[p] = b[p]; };\n    return esm_extendStatics(d, b);\n};\nfunction esm_extends(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    esm_extendStatics(d, b);\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar esm_assign = function () {\n    esm_assign = Object.assign || function __assign(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s)\n                if (Object.prototype.hasOwnProperty.call(s, p))\n                    t[p] = s[p];\n        }\n        return t;\n    };\n    return esm_assign.apply(this, arguments);\n};\nfunction esm_spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2)\n        for (var i = 0, l = from.length, ar; i < l; i++) {\n            if (ar || !(i in from)) {\n                if (!ar)\n                    ar = Array.prototype.slice.call(from, 0, i);\n                ar[i] = from[i];\n            }\n        }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __nested_webpack_require_87464__.g !== 'undefined' ? __nested_webpack_require_87464__.g : typeof self !== 'undefined' ? self : {};\nvar encodeCache = {};\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache(exclude) {\n    var i, ch, cache = encodeCache[exclude];\n    if (cache) {\n        return cache;\n    }\n    cache = encodeCache[exclude] = [];\n    for (i = 0; i < 128; i++) {\n        ch = String.fromCharCode(i);\n        if (/^[0-9a-z]$/i.test(ch)) {\n            // always allow unencoded alphanumeric characters\n            cache.push(ch);\n        }\n        else {\n            cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n        }\n    }\n    for (i = 0; i < exclude.length; i++) {\n        cache[exclude.charCodeAt(i)] = exclude[i];\n    }\n    return cache;\n}\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode$1(string, exclude, keepEscaped) {\n    var i, l, code, nextCode, cache, result = '';\n    if (typeof exclude !== 'string') {\n        // encode(string, keepEscaped)\n        keepEscaped = exclude;\n        exclude = encode$1.defaultChars;\n    }\n    if (typeof keepEscaped === 'undefined') {\n        keepEscaped = true;\n    }\n    cache = getEncodeCache(exclude);\n    for (i = 0, l = string.length; i < l; i++) {\n        code = string.charCodeAt(i);\n        if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n            if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n                result += string.slice(i, i + 3);\n                i += 2;\n                continue;\n            }\n        }\n        if (code < 128) {\n            result += cache[code];\n            continue;\n        }\n        if (code >= 0xD800 && code <= 0xDFFF) {\n            if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n                nextCode = string.charCodeAt(i + 1);\n                if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n                    result += encodeURIComponent(string[i] + string[i + 1]);\n                    i++;\n                    continue;\n                }\n            }\n            result += '%EF%BF%BD';\n            continue;\n        }\n        result += encodeURIComponent(string[i]);\n    }\n    return result;\n}\nencode$1.defaultChars = \";/?:@&=+$,-_.!~*'()#\";\nencode$1.componentChars = \"-_.!~*'()\";\nvar encode_1 = encode$1;\nvar lib = {};\nvar decode = {};\nvar Aacute$1 = \"Á\";\nvar aacute$1 = \"á\";\nvar Abreve = \"Ă\";\nvar abreve = \"ă\";\nvar ac = \"∾\";\nvar acd = \"∿\";\nvar acE = \"∾̳\";\nvar Acirc$1 = \"Â\";\nvar acirc$1 = \"â\";\nvar acute$1 = \"´\";\nvar Acy = \"А\";\nvar acy = \"а\";\nvar AElig$1 = \"Æ\";\nvar aelig$1 = \"æ\";\nvar af = \"⁡\";\nvar Afr = \"𝔄\";\nvar afr = \"𝔞\";\nvar Agrave$1 = \"À\";\nvar agrave$1 = \"à\";\nvar alefsym = \"ℵ\";\nvar aleph = \"ℵ\";\nvar Alpha = \"Α\";\nvar alpha = \"α\";\nvar Amacr = \"Ā\";\nvar amacr = \"ā\";\nvar amalg = \"⨿\";\nvar amp$2 = \"&\";\nvar AMP$1 = \"&\";\nvar andand = \"⩕\";\nvar And = \"⩓\";\nvar and = \"∧\";\nvar andd = \"⩜\";\nvar andslope = \"⩘\";\nvar andv = \"⩚\";\nvar ang = \"∠\";\nvar ange = \"⦤\";\nvar angle = \"∠\";\nvar angmsdaa = \"⦨\";\nvar angmsdab = \"⦩\";\nvar angmsdac = \"⦪\";\nvar angmsdad = \"⦫\";\nvar angmsdae = \"⦬\";\nvar angmsdaf = \"⦭\";\nvar angmsdag = \"⦮\";\nvar angmsdah = \"⦯\";\nvar angmsd = \"∡\";\nvar angrt = \"∟\";\nvar angrtvb = \"⊾\";\nvar angrtvbd = \"⦝\";\nvar angsph = \"∢\";\nvar angst = \"Å\";\nvar angzarr = \"⍼\";\nvar Aogon = \"Ą\";\nvar aogon = \"ą\";\nvar Aopf = \"𝔸\";\nvar aopf = \"𝕒\";\nvar apacir = \"⩯\";\nvar ap = \"≈\";\nvar apE = \"⩰\";\nvar ape = \"≊\";\nvar apid = \"≋\";\nvar apos$1 = \"'\";\nvar ApplyFunction = \"⁡\";\nvar approx = \"≈\";\nvar approxeq = \"≊\";\nvar Aring$1 = \"Å\";\nvar aring$1 = \"å\";\nvar Ascr = \"𝒜\";\nvar ascr = \"𝒶\";\nvar Assign = \"≔\";\nvar ast = \"*\";\nvar asymp = \"≈\";\nvar asympeq = \"≍\";\nvar Atilde$1 = \"Ã\";\nvar atilde$1 = \"ã\";\nvar Auml$1 = \"Ä\";\nvar auml$1 = \"ä\";\nvar awconint = \"∳\";\nvar awint = \"⨑\";\nvar backcong = \"≌\";\nvar backepsilon = \"϶\";\nvar backprime = \"‵\";\nvar backsim = \"∽\";\nvar backsimeq = \"⋍\";\nvar Backslash = \"∖\";\nvar Barv = \"⫧\";\nvar barvee = \"⊽\";\nvar barwed = \"⌅\";\nvar Barwed = \"⌆\";\nvar barwedge = \"⌅\";\nvar bbrk = \"⎵\";\nvar bbrktbrk = \"⎶\";\nvar bcong = \"≌\";\nvar Bcy = \"Б\";\nvar bcy = \"б\";\nvar bdquo = \"„\";\nvar becaus = \"∵\";\nvar because = \"∵\";\nvar Because = \"∵\";\nvar bemptyv = \"⦰\";\nvar bepsi = \"϶\";\nvar bernou = \"ℬ\";\nvar Bernoullis = \"ℬ\";\nvar Beta = \"Β\";\nvar beta = \"β\";\nvar beth = \"ℶ\";\nvar between = \"≬\";\nvar Bfr = \"𝔅\";\nvar bfr = \"𝔟\";\nvar bigcap = \"⋂\";\nvar bigcirc = \"◯\";\nvar bigcup = \"⋃\";\nvar bigodot = \"⨀\";\nvar bigoplus = \"⨁\";\nvar bigotimes = \"⨂\";\nvar bigsqcup = \"⨆\";\nvar bigstar = \"★\";\nvar bigtriangledown = \"▽\";\nvar bigtriangleup = \"△\";\nvar biguplus = \"⨄\";\nvar bigvee = \"⋁\";\nvar bigwedge = \"⋀\";\nvar bkarow = \"⤍\";\nvar blacklozenge = \"⧫\";\nvar blacksquare = \"▪\";\nvar blacktriangle = \"▴\";\nvar blacktriangledown = \"▾\";\nvar blacktriangleleft = \"◂\";\nvar blacktriangleright = \"▸\";\nvar blank = \"␣\";\nvar blk12 = \"▒\";\nvar blk14 = \"░\";\nvar blk34 = \"▓\";\nvar block = \"█\";\nvar bne = \"=⃥\";\nvar bnequiv = \"≡⃥\";\nvar bNot = \"⫭\";\nvar bnot = \"⌐\";\nvar Bopf = \"𝔹\";\nvar bopf = \"𝕓\";\nvar bot = \"⊥\";\nvar bottom = \"⊥\";\nvar bowtie = \"⋈\";\nvar boxbox = \"⧉\";\nvar boxdl = \"┐\";\nvar boxdL = \"╕\";\nvar boxDl = \"╖\";\nvar boxDL = \"╗\";\nvar boxdr = \"┌\";\nvar boxdR = \"╒\";\nvar boxDr = \"╓\";\nvar boxDR = \"╔\";\nvar boxh = \"─\";\nvar boxH = \"═\";\nvar boxhd = \"┬\";\nvar boxHd = \"╤\";\nvar boxhD = \"╥\";\nvar boxHD = \"╦\";\nvar boxhu = \"┴\";\nvar boxHu = \"╧\";\nvar boxhU = \"╨\";\nvar boxHU = \"╩\";\nvar boxminus = \"⊟\";\nvar boxplus = \"⊞\";\nvar boxtimes = \"⊠\";\nvar boxul = \"┘\";\nvar boxuL = \"╛\";\nvar boxUl = \"╜\";\nvar boxUL = \"╝\";\nvar boxur = \"└\";\nvar boxuR = \"╘\";\nvar boxUr = \"╙\";\nvar boxUR = \"╚\";\nvar boxv = \"│\";\nvar boxV = \"║\";\nvar boxvh = \"┼\";\nvar boxvH = \"╪\";\nvar boxVh = \"╫\";\nvar boxVH = \"╬\";\nvar boxvl = \"┤\";\nvar boxvL = \"╡\";\nvar boxVl = \"╢\";\nvar boxVL = \"╣\";\nvar boxvr = \"├\";\nvar boxvR = \"╞\";\nvar boxVr = \"╟\";\nvar boxVR = \"╠\";\nvar bprime = \"‵\";\nvar breve = \"˘\";\nvar Breve = \"˘\";\nvar brvbar$1 = \"¦\";\nvar bscr = \"𝒷\";\nvar Bscr = \"ℬ\";\nvar bsemi = \"⁏\";\nvar bsim = \"∽\";\nvar bsime = \"⋍\";\nvar bsolb = \"⧅\";\nvar bsol = \"\\\\\";\nvar bsolhsub = \"⟈\";\nvar bull = \"•\";\nvar bullet = \"•\";\nvar bump = \"≎\";\nvar bumpE = \"⪮\";\nvar bumpe = \"≏\";\nvar Bumpeq = \"≎\";\nvar bumpeq = \"≏\";\nvar Cacute = \"Ć\";\nvar cacute = \"ć\";\nvar capand = \"⩄\";\nvar capbrcup = \"⩉\";\nvar capcap = \"⩋\";\nvar cap = \"∩\";\nvar Cap = \"⋒\";\nvar capcup = \"⩇\";\nvar capdot = \"⩀\";\nvar CapitalDifferentialD = \"ⅅ\";\nvar caps = \"∩︀\";\nvar caret = \"⁁\";\nvar caron = \"ˇ\";\nvar Cayleys = \"ℭ\";\nvar ccaps = \"⩍\";\nvar Ccaron = \"Č\";\nvar ccaron = \"č\";\nvar Ccedil$1 = \"Ç\";\nvar ccedil$1 = \"ç\";\nvar Ccirc = \"Ĉ\";\nvar ccirc = \"ĉ\";\nvar Cconint = \"∰\";\nvar ccups = \"⩌\";\nvar ccupssm = \"⩐\";\nvar Cdot = \"Ċ\";\nvar cdot = \"ċ\";\nvar cedil$1 = \"¸\";\nvar Cedilla = \"¸\";\nvar cemptyv = \"⦲\";\nvar cent$1 = \"¢\";\nvar centerdot = \"·\";\nvar CenterDot = \"·\";\nvar cfr = \"𝔠\";\nvar Cfr = \"ℭ\";\nvar CHcy = \"Ч\";\nvar chcy = \"ч\";\nvar check = \"✓\";\nvar checkmark = \"✓\";\nvar Chi = \"Χ\";\nvar chi = \"χ\";\nvar circ = \"ˆ\";\nvar circeq = \"≗\";\nvar circlearrowleft = \"↺\";\nvar circlearrowright = \"↻\";\nvar circledast = \"⊛\";\nvar circledcirc = \"⊚\";\nvar circleddash = \"⊝\";\nvar CircleDot = \"⊙\";\nvar circledR = \"®\";\nvar circledS = \"Ⓢ\";\nvar CircleMinus = \"⊖\";\nvar CirclePlus = \"⊕\";\nvar CircleTimes = \"⊗\";\nvar cir = \"○\";\nvar cirE = \"⧃\";\nvar cire = \"≗\";\nvar cirfnint = \"⨐\";\nvar cirmid = \"⫯\";\nvar cirscir = \"⧂\";\nvar ClockwiseContourIntegral = \"∲\";\nvar CloseCurlyDoubleQuote = \"”\";\nvar CloseCurlyQuote = \"’\";\nvar clubs = \"♣\";\nvar clubsuit = \"♣\";\nvar colon = \":\";\nvar Colon = \"∷\";\nvar Colone = \"⩴\";\nvar colone = \"≔\";\nvar coloneq = \"≔\";\nvar comma = \",\";\nvar commat = \"@\";\nvar comp = \"∁\";\nvar compfn = \"∘\";\nvar complement = \"∁\";\nvar complexes = \"ℂ\";\nvar cong = \"≅\";\nvar congdot = \"⩭\";\nvar Congruent = \"≡\";\nvar conint = \"∮\";\nvar Conint = \"∯\";\nvar ContourIntegral = \"∮\";\nvar copf = \"𝕔\";\nvar Copf = \"ℂ\";\nvar coprod = \"∐\";\nvar Coproduct = \"∐\";\nvar copy$1 = \"©\";\nvar COPY$1 = \"©\";\nvar copysr = \"℗\";\nvar CounterClockwiseContourIntegral = \"∳\";\nvar crarr = \"↵\";\nvar cross = \"✗\";\nvar Cross = \"⨯\";\nvar Cscr = \"𝒞\";\nvar cscr = \"𝒸\";\nvar csub = \"⫏\";\nvar csube = \"⫑\";\nvar csup = \"⫐\";\nvar csupe = \"⫒\";\nvar ctdot = \"⋯\";\nvar cudarrl = \"⤸\";\nvar cudarrr = \"⤵\";\nvar cuepr = \"⋞\";\nvar cuesc = \"⋟\";\nvar cularr = \"↶\";\nvar cularrp = \"⤽\";\nvar cupbrcap = \"⩈\";\nvar cupcap = \"⩆\";\nvar CupCap = \"≍\";\nvar cup = \"∪\";\nvar Cup = \"⋓\";\nvar cupcup = \"⩊\";\nvar cupdot = \"⊍\";\nvar cupor = \"⩅\";\nvar cups = \"∪︀\";\nvar curarr = \"↷\";\nvar curarrm = \"⤼\";\nvar curlyeqprec = \"⋞\";\nvar curlyeqsucc = \"⋟\";\nvar curlyvee = \"⋎\";\nvar curlywedge = \"⋏\";\nvar curren$1 = \"¤\";\nvar curvearrowleft = \"↶\";\nvar curvearrowright = \"↷\";\nvar cuvee = \"⋎\";\nvar cuwed = \"⋏\";\nvar cwconint = \"∲\";\nvar cwint = \"∱\";\nvar cylcty = \"⌭\";\nvar dagger = \"†\";\nvar Dagger = \"‡\";\nvar daleth = \"ℸ\";\nvar darr = \"↓\";\nvar Darr = \"↡\";\nvar dArr = \"⇓\";\nvar dash = \"‐\";\nvar Dashv = \"⫤\";\nvar dashv = \"⊣\";\nvar dbkarow = \"⤏\";\nvar dblac = \"˝\";\nvar Dcaron = \"Ď\";\nvar dcaron = \"ď\";\nvar Dcy = \"Д\";\nvar dcy = \"д\";\nvar ddagger = \"‡\";\nvar ddarr = \"⇊\";\nvar DD = \"ⅅ\";\nvar dd = \"ⅆ\";\nvar DDotrahd = \"⤑\";\nvar ddotseq = \"⩷\";\nvar deg$1 = \"°\";\nvar Del = \"∇\";\nvar Delta = \"Δ\";\nvar delta = \"δ\";\nvar demptyv = \"⦱\";\nvar dfisht = \"⥿\";\nvar Dfr = \"𝔇\";\nvar dfr = \"𝔡\";\nvar dHar = \"⥥\";\nvar dharl = \"⇃\";\nvar dharr = \"⇂\";\nvar DiacriticalAcute = \"´\";\nvar DiacriticalDot = \"˙\";\nvar DiacriticalDoubleAcute = \"˝\";\nvar DiacriticalGrave = \"`\";\nvar DiacriticalTilde = \"˜\";\nvar diam = \"⋄\";\nvar diamond = \"⋄\";\nvar Diamond = \"⋄\";\nvar diamondsuit = \"♦\";\nvar diams = \"♦\";\nvar die = \"¨\";\nvar DifferentialD = \"ⅆ\";\nvar digamma = \"ϝ\";\nvar disin = \"⋲\";\nvar div = \"÷\";\nvar divide$1 = \"÷\";\nvar divideontimes = \"⋇\";\nvar divonx = \"⋇\";\nvar DJcy = \"Ђ\";\nvar djcy = \"ђ\";\nvar dlcorn = \"⌞\";\nvar dlcrop = \"⌍\";\nvar dollar = \"$\";\nvar Dopf = \"𝔻\";\nvar dopf = \"𝕕\";\nvar Dot = \"¨\";\nvar dot = \"˙\";\nvar DotDot = \"⃜\";\nvar doteq = \"≐\";\nvar doteqdot = \"≑\";\nvar DotEqual = \"≐\";\nvar dotminus = \"∸\";\nvar dotplus = \"∔\";\nvar dotsquare = \"⊡\";\nvar doublebarwedge = \"⌆\";\nvar DoubleContourIntegral = \"∯\";\nvar DoubleDot = \"¨\";\nvar DoubleDownArrow = \"⇓\";\nvar DoubleLeftArrow = \"⇐\";\nvar DoubleLeftRightArrow = \"⇔\";\nvar DoubleLeftTee = \"⫤\";\nvar DoubleLongLeftArrow = \"⟸\";\nvar DoubleLongLeftRightArrow = \"⟺\";\nvar DoubleLongRightArrow = \"⟹\";\nvar DoubleRightArrow = \"⇒\";\nvar DoubleRightTee = \"⊨\";\nvar DoubleUpArrow = \"⇑\";\nvar DoubleUpDownArrow = \"⇕\";\nvar DoubleVerticalBar = \"∥\";\nvar DownArrowBar = \"⤓\";\nvar downarrow = \"↓\";\nvar DownArrow = \"↓\";\nvar Downarrow = \"⇓\";\nvar DownArrowUpArrow = \"⇵\";\nvar DownBreve = \"̑\";\nvar downdownarrows = \"⇊\";\nvar downharpoonleft = \"⇃\";\nvar downharpoonright = \"⇂\";\nvar DownLeftRightVector = \"⥐\";\nvar DownLeftTeeVector = \"⥞\";\nvar DownLeftVectorBar = \"⥖\";\nvar DownLeftVector = \"↽\";\nvar DownRightTeeVector = \"⥟\";\nvar DownRightVectorBar = \"⥗\";\nvar DownRightVector = \"⇁\";\nvar DownTeeArrow = \"↧\";\nvar DownTee = \"⊤\";\nvar drbkarow = \"⤐\";\nvar drcorn = \"⌟\";\nvar drcrop = \"⌌\";\nvar Dscr = \"𝒟\";\nvar dscr = \"𝒹\";\nvar DScy = \"Ѕ\";\nvar dscy = \"ѕ\";\nvar dsol = \"⧶\";\nvar Dstrok = \"Đ\";\nvar dstrok = \"đ\";\nvar dtdot = \"⋱\";\nvar dtri = \"▿\";\nvar dtrif = \"▾\";\nvar duarr = \"⇵\";\nvar duhar = \"⥯\";\nvar dwangle = \"⦦\";\nvar DZcy = \"Џ\";\nvar dzcy = \"џ\";\nvar dzigrarr = \"⟿\";\nvar Eacute$1 = \"É\";\nvar eacute$1 = \"é\";\nvar easter = \"⩮\";\nvar Ecaron = \"Ě\";\nvar ecaron = \"ě\";\nvar Ecirc$1 = \"Ê\";\nvar ecirc$1 = \"ê\";\nvar ecir = \"≖\";\nvar ecolon = \"≕\";\nvar Ecy = \"Э\";\nvar ecy = \"э\";\nvar eDDot = \"⩷\";\nvar Edot = \"Ė\";\nvar edot = \"ė\";\nvar eDot = \"≑\";\nvar ee = \"ⅇ\";\nvar efDot = \"≒\";\nvar Efr = \"𝔈\";\nvar efr = \"𝔢\";\nvar eg = \"⪚\";\nvar Egrave$1 = \"È\";\nvar egrave$1 = \"è\";\nvar egs = \"⪖\";\nvar egsdot = \"⪘\";\nvar el = \"⪙\";\nvar Element = \"∈\";\nvar elinters = \"⏧\";\nvar ell = \"ℓ\";\nvar els = \"⪕\";\nvar elsdot = \"⪗\";\nvar Emacr = \"Ē\";\nvar emacr = \"ē\";\nvar empty = \"∅\";\nvar emptyset = \"∅\";\nvar EmptySmallSquare = \"◻\";\nvar emptyv = \"∅\";\nvar EmptyVerySmallSquare = \"▫\";\nvar emsp13 = \" \";\nvar emsp14 = \" \";\nvar emsp = \" \";\nvar ENG = \"Ŋ\";\nvar eng = \"ŋ\";\nvar ensp = \" \";\nvar Eogon = \"Ę\";\nvar eogon = \"ę\";\nvar Eopf = \"𝔼\";\nvar eopf = \"𝕖\";\nvar epar = \"⋕\";\nvar eparsl = \"⧣\";\nvar eplus = \"⩱\";\nvar epsi = \"ε\";\nvar Epsilon = \"Ε\";\nvar epsilon = \"ε\";\nvar epsiv = \"ϵ\";\nvar eqcirc = \"≖\";\nvar eqcolon = \"≕\";\nvar eqsim = \"≂\";\nvar eqslantgtr = \"⪖\";\nvar eqslantless = \"⪕\";\nvar Equal = \"⩵\";\nvar equals = \"=\";\nvar EqualTilde = \"≂\";\nvar equest = \"≟\";\nvar Equilibrium = \"⇌\";\nvar equiv = \"≡\";\nvar equivDD = \"⩸\";\nvar eqvparsl = \"⧥\";\nvar erarr = \"⥱\";\nvar erDot = \"≓\";\nvar escr = \"ℯ\";\nvar Escr = \"ℰ\";\nvar esdot = \"≐\";\nvar Esim = \"⩳\";\nvar esim = \"≂\";\nvar Eta = \"Η\";\nvar eta = \"η\";\nvar ETH$1 = \"Ð\";\nvar eth$1 = \"ð\";\nvar Euml$1 = \"Ë\";\nvar euml$1 = \"ë\";\nvar euro = \"€\";\nvar excl = \"!\";\nvar exist = \"∃\";\nvar Exists = \"∃\";\nvar expectation = \"ℰ\";\nvar exponentiale = \"ⅇ\";\nvar ExponentialE = \"ⅇ\";\nvar fallingdotseq = \"≒\";\nvar Fcy = \"Ф\";\nvar fcy = \"ф\";\nvar female = \"♀\";\nvar ffilig = \"ﬃ\";\nvar fflig = \"ﬀ\";\nvar ffllig = \"ﬄ\";\nvar Ffr = \"𝔉\";\nvar ffr = \"𝔣\";\nvar filig = \"ﬁ\";\nvar FilledSmallSquare = \"◼\";\nvar FilledVerySmallSquare = \"▪\";\nvar fjlig = \"fj\";\nvar flat = \"♭\";\nvar fllig = \"ﬂ\";\nvar fltns = \"▱\";\nvar fnof = \"ƒ\";\nvar Fopf = \"𝔽\";\nvar fopf = \"𝕗\";\nvar forall = \"∀\";\nvar ForAll = \"∀\";\nvar fork = \"⋔\";\nvar forkv = \"⫙\";\nvar Fouriertrf = \"ℱ\";\nvar fpartint = \"⨍\";\nvar frac12$1 = \"½\";\nvar frac13 = \"⅓\";\nvar frac14$1 = \"¼\";\nvar frac15 = \"⅕\";\nvar frac16 = \"⅙\";\nvar frac18 = \"⅛\";\nvar frac23 = \"⅔\";\nvar frac25 = \"⅖\";\nvar frac34$1 = \"¾\";\nvar frac35 = \"⅗\";\nvar frac38 = \"⅜\";\nvar frac45 = \"⅘\";\nvar frac56 = \"⅚\";\nvar frac58 = \"⅝\";\nvar frac78 = \"⅞\";\nvar frasl = \"⁄\";\nvar frown = \"⌢\";\nvar fscr = \"𝒻\";\nvar Fscr = \"ℱ\";\nvar gacute = \"ǵ\";\nvar Gamma = \"Γ\";\nvar gamma = \"γ\";\nvar Gammad = \"Ϝ\";\nvar gammad = \"ϝ\";\nvar gap = \"⪆\";\nvar Gbreve = \"Ğ\";\nvar gbreve = \"ğ\";\nvar Gcedil = \"Ģ\";\nvar Gcirc = \"Ĝ\";\nvar gcirc = \"ĝ\";\nvar Gcy = \"Г\";\nvar gcy = \"г\";\nvar Gdot = \"Ġ\";\nvar gdot = \"ġ\";\nvar ge = \"≥\";\nvar gE = \"≧\";\nvar gEl = \"⪌\";\nvar gel = \"⋛\";\nvar geq = \"≥\";\nvar geqq = \"≧\";\nvar geqslant = \"⩾\";\nvar gescc = \"⪩\";\nvar ges = \"⩾\";\nvar gesdot = \"⪀\";\nvar gesdoto = \"⪂\";\nvar gesdotol = \"⪄\";\nvar gesl = \"⋛︀\";\nvar gesles = \"⪔\";\nvar Gfr = \"𝔊\";\nvar gfr = \"𝔤\";\nvar gg = \"≫\";\nvar Gg = \"⋙\";\nvar ggg = \"⋙\";\nvar gimel = \"ℷ\";\nvar GJcy = \"Ѓ\";\nvar gjcy = \"ѓ\";\nvar gla = \"⪥\";\nvar gl = \"≷\";\nvar glE = \"⪒\";\nvar glj = \"⪤\";\nvar gnap = \"⪊\";\nvar gnapprox = \"⪊\";\nvar gne = \"⪈\";\nvar gnE = \"≩\";\nvar gneq = \"⪈\";\nvar gneqq = \"≩\";\nvar gnsim = \"⋧\";\nvar Gopf = \"𝔾\";\nvar gopf = \"𝕘\";\nvar grave = \"`\";\nvar GreaterEqual = \"≥\";\nvar GreaterEqualLess = \"⋛\";\nvar GreaterFullEqual = \"≧\";\nvar GreaterGreater = \"⪢\";\nvar GreaterLess = \"≷\";\nvar GreaterSlantEqual = \"⩾\";\nvar GreaterTilde = \"≳\";\nvar Gscr = \"𝒢\";\nvar gscr = \"ℊ\";\nvar gsim = \"≳\";\nvar gsime = \"⪎\";\nvar gsiml = \"⪐\";\nvar gtcc = \"⪧\";\nvar gtcir = \"⩺\";\nvar gt$2 = \">\";\nvar GT$1 = \">\";\nvar Gt = \"≫\";\nvar gtdot = \"⋗\";\nvar gtlPar = \"⦕\";\nvar gtquest = \"⩼\";\nvar gtrapprox = \"⪆\";\nvar gtrarr = \"⥸\";\nvar gtrdot = \"⋗\";\nvar gtreqless = \"⋛\";\nvar gtreqqless = \"⪌\";\nvar gtrless = \"≷\";\nvar gtrsim = \"≳\";\nvar gvertneqq = \"≩︀\";\nvar gvnE = \"≩︀\";\nvar Hacek = \"ˇ\";\nvar hairsp = \" \";\nvar half = \"½\";\nvar hamilt = \"ℋ\";\nvar HARDcy = \"Ъ\";\nvar hardcy = \"ъ\";\nvar harrcir = \"⥈\";\nvar harr = \"↔\";\nvar hArr = \"⇔\";\nvar harrw = \"↭\";\nvar Hat = \"^\";\nvar hbar = \"ℏ\";\nvar Hcirc = \"Ĥ\";\nvar hcirc = \"ĥ\";\nvar hearts = \"♥\";\nvar heartsuit = \"♥\";\nvar hellip = \"…\";\nvar hercon = \"⊹\";\nvar hfr = \"𝔥\";\nvar Hfr = \"ℌ\";\nvar HilbertSpace = \"ℋ\";\nvar hksearow = \"⤥\";\nvar hkswarow = \"⤦\";\nvar hoarr = \"⇿\";\nvar homtht = \"∻\";\nvar hookleftarrow = \"↩\";\nvar hookrightarrow = \"↪\";\nvar hopf = \"𝕙\";\nvar Hopf = \"ℍ\";\nvar horbar = \"―\";\nvar HorizontalLine = \"─\";\nvar hscr = \"𝒽\";\nvar Hscr = \"ℋ\";\nvar hslash = \"ℏ\";\nvar Hstrok = \"Ħ\";\nvar hstrok = \"ħ\";\nvar HumpDownHump = \"≎\";\nvar HumpEqual = \"≏\";\nvar hybull = \"⁃\";\nvar hyphen = \"‐\";\nvar Iacute$1 = \"Í\";\nvar iacute$1 = \"í\";\nvar ic = \"⁣\";\nvar Icirc$1 = \"Î\";\nvar icirc$1 = \"î\";\nvar Icy = \"И\";\nvar icy = \"и\";\nvar Idot = \"İ\";\nvar IEcy = \"Е\";\nvar iecy = \"е\";\nvar iexcl$1 = \"¡\";\nvar iff = \"⇔\";\nvar ifr = \"𝔦\";\nvar Ifr = \"ℑ\";\nvar Igrave$1 = \"Ì\";\nvar igrave$1 = \"ì\";\nvar ii = \"ⅈ\";\nvar iiiint = \"⨌\";\nvar iiint = \"∭\";\nvar iinfin = \"⧜\";\nvar iiota = \"℩\";\nvar IJlig = \"Ĳ\";\nvar ijlig = \"ĳ\";\nvar Imacr = \"Ī\";\nvar imacr = \"ī\";\nvar esm_image = \"ℑ\";\nvar ImaginaryI = \"ⅈ\";\nvar imagline = \"ℐ\";\nvar imagpart = \"ℑ\";\nvar imath = \"ı\";\nvar Im = \"ℑ\";\nvar imof = \"⊷\";\nvar imped = \"Ƶ\";\nvar Implies = \"⇒\";\nvar incare = \"℅\";\nvar infin = \"∞\";\nvar infintie = \"⧝\";\nvar inodot = \"ı\";\nvar intcal = \"⊺\";\nvar esm_int = \"∫\";\nvar Int = \"∬\";\nvar integers = \"ℤ\";\nvar Integral = \"∫\";\nvar intercal = \"⊺\";\nvar Intersection = \"⋂\";\nvar intlarhk = \"⨗\";\nvar intprod = \"⨼\";\nvar InvisibleComma = \"⁣\";\nvar InvisibleTimes = \"⁢\";\nvar IOcy = \"Ё\";\nvar iocy = \"ё\";\nvar Iogon = \"Į\";\nvar iogon = \"į\";\nvar Iopf = \"𝕀\";\nvar iopf = \"𝕚\";\nvar Iota = \"Ι\";\nvar iota = \"ι\";\nvar iprod = \"⨼\";\nvar iquest$1 = \"¿\";\nvar iscr = \"𝒾\";\nvar Iscr = \"ℐ\";\nvar isin = \"∈\";\nvar isindot = \"⋵\";\nvar isinE = \"⋹\";\nvar isins = \"⋴\";\nvar isinsv = \"⋳\";\nvar isinv = \"∈\";\nvar it = \"⁢\";\nvar Itilde = \"Ĩ\";\nvar itilde = \"ĩ\";\nvar Iukcy = \"І\";\nvar iukcy = \"і\";\nvar Iuml$1 = \"Ï\";\nvar iuml$1 = \"ï\";\nvar Jcirc = \"Ĵ\";\nvar jcirc = \"ĵ\";\nvar Jcy = \"Й\";\nvar jcy = \"й\";\nvar Jfr = \"𝔍\";\nvar jfr = \"𝔧\";\nvar jmath = \"ȷ\";\nvar Jopf = \"𝕁\";\nvar jopf = \"𝕛\";\nvar Jscr = \"𝒥\";\nvar jscr = \"𝒿\";\nvar Jsercy = \"Ј\";\nvar jsercy = \"ј\";\nvar Jukcy = \"Є\";\nvar jukcy = \"є\";\nvar Kappa = \"Κ\";\nvar kappa = \"κ\";\nvar kappav = \"ϰ\";\nvar Kcedil = \"Ķ\";\nvar kcedil = \"ķ\";\nvar Kcy = \"К\";\nvar kcy = \"к\";\nvar Kfr = \"𝔎\";\nvar kfr = \"𝔨\";\nvar kgreen = \"ĸ\";\nvar KHcy = \"Х\";\nvar khcy = \"х\";\nvar KJcy = \"Ќ\";\nvar kjcy = \"ќ\";\nvar Kopf = \"𝕂\";\nvar kopf = \"𝕜\";\nvar Kscr = \"𝒦\";\nvar kscr = \"𝓀\";\nvar lAarr = \"⇚\";\nvar Lacute = \"Ĺ\";\nvar lacute = \"ĺ\";\nvar laemptyv = \"⦴\";\nvar lagran = \"ℒ\";\nvar Lambda = \"Λ\";\nvar lambda = \"λ\";\nvar lang = \"⟨\";\nvar Lang = \"⟪\";\nvar langd = \"⦑\";\nvar langle = \"⟨\";\nvar lap = \"⪅\";\nvar Laplacetrf = \"ℒ\";\nvar laquo$1 = \"«\";\nvar larrb = \"⇤\";\nvar larrbfs = \"⤟\";\nvar larr = \"←\";\nvar Larr = \"↞\";\nvar lArr = \"⇐\";\nvar larrfs = \"⤝\";\nvar larrhk = \"↩\";\nvar larrlp = \"↫\";\nvar larrpl = \"⤹\";\nvar larrsim = \"⥳\";\nvar larrtl = \"↢\";\nvar latail = \"⤙\";\nvar lAtail = \"⤛\";\nvar lat = \"⪫\";\nvar late = \"⪭\";\nvar lates = \"⪭︀\";\nvar lbarr = \"⤌\";\nvar lBarr = \"⤎\";\nvar lbbrk = \"❲\";\nvar lbrace = \"{\";\nvar lbrack = \"[\";\nvar lbrke = \"⦋\";\nvar lbrksld = \"⦏\";\nvar lbrkslu = \"⦍\";\nvar Lcaron = \"Ľ\";\nvar lcaron = \"ľ\";\nvar Lcedil = \"Ļ\";\nvar lcedil = \"ļ\";\nvar lceil = \"⌈\";\nvar lcub = \"{\";\nvar Lcy = \"Л\";\nvar lcy = \"л\";\nvar ldca = \"⤶\";\nvar ldquo = \"“\";\nvar ldquor = \"„\";\nvar ldrdhar = \"⥧\";\nvar ldrushar = \"⥋\";\nvar ldsh = \"↲\";\nvar le = \"≤\";\nvar lE = \"≦\";\nvar LeftAngleBracket = \"⟨\";\nvar LeftArrowBar = \"⇤\";\nvar leftarrow = \"←\";\nvar LeftArrow = \"←\";\nvar Leftarrow = \"⇐\";\nvar LeftArrowRightArrow = \"⇆\";\nvar leftarrowtail = \"↢\";\nvar LeftCeiling = \"⌈\";\nvar LeftDoubleBracket = \"⟦\";\nvar LeftDownTeeVector = \"⥡\";\nvar LeftDownVectorBar = \"⥙\";\nvar LeftDownVector = \"⇃\";\nvar LeftFloor = \"⌊\";\nvar leftharpoondown = \"↽\";\nvar leftharpoonup = \"↼\";\nvar leftleftarrows = \"⇇\";\nvar leftrightarrow = \"↔\";\nvar LeftRightArrow = \"↔\";\nvar Leftrightarrow = \"⇔\";\nvar leftrightarrows = \"⇆\";\nvar leftrightharpoons = \"⇋\";\nvar leftrightsquigarrow = \"↭\";\nvar LeftRightVector = \"⥎\";\nvar LeftTeeArrow = \"↤\";\nvar LeftTee = \"⊣\";\nvar LeftTeeVector = \"⥚\";\nvar leftthreetimes = \"⋋\";\nvar LeftTriangleBar = \"⧏\";\nvar LeftTriangle = \"⊲\";\nvar LeftTriangleEqual = \"⊴\";\nvar LeftUpDownVector = \"⥑\";\nvar LeftUpTeeVector = \"⥠\";\nvar LeftUpVectorBar = \"⥘\";\nvar LeftUpVector = \"↿\";\nvar LeftVectorBar = \"⥒\";\nvar LeftVector = \"↼\";\nvar lEg = \"⪋\";\nvar leg = \"⋚\";\nvar leq = \"≤\";\nvar leqq = \"≦\";\nvar leqslant = \"⩽\";\nvar lescc = \"⪨\";\nvar les = \"⩽\";\nvar lesdot = \"⩿\";\nvar lesdoto = \"⪁\";\nvar lesdotor = \"⪃\";\nvar lesg = \"⋚︀\";\nvar lesges = \"⪓\";\nvar lessapprox = \"⪅\";\nvar lessdot = \"⋖\";\nvar lesseqgtr = \"⋚\";\nvar lesseqqgtr = \"⪋\";\nvar LessEqualGreater = \"⋚\";\nvar LessFullEqual = \"≦\";\nvar LessGreater = \"≶\";\nvar lessgtr = \"≶\";\nvar LessLess = \"⪡\";\nvar lesssim = \"≲\";\nvar LessSlantEqual = \"⩽\";\nvar LessTilde = \"≲\";\nvar lfisht = \"⥼\";\nvar lfloor = \"⌊\";\nvar Lfr = \"𝔏\";\nvar lfr = \"𝔩\";\nvar lg = \"≶\";\nvar lgE = \"⪑\";\nvar lHar = \"⥢\";\nvar lhard = \"↽\";\nvar lharu = \"↼\";\nvar lharul = \"⥪\";\nvar lhblk = \"▄\";\nvar LJcy = \"Љ\";\nvar ljcy = \"љ\";\nvar llarr = \"⇇\";\nvar ll = \"≪\";\nvar Ll = \"⋘\";\nvar llcorner = \"⌞\";\nvar Lleftarrow = \"⇚\";\nvar llhard = \"⥫\";\nvar lltri = \"◺\";\nvar Lmidot = \"Ŀ\";\nvar lmidot = \"ŀ\";\nvar lmoustache = \"⎰\";\nvar lmoust = \"⎰\";\nvar lnap = \"⪉\";\nvar lnapprox = \"⪉\";\nvar lne = \"⪇\";\nvar lnE = \"≨\";\nvar lneq = \"⪇\";\nvar lneqq = \"≨\";\nvar lnsim = \"⋦\";\nvar loang = \"⟬\";\nvar loarr = \"⇽\";\nvar lobrk = \"⟦\";\nvar longleftarrow = \"⟵\";\nvar LongLeftArrow = \"⟵\";\nvar Longleftarrow = \"⟸\";\nvar longleftrightarrow = \"⟷\";\nvar LongLeftRightArrow = \"⟷\";\nvar Longleftrightarrow = \"⟺\";\nvar longmapsto = \"⟼\";\nvar longrightarrow = \"⟶\";\nvar LongRightArrow = \"⟶\";\nvar Longrightarrow = \"⟹\";\nvar looparrowleft = \"↫\";\nvar looparrowright = \"↬\";\nvar lopar = \"⦅\";\nvar Lopf = \"𝕃\";\nvar lopf = \"𝕝\";\nvar loplus = \"⨭\";\nvar lotimes = \"⨴\";\nvar lowast = \"∗\";\nvar lowbar = \"_\";\nvar LowerLeftArrow = \"↙\";\nvar LowerRightArrow = \"↘\";\nvar loz = \"◊\";\nvar lozenge = \"◊\";\nvar lozf = \"⧫\";\nvar lpar = \"(\";\nvar lparlt = \"⦓\";\nvar lrarr = \"⇆\";\nvar lrcorner = \"⌟\";\nvar lrhar = \"⇋\";\nvar lrhard = \"⥭\";\nvar lrm = \"‎\";\nvar lrtri = \"⊿\";\nvar lsaquo = \"‹\";\nvar lscr = \"𝓁\";\nvar Lscr = \"ℒ\";\nvar lsh = \"↰\";\nvar Lsh = \"↰\";\nvar lsim = \"≲\";\nvar lsime = \"⪍\";\nvar lsimg = \"⪏\";\nvar lsqb = \"[\";\nvar lsquo = \"‘\";\nvar lsquor = \"‚\";\nvar Lstrok = \"Ł\";\nvar lstrok = \"ł\";\nvar ltcc = \"⪦\";\nvar ltcir = \"⩹\";\nvar lt$2 = \"<\";\nvar LT$1 = \"<\";\nvar Lt = \"≪\";\nvar ltdot = \"⋖\";\nvar lthree = \"⋋\";\nvar ltimes = \"⋉\";\nvar ltlarr = \"⥶\";\nvar ltquest = \"⩻\";\nvar ltri = \"◃\";\nvar ltrie = \"⊴\";\nvar ltrif = \"◂\";\nvar ltrPar = \"⦖\";\nvar lurdshar = \"⥊\";\nvar luruhar = \"⥦\";\nvar lvertneqq = \"≨︀\";\nvar lvnE = \"≨︀\";\nvar macr$1 = \"¯\";\nvar male = \"♂\";\nvar malt = \"✠\";\nvar maltese = \"✠\";\nvar map = \"↦\";\nvar mapsto = \"↦\";\nvar mapstodown = \"↧\";\nvar mapstoleft = \"↤\";\nvar mapstoup = \"↥\";\nvar marker = \"▮\";\nvar mcomma = \"⨩\";\nvar Mcy = \"М\";\nvar mcy = \"м\";\nvar mdash = \"—\";\nvar mDDot = \"∺\";\nvar measuredangle = \"∡\";\nvar MediumSpace = \" \";\nvar Mellintrf = \"ℳ\";\nvar Mfr = \"𝔐\";\nvar mfr = \"𝔪\";\nvar mho = \"℧\";\nvar micro$1 = \"µ\";\nvar midast = \"*\";\nvar midcir = \"⫰\";\nvar mid = \"∣\";\nvar middot$1 = \"·\";\nvar minusb = \"⊟\";\nvar minus = \"−\";\nvar minusd = \"∸\";\nvar minusdu = \"⨪\";\nvar MinusPlus = \"∓\";\nvar mlcp = \"⫛\";\nvar mldr = \"…\";\nvar mnplus = \"∓\";\nvar models = \"⊧\";\nvar Mopf = \"𝕄\";\nvar mopf = \"𝕞\";\nvar mp = \"∓\";\nvar mscr = \"𝓂\";\nvar Mscr = \"ℳ\";\nvar mstpos = \"∾\";\nvar Mu = \"Μ\";\nvar mu = \"μ\";\nvar multimap = \"⊸\";\nvar mumap = \"⊸\";\nvar nabla = \"∇\";\nvar Nacute = \"Ń\";\nvar nacute = \"ń\";\nvar nang = \"∠⃒\";\nvar nap = \"≉\";\nvar napE = \"⩰̸\";\nvar napid = \"≋̸\";\nvar napos = \"ŉ\";\nvar napprox = \"≉\";\nvar natural = \"♮\";\nvar naturals = \"ℕ\";\nvar natur = \"♮\";\nvar nbsp$1 = \" \";\nvar nbump = \"≎̸\";\nvar nbumpe = \"≏̸\";\nvar ncap = \"⩃\";\nvar Ncaron = \"Ň\";\nvar ncaron = \"ň\";\nvar Ncedil = \"Ņ\";\nvar ncedil = \"ņ\";\nvar ncong = \"≇\";\nvar ncongdot = \"⩭̸\";\nvar ncup = \"⩂\";\nvar Ncy = \"Н\";\nvar ncy = \"н\";\nvar ndash = \"–\";\nvar nearhk = \"⤤\";\nvar nearr = \"↗\";\nvar neArr = \"⇗\";\nvar nearrow = \"↗\";\nvar ne = \"≠\";\nvar nedot = \"≐̸\";\nvar NegativeMediumSpace = \"​\";\nvar NegativeThickSpace = \"​\";\nvar NegativeThinSpace = \"​\";\nvar NegativeVeryThinSpace = \"​\";\nvar nequiv = \"≢\";\nvar nesear = \"⤨\";\nvar nesim = \"≂̸\";\nvar NestedGreaterGreater = \"≫\";\nvar NestedLessLess = \"≪\";\nvar NewLine = \"\\n\";\nvar nexist = \"∄\";\nvar nexists = \"∄\";\nvar Nfr = \"𝔑\";\nvar nfr = \"𝔫\";\nvar ngE = \"≧̸\";\nvar nge = \"≱\";\nvar ngeq = \"≱\";\nvar ngeqq = \"≧̸\";\nvar ngeqslant = \"⩾̸\";\nvar nges = \"⩾̸\";\nvar nGg = \"⋙̸\";\nvar ngsim = \"≵\";\nvar nGt = \"≫⃒\";\nvar ngt = \"≯\";\nvar ngtr = \"≯\";\nvar nGtv = \"≫̸\";\nvar nharr = \"↮\";\nvar nhArr = \"⇎\";\nvar nhpar = \"⫲\";\nvar ni = \"∋\";\nvar nis = \"⋼\";\nvar nisd = \"⋺\";\nvar niv = \"∋\";\nvar NJcy = \"Њ\";\nvar njcy = \"њ\";\nvar nlarr = \"↚\";\nvar nlArr = \"⇍\";\nvar nldr = \"‥\";\nvar nlE = \"≦̸\";\nvar nle = \"≰\";\nvar nleftarrow = \"↚\";\nvar nLeftarrow = \"⇍\";\nvar nleftrightarrow = \"↮\";\nvar nLeftrightarrow = \"⇎\";\nvar nleq = \"≰\";\nvar nleqq = \"≦̸\";\nvar nleqslant = \"⩽̸\";\nvar nles = \"⩽̸\";\nvar nless = \"≮\";\nvar nLl = \"⋘̸\";\nvar nlsim = \"≴\";\nvar nLt = \"≪⃒\";\nvar nlt = \"≮\";\nvar nltri = \"⋪\";\nvar nltrie = \"⋬\";\nvar nLtv = \"≪̸\";\nvar nmid = \"∤\";\nvar NoBreak = \"⁠\";\nvar NonBreakingSpace = \" \";\nvar nopf = \"𝕟\";\nvar Nopf = \"ℕ\";\nvar Not = \"⫬\";\nvar not$1 = \"¬\";\nvar NotCongruent = \"≢\";\nvar NotCupCap = \"≭\";\nvar NotDoubleVerticalBar = \"∦\";\nvar NotElement = \"∉\";\nvar NotEqual = \"≠\";\nvar NotEqualTilde = \"≂̸\";\nvar NotExists = \"∄\";\nvar NotGreater = \"≯\";\nvar NotGreaterEqual = \"≱\";\nvar NotGreaterFullEqual = \"≧̸\";\nvar NotGreaterGreater = \"≫̸\";\nvar NotGreaterLess = \"≹\";\nvar NotGreaterSlantEqual = \"⩾̸\";\nvar NotGreaterTilde = \"≵\";\nvar NotHumpDownHump = \"≎̸\";\nvar NotHumpEqual = \"≏̸\";\nvar notin = \"∉\";\nvar notindot = \"⋵̸\";\nvar notinE = \"⋹̸\";\nvar notinva = \"∉\";\nvar notinvb = \"⋷\";\nvar notinvc = \"⋶\";\nvar NotLeftTriangleBar = \"⧏̸\";\nvar NotLeftTriangle = \"⋪\";\nvar NotLeftTriangleEqual = \"⋬\";\nvar NotLess = \"≮\";\nvar NotLessEqual = \"≰\";\nvar NotLessGreater = \"≸\";\nvar NotLessLess = \"≪̸\";\nvar NotLessSlantEqual = \"⩽̸\";\nvar NotLessTilde = \"≴\";\nvar NotNestedGreaterGreater = \"⪢̸\";\nvar NotNestedLessLess = \"⪡̸\";\nvar notni = \"∌\";\nvar notniva = \"∌\";\nvar notnivb = \"⋾\";\nvar notnivc = \"⋽\";\nvar NotPrecedes = \"⊀\";\nvar NotPrecedesEqual = \"⪯̸\";\nvar NotPrecedesSlantEqual = \"⋠\";\nvar NotReverseElement = \"∌\";\nvar NotRightTriangleBar = \"⧐̸\";\nvar NotRightTriangle = \"⋫\";\nvar NotRightTriangleEqual = \"⋭\";\nvar NotSquareSubset = \"⊏̸\";\nvar NotSquareSubsetEqual = \"⋢\";\nvar NotSquareSuperset = \"⊐̸\";\nvar NotSquareSupersetEqual = \"⋣\";\nvar NotSubset = \"⊂⃒\";\nvar NotSubsetEqual = \"⊈\";\nvar NotSucceeds = \"⊁\";\nvar NotSucceedsEqual = \"⪰̸\";\nvar NotSucceedsSlantEqual = \"⋡\";\nvar NotSucceedsTilde = \"≿̸\";\nvar NotSuperset = \"⊃⃒\";\nvar NotSupersetEqual = \"⊉\";\nvar NotTilde = \"≁\";\nvar NotTildeEqual = \"≄\";\nvar NotTildeFullEqual = \"≇\";\nvar NotTildeTilde = \"≉\";\nvar NotVerticalBar = \"∤\";\nvar nparallel = \"∦\";\nvar npar = \"∦\";\nvar nparsl = \"⫽⃥\";\nvar npart = \"∂̸\";\nvar npolint = \"⨔\";\nvar npr = \"⊀\";\nvar nprcue = \"⋠\";\nvar nprec = \"⊀\";\nvar npreceq = \"⪯̸\";\nvar npre = \"⪯̸\";\nvar nrarrc = \"⤳̸\";\nvar nrarr = \"↛\";\nvar nrArr = \"⇏\";\nvar nrarrw = \"↝̸\";\nvar nrightarrow = \"↛\";\nvar nRightarrow = \"⇏\";\nvar nrtri = \"⋫\";\nvar nrtrie = \"⋭\";\nvar nsc = \"⊁\";\nvar nsccue = \"⋡\";\nvar nsce = \"⪰̸\";\nvar Nscr = \"𝒩\";\nvar nscr = \"𝓃\";\nvar nshortmid = \"∤\";\nvar nshortparallel = \"∦\";\nvar nsim = \"≁\";\nvar nsime = \"≄\";\nvar nsimeq = \"≄\";\nvar nsmid = \"∤\";\nvar nspar = \"∦\";\nvar nsqsube = \"⋢\";\nvar nsqsupe = \"⋣\";\nvar nsub = \"⊄\";\nvar nsubE = \"⫅̸\";\nvar nsube = \"⊈\";\nvar nsubset = \"⊂⃒\";\nvar nsubseteq = \"⊈\";\nvar nsubseteqq = \"⫅̸\";\nvar nsucc = \"⊁\";\nvar nsucceq = \"⪰̸\";\nvar nsup = \"⊅\";\nvar nsupE = \"⫆̸\";\nvar nsupe = \"⊉\";\nvar nsupset = \"⊃⃒\";\nvar nsupseteq = \"⊉\";\nvar nsupseteqq = \"⫆̸\";\nvar ntgl = \"≹\";\nvar Ntilde$1 = \"Ñ\";\nvar ntilde$1 = \"ñ\";\nvar ntlg = \"≸\";\nvar ntriangleleft = \"⋪\";\nvar ntrianglelefteq = \"⋬\";\nvar ntriangleright = \"⋫\";\nvar ntrianglerighteq = \"⋭\";\nvar Nu = \"Ν\";\nvar nu = \"ν\";\nvar num = \"#\";\nvar numero = \"№\";\nvar numsp = \" \";\nvar nvap = \"≍⃒\";\nvar nvdash = \"⊬\";\nvar nvDash = \"⊭\";\nvar nVdash = \"⊮\";\nvar nVDash = \"⊯\";\nvar nvge = \"≥⃒\";\nvar nvgt = \">⃒\";\nvar nvHarr = \"⤄\";\nvar nvinfin = \"⧞\";\nvar nvlArr = \"⤂\";\nvar nvle = \"≤⃒\";\nvar nvlt = \"<⃒\";\nvar nvltrie = \"⊴⃒\";\nvar nvrArr = \"⤃\";\nvar nvrtrie = \"⊵⃒\";\nvar nvsim = \"∼⃒\";\nvar nwarhk = \"⤣\";\nvar nwarr = \"↖\";\nvar nwArr = \"⇖\";\nvar nwarrow = \"↖\";\nvar nwnear = \"⤧\";\nvar Oacute$1 = \"Ó\";\nvar oacute$1 = \"ó\";\nvar oast = \"⊛\";\nvar Ocirc$1 = \"Ô\";\nvar ocirc$1 = \"ô\";\nvar ocir = \"⊚\";\nvar Ocy = \"О\";\nvar ocy = \"о\";\nvar odash = \"⊝\";\nvar Odblac = \"Ő\";\nvar odblac = \"ő\";\nvar odiv = \"⨸\";\nvar odot = \"⊙\";\nvar odsold = \"⦼\";\nvar OElig = \"Œ\";\nvar oelig = \"œ\";\nvar ofcir = \"⦿\";\nvar Ofr = \"𝔒\";\nvar ofr = \"𝔬\";\nvar ogon = \"˛\";\nvar Ograve$1 = \"Ò\";\nvar ograve$1 = \"ò\";\nvar ogt = \"⧁\";\nvar ohbar = \"⦵\";\nvar ohm = \"Ω\";\nvar oint = \"∮\";\nvar olarr = \"↺\";\nvar olcir = \"⦾\";\nvar olcross = \"⦻\";\nvar oline = \"‾\";\nvar olt = \"⧀\";\nvar Omacr = \"Ō\";\nvar omacr = \"ō\";\nvar Omega = \"Ω\";\nvar omega = \"ω\";\nvar Omicron = \"Ο\";\nvar omicron = \"ο\";\nvar omid = \"⦶\";\nvar ominus = \"⊖\";\nvar Oopf = \"𝕆\";\nvar oopf = \"𝕠\";\nvar opar = \"⦷\";\nvar OpenCurlyDoubleQuote = \"“\";\nvar OpenCurlyQuote = \"‘\";\nvar operp = \"⦹\";\nvar oplus = \"⊕\";\nvar orarr = \"↻\";\nvar Or = \"⩔\";\nvar or = \"∨\";\nvar ord = \"⩝\";\nvar order = \"ℴ\";\nvar orderof = \"ℴ\";\nvar ordf$1 = \"ª\";\nvar ordm$1 = \"º\";\nvar origof = \"⊶\";\nvar oror = \"⩖\";\nvar orslope = \"⩗\";\nvar orv = \"⩛\";\nvar oS = \"Ⓢ\";\nvar Oscr = \"𝒪\";\nvar oscr = \"ℴ\";\nvar Oslash$1 = \"Ø\";\nvar oslash$1 = \"ø\";\nvar osol = \"⊘\";\nvar Otilde$1 = \"Õ\";\nvar otilde$1 = \"õ\";\nvar otimesas = \"⨶\";\nvar Otimes = \"⨷\";\nvar otimes = \"⊗\";\nvar Ouml$1 = \"Ö\";\nvar ouml$1 = \"ö\";\nvar ovbar = \"⌽\";\nvar OverBar = \"‾\";\nvar OverBrace = \"⏞\";\nvar OverBracket = \"⎴\";\nvar OverParenthesis = \"⏜\";\nvar para$1 = \"¶\";\nvar parallel = \"∥\";\nvar par = \"∥\";\nvar parsim = \"⫳\";\nvar parsl = \"⫽\";\nvar part = \"∂\";\nvar PartialD = \"∂\";\nvar Pcy = \"П\";\nvar pcy = \"п\";\nvar percnt = \"%\";\nvar period = \".\";\nvar permil = \"‰\";\nvar perp = \"⊥\";\nvar pertenk = \"‱\";\nvar Pfr = \"𝔓\";\nvar pfr = \"𝔭\";\nvar Phi = \"Φ\";\nvar phi = \"φ\";\nvar phiv = \"ϕ\";\nvar phmmat = \"ℳ\";\nvar phone = \"☎\";\nvar Pi = \"Π\";\nvar pi = \"π\";\nvar pitchfork = \"⋔\";\nvar piv = \"ϖ\";\nvar planck = \"ℏ\";\nvar planckh = \"ℎ\";\nvar plankv = \"ℏ\";\nvar plusacir = \"⨣\";\nvar plusb = \"⊞\";\nvar pluscir = \"⨢\";\nvar plus = \"+\";\nvar plusdo = \"∔\";\nvar plusdu = \"⨥\";\nvar pluse = \"⩲\";\nvar PlusMinus = \"±\";\nvar plusmn$1 = \"±\";\nvar plussim = \"⨦\";\nvar plustwo = \"⨧\";\nvar pm = \"±\";\nvar Poincareplane = \"ℌ\";\nvar pointint = \"⨕\";\nvar popf = \"𝕡\";\nvar Popf = \"ℙ\";\nvar pound$1 = \"£\";\nvar prap = \"⪷\";\nvar Pr = \"⪻\";\nvar pr = \"≺\";\nvar prcue = \"≼\";\nvar precapprox = \"⪷\";\nvar prec = \"≺\";\nvar preccurlyeq = \"≼\";\nvar Precedes = \"≺\";\nvar PrecedesEqual = \"⪯\";\nvar PrecedesSlantEqual = \"≼\";\nvar PrecedesTilde = \"≾\";\nvar preceq = \"⪯\";\nvar precnapprox = \"⪹\";\nvar precneqq = \"⪵\";\nvar precnsim = \"⋨\";\nvar pre = \"⪯\";\nvar prE = \"⪳\";\nvar precsim = \"≾\";\nvar prime = \"′\";\nvar Prime = \"″\";\nvar primes = \"ℙ\";\nvar prnap = \"⪹\";\nvar prnE = \"⪵\";\nvar prnsim = \"⋨\";\nvar prod = \"∏\";\nvar Product = \"∏\";\nvar profalar = \"⌮\";\nvar profline = \"⌒\";\nvar profsurf = \"⌓\";\nvar prop = \"∝\";\nvar Proportional = \"∝\";\nvar Proportion = \"∷\";\nvar propto = \"∝\";\nvar prsim = \"≾\";\nvar prurel = \"⊰\";\nvar Pscr = \"𝒫\";\nvar pscr = \"𝓅\";\nvar Psi = \"Ψ\";\nvar psi = \"ψ\";\nvar puncsp = \" \";\nvar Qfr = \"𝔔\";\nvar qfr = \"𝔮\";\nvar qint = \"⨌\";\nvar qopf = \"𝕢\";\nvar Qopf = \"ℚ\";\nvar qprime = \"⁗\";\nvar Qscr = \"𝒬\";\nvar qscr = \"𝓆\";\nvar quaternions = \"ℍ\";\nvar quatint = \"⨖\";\nvar quest = \"?\";\nvar questeq = \"≟\";\nvar quot$2 = \"\\\"\";\nvar QUOT$1 = \"\\\"\";\nvar rAarr = \"⇛\";\nvar race = \"∽̱\";\nvar Racute = \"Ŕ\";\nvar racute = \"ŕ\";\nvar radic = \"√\";\nvar raemptyv = \"⦳\";\nvar rang = \"⟩\";\nvar Rang = \"⟫\";\nvar rangd = \"⦒\";\nvar range = \"⦥\";\nvar rangle = \"⟩\";\nvar raquo$1 = \"»\";\nvar rarrap = \"⥵\";\nvar rarrb = \"⇥\";\nvar rarrbfs = \"⤠\";\nvar rarrc = \"⤳\";\nvar rarr = \"→\";\nvar Rarr = \"↠\";\nvar rArr = \"⇒\";\nvar rarrfs = \"⤞\";\nvar rarrhk = \"↪\";\nvar rarrlp = \"↬\";\nvar rarrpl = \"⥅\";\nvar rarrsim = \"⥴\";\nvar Rarrtl = \"⤖\";\nvar rarrtl = \"↣\";\nvar rarrw = \"↝\";\nvar ratail = \"⤚\";\nvar rAtail = \"⤜\";\nvar ratio = \"∶\";\nvar rationals = \"ℚ\";\nvar rbarr = \"⤍\";\nvar rBarr = \"⤏\";\nvar RBarr = \"⤐\";\nvar rbbrk = \"❳\";\nvar rbrace = \"}\";\nvar rbrack = \"]\";\nvar rbrke = \"⦌\";\nvar rbrksld = \"⦎\";\nvar rbrkslu = \"⦐\";\nvar Rcaron = \"Ř\";\nvar rcaron = \"ř\";\nvar Rcedil = \"Ŗ\";\nvar rcedil = \"ŗ\";\nvar rceil = \"⌉\";\nvar rcub = \"}\";\nvar Rcy = \"Р\";\nvar rcy = \"р\";\nvar rdca = \"⤷\";\nvar rdldhar = \"⥩\";\nvar rdquo = \"”\";\nvar rdquor = \"”\";\nvar rdsh = \"↳\";\nvar real = \"ℜ\";\nvar realine = \"ℛ\";\nvar realpart = \"ℜ\";\nvar reals = \"ℝ\";\nvar Re = \"ℜ\";\nvar rect = \"▭\";\nvar reg$1 = \"®\";\nvar REG$1 = \"®\";\nvar ReverseElement = \"∋\";\nvar ReverseEquilibrium = \"⇋\";\nvar ReverseUpEquilibrium = \"⥯\";\nvar rfisht = \"⥽\";\nvar rfloor = \"⌋\";\nvar rfr = \"𝔯\";\nvar Rfr = \"ℜ\";\nvar rHar = \"⥤\";\nvar rhard = \"⇁\";\nvar rharu = \"⇀\";\nvar rharul = \"⥬\";\nvar Rho = \"Ρ\";\nvar rho = \"ρ\";\nvar rhov = \"ϱ\";\nvar RightAngleBracket = \"⟩\";\nvar RightArrowBar = \"⇥\";\nvar rightarrow = \"→\";\nvar RightArrow = \"→\";\nvar Rightarrow = \"⇒\";\nvar RightArrowLeftArrow = \"⇄\";\nvar rightarrowtail = \"↣\";\nvar RightCeiling = \"⌉\";\nvar RightDoubleBracket = \"⟧\";\nvar RightDownTeeVector = \"⥝\";\nvar RightDownVectorBar = \"⥕\";\nvar RightDownVector = \"⇂\";\nvar RightFloor = \"⌋\";\nvar rightharpoondown = \"⇁\";\nvar rightharpoonup = \"⇀\";\nvar rightleftarrows = \"⇄\";\nvar rightleftharpoons = \"⇌\";\nvar rightrightarrows = \"⇉\";\nvar rightsquigarrow = \"↝\";\nvar RightTeeArrow = \"↦\";\nvar RightTee = \"⊢\";\nvar RightTeeVector = \"⥛\";\nvar rightthreetimes = \"⋌\";\nvar RightTriangleBar = \"⧐\";\nvar RightTriangle = \"⊳\";\nvar RightTriangleEqual = \"⊵\";\nvar RightUpDownVector = \"⥏\";\nvar RightUpTeeVector = \"⥜\";\nvar RightUpVectorBar = \"⥔\";\nvar RightUpVector = \"↾\";\nvar RightVectorBar = \"⥓\";\nvar RightVector = \"⇀\";\nvar ring = \"˚\";\nvar risingdotseq = \"≓\";\nvar rlarr = \"⇄\";\nvar rlhar = \"⇌\";\nvar rlm = \"‏\";\nvar rmoustache = \"⎱\";\nvar rmoust = \"⎱\";\nvar rnmid = \"⫮\";\nvar roang = \"⟭\";\nvar roarr = \"⇾\";\nvar robrk = \"⟧\";\nvar ropar = \"⦆\";\nvar ropf = \"𝕣\";\nvar Ropf = \"ℝ\";\nvar roplus = \"⨮\";\nvar rotimes = \"⨵\";\nvar RoundImplies = \"⥰\";\nvar rpar = \")\";\nvar rpargt = \"⦔\";\nvar rppolint = \"⨒\";\nvar rrarr = \"⇉\";\nvar Rrightarrow = \"⇛\";\nvar rsaquo = \"›\";\nvar rscr = \"𝓇\";\nvar Rscr = \"ℛ\";\nvar rsh = \"↱\";\nvar Rsh = \"↱\";\nvar rsqb = \"]\";\nvar rsquo = \"’\";\nvar rsquor = \"’\";\nvar rthree = \"⋌\";\nvar rtimes = \"⋊\";\nvar rtri = \"▹\";\nvar rtrie = \"⊵\";\nvar rtrif = \"▸\";\nvar rtriltri = \"⧎\";\nvar RuleDelayed = \"⧴\";\nvar ruluhar = \"⥨\";\nvar rx = \"℞\";\nvar Sacute = \"Ś\";\nvar sacute = \"ś\";\nvar sbquo = \"‚\";\nvar scap = \"⪸\";\nvar Scaron = \"Š\";\nvar scaron = \"š\";\nvar Sc = \"⪼\";\nvar sc = \"≻\";\nvar sccue = \"≽\";\nvar sce = \"⪰\";\nvar scE = \"⪴\";\nvar Scedil = \"Ş\";\nvar scedil = \"ş\";\nvar Scirc = \"Ŝ\";\nvar scirc = \"ŝ\";\nvar scnap = \"⪺\";\nvar scnE = \"⪶\";\nvar scnsim = \"⋩\";\nvar scpolint = \"⨓\";\nvar scsim = \"≿\";\nvar Scy = \"С\";\nvar scy = \"с\";\nvar sdotb = \"⊡\";\nvar sdot = \"⋅\";\nvar sdote = \"⩦\";\nvar searhk = \"⤥\";\nvar searr = \"↘\";\nvar seArr = \"⇘\";\nvar searrow = \"↘\";\nvar sect$1 = \"§\";\nvar semi = \";\";\nvar seswar = \"⤩\";\nvar setminus = \"∖\";\nvar setmn = \"∖\";\nvar sext = \"✶\";\nvar Sfr = \"𝔖\";\nvar sfr = \"𝔰\";\nvar sfrown = \"⌢\";\nvar sharp = \"♯\";\nvar SHCHcy = \"Щ\";\nvar shchcy = \"щ\";\nvar SHcy = \"Ш\";\nvar shcy = \"ш\";\nvar ShortDownArrow = \"↓\";\nvar ShortLeftArrow = \"←\";\nvar shortmid = \"∣\";\nvar shortparallel = \"∥\";\nvar ShortRightArrow = \"→\";\nvar ShortUpArrow = \"↑\";\nvar shy$1 = \"­\";\nvar Sigma = \"Σ\";\nvar sigma = \"σ\";\nvar sigmaf = \"ς\";\nvar sigmav = \"ς\";\nvar sim = \"∼\";\nvar simdot = \"⩪\";\nvar sime = \"≃\";\nvar simeq = \"≃\";\nvar simg = \"⪞\";\nvar simgE = \"⪠\";\nvar siml = \"⪝\";\nvar simlE = \"⪟\";\nvar simne = \"≆\";\nvar simplus = \"⨤\";\nvar simrarr = \"⥲\";\nvar slarr = \"←\";\nvar SmallCircle = \"∘\";\nvar smallsetminus = \"∖\";\nvar smashp = \"⨳\";\nvar smeparsl = \"⧤\";\nvar smid = \"∣\";\nvar smile = \"⌣\";\nvar smt = \"⪪\";\nvar smte = \"⪬\";\nvar smtes = \"⪬︀\";\nvar SOFTcy = \"Ь\";\nvar softcy = \"ь\";\nvar solbar = \"⌿\";\nvar solb = \"⧄\";\nvar sol = \"/\";\nvar Sopf = \"𝕊\";\nvar sopf = \"𝕤\";\nvar spades = \"♠\";\nvar spadesuit = \"♠\";\nvar spar = \"∥\";\nvar sqcap = \"⊓\";\nvar sqcaps = \"⊓︀\";\nvar sqcup = \"⊔\";\nvar sqcups = \"⊔︀\";\nvar Sqrt = \"√\";\nvar sqsub = \"⊏\";\nvar sqsube = \"⊑\";\nvar sqsubset = \"⊏\";\nvar sqsubseteq = \"⊑\";\nvar sqsup = \"⊐\";\nvar sqsupe = \"⊒\";\nvar sqsupset = \"⊐\";\nvar sqsupseteq = \"⊒\";\nvar square = \"□\";\nvar Square = \"□\";\nvar SquareIntersection = \"⊓\";\nvar SquareSubset = \"⊏\";\nvar SquareSubsetEqual = \"⊑\";\nvar SquareSuperset = \"⊐\";\nvar SquareSupersetEqual = \"⊒\";\nvar SquareUnion = \"⊔\";\nvar squarf = \"▪\";\nvar squ = \"□\";\nvar squf = \"▪\";\nvar srarr = \"→\";\nvar Sscr = \"𝒮\";\nvar sscr = \"𝓈\";\nvar ssetmn = \"∖\";\nvar ssmile = \"⌣\";\nvar sstarf = \"⋆\";\nvar Star = \"⋆\";\nvar star = \"☆\";\nvar starf = \"★\";\nvar straightepsilon = \"ϵ\";\nvar straightphi = \"ϕ\";\nvar strns = \"¯\";\nvar sub = \"⊂\";\nvar Sub = \"⋐\";\nvar subdot = \"⪽\";\nvar subE = \"⫅\";\nvar sube = \"⊆\";\nvar subedot = \"⫃\";\nvar submult = \"⫁\";\nvar subnE = \"⫋\";\nvar subne = \"⊊\";\nvar subplus = \"⪿\";\nvar subrarr = \"⥹\";\nvar subset = \"⊂\";\nvar Subset = \"⋐\";\nvar subseteq = \"⊆\";\nvar subseteqq = \"⫅\";\nvar SubsetEqual = \"⊆\";\nvar subsetneq = \"⊊\";\nvar subsetneqq = \"⫋\";\nvar subsim = \"⫇\";\nvar subsub = \"⫕\";\nvar subsup = \"⫓\";\nvar succapprox = \"⪸\";\nvar succ = \"≻\";\nvar succcurlyeq = \"≽\";\nvar Succeeds = \"≻\";\nvar SucceedsEqual = \"⪰\";\nvar SucceedsSlantEqual = \"≽\";\nvar SucceedsTilde = \"≿\";\nvar succeq = \"⪰\";\nvar succnapprox = \"⪺\";\nvar succneqq = \"⪶\";\nvar succnsim = \"⋩\";\nvar succsim = \"≿\";\nvar SuchThat = \"∋\";\nvar sum = \"∑\";\nvar Sum = \"∑\";\nvar sung = \"♪\";\nvar sup1$1 = \"¹\";\nvar sup2$1 = \"²\";\nvar sup3$1 = \"³\";\nvar sup = \"⊃\";\nvar Sup = \"⋑\";\nvar supdot = \"⪾\";\nvar supdsub = \"⫘\";\nvar supE = \"⫆\";\nvar supe = \"⊇\";\nvar supedot = \"⫄\";\nvar Superset = \"⊃\";\nvar SupersetEqual = \"⊇\";\nvar suphsol = \"⟉\";\nvar suphsub = \"⫗\";\nvar suplarr = \"⥻\";\nvar supmult = \"⫂\";\nvar supnE = \"⫌\";\nvar supne = \"⊋\";\nvar supplus = \"⫀\";\nvar supset = \"⊃\";\nvar Supset = \"⋑\";\nvar supseteq = \"⊇\";\nvar supseteqq = \"⫆\";\nvar supsetneq = \"⊋\";\nvar supsetneqq = \"⫌\";\nvar supsim = \"⫈\";\nvar supsub = \"⫔\";\nvar supsup = \"⫖\";\nvar swarhk = \"⤦\";\nvar swarr = \"↙\";\nvar swArr = \"⇙\";\nvar swarrow = \"↙\";\nvar swnwar = \"⤪\";\nvar szlig$1 = \"ß\";\nvar Tab = \"\\t\";\nvar target = \"⌖\";\nvar Tau = \"Τ\";\nvar tau = \"τ\";\nvar tbrk = \"⎴\";\nvar Tcaron = \"Ť\";\nvar tcaron = \"ť\";\nvar Tcedil = \"Ţ\";\nvar tcedil = \"ţ\";\nvar Tcy = \"Т\";\nvar tcy = \"т\";\nvar tdot = \"⃛\";\nvar telrec = \"⌕\";\nvar Tfr = \"𝔗\";\nvar tfr = \"𝔱\";\nvar there4 = \"∴\";\nvar therefore = \"∴\";\nvar Therefore = \"∴\";\nvar Theta = \"Θ\";\nvar theta = \"θ\";\nvar thetasym = \"ϑ\";\nvar thetav = \"ϑ\";\nvar thickapprox = \"≈\";\nvar thicksim = \"∼\";\nvar ThickSpace = \"  \";\nvar ThinSpace = \" \";\nvar thinsp = \" \";\nvar thkap = \"≈\";\nvar thksim = \"∼\";\nvar THORN$1 = \"Þ\";\nvar thorn$1 = \"þ\";\nvar tilde = \"˜\";\nvar Tilde = \"∼\";\nvar TildeEqual = \"≃\";\nvar TildeFullEqual = \"≅\";\nvar TildeTilde = \"≈\";\nvar timesbar = \"⨱\";\nvar timesb = \"⊠\";\nvar times$1 = \"×\";\nvar timesd = \"⨰\";\nvar tint = \"∭\";\nvar toea = \"⤨\";\nvar topbot = \"⌶\";\nvar topcir = \"⫱\";\nvar esm_top = \"⊤\";\nvar Topf = \"𝕋\";\nvar topf = \"𝕥\";\nvar topfork = \"⫚\";\nvar tosa = \"⤩\";\nvar tprime = \"‴\";\nvar trade = \"™\";\nvar TRADE = \"™\";\nvar triangle = \"▵\";\nvar triangledown = \"▿\";\nvar triangleleft = \"◃\";\nvar trianglelefteq = \"⊴\";\nvar triangleq = \"≜\";\nvar triangleright = \"▹\";\nvar trianglerighteq = \"⊵\";\nvar tridot = \"◬\";\nvar trie = \"≜\";\nvar triminus = \"⨺\";\nvar TripleDot = \"⃛\";\nvar triplus = \"⨹\";\nvar trisb = \"⧍\";\nvar tritime = \"⨻\";\nvar trpezium = \"⏢\";\nvar Tscr = \"𝒯\";\nvar tscr = \"𝓉\";\nvar TScy = \"Ц\";\nvar tscy = \"ц\";\nvar TSHcy = \"Ћ\";\nvar tshcy = \"ћ\";\nvar Tstrok = \"Ŧ\";\nvar tstrok = \"ŧ\";\nvar twixt = \"≬\";\nvar twoheadleftarrow = \"↞\";\nvar twoheadrightarrow = \"↠\";\nvar Uacute$1 = \"Ú\";\nvar uacute$1 = \"ú\";\nvar uarr = \"↑\";\nvar Uarr = \"↟\";\nvar uArr = \"⇑\";\nvar Uarrocir = \"⥉\";\nvar Ubrcy = \"Ў\";\nvar ubrcy = \"ў\";\nvar Ubreve = \"Ŭ\";\nvar ubreve = \"ŭ\";\nvar Ucirc$1 = \"Û\";\nvar ucirc$1 = \"û\";\nvar Ucy = \"У\";\nvar ucy = \"у\";\nvar udarr = \"⇅\";\nvar Udblac = \"Ű\";\nvar udblac = \"ű\";\nvar udhar = \"⥮\";\nvar ufisht = \"⥾\";\nvar Ufr = \"𝔘\";\nvar ufr = \"𝔲\";\nvar Ugrave$1 = \"Ù\";\nvar ugrave$1 = \"ù\";\nvar uHar = \"⥣\";\nvar uharl = \"↿\";\nvar uharr = \"↾\";\nvar uhblk = \"▀\";\nvar ulcorn = \"⌜\";\nvar ulcorner = \"⌜\";\nvar ulcrop = \"⌏\";\nvar ultri = \"◸\";\nvar Umacr = \"Ū\";\nvar umacr = \"ū\";\nvar uml$1 = \"¨\";\nvar UnderBar = \"_\";\nvar UnderBrace = \"⏟\";\nvar UnderBracket = \"⎵\";\nvar UnderParenthesis = \"⏝\";\nvar Union = \"⋃\";\nvar UnionPlus = \"⊎\";\nvar Uogon = \"Ų\";\nvar uogon = \"ų\";\nvar Uopf = \"𝕌\";\nvar uopf = \"𝕦\";\nvar UpArrowBar = \"⤒\";\nvar uparrow = \"↑\";\nvar UpArrow = \"↑\";\nvar Uparrow = \"⇑\";\nvar UpArrowDownArrow = \"⇅\";\nvar updownarrow = \"↕\";\nvar UpDownArrow = \"↕\";\nvar Updownarrow = \"⇕\";\nvar UpEquilibrium = \"⥮\";\nvar upharpoonleft = \"↿\";\nvar upharpoonright = \"↾\";\nvar uplus = \"⊎\";\nvar UpperLeftArrow = \"↖\";\nvar UpperRightArrow = \"↗\";\nvar upsi = \"υ\";\nvar Upsi = \"ϒ\";\nvar upsih = \"ϒ\";\nvar Upsilon = \"Υ\";\nvar upsilon = \"υ\";\nvar UpTeeArrow = \"↥\";\nvar UpTee = \"⊥\";\nvar upuparrows = \"⇈\";\nvar urcorn = \"⌝\";\nvar urcorner = \"⌝\";\nvar urcrop = \"⌎\";\nvar Uring = \"Ů\";\nvar uring = \"ů\";\nvar urtri = \"◹\";\nvar Uscr = \"𝒰\";\nvar uscr = \"𝓊\";\nvar utdot = \"⋰\";\nvar Utilde = \"Ũ\";\nvar utilde = \"ũ\";\nvar utri = \"▵\";\nvar utrif = \"▴\";\nvar uuarr = \"⇈\";\nvar Uuml$1 = \"Ü\";\nvar uuml$1 = \"ü\";\nvar uwangle = \"⦧\";\nvar vangrt = \"⦜\";\nvar varepsilon = \"ϵ\";\nvar varkappa = \"ϰ\";\nvar varnothing = \"∅\";\nvar varphi = \"ϕ\";\nvar varpi = \"ϖ\";\nvar varpropto = \"∝\";\nvar varr = \"↕\";\nvar vArr = \"⇕\";\nvar varrho = \"ϱ\";\nvar varsigma = \"ς\";\nvar varsubsetneq = \"⊊︀\";\nvar varsubsetneqq = \"⫋︀\";\nvar varsupsetneq = \"⊋︀\";\nvar varsupsetneqq = \"⫌︀\";\nvar vartheta = \"ϑ\";\nvar vartriangleleft = \"⊲\";\nvar vartriangleright = \"⊳\";\nvar vBar = \"⫨\";\nvar Vbar = \"⫫\";\nvar vBarv = \"⫩\";\nvar Vcy = \"В\";\nvar vcy = \"в\";\nvar vdash = \"⊢\";\nvar vDash = \"⊨\";\nvar Vdash = \"⊩\";\nvar VDash = \"⊫\";\nvar Vdashl = \"⫦\";\nvar veebar = \"⊻\";\nvar vee = \"∨\";\nvar Vee = \"⋁\";\nvar veeeq = \"≚\";\nvar vellip = \"⋮\";\nvar verbar = \"|\";\nvar Verbar = \"‖\";\nvar vert = \"|\";\nvar Vert = \"‖\";\nvar VerticalBar = \"∣\";\nvar VerticalLine = \"|\";\nvar VerticalSeparator = \"❘\";\nvar VerticalTilde = \"≀\";\nvar VeryThinSpace = \" \";\nvar Vfr = \"𝔙\";\nvar vfr = \"𝔳\";\nvar vltri = \"⊲\";\nvar vnsub = \"⊂⃒\";\nvar vnsup = \"⊃⃒\";\nvar Vopf = \"𝕍\";\nvar vopf = \"𝕧\";\nvar vprop = \"∝\";\nvar vrtri = \"⊳\";\nvar Vscr = \"𝒱\";\nvar vscr = \"𝓋\";\nvar vsubnE = \"⫋︀\";\nvar vsubne = \"⊊︀\";\nvar vsupnE = \"⫌︀\";\nvar vsupne = \"⊋︀\";\nvar Vvdash = \"⊪\";\nvar vzigzag = \"⦚\";\nvar Wcirc = \"Ŵ\";\nvar wcirc = \"ŵ\";\nvar wedbar = \"⩟\";\nvar wedge = \"∧\";\nvar Wedge = \"⋀\";\nvar wedgeq = \"≙\";\nvar weierp = \"℘\";\nvar Wfr = \"𝔚\";\nvar wfr = \"𝔴\";\nvar Wopf = \"𝕎\";\nvar wopf = \"𝕨\";\nvar wp = \"℘\";\nvar wr = \"≀\";\nvar wreath = \"≀\";\nvar Wscr = \"𝒲\";\nvar wscr = \"𝓌\";\nvar xcap = \"⋂\";\nvar xcirc = \"◯\";\nvar xcup = \"⋃\";\nvar xdtri = \"▽\";\nvar Xfr = \"𝔛\";\nvar xfr = \"𝔵\";\nvar xharr = \"⟷\";\nvar xhArr = \"⟺\";\nvar Xi = \"Ξ\";\nvar xi = \"ξ\";\nvar xlarr = \"⟵\";\nvar xlArr = \"⟸\";\nvar xmap = \"⟼\";\nvar xnis = \"⋻\";\nvar xodot = \"⨀\";\nvar Xopf = \"𝕏\";\nvar xopf = \"𝕩\";\nvar xoplus = \"⨁\";\nvar xotime = \"⨂\";\nvar xrarr = \"⟶\";\nvar xrArr = \"⟹\";\nvar Xscr = \"𝒳\";\nvar xscr = \"𝓍\";\nvar xsqcup = \"⨆\";\nvar xuplus = \"⨄\";\nvar xutri = \"△\";\nvar xvee = \"⋁\";\nvar xwedge = \"⋀\";\nvar Yacute$1 = \"Ý\";\nvar yacute$1 = \"ý\";\nvar YAcy = \"Я\";\nvar yacy = \"я\";\nvar Ycirc = \"Ŷ\";\nvar ycirc = \"ŷ\";\nvar Ycy = \"Ы\";\nvar ycy = \"ы\";\nvar yen$1 = \"¥\";\nvar Yfr = \"𝔜\";\nvar yfr = \"𝔶\";\nvar YIcy = \"Ї\";\nvar yicy = \"ї\";\nvar Yopf = \"𝕐\";\nvar yopf = \"𝕪\";\nvar Yscr = \"𝒴\";\nvar yscr = \"𝓎\";\nvar YUcy = \"Ю\";\nvar yucy = \"ю\";\nvar yuml$1 = \"ÿ\";\nvar Yuml = \"Ÿ\";\nvar Zacute = \"Ź\";\nvar zacute = \"ź\";\nvar Zcaron = \"Ž\";\nvar zcaron = \"ž\";\nvar Zcy = \"З\";\nvar zcy = \"з\";\nvar Zdot = \"Ż\";\nvar zdot = \"ż\";\nvar zeetrf = \"ℨ\";\nvar ZeroWidthSpace = \"​\";\nvar Zeta = \"Ζ\";\nvar zeta = \"ζ\";\nvar zfr = \"𝔷\";\nvar Zfr = \"ℨ\";\nvar ZHcy = \"Ж\";\nvar zhcy = \"ж\";\nvar zigrarr = \"⇝\";\nvar zopf = \"𝕫\";\nvar Zopf = \"ℤ\";\nvar Zscr = \"𝒵\";\nvar zscr = \"𝓏\";\nvar zwj = \"‍\";\nvar zwnj = \"‌\";\nvar require$$1$1 = {\n    Aacute: Aacute$1,\n    aacute: aacute$1,\n    Abreve: Abreve,\n    abreve: abreve,\n    ac: ac,\n    acd: acd,\n    acE: acE,\n    Acirc: Acirc$1,\n    acirc: acirc$1,\n    acute: acute$1,\n    Acy: Acy,\n    acy: acy,\n    AElig: AElig$1,\n    aelig: aelig$1,\n    af: af,\n    Afr: Afr,\n    afr: afr,\n    Agrave: Agrave$1,\n    agrave: agrave$1,\n    alefsym: alefsym,\n    aleph: aleph,\n    Alpha: Alpha,\n    alpha: alpha,\n    Amacr: Amacr,\n    amacr: amacr,\n    amalg: amalg,\n    amp: amp$2,\n    AMP: AMP$1,\n    andand: andand,\n    And: And,\n    and: and,\n    andd: andd,\n    andslope: andslope,\n    andv: andv,\n    ang: ang,\n    ange: ange,\n    angle: angle,\n    angmsdaa: angmsdaa,\n    angmsdab: angmsdab,\n    angmsdac: angmsdac,\n    angmsdad: angmsdad,\n    angmsdae: angmsdae,\n    angmsdaf: angmsdaf,\n    angmsdag: angmsdag,\n    angmsdah: angmsdah,\n    angmsd: angmsd,\n    angrt: angrt,\n    angrtvb: angrtvb,\n    angrtvbd: angrtvbd,\n    angsph: angsph,\n    angst: angst,\n    angzarr: angzarr,\n    Aogon: Aogon,\n    aogon: aogon,\n    Aopf: Aopf,\n    aopf: aopf,\n    apacir: apacir,\n    ap: ap,\n    apE: apE,\n    ape: ape,\n    apid: apid,\n    apos: apos$1,\n    ApplyFunction: ApplyFunction,\n    approx: approx,\n    approxeq: approxeq,\n    Aring: Aring$1,\n    aring: aring$1,\n    Ascr: Ascr,\n    ascr: ascr,\n    Assign: Assign,\n    ast: ast,\n    asymp: asymp,\n    asympeq: asympeq,\n    Atilde: Atilde$1,\n    atilde: atilde$1,\n    Auml: Auml$1,\n    auml: auml$1,\n    awconint: awconint,\n    awint: awint,\n    backcong: backcong,\n    backepsilon: backepsilon,\n    backprime: backprime,\n    backsim: backsim,\n    backsimeq: backsimeq,\n    Backslash: Backslash,\n    Barv: Barv,\n    barvee: barvee,\n    barwed: barwed,\n    Barwed: Barwed,\n    barwedge: barwedge,\n    bbrk: bbrk,\n    bbrktbrk: bbrktbrk,\n    bcong: bcong,\n    Bcy: Bcy,\n    bcy: bcy,\n    bdquo: bdquo,\n    becaus: becaus,\n    because: because,\n    Because: Because,\n    bemptyv: bemptyv,\n    bepsi: bepsi,\n    bernou: bernou,\n    Bernoullis: Bernoullis,\n    Beta: Beta,\n    beta: beta,\n    beth: beth,\n    between: between,\n    Bfr: Bfr,\n    bfr: bfr,\n    bigcap: bigcap,\n    bigcirc: bigcirc,\n    bigcup: bigcup,\n    bigodot: bigodot,\n    bigoplus: bigoplus,\n    bigotimes: bigotimes,\n    bigsqcup: bigsqcup,\n    bigstar: bigstar,\n    bigtriangledown: bigtriangledown,\n    bigtriangleup: bigtriangleup,\n    biguplus: biguplus,\n    bigvee: bigvee,\n    bigwedge: bigwedge,\n    bkarow: bkarow,\n    blacklozenge: blacklozenge,\n    blacksquare: blacksquare,\n    blacktriangle: blacktriangle,\n    blacktriangledown: blacktriangledown,\n    blacktriangleleft: blacktriangleleft,\n    blacktriangleright: blacktriangleright,\n    blank: blank,\n    blk12: blk12,\n    blk14: blk14,\n    blk34: blk34,\n    block: block,\n    bne: bne,\n    bnequiv: bnequiv,\n    bNot: bNot,\n    bnot: bnot,\n    Bopf: Bopf,\n    bopf: bopf,\n    bot: bot,\n    bottom: bottom,\n    bowtie: bowtie,\n    boxbox: boxbox,\n    boxdl: boxdl,\n    boxdL: boxdL,\n    boxDl: boxDl,\n    boxDL: boxDL,\n    boxdr: boxdr,\n    boxdR: boxdR,\n    boxDr: boxDr,\n    boxDR: boxDR,\n    boxh: boxh,\n    boxH: boxH,\n    boxhd: boxhd,\n    boxHd: boxHd,\n    boxhD: boxhD,\n    boxHD: boxHD,\n    boxhu: boxhu,\n    boxHu: boxHu,\n    boxhU: boxhU,\n    boxHU: boxHU,\n    boxminus: boxminus,\n    boxplus: boxplus,\n    boxtimes: boxtimes,\n    boxul: boxul,\n    boxuL: boxuL,\n    boxUl: boxUl,\n    boxUL: boxUL,\n    boxur: boxur,\n    boxuR: boxuR,\n    boxUr: boxUr,\n    boxUR: boxUR,\n    boxv: boxv,\n    boxV: boxV,\n    boxvh: boxvh,\n    boxvH: boxvH,\n    boxVh: boxVh,\n    boxVH: boxVH,\n    boxvl: boxvl,\n    boxvL: boxvL,\n    boxVl: boxVl,\n    boxVL: boxVL,\n    boxvr: boxvr,\n    boxvR: boxvR,\n    boxVr: boxVr,\n    boxVR: boxVR,\n    bprime: bprime,\n    breve: breve,\n    Breve: Breve,\n    brvbar: brvbar$1,\n    bscr: bscr,\n    Bscr: Bscr,\n    bsemi: bsemi,\n    bsim: bsim,\n    bsime: bsime,\n    bsolb: bsolb,\n    bsol: bsol,\n    bsolhsub: bsolhsub,\n    bull: bull,\n    bullet: bullet,\n    bump: bump,\n    bumpE: bumpE,\n    bumpe: bumpe,\n    Bumpeq: Bumpeq,\n    bumpeq: bumpeq,\n    Cacute: Cacute,\n    cacute: cacute,\n    capand: capand,\n    capbrcup: capbrcup,\n    capcap: capcap,\n    cap: cap,\n    Cap: Cap,\n    capcup: capcup,\n    capdot: capdot,\n    CapitalDifferentialD: CapitalDifferentialD,\n    caps: caps,\n    caret: caret,\n    caron: caron,\n    Cayleys: Cayleys,\n    ccaps: ccaps,\n    Ccaron: Ccaron,\n    ccaron: ccaron,\n    Ccedil: Ccedil$1,\n    ccedil: ccedil$1,\n    Ccirc: Ccirc,\n    ccirc: ccirc,\n    Cconint: Cconint,\n    ccups: ccups,\n    ccupssm: ccupssm,\n    Cdot: Cdot,\n    cdot: cdot,\n    cedil: cedil$1,\n    Cedilla: Cedilla,\n    cemptyv: cemptyv,\n    cent: cent$1,\n    centerdot: centerdot,\n    CenterDot: CenterDot,\n    cfr: cfr,\n    Cfr: Cfr,\n    CHcy: CHcy,\n    chcy: chcy,\n    check: check,\n    checkmark: checkmark,\n    Chi: Chi,\n    chi: chi,\n    circ: circ,\n    circeq: circeq,\n    circlearrowleft: circlearrowleft,\n    circlearrowright: circlearrowright,\n    circledast: circledast,\n    circledcirc: circledcirc,\n    circleddash: circleddash,\n    CircleDot: CircleDot,\n    circledR: circledR,\n    circledS: circledS,\n    CircleMinus: CircleMinus,\n    CirclePlus: CirclePlus,\n    CircleTimes: CircleTimes,\n    cir: cir,\n    cirE: cirE,\n    cire: cire,\n    cirfnint: cirfnint,\n    cirmid: cirmid,\n    cirscir: cirscir,\n    ClockwiseContourIntegral: ClockwiseContourIntegral,\n    CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,\n    CloseCurlyQuote: CloseCurlyQuote,\n    clubs: clubs,\n    clubsuit: clubsuit,\n    colon: colon,\n    Colon: Colon,\n    Colone: Colone,\n    colone: colone,\n    coloneq: coloneq,\n    comma: comma,\n    commat: commat,\n    comp: comp,\n    compfn: compfn,\n    complement: complement,\n    complexes: complexes,\n    cong: cong,\n    congdot: congdot,\n    Congruent: Congruent,\n    conint: conint,\n    Conint: Conint,\n    ContourIntegral: ContourIntegral,\n    copf: copf,\n    Copf: Copf,\n    coprod: coprod,\n    Coproduct: Coproduct,\n    copy: copy$1,\n    COPY: COPY$1,\n    copysr: copysr,\n    CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,\n    crarr: crarr,\n    cross: cross,\n    Cross: Cross,\n    Cscr: Cscr,\n    cscr: cscr,\n    csub: csub,\n    csube: csube,\n    csup: csup,\n    csupe: csupe,\n    ctdot: ctdot,\n    cudarrl: cudarrl,\n    cudarrr: cudarrr,\n    cuepr: cuepr,\n    cuesc: cuesc,\n    cularr: cularr,\n    cularrp: cularrp,\n    cupbrcap: cupbrcap,\n    cupcap: cupcap,\n    CupCap: CupCap,\n    cup: cup,\n    Cup: Cup,\n    cupcup: cupcup,\n    cupdot: cupdot,\n    cupor: cupor,\n    cups: cups,\n    curarr: curarr,\n    curarrm: curarrm,\n    curlyeqprec: curlyeqprec,\n    curlyeqsucc: curlyeqsucc,\n    curlyvee: curlyvee,\n    curlywedge: curlywedge,\n    curren: curren$1,\n    curvearrowleft: curvearrowleft,\n    curvearrowright: curvearrowright,\n    cuvee: cuvee,\n    cuwed: cuwed,\n    cwconint: cwconint,\n    cwint: cwint,\n    cylcty: cylcty,\n    dagger: dagger,\n    Dagger: Dagger,\n    daleth: daleth,\n    darr: darr,\n    Darr: Darr,\n    dArr: dArr,\n    dash: dash,\n    Dashv: Dashv,\n    dashv: dashv,\n    dbkarow: dbkarow,\n    dblac: dblac,\n    Dcaron: Dcaron,\n    dcaron: dcaron,\n    Dcy: Dcy,\n    dcy: dcy,\n    ddagger: ddagger,\n    ddarr: ddarr,\n    DD: DD,\n    dd: dd,\n    DDotrahd: DDotrahd,\n    ddotseq: ddotseq,\n    deg: deg$1,\n    Del: Del,\n    Delta: Delta,\n    delta: delta,\n    demptyv: demptyv,\n    dfisht: dfisht,\n    Dfr: Dfr,\n    dfr: dfr,\n    dHar: dHar,\n    dharl: dharl,\n    dharr: dharr,\n    DiacriticalAcute: DiacriticalAcute,\n    DiacriticalDot: DiacriticalDot,\n    DiacriticalDoubleAcute: DiacriticalDoubleAcute,\n    DiacriticalGrave: DiacriticalGrave,\n    DiacriticalTilde: DiacriticalTilde,\n    diam: diam,\n    diamond: diamond,\n    Diamond: Diamond,\n    diamondsuit: diamondsuit,\n    diams: diams,\n    die: die,\n    DifferentialD: DifferentialD,\n    digamma: digamma,\n    disin: disin,\n    div: div,\n    divide: divide$1,\n    divideontimes: divideontimes,\n    divonx: divonx,\n    DJcy: DJcy,\n    djcy: djcy,\n    dlcorn: dlcorn,\n    dlcrop: dlcrop,\n    dollar: dollar,\n    Dopf: Dopf,\n    dopf: dopf,\n    Dot: Dot,\n    dot: dot,\n    DotDot: DotDot,\n    doteq: doteq,\n    doteqdot: doteqdot,\n    DotEqual: DotEqual,\n    dotminus: dotminus,\n    dotplus: dotplus,\n    dotsquare: dotsquare,\n    doublebarwedge: doublebarwedge,\n    DoubleContourIntegral: DoubleContourIntegral,\n    DoubleDot: DoubleDot,\n    DoubleDownArrow: DoubleDownArrow,\n    DoubleLeftArrow: DoubleLeftArrow,\n    DoubleLeftRightArrow: DoubleLeftRightArrow,\n    DoubleLeftTee: DoubleLeftTee,\n    DoubleLongLeftArrow: DoubleLongLeftArrow,\n    DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,\n    DoubleLongRightArrow: DoubleLongRightArrow,\n    DoubleRightArrow: DoubleRightArrow,\n    DoubleRightTee: DoubleRightTee,\n    DoubleUpArrow: DoubleUpArrow,\n    DoubleUpDownArrow: DoubleUpDownArrow,\n    DoubleVerticalBar: DoubleVerticalBar,\n    DownArrowBar: DownArrowBar,\n    downarrow: downarrow,\n    DownArrow: DownArrow,\n    Downarrow: Downarrow,\n    DownArrowUpArrow: DownArrowUpArrow,\n    DownBreve: DownBreve,\n    downdownarrows: downdownarrows,\n    downharpoonleft: downharpoonleft,\n    downharpoonright: downharpoonright,\n    DownLeftRightVector: DownLeftRightVector,\n    DownLeftTeeVector: DownLeftTeeVector,\n    DownLeftVectorBar: DownLeftVectorBar,\n    DownLeftVector: DownLeftVector,\n    DownRightTeeVector: DownRightTeeVector,\n    DownRightVectorBar: DownRightVectorBar,\n    DownRightVector: DownRightVector,\n    DownTeeArrow: DownTeeArrow,\n    DownTee: DownTee,\n    drbkarow: drbkarow,\n    drcorn: drcorn,\n    drcrop: drcrop,\n    Dscr: Dscr,\n    dscr: dscr,\n    DScy: DScy,\n    dscy: dscy,\n    dsol: dsol,\n    Dstrok: Dstrok,\n    dstrok: dstrok,\n    dtdot: dtdot,\n    dtri: dtri,\n    dtrif: dtrif,\n    duarr: duarr,\n    duhar: duhar,\n    dwangle: dwangle,\n    DZcy: DZcy,\n    dzcy: dzcy,\n    dzigrarr: dzigrarr,\n    Eacute: Eacute$1,\n    eacute: eacute$1,\n    easter: easter,\n    Ecaron: Ecaron,\n    ecaron: ecaron,\n    Ecirc: Ecirc$1,\n    ecirc: ecirc$1,\n    ecir: ecir,\n    ecolon: ecolon,\n    Ecy: Ecy,\n    ecy: ecy,\n    eDDot: eDDot,\n    Edot: Edot,\n    edot: edot,\n    eDot: eDot,\n    ee: ee,\n    efDot: efDot,\n    Efr: Efr,\n    efr: efr,\n    eg: eg,\n    Egrave: Egrave$1,\n    egrave: egrave$1,\n    egs: egs,\n    egsdot: egsdot,\n    el: el,\n    Element: Element,\n    elinters: elinters,\n    ell: ell,\n    els: els,\n    elsdot: elsdot,\n    Emacr: Emacr,\n    emacr: emacr,\n    empty: empty,\n    emptyset: emptyset,\n    EmptySmallSquare: EmptySmallSquare,\n    emptyv: emptyv,\n    EmptyVerySmallSquare: EmptyVerySmallSquare,\n    emsp13: emsp13,\n    emsp14: emsp14,\n    emsp: emsp,\n    ENG: ENG,\n    eng: eng,\n    ensp: ensp,\n    Eogon: Eogon,\n    eogon: eogon,\n    Eopf: Eopf,\n    eopf: eopf,\n    epar: epar,\n    eparsl: eparsl,\n    eplus: eplus,\n    epsi: epsi,\n    Epsilon: Epsilon,\n    epsilon: epsilon,\n    epsiv: epsiv,\n    eqcirc: eqcirc,\n    eqcolon: eqcolon,\n    eqsim: eqsim,\n    eqslantgtr: eqslantgtr,\n    eqslantless: eqslantless,\n    Equal: Equal,\n    equals: equals,\n    EqualTilde: EqualTilde,\n    equest: equest,\n    Equilibrium: Equilibrium,\n    equiv: equiv,\n    equivDD: equivDD,\n    eqvparsl: eqvparsl,\n    erarr: erarr,\n    erDot: erDot,\n    escr: escr,\n    Escr: Escr,\n    esdot: esdot,\n    Esim: Esim,\n    esim: esim,\n    Eta: Eta,\n    eta: eta,\n    ETH: ETH$1,\n    eth: eth$1,\n    Euml: Euml$1,\n    euml: euml$1,\n    euro: euro,\n    excl: excl,\n    exist: exist,\n    Exists: Exists,\n    expectation: expectation,\n    exponentiale: exponentiale,\n    ExponentialE: ExponentialE,\n    fallingdotseq: fallingdotseq,\n    Fcy: Fcy,\n    fcy: fcy,\n    female: female,\n    ffilig: ffilig,\n    fflig: fflig,\n    ffllig: ffllig,\n    Ffr: Ffr,\n    ffr: ffr,\n    filig: filig,\n    FilledSmallSquare: FilledSmallSquare,\n    FilledVerySmallSquare: FilledVerySmallSquare,\n    fjlig: fjlig,\n    flat: flat,\n    fllig: fllig,\n    fltns: fltns,\n    fnof: fnof,\n    Fopf: Fopf,\n    fopf: fopf,\n    forall: forall,\n    ForAll: ForAll,\n    fork: fork,\n    forkv: forkv,\n    Fouriertrf: Fouriertrf,\n    fpartint: fpartint,\n    frac12: frac12$1,\n    frac13: frac13,\n    frac14: frac14$1,\n    frac15: frac15,\n    frac16: frac16,\n    frac18: frac18,\n    frac23: frac23,\n    frac25: frac25,\n    frac34: frac34$1,\n    frac35: frac35,\n    frac38: frac38,\n    frac45: frac45,\n    frac56: frac56,\n    frac58: frac58,\n    frac78: frac78,\n    frasl: frasl,\n    frown: frown,\n    fscr: fscr,\n    Fscr: Fscr,\n    gacute: gacute,\n    Gamma: Gamma,\n    gamma: gamma,\n    Gammad: Gammad,\n    gammad: gammad,\n    gap: gap,\n    Gbreve: Gbreve,\n    gbreve: gbreve,\n    Gcedil: Gcedil,\n    Gcirc: Gcirc,\n    gcirc: gcirc,\n    Gcy: Gcy,\n    gcy: gcy,\n    Gdot: Gdot,\n    gdot: gdot,\n    ge: ge,\n    gE: gE,\n    gEl: gEl,\n    gel: gel,\n    geq: geq,\n    geqq: geqq,\n    geqslant: geqslant,\n    gescc: gescc,\n    ges: ges,\n    gesdot: gesdot,\n    gesdoto: gesdoto,\n    gesdotol: gesdotol,\n    gesl: gesl,\n    gesles: gesles,\n    Gfr: Gfr,\n    gfr: gfr,\n    gg: gg,\n    Gg: Gg,\n    ggg: ggg,\n    gimel: gimel,\n    GJcy: GJcy,\n    gjcy: gjcy,\n    gla: gla,\n    gl: gl,\n    glE: glE,\n    glj: glj,\n    gnap: gnap,\n    gnapprox: gnapprox,\n    gne: gne,\n    gnE: gnE,\n    gneq: gneq,\n    gneqq: gneqq,\n    gnsim: gnsim,\n    Gopf: Gopf,\n    gopf: gopf,\n    grave: grave,\n    GreaterEqual: GreaterEqual,\n    GreaterEqualLess: GreaterEqualLess,\n    GreaterFullEqual: GreaterFullEqual,\n    GreaterGreater: GreaterGreater,\n    GreaterLess: GreaterLess,\n    GreaterSlantEqual: GreaterSlantEqual,\n    GreaterTilde: GreaterTilde,\n    Gscr: Gscr,\n    gscr: gscr,\n    gsim: gsim,\n    gsime: gsime,\n    gsiml: gsiml,\n    gtcc: gtcc,\n    gtcir: gtcir,\n    gt: gt$2,\n    GT: GT$1,\n    Gt: Gt,\n    gtdot: gtdot,\n    gtlPar: gtlPar,\n    gtquest: gtquest,\n    gtrapprox: gtrapprox,\n    gtrarr: gtrarr,\n    gtrdot: gtrdot,\n    gtreqless: gtreqless,\n    gtreqqless: gtreqqless,\n    gtrless: gtrless,\n    gtrsim: gtrsim,\n    gvertneqq: gvertneqq,\n    gvnE: gvnE,\n    Hacek: Hacek,\n    hairsp: hairsp,\n    half: half,\n    hamilt: hamilt,\n    HARDcy: HARDcy,\n    hardcy: hardcy,\n    harrcir: harrcir,\n    harr: harr,\n    hArr: hArr,\n    harrw: harrw,\n    Hat: Hat,\n    hbar: hbar,\n    Hcirc: Hcirc,\n    hcirc: hcirc,\n    hearts: hearts,\n    heartsuit: heartsuit,\n    hellip: hellip,\n    hercon: hercon,\n    hfr: hfr,\n    Hfr: Hfr,\n    HilbertSpace: HilbertSpace,\n    hksearow: hksearow,\n    hkswarow: hkswarow,\n    hoarr: hoarr,\n    homtht: homtht,\n    hookleftarrow: hookleftarrow,\n    hookrightarrow: hookrightarrow,\n    hopf: hopf,\n    Hopf: Hopf,\n    horbar: horbar,\n    HorizontalLine: HorizontalLine,\n    hscr: hscr,\n    Hscr: Hscr,\n    hslash: hslash,\n    Hstrok: Hstrok,\n    hstrok: hstrok,\n    HumpDownHump: HumpDownHump,\n    HumpEqual: HumpEqual,\n    hybull: hybull,\n    hyphen: hyphen,\n    Iacute: Iacute$1,\n    iacute: iacute$1,\n    ic: ic,\n    Icirc: Icirc$1,\n    icirc: icirc$1,\n    Icy: Icy,\n    icy: icy,\n    Idot: Idot,\n    IEcy: IEcy,\n    iecy: iecy,\n    iexcl: iexcl$1,\n    iff: iff,\n    ifr: ifr,\n    Ifr: Ifr,\n    Igrave: Igrave$1,\n    igrave: igrave$1,\n    ii: ii,\n    iiiint: iiiint,\n    iiint: iiint,\n    iinfin: iinfin,\n    iiota: iiota,\n    IJlig: IJlig,\n    ijlig: ijlig,\n    Imacr: Imacr,\n    imacr: imacr,\n    image: esm_image,\n    ImaginaryI: ImaginaryI,\n    imagline: imagline,\n    imagpart: imagpart,\n    imath: imath,\n    Im: Im,\n    imof: imof,\n    imped: imped,\n    Implies: Implies,\n    incare: incare,\n    \"in\": \"∈\",\n    infin: infin,\n    infintie: infintie,\n    inodot: inodot,\n    intcal: intcal,\n    int: esm_int,\n    Int: Int,\n    integers: integers,\n    Integral: Integral,\n    intercal: intercal,\n    Intersection: Intersection,\n    intlarhk: intlarhk,\n    intprod: intprod,\n    InvisibleComma: InvisibleComma,\n    InvisibleTimes: InvisibleTimes,\n    IOcy: IOcy,\n    iocy: iocy,\n    Iogon: Iogon,\n    iogon: iogon,\n    Iopf: Iopf,\n    iopf: iopf,\n    Iota: Iota,\n    iota: iota,\n    iprod: iprod,\n    iquest: iquest$1,\n    iscr: iscr,\n    Iscr: Iscr,\n    isin: isin,\n    isindot: isindot,\n    isinE: isinE,\n    isins: isins,\n    isinsv: isinsv,\n    isinv: isinv,\n    it: it,\n    Itilde: Itilde,\n    itilde: itilde,\n    Iukcy: Iukcy,\n    iukcy: iukcy,\n    Iuml: Iuml$1,\n    iuml: iuml$1,\n    Jcirc: Jcirc,\n    jcirc: jcirc,\n    Jcy: Jcy,\n    jcy: jcy,\n    Jfr: Jfr,\n    jfr: jfr,\n    jmath: jmath,\n    Jopf: Jopf,\n    jopf: jopf,\n    Jscr: Jscr,\n    jscr: jscr,\n    Jsercy: Jsercy,\n    jsercy: jsercy,\n    Jukcy: Jukcy,\n    jukcy: jukcy,\n    Kappa: Kappa,\n    kappa: kappa,\n    kappav: kappav,\n    Kcedil: Kcedil,\n    kcedil: kcedil,\n    Kcy: Kcy,\n    kcy: kcy,\n    Kfr: Kfr,\n    kfr: kfr,\n    kgreen: kgreen,\n    KHcy: KHcy,\n    khcy: khcy,\n    KJcy: KJcy,\n    kjcy: kjcy,\n    Kopf: Kopf,\n    kopf: kopf,\n    Kscr: Kscr,\n    kscr: kscr,\n    lAarr: lAarr,\n    Lacute: Lacute,\n    lacute: lacute,\n    laemptyv: laemptyv,\n    lagran: lagran,\n    Lambda: Lambda,\n    lambda: lambda,\n    lang: lang,\n    Lang: Lang,\n    langd: langd,\n    langle: langle,\n    lap: lap,\n    Laplacetrf: Laplacetrf,\n    laquo: laquo$1,\n    larrb: larrb,\n    larrbfs: larrbfs,\n    larr: larr,\n    Larr: Larr,\n    lArr: lArr,\n    larrfs: larrfs,\n    larrhk: larrhk,\n    larrlp: larrlp,\n    larrpl: larrpl,\n    larrsim: larrsim,\n    larrtl: larrtl,\n    latail: latail,\n    lAtail: lAtail,\n    lat: lat,\n    late: late,\n    lates: lates,\n    lbarr: lbarr,\n    lBarr: lBarr,\n    lbbrk: lbbrk,\n    lbrace: lbrace,\n    lbrack: lbrack,\n    lbrke: lbrke,\n    lbrksld: lbrksld,\n    lbrkslu: lbrkslu,\n    Lcaron: Lcaron,\n    lcaron: lcaron,\n    Lcedil: Lcedil,\n    lcedil: lcedil,\n    lceil: lceil,\n    lcub: lcub,\n    Lcy: Lcy,\n    lcy: lcy,\n    ldca: ldca,\n    ldquo: ldquo,\n    ldquor: ldquor,\n    ldrdhar: ldrdhar,\n    ldrushar: ldrushar,\n    ldsh: ldsh,\n    le: le,\n    lE: lE,\n    LeftAngleBracket: LeftAngleBracket,\n    LeftArrowBar: LeftArrowBar,\n    leftarrow: leftarrow,\n    LeftArrow: LeftArrow,\n    Leftarrow: Leftarrow,\n    LeftArrowRightArrow: LeftArrowRightArrow,\n    leftarrowtail: leftarrowtail,\n    LeftCeiling: LeftCeiling,\n    LeftDoubleBracket: LeftDoubleBracket,\n    LeftDownTeeVector: LeftDownTeeVector,\n    LeftDownVectorBar: LeftDownVectorBar,\n    LeftDownVector: LeftDownVector,\n    LeftFloor: LeftFloor,\n    leftharpoondown: leftharpoondown,\n    leftharpoonup: leftharpoonup,\n    leftleftarrows: leftleftarrows,\n    leftrightarrow: leftrightarrow,\n    LeftRightArrow: LeftRightArrow,\n    Leftrightarrow: Leftrightarrow,\n    leftrightarrows: leftrightarrows,\n    leftrightharpoons: leftrightharpoons,\n    leftrightsquigarrow: leftrightsquigarrow,\n    LeftRightVector: LeftRightVector,\n    LeftTeeArrow: LeftTeeArrow,\n    LeftTee: LeftTee,\n    LeftTeeVector: LeftTeeVector,\n    leftthreetimes: leftthreetimes,\n    LeftTriangleBar: LeftTriangleBar,\n    LeftTriangle: LeftTriangle,\n    LeftTriangleEqual: LeftTriangleEqual,\n    LeftUpDownVector: LeftUpDownVector,\n    LeftUpTeeVector: LeftUpTeeVector,\n    LeftUpVectorBar: LeftUpVectorBar,\n    LeftUpVector: LeftUpVector,\n    LeftVectorBar: LeftVectorBar,\n    LeftVector: LeftVector,\n    lEg: lEg,\n    leg: leg,\n    leq: leq,\n    leqq: leqq,\n    leqslant: leqslant,\n    lescc: lescc,\n    les: les,\n    lesdot: lesdot,\n    lesdoto: lesdoto,\n    lesdotor: lesdotor,\n    lesg: lesg,\n    lesges: lesges,\n    lessapprox: lessapprox,\n    lessdot: lessdot,\n    lesseqgtr: lesseqgtr,\n    lesseqqgtr: lesseqqgtr,\n    LessEqualGreater: LessEqualGreater,\n    LessFullEqual: LessFullEqual,\n    LessGreater: LessGreater,\n    lessgtr: lessgtr,\n    LessLess: LessLess,\n    lesssim: lesssim,\n    LessSlantEqual: LessSlantEqual,\n    LessTilde: LessTilde,\n    lfisht: lfisht,\n    lfloor: lfloor,\n    Lfr: Lfr,\n    lfr: lfr,\n    lg: lg,\n    lgE: lgE,\n    lHar: lHar,\n    lhard: lhard,\n    lharu: lharu,\n    lharul: lharul,\n    lhblk: lhblk,\n    LJcy: LJcy,\n    ljcy: ljcy,\n    llarr: llarr,\n    ll: ll,\n    Ll: Ll,\n    llcorner: llcorner,\n    Lleftarrow: Lleftarrow,\n    llhard: llhard,\n    lltri: lltri,\n    Lmidot: Lmidot,\n    lmidot: lmidot,\n    lmoustache: lmoustache,\n    lmoust: lmoust,\n    lnap: lnap,\n    lnapprox: lnapprox,\n    lne: lne,\n    lnE: lnE,\n    lneq: lneq,\n    lneqq: lneqq,\n    lnsim: lnsim,\n    loang: loang,\n    loarr: loarr,\n    lobrk: lobrk,\n    longleftarrow: longleftarrow,\n    LongLeftArrow: LongLeftArrow,\n    Longleftarrow: Longleftarrow,\n    longleftrightarrow: longleftrightarrow,\n    LongLeftRightArrow: LongLeftRightArrow,\n    Longleftrightarrow: Longleftrightarrow,\n    longmapsto: longmapsto,\n    longrightarrow: longrightarrow,\n    LongRightArrow: LongRightArrow,\n    Longrightarrow: Longrightarrow,\n    looparrowleft: looparrowleft,\n    looparrowright: looparrowright,\n    lopar: lopar,\n    Lopf: Lopf,\n    lopf: lopf,\n    loplus: loplus,\n    lotimes: lotimes,\n    lowast: lowast,\n    lowbar: lowbar,\n    LowerLeftArrow: LowerLeftArrow,\n    LowerRightArrow: LowerRightArrow,\n    loz: loz,\n    lozenge: lozenge,\n    lozf: lozf,\n    lpar: lpar,\n    lparlt: lparlt,\n    lrarr: lrarr,\n    lrcorner: lrcorner,\n    lrhar: lrhar,\n    lrhard: lrhard,\n    lrm: lrm,\n    lrtri: lrtri,\n    lsaquo: lsaquo,\n    lscr: lscr,\n    Lscr: Lscr,\n    lsh: lsh,\n    Lsh: Lsh,\n    lsim: lsim,\n    lsime: lsime,\n    lsimg: lsimg,\n    lsqb: lsqb,\n    lsquo: lsquo,\n    lsquor: lsquor,\n    Lstrok: Lstrok,\n    lstrok: lstrok,\n    ltcc: ltcc,\n    ltcir: ltcir,\n    lt: lt$2,\n    LT: LT$1,\n    Lt: Lt,\n    ltdot: ltdot,\n    lthree: lthree,\n    ltimes: ltimes,\n    ltlarr: ltlarr,\n    ltquest: ltquest,\n    ltri: ltri,\n    ltrie: ltrie,\n    ltrif: ltrif,\n    ltrPar: ltrPar,\n    lurdshar: lurdshar,\n    luruhar: luruhar,\n    lvertneqq: lvertneqq,\n    lvnE: lvnE,\n    macr: macr$1,\n    male: male,\n    malt: malt,\n    maltese: maltese,\n    \"Map\": \"⤅\",\n    map: map,\n    mapsto: mapsto,\n    mapstodown: mapstodown,\n    mapstoleft: mapstoleft,\n    mapstoup: mapstoup,\n    marker: marker,\n    mcomma: mcomma,\n    Mcy: Mcy,\n    mcy: mcy,\n    mdash: mdash,\n    mDDot: mDDot,\n    measuredangle: measuredangle,\n    MediumSpace: MediumSpace,\n    Mellintrf: Mellintrf,\n    Mfr: Mfr,\n    mfr: mfr,\n    mho: mho,\n    micro: micro$1,\n    midast: midast,\n    midcir: midcir,\n    mid: mid,\n    middot: middot$1,\n    minusb: minusb,\n    minus: minus,\n    minusd: minusd,\n    minusdu: minusdu,\n    MinusPlus: MinusPlus,\n    mlcp: mlcp,\n    mldr: mldr,\n    mnplus: mnplus,\n    models: models,\n    Mopf: Mopf,\n    mopf: mopf,\n    mp: mp,\n    mscr: mscr,\n    Mscr: Mscr,\n    mstpos: mstpos,\n    Mu: Mu,\n    mu: mu,\n    multimap: multimap,\n    mumap: mumap,\n    nabla: nabla,\n    Nacute: Nacute,\n    nacute: nacute,\n    nang: nang,\n    nap: nap,\n    napE: napE,\n    napid: napid,\n    napos: napos,\n    napprox: napprox,\n    natural: natural,\n    naturals: naturals,\n    natur: natur,\n    nbsp: nbsp$1,\n    nbump: nbump,\n    nbumpe: nbumpe,\n    ncap: ncap,\n    Ncaron: Ncaron,\n    ncaron: ncaron,\n    Ncedil: Ncedil,\n    ncedil: ncedil,\n    ncong: ncong,\n    ncongdot: ncongdot,\n    ncup: ncup,\n    Ncy: Ncy,\n    ncy: ncy,\n    ndash: ndash,\n    nearhk: nearhk,\n    nearr: nearr,\n    neArr: neArr,\n    nearrow: nearrow,\n    ne: ne,\n    nedot: nedot,\n    NegativeMediumSpace: NegativeMediumSpace,\n    NegativeThickSpace: NegativeThickSpace,\n    NegativeThinSpace: NegativeThinSpace,\n    NegativeVeryThinSpace: NegativeVeryThinSpace,\n    nequiv: nequiv,\n    nesear: nesear,\n    nesim: nesim,\n    NestedGreaterGreater: NestedGreaterGreater,\n    NestedLessLess: NestedLessLess,\n    NewLine: NewLine,\n    nexist: nexist,\n    nexists: nexists,\n    Nfr: Nfr,\n    nfr: nfr,\n    ngE: ngE,\n    nge: nge,\n    ngeq: ngeq,\n    ngeqq: ngeqq,\n    ngeqslant: ngeqslant,\n    nges: nges,\n    nGg: nGg,\n    ngsim: ngsim,\n    nGt: nGt,\n    ngt: ngt,\n    ngtr: ngtr,\n    nGtv: nGtv,\n    nharr: nharr,\n    nhArr: nhArr,\n    nhpar: nhpar,\n    ni: ni,\n    nis: nis,\n    nisd: nisd,\n    niv: niv,\n    NJcy: NJcy,\n    njcy: njcy,\n    nlarr: nlarr,\n    nlArr: nlArr,\n    nldr: nldr,\n    nlE: nlE,\n    nle: nle,\n    nleftarrow: nleftarrow,\n    nLeftarrow: nLeftarrow,\n    nleftrightarrow: nleftrightarrow,\n    nLeftrightarrow: nLeftrightarrow,\n    nleq: nleq,\n    nleqq: nleqq,\n    nleqslant: nleqslant,\n    nles: nles,\n    nless: nless,\n    nLl: nLl,\n    nlsim: nlsim,\n    nLt: nLt,\n    nlt: nlt,\n    nltri: nltri,\n    nltrie: nltrie,\n    nLtv: nLtv,\n    nmid: nmid,\n    NoBreak: NoBreak,\n    NonBreakingSpace: NonBreakingSpace,\n    nopf: nopf,\n    Nopf: Nopf,\n    Not: Not,\n    not: not$1,\n    NotCongruent: NotCongruent,\n    NotCupCap: NotCupCap,\n    NotDoubleVerticalBar: NotDoubleVerticalBar,\n    NotElement: NotElement,\n    NotEqual: NotEqual,\n    NotEqualTilde: NotEqualTilde,\n    NotExists: NotExists,\n    NotGreater: NotGreater,\n    NotGreaterEqual: NotGreaterEqual,\n    NotGreaterFullEqual: NotGreaterFullEqual,\n    NotGreaterGreater: NotGreaterGreater,\n    NotGreaterLess: NotGreaterLess,\n    NotGreaterSlantEqual: NotGreaterSlantEqual,\n    NotGreaterTilde: NotGreaterTilde,\n    NotHumpDownHump: NotHumpDownHump,\n    NotHumpEqual: NotHumpEqual,\n    notin: notin,\n    notindot: notindot,\n    notinE: notinE,\n    notinva: notinva,\n    notinvb: notinvb,\n    notinvc: notinvc,\n    NotLeftTriangleBar: NotLeftTriangleBar,\n    NotLeftTriangle: NotLeftTriangle,\n    NotLeftTriangleEqual: NotLeftTriangleEqual,\n    NotLess: NotLess,\n    NotLessEqual: NotLessEqual,\n    NotLessGreater: NotLessGreater,\n    NotLessLess: NotLessLess,\n    NotLessSlantEqual: NotLessSlantEqual,\n    NotLessTilde: NotLessTilde,\n    NotNestedGreaterGreater: NotNestedGreaterGreater,\n    NotNestedLessLess: NotNestedLessLess,\n    notni: notni,\n    notniva: notniva,\n    notnivb: notnivb,\n    notnivc: notnivc,\n    NotPrecedes: NotPrecedes,\n    NotPrecedesEqual: NotPrecedesEqual,\n    NotPrecedesSlantEqual: NotPrecedesSlantEqual,\n    NotReverseElement: NotReverseElement,\n    NotRightTriangleBar: NotRightTriangleBar,\n    NotRightTriangle: NotRightTriangle,\n    NotRightTriangleEqual: NotRightTriangleEqual,\n    NotSquareSubset: NotSquareSubset,\n    NotSquareSubsetEqual: NotSquareSubsetEqual,\n    NotSquareSuperset: NotSquareSuperset,\n    NotSquareSupersetEqual: NotSquareSupersetEqual,\n    NotSubset: NotSubset,\n    NotSubsetEqual: NotSubsetEqual,\n    NotSucceeds: NotSucceeds,\n    NotSucceedsEqual: NotSucceedsEqual,\n    NotSucceedsSlantEqual: NotSucceedsSlantEqual,\n    NotSucceedsTilde: NotSucceedsTilde,\n    NotSuperset: NotSuperset,\n    NotSupersetEqual: NotSupersetEqual,\n    NotTilde: NotTilde,\n    NotTildeEqual: NotTildeEqual,\n    NotTildeFullEqual: NotTildeFullEqual,\n    NotTildeTilde: NotTildeTilde,\n    NotVerticalBar: NotVerticalBar,\n    nparallel: nparallel,\n    npar: npar,\n    nparsl: nparsl,\n    npart: npart,\n    npolint: npolint,\n    npr: npr,\n    nprcue: nprcue,\n    nprec: nprec,\n    npreceq: npreceq,\n    npre: npre,\n    nrarrc: nrarrc,\n    nrarr: nrarr,\n    nrArr: nrArr,\n    nrarrw: nrarrw,\n    nrightarrow: nrightarrow,\n    nRightarrow: nRightarrow,\n    nrtri: nrtri,\n    nrtrie: nrtrie,\n    nsc: nsc,\n    nsccue: nsccue,\n    nsce: nsce,\n    Nscr: Nscr,\n    nscr: nscr,\n    nshortmid: nshortmid,\n    nshortparallel: nshortparallel,\n    nsim: nsim,\n    nsime: nsime,\n    nsimeq: nsimeq,\n    nsmid: nsmid,\n    nspar: nspar,\n    nsqsube: nsqsube,\n    nsqsupe: nsqsupe,\n    nsub: nsub,\n    nsubE: nsubE,\n    nsube: nsube,\n    nsubset: nsubset,\n    nsubseteq: nsubseteq,\n    nsubseteqq: nsubseteqq,\n    nsucc: nsucc,\n    nsucceq: nsucceq,\n    nsup: nsup,\n    nsupE: nsupE,\n    nsupe: nsupe,\n    nsupset: nsupset,\n    nsupseteq: nsupseteq,\n    nsupseteqq: nsupseteqq,\n    ntgl: ntgl,\n    Ntilde: Ntilde$1,\n    ntilde: ntilde$1,\n    ntlg: ntlg,\n    ntriangleleft: ntriangleleft,\n    ntrianglelefteq: ntrianglelefteq,\n    ntriangleright: ntriangleright,\n    ntrianglerighteq: ntrianglerighteq,\n    Nu: Nu,\n    nu: nu,\n    num: num,\n    numero: numero,\n    numsp: numsp,\n    nvap: nvap,\n    nvdash: nvdash,\n    nvDash: nvDash,\n    nVdash: nVdash,\n    nVDash: nVDash,\n    nvge: nvge,\n    nvgt: nvgt,\n    nvHarr: nvHarr,\n    nvinfin: nvinfin,\n    nvlArr: nvlArr,\n    nvle: nvle,\n    nvlt: nvlt,\n    nvltrie: nvltrie,\n    nvrArr: nvrArr,\n    nvrtrie: nvrtrie,\n    nvsim: nvsim,\n    nwarhk: nwarhk,\n    nwarr: nwarr,\n    nwArr: nwArr,\n    nwarrow: nwarrow,\n    nwnear: nwnear,\n    Oacute: Oacute$1,\n    oacute: oacute$1,\n    oast: oast,\n    Ocirc: Ocirc$1,\n    ocirc: ocirc$1,\n    ocir: ocir,\n    Ocy: Ocy,\n    ocy: ocy,\n    odash: odash,\n    Odblac: Odblac,\n    odblac: odblac,\n    odiv: odiv,\n    odot: odot,\n    odsold: odsold,\n    OElig: OElig,\n    oelig: oelig,\n    ofcir: ofcir,\n    Ofr: Ofr,\n    ofr: ofr,\n    ogon: ogon,\n    Ograve: Ograve$1,\n    ograve: ograve$1,\n    ogt: ogt,\n    ohbar: ohbar,\n    ohm: ohm,\n    oint: oint,\n    olarr: olarr,\n    olcir: olcir,\n    olcross: olcross,\n    oline: oline,\n    olt: olt,\n    Omacr: Omacr,\n    omacr: omacr,\n    Omega: Omega,\n    omega: omega,\n    Omicron: Omicron,\n    omicron: omicron,\n    omid: omid,\n    ominus: ominus,\n    Oopf: Oopf,\n    oopf: oopf,\n    opar: opar,\n    OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,\n    OpenCurlyQuote: OpenCurlyQuote,\n    operp: operp,\n    oplus: oplus,\n    orarr: orarr,\n    Or: Or,\n    or: or,\n    ord: ord,\n    order: order,\n    orderof: orderof,\n    ordf: ordf$1,\n    ordm: ordm$1,\n    origof: origof,\n    oror: oror,\n    orslope: orslope,\n    orv: orv,\n    oS: oS,\n    Oscr: Oscr,\n    oscr: oscr,\n    Oslash: Oslash$1,\n    oslash: oslash$1,\n    osol: osol,\n    Otilde: Otilde$1,\n    otilde: otilde$1,\n    otimesas: otimesas,\n    Otimes: Otimes,\n    otimes: otimes,\n    Ouml: Ouml$1,\n    ouml: ouml$1,\n    ovbar: ovbar,\n    OverBar: OverBar,\n    OverBrace: OverBrace,\n    OverBracket: OverBracket,\n    OverParenthesis: OverParenthesis,\n    para: para$1,\n    parallel: parallel,\n    par: par,\n    parsim: parsim,\n    parsl: parsl,\n    part: part,\n    PartialD: PartialD,\n    Pcy: Pcy,\n    pcy: pcy,\n    percnt: percnt,\n    period: period,\n    permil: permil,\n    perp: perp,\n    pertenk: pertenk,\n    Pfr: Pfr,\n    pfr: pfr,\n    Phi: Phi,\n    phi: phi,\n    phiv: phiv,\n    phmmat: phmmat,\n    phone: phone,\n    Pi: Pi,\n    pi: pi,\n    pitchfork: pitchfork,\n    piv: piv,\n    planck: planck,\n    planckh: planckh,\n    plankv: plankv,\n    plusacir: plusacir,\n    plusb: plusb,\n    pluscir: pluscir,\n    plus: plus,\n    plusdo: plusdo,\n    plusdu: plusdu,\n    pluse: pluse,\n    PlusMinus: PlusMinus,\n    plusmn: plusmn$1,\n    plussim: plussim,\n    plustwo: plustwo,\n    pm: pm,\n    Poincareplane: Poincareplane,\n    pointint: pointint,\n    popf: popf,\n    Popf: Popf,\n    pound: pound$1,\n    prap: prap,\n    Pr: Pr,\n    pr: pr,\n    prcue: prcue,\n    precapprox: precapprox,\n    prec: prec,\n    preccurlyeq: preccurlyeq,\n    Precedes: Precedes,\n    PrecedesEqual: PrecedesEqual,\n    PrecedesSlantEqual: PrecedesSlantEqual,\n    PrecedesTilde: PrecedesTilde,\n    preceq: preceq,\n    precnapprox: precnapprox,\n    precneqq: precneqq,\n    precnsim: precnsim,\n    pre: pre,\n    prE: prE,\n    precsim: precsim,\n    prime: prime,\n    Prime: Prime,\n    primes: primes,\n    prnap: prnap,\n    prnE: prnE,\n    prnsim: prnsim,\n    prod: prod,\n    Product: Product,\n    profalar: profalar,\n    profline: profline,\n    profsurf: profsurf,\n    prop: prop,\n    Proportional: Proportional,\n    Proportion: Proportion,\n    propto: propto,\n    prsim: prsim,\n    prurel: prurel,\n    Pscr: Pscr,\n    pscr: pscr,\n    Psi: Psi,\n    psi: psi,\n    puncsp: puncsp,\n    Qfr: Qfr,\n    qfr: qfr,\n    qint: qint,\n    qopf: qopf,\n    Qopf: Qopf,\n    qprime: qprime,\n    Qscr: Qscr,\n    qscr: qscr,\n    quaternions: quaternions,\n    quatint: quatint,\n    quest: quest,\n    questeq: questeq,\n    quot: quot$2,\n    QUOT: QUOT$1,\n    rAarr: rAarr,\n    race: race,\n    Racute: Racute,\n    racute: racute,\n    radic: radic,\n    raemptyv: raemptyv,\n    rang: rang,\n    Rang: Rang,\n    rangd: rangd,\n    range: range,\n    rangle: rangle,\n    raquo: raquo$1,\n    rarrap: rarrap,\n    rarrb: rarrb,\n    rarrbfs: rarrbfs,\n    rarrc: rarrc,\n    rarr: rarr,\n    Rarr: Rarr,\n    rArr: rArr,\n    rarrfs: rarrfs,\n    rarrhk: rarrhk,\n    rarrlp: rarrlp,\n    rarrpl: rarrpl,\n    rarrsim: rarrsim,\n    Rarrtl: Rarrtl,\n    rarrtl: rarrtl,\n    rarrw: rarrw,\n    ratail: ratail,\n    rAtail: rAtail,\n    ratio: ratio,\n    rationals: rationals,\n    rbarr: rbarr,\n    rBarr: rBarr,\n    RBarr: RBarr,\n    rbbrk: rbbrk,\n    rbrace: rbrace,\n    rbrack: rbrack,\n    rbrke: rbrke,\n    rbrksld: rbrksld,\n    rbrkslu: rbrkslu,\n    Rcaron: Rcaron,\n    rcaron: rcaron,\n    Rcedil: Rcedil,\n    rcedil: rcedil,\n    rceil: rceil,\n    rcub: rcub,\n    Rcy: Rcy,\n    rcy: rcy,\n    rdca: rdca,\n    rdldhar: rdldhar,\n    rdquo: rdquo,\n    rdquor: rdquor,\n    rdsh: rdsh,\n    real: real,\n    realine: realine,\n    realpart: realpart,\n    reals: reals,\n    Re: Re,\n    rect: rect,\n    reg: reg$1,\n    REG: REG$1,\n    ReverseElement: ReverseElement,\n    ReverseEquilibrium: ReverseEquilibrium,\n    ReverseUpEquilibrium: ReverseUpEquilibrium,\n    rfisht: rfisht,\n    rfloor: rfloor,\n    rfr: rfr,\n    Rfr: Rfr,\n    rHar: rHar,\n    rhard: rhard,\n    rharu: rharu,\n    rharul: rharul,\n    Rho: Rho,\n    rho: rho,\n    rhov: rhov,\n    RightAngleBracket: RightAngleBracket,\n    RightArrowBar: RightArrowBar,\n    rightarrow: rightarrow,\n    RightArrow: RightArrow,\n    Rightarrow: Rightarrow,\n    RightArrowLeftArrow: RightArrowLeftArrow,\n    rightarrowtail: rightarrowtail,\n    RightCeiling: RightCeiling,\n    RightDoubleBracket: RightDoubleBracket,\n    RightDownTeeVector: RightDownTeeVector,\n    RightDownVectorBar: RightDownVectorBar,\n    RightDownVector: RightDownVector,\n    RightFloor: RightFloor,\n    rightharpoondown: rightharpoondown,\n    rightharpoonup: rightharpoonup,\n    rightleftarrows: rightleftarrows,\n    rightleftharpoons: rightleftharpoons,\n    rightrightarrows: rightrightarrows,\n    rightsquigarrow: rightsquigarrow,\n    RightTeeArrow: RightTeeArrow,\n    RightTee: RightTee,\n    RightTeeVector: RightTeeVector,\n    rightthreetimes: rightthreetimes,\n    RightTriangleBar: RightTriangleBar,\n    RightTriangle: RightTriangle,\n    RightTriangleEqual: RightTriangleEqual,\n    RightUpDownVector: RightUpDownVector,\n    RightUpTeeVector: RightUpTeeVector,\n    RightUpVectorBar: RightUpVectorBar,\n    RightUpVector: RightUpVector,\n    RightVectorBar: RightVectorBar,\n    RightVector: RightVector,\n    ring: ring,\n    risingdotseq: risingdotseq,\n    rlarr: rlarr,\n    rlhar: rlhar,\n    rlm: rlm,\n    rmoustache: rmoustache,\n    rmoust: rmoust,\n    rnmid: rnmid,\n    roang: roang,\n    roarr: roarr,\n    robrk: robrk,\n    ropar: ropar,\n    ropf: ropf,\n    Ropf: Ropf,\n    roplus: roplus,\n    rotimes: rotimes,\n    RoundImplies: RoundImplies,\n    rpar: rpar,\n    rpargt: rpargt,\n    rppolint: rppolint,\n    rrarr: rrarr,\n    Rrightarrow: Rrightarrow,\n    rsaquo: rsaquo,\n    rscr: rscr,\n    Rscr: Rscr,\n    rsh: rsh,\n    Rsh: Rsh,\n    rsqb: rsqb,\n    rsquo: rsquo,\n    rsquor: rsquor,\n    rthree: rthree,\n    rtimes: rtimes,\n    rtri: rtri,\n    rtrie: rtrie,\n    rtrif: rtrif,\n    rtriltri: rtriltri,\n    RuleDelayed: RuleDelayed,\n    ruluhar: ruluhar,\n    rx: rx,\n    Sacute: Sacute,\n    sacute: sacute,\n    sbquo: sbquo,\n    scap: scap,\n    Scaron: Scaron,\n    scaron: scaron,\n    Sc: Sc,\n    sc: sc,\n    sccue: sccue,\n    sce: sce,\n    scE: scE,\n    Scedil: Scedil,\n    scedil: scedil,\n    Scirc: Scirc,\n    scirc: scirc,\n    scnap: scnap,\n    scnE: scnE,\n    scnsim: scnsim,\n    scpolint: scpolint,\n    scsim: scsim,\n    Scy: Scy,\n    scy: scy,\n    sdotb: sdotb,\n    sdot: sdot,\n    sdote: sdote,\n    searhk: searhk,\n    searr: searr,\n    seArr: seArr,\n    searrow: searrow,\n    sect: sect$1,\n    semi: semi,\n    seswar: seswar,\n    setminus: setminus,\n    setmn: setmn,\n    sext: sext,\n    Sfr: Sfr,\n    sfr: sfr,\n    sfrown: sfrown,\n    sharp: sharp,\n    SHCHcy: SHCHcy,\n    shchcy: shchcy,\n    SHcy: SHcy,\n    shcy: shcy,\n    ShortDownArrow: ShortDownArrow,\n    ShortLeftArrow: ShortLeftArrow,\n    shortmid: shortmid,\n    shortparallel: shortparallel,\n    ShortRightArrow: ShortRightArrow,\n    ShortUpArrow: ShortUpArrow,\n    shy: shy$1,\n    Sigma: Sigma,\n    sigma: sigma,\n    sigmaf: sigmaf,\n    sigmav: sigmav,\n    sim: sim,\n    simdot: simdot,\n    sime: sime,\n    simeq: simeq,\n    simg: simg,\n    simgE: simgE,\n    siml: siml,\n    simlE: simlE,\n    simne: simne,\n    simplus: simplus,\n    simrarr: simrarr,\n    slarr: slarr,\n    SmallCircle: SmallCircle,\n    smallsetminus: smallsetminus,\n    smashp: smashp,\n    smeparsl: smeparsl,\n    smid: smid,\n    smile: smile,\n    smt: smt,\n    smte: smte,\n    smtes: smtes,\n    SOFTcy: SOFTcy,\n    softcy: softcy,\n    solbar: solbar,\n    solb: solb,\n    sol: sol,\n    Sopf: Sopf,\n    sopf: sopf,\n    spades: spades,\n    spadesuit: spadesuit,\n    spar: spar,\n    sqcap: sqcap,\n    sqcaps: sqcaps,\n    sqcup: sqcup,\n    sqcups: sqcups,\n    Sqrt: Sqrt,\n    sqsub: sqsub,\n    sqsube: sqsube,\n    sqsubset: sqsubset,\n    sqsubseteq: sqsubseteq,\n    sqsup: sqsup,\n    sqsupe: sqsupe,\n    sqsupset: sqsupset,\n    sqsupseteq: sqsupseteq,\n    square: square,\n    Square: Square,\n    SquareIntersection: SquareIntersection,\n    SquareSubset: SquareSubset,\n    SquareSubsetEqual: SquareSubsetEqual,\n    SquareSuperset: SquareSuperset,\n    SquareSupersetEqual: SquareSupersetEqual,\n    SquareUnion: SquareUnion,\n    squarf: squarf,\n    squ: squ,\n    squf: squf,\n    srarr: srarr,\n    Sscr: Sscr,\n    sscr: sscr,\n    ssetmn: ssetmn,\n    ssmile: ssmile,\n    sstarf: sstarf,\n    Star: Star,\n    star: star,\n    starf: starf,\n    straightepsilon: straightepsilon,\n    straightphi: straightphi,\n    strns: strns,\n    sub: sub,\n    Sub: Sub,\n    subdot: subdot,\n    subE: subE,\n    sube: sube,\n    subedot: subedot,\n    submult: submult,\n    subnE: subnE,\n    subne: subne,\n    subplus: subplus,\n    subrarr: subrarr,\n    subset: subset,\n    Subset: Subset,\n    subseteq: subseteq,\n    subseteqq: subseteqq,\n    SubsetEqual: SubsetEqual,\n    subsetneq: subsetneq,\n    subsetneqq: subsetneqq,\n    subsim: subsim,\n    subsub: subsub,\n    subsup: subsup,\n    succapprox: succapprox,\n    succ: succ,\n    succcurlyeq: succcurlyeq,\n    Succeeds: Succeeds,\n    SucceedsEqual: SucceedsEqual,\n    SucceedsSlantEqual: SucceedsSlantEqual,\n    SucceedsTilde: SucceedsTilde,\n    succeq: succeq,\n    succnapprox: succnapprox,\n    succneqq: succneqq,\n    succnsim: succnsim,\n    succsim: succsim,\n    SuchThat: SuchThat,\n    sum: sum,\n    Sum: Sum,\n    sung: sung,\n    sup1: sup1$1,\n    sup2: sup2$1,\n    sup3: sup3$1,\n    sup: sup,\n    Sup: Sup,\n    supdot: supdot,\n    supdsub: supdsub,\n    supE: supE,\n    supe: supe,\n    supedot: supedot,\n    Superset: Superset,\n    SupersetEqual: SupersetEqual,\n    suphsol: suphsol,\n    suphsub: suphsub,\n    suplarr: suplarr,\n    supmult: supmult,\n    supnE: supnE,\n    supne: supne,\n    supplus: supplus,\n    supset: supset,\n    Supset: Supset,\n    supseteq: supseteq,\n    supseteqq: supseteqq,\n    supsetneq: supsetneq,\n    supsetneqq: supsetneqq,\n    supsim: supsim,\n    supsub: supsub,\n    supsup: supsup,\n    swarhk: swarhk,\n    swarr: swarr,\n    swArr: swArr,\n    swarrow: swarrow,\n    swnwar: swnwar,\n    szlig: szlig$1,\n    Tab: Tab,\n    target: target,\n    Tau: Tau,\n    tau: tau,\n    tbrk: tbrk,\n    Tcaron: Tcaron,\n    tcaron: tcaron,\n    Tcedil: Tcedil,\n    tcedil: tcedil,\n    Tcy: Tcy,\n    tcy: tcy,\n    tdot: tdot,\n    telrec: telrec,\n    Tfr: Tfr,\n    tfr: tfr,\n    there4: there4,\n    therefore: therefore,\n    Therefore: Therefore,\n    Theta: Theta,\n    theta: theta,\n    thetasym: thetasym,\n    thetav: thetav,\n    thickapprox: thickapprox,\n    thicksim: thicksim,\n    ThickSpace: ThickSpace,\n    ThinSpace: ThinSpace,\n    thinsp: thinsp,\n    thkap: thkap,\n    thksim: thksim,\n    THORN: THORN$1,\n    thorn: thorn$1,\n    tilde: tilde,\n    Tilde: Tilde,\n    TildeEqual: TildeEqual,\n    TildeFullEqual: TildeFullEqual,\n    TildeTilde: TildeTilde,\n    timesbar: timesbar,\n    timesb: timesb,\n    times: times$1,\n    timesd: timesd,\n    tint: tint,\n    toea: toea,\n    topbot: topbot,\n    topcir: topcir,\n    top: esm_top,\n    Topf: Topf,\n    topf: topf,\n    topfork: topfork,\n    tosa: tosa,\n    tprime: tprime,\n    trade: trade,\n    TRADE: TRADE,\n    triangle: triangle,\n    triangledown: triangledown,\n    triangleleft: triangleleft,\n    trianglelefteq: trianglelefteq,\n    triangleq: triangleq,\n    triangleright: triangleright,\n    trianglerighteq: trianglerighteq,\n    tridot: tridot,\n    trie: trie,\n    triminus: triminus,\n    TripleDot: TripleDot,\n    triplus: triplus,\n    trisb: trisb,\n    tritime: tritime,\n    trpezium: trpezium,\n    Tscr: Tscr,\n    tscr: tscr,\n    TScy: TScy,\n    tscy: tscy,\n    TSHcy: TSHcy,\n    tshcy: tshcy,\n    Tstrok: Tstrok,\n    tstrok: tstrok,\n    twixt: twixt,\n    twoheadleftarrow: twoheadleftarrow,\n    twoheadrightarrow: twoheadrightarrow,\n    Uacute: Uacute$1,\n    uacute: uacute$1,\n    uarr: uarr,\n    Uarr: Uarr,\n    uArr: uArr,\n    Uarrocir: Uarrocir,\n    Ubrcy: Ubrcy,\n    ubrcy: ubrcy,\n    Ubreve: Ubreve,\n    ubreve: ubreve,\n    Ucirc: Ucirc$1,\n    ucirc: ucirc$1,\n    Ucy: Ucy,\n    ucy: ucy,\n    udarr: udarr,\n    Udblac: Udblac,\n    udblac: udblac,\n    udhar: udhar,\n    ufisht: ufisht,\n    Ufr: Ufr,\n    ufr: ufr,\n    Ugrave: Ugrave$1,\n    ugrave: ugrave$1,\n    uHar: uHar,\n    uharl: uharl,\n    uharr: uharr,\n    uhblk: uhblk,\n    ulcorn: ulcorn,\n    ulcorner: ulcorner,\n    ulcrop: ulcrop,\n    ultri: ultri,\n    Umacr: Umacr,\n    umacr: umacr,\n    uml: uml$1,\n    UnderBar: UnderBar,\n    UnderBrace: UnderBrace,\n    UnderBracket: UnderBracket,\n    UnderParenthesis: UnderParenthesis,\n    Union: Union,\n    UnionPlus: UnionPlus,\n    Uogon: Uogon,\n    uogon: uogon,\n    Uopf: Uopf,\n    uopf: uopf,\n    UpArrowBar: UpArrowBar,\n    uparrow: uparrow,\n    UpArrow: UpArrow,\n    Uparrow: Uparrow,\n    UpArrowDownArrow: UpArrowDownArrow,\n    updownarrow: updownarrow,\n    UpDownArrow: UpDownArrow,\n    Updownarrow: Updownarrow,\n    UpEquilibrium: UpEquilibrium,\n    upharpoonleft: upharpoonleft,\n    upharpoonright: upharpoonright,\n    uplus: uplus,\n    UpperLeftArrow: UpperLeftArrow,\n    UpperRightArrow: UpperRightArrow,\n    upsi: upsi,\n    Upsi: Upsi,\n    upsih: upsih,\n    Upsilon: Upsilon,\n    upsilon: upsilon,\n    UpTeeArrow: UpTeeArrow,\n    UpTee: UpTee,\n    upuparrows: upuparrows,\n    urcorn: urcorn,\n    urcorner: urcorner,\n    urcrop: urcrop,\n    Uring: Uring,\n    uring: uring,\n    urtri: urtri,\n    Uscr: Uscr,\n    uscr: uscr,\n    utdot: utdot,\n    Utilde: Utilde,\n    utilde: utilde,\n    utri: utri,\n    utrif: utrif,\n    uuarr: uuarr,\n    Uuml: Uuml$1,\n    uuml: uuml$1,\n    uwangle: uwangle,\n    vangrt: vangrt,\n    varepsilon: varepsilon,\n    varkappa: varkappa,\n    varnothing: varnothing,\n    varphi: varphi,\n    varpi: varpi,\n    varpropto: varpropto,\n    varr: varr,\n    vArr: vArr,\n    varrho: varrho,\n    varsigma: varsigma,\n    varsubsetneq: varsubsetneq,\n    varsubsetneqq: varsubsetneqq,\n    varsupsetneq: varsupsetneq,\n    varsupsetneqq: varsupsetneqq,\n    vartheta: vartheta,\n    vartriangleleft: vartriangleleft,\n    vartriangleright: vartriangleright,\n    vBar: vBar,\n    Vbar: Vbar,\n    vBarv: vBarv,\n    Vcy: Vcy,\n    vcy: vcy,\n    vdash: vdash,\n    vDash: vDash,\n    Vdash: Vdash,\n    VDash: VDash,\n    Vdashl: Vdashl,\n    veebar: veebar,\n    vee: vee,\n    Vee: Vee,\n    veeeq: veeeq,\n    vellip: vellip,\n    verbar: verbar,\n    Verbar: Verbar,\n    vert: vert,\n    Vert: Vert,\n    VerticalBar: VerticalBar,\n    VerticalLine: VerticalLine,\n    VerticalSeparator: VerticalSeparator,\n    VerticalTilde: VerticalTilde,\n    VeryThinSpace: VeryThinSpace,\n    Vfr: Vfr,\n    vfr: vfr,\n    vltri: vltri,\n    vnsub: vnsub,\n    vnsup: vnsup,\n    Vopf: Vopf,\n    vopf: vopf,\n    vprop: vprop,\n    vrtri: vrtri,\n    Vscr: Vscr,\n    vscr: vscr,\n    vsubnE: vsubnE,\n    vsubne: vsubne,\n    vsupnE: vsupnE,\n    vsupne: vsupne,\n    Vvdash: Vvdash,\n    vzigzag: vzigzag,\n    Wcirc: Wcirc,\n    wcirc: wcirc,\n    wedbar: wedbar,\n    wedge: wedge,\n    Wedge: Wedge,\n    wedgeq: wedgeq,\n    weierp: weierp,\n    Wfr: Wfr,\n    wfr: wfr,\n    Wopf: Wopf,\n    wopf: wopf,\n    wp: wp,\n    wr: wr,\n    wreath: wreath,\n    Wscr: Wscr,\n    wscr: wscr,\n    xcap: xcap,\n    xcirc: xcirc,\n    xcup: xcup,\n    xdtri: xdtri,\n    Xfr: Xfr,\n    xfr: xfr,\n    xharr: xharr,\n    xhArr: xhArr,\n    Xi: Xi,\n    xi: xi,\n    xlarr: xlarr,\n    xlArr: xlArr,\n    xmap: xmap,\n    xnis: xnis,\n    xodot: xodot,\n    Xopf: Xopf,\n    xopf: xopf,\n    xoplus: xoplus,\n    xotime: xotime,\n    xrarr: xrarr,\n    xrArr: xrArr,\n    Xscr: Xscr,\n    xscr: xscr,\n    xsqcup: xsqcup,\n    xuplus: xuplus,\n    xutri: xutri,\n    xvee: xvee,\n    xwedge: xwedge,\n    Yacute: Yacute$1,\n    yacute: yacute$1,\n    YAcy: YAcy,\n    yacy: yacy,\n    Ycirc: Ycirc,\n    ycirc: ycirc,\n    Ycy: Ycy,\n    ycy: ycy,\n    yen: yen$1,\n    Yfr: Yfr,\n    yfr: yfr,\n    YIcy: YIcy,\n    yicy: yicy,\n    Yopf: Yopf,\n    yopf: yopf,\n    Yscr: Yscr,\n    yscr: yscr,\n    YUcy: YUcy,\n    yucy: yucy,\n    yuml: yuml$1,\n    Yuml: Yuml,\n    Zacute: Zacute,\n    zacute: zacute,\n    Zcaron: Zcaron,\n    zcaron: zcaron,\n    Zcy: Zcy,\n    zcy: zcy,\n    Zdot: Zdot,\n    zdot: zdot,\n    zeetrf: zeetrf,\n    ZeroWidthSpace: ZeroWidthSpace,\n    Zeta: Zeta,\n    zeta: zeta,\n    zfr: zfr,\n    Zfr: Zfr,\n    ZHcy: ZHcy,\n    zhcy: zhcy,\n    zigrarr: zigrarr,\n    zopf: zopf,\n    Zopf: Zopf,\n    Zscr: Zscr,\n    zscr: zscr,\n    zwj: zwj,\n    zwnj: zwnj\n};\nvar Aacute = \"Á\";\nvar aacute = \"á\";\nvar Acirc = \"Â\";\nvar acirc = \"â\";\nvar acute = \"´\";\nvar AElig = \"Æ\";\nvar aelig = \"æ\";\nvar Agrave = \"À\";\nvar agrave = \"à\";\nvar amp$1 = \"&\";\nvar AMP = \"&\";\nvar Aring = \"Å\";\nvar aring = \"å\";\nvar Atilde = \"Ã\";\nvar atilde = \"ã\";\nvar Auml = \"Ä\";\nvar auml = \"ä\";\nvar brvbar = \"¦\";\nvar Ccedil = \"Ç\";\nvar ccedil = \"ç\";\nvar cedil = \"¸\";\nvar cent = \"¢\";\nvar copy = \"©\";\nvar COPY = \"©\";\nvar curren = \"¤\";\nvar deg = \"°\";\nvar divide = \"÷\";\nvar Eacute = \"É\";\nvar eacute = \"é\";\nvar Ecirc = \"Ê\";\nvar ecirc = \"ê\";\nvar Egrave = \"È\";\nvar egrave = \"è\";\nvar ETH = \"Ð\";\nvar eth = \"ð\";\nvar Euml = \"Ë\";\nvar euml = \"ë\";\nvar frac12 = \"½\";\nvar frac14 = \"¼\";\nvar frac34 = \"¾\";\nvar gt$1 = \">\";\nvar GT = \">\";\nvar Iacute = \"Í\";\nvar iacute = \"í\";\nvar Icirc = \"Î\";\nvar icirc = \"î\";\nvar iexcl = \"¡\";\nvar Igrave = \"Ì\";\nvar igrave = \"ì\";\nvar iquest = \"¿\";\nvar Iuml = \"Ï\";\nvar iuml = \"ï\";\nvar laquo = \"«\";\nvar lt$1 = \"<\";\nvar LT = \"<\";\nvar macr = \"¯\";\nvar micro = \"µ\";\nvar middot = \"·\";\nvar nbsp = \" \";\nvar not = \"¬\";\nvar Ntilde = \"Ñ\";\nvar ntilde = \"ñ\";\nvar Oacute = \"Ó\";\nvar oacute = \"ó\";\nvar Ocirc = \"Ô\";\nvar ocirc = \"ô\";\nvar Ograve = \"Ò\";\nvar ograve = \"ò\";\nvar ordf = \"ª\";\nvar ordm = \"º\";\nvar Oslash = \"Ø\";\nvar oslash = \"ø\";\nvar Otilde = \"Õ\";\nvar otilde = \"õ\";\nvar Ouml = \"Ö\";\nvar ouml = \"ö\";\nvar para = \"¶\";\nvar plusmn = \"±\";\nvar pound = \"£\";\nvar quot$1 = \"\\\"\";\nvar QUOT = \"\\\"\";\nvar raquo = \"»\";\nvar reg = \"®\";\nvar REG = \"®\";\nvar sect = \"§\";\nvar shy = \"­\";\nvar sup1 = \"¹\";\nvar sup2 = \"²\";\nvar sup3 = \"³\";\nvar szlig = \"ß\";\nvar THORN = \"Þ\";\nvar thorn = \"þ\";\nvar times = \"×\";\nvar Uacute = \"Ú\";\nvar uacute = \"ú\";\nvar Ucirc = \"Û\";\nvar ucirc = \"û\";\nvar Ugrave = \"Ù\";\nvar ugrave = \"ù\";\nvar uml = \"¨\";\nvar Uuml = \"Ü\";\nvar uuml = \"ü\";\nvar Yacute = \"Ý\";\nvar yacute = \"ý\";\nvar yen = \"¥\";\nvar yuml = \"ÿ\";\nvar require$$1 = {\n    Aacute: Aacute,\n    aacute: aacute,\n    Acirc: Acirc,\n    acirc: acirc,\n    acute: acute,\n    AElig: AElig,\n    aelig: aelig,\n    Agrave: Agrave,\n    agrave: agrave,\n    amp: amp$1,\n    AMP: AMP,\n    Aring: Aring,\n    aring: aring,\n    Atilde: Atilde,\n    atilde: atilde,\n    Auml: Auml,\n    auml: auml,\n    brvbar: brvbar,\n    Ccedil: Ccedil,\n    ccedil: ccedil,\n    cedil: cedil,\n    cent: cent,\n    copy: copy,\n    COPY: COPY,\n    curren: curren,\n    deg: deg,\n    divide: divide,\n    Eacute: Eacute,\n    eacute: eacute,\n    Ecirc: Ecirc,\n    ecirc: ecirc,\n    Egrave: Egrave,\n    egrave: egrave,\n    ETH: ETH,\n    eth: eth,\n    Euml: Euml,\n    euml: euml,\n    frac12: frac12,\n    frac14: frac14,\n    frac34: frac34,\n    gt: gt$1,\n    GT: GT,\n    Iacute: Iacute,\n    iacute: iacute,\n    Icirc: Icirc,\n    icirc: icirc,\n    iexcl: iexcl,\n    Igrave: Igrave,\n    igrave: igrave,\n    iquest: iquest,\n    Iuml: Iuml,\n    iuml: iuml,\n    laquo: laquo,\n    lt: lt$1,\n    LT: LT,\n    macr: macr,\n    micro: micro,\n    middot: middot,\n    nbsp: nbsp,\n    not: not,\n    Ntilde: Ntilde,\n    ntilde: ntilde,\n    Oacute: Oacute,\n    oacute: oacute,\n    Ocirc: Ocirc,\n    ocirc: ocirc,\n    Ograve: Ograve,\n    ograve: ograve,\n    ordf: ordf,\n    ordm: ordm,\n    Oslash: Oslash,\n    oslash: oslash,\n    Otilde: Otilde,\n    otilde: otilde,\n    Ouml: Ouml,\n    ouml: ouml,\n    para: para,\n    plusmn: plusmn,\n    pound: pound,\n    quot: quot$1,\n    QUOT: QUOT,\n    raquo: raquo,\n    reg: reg,\n    REG: REG,\n    sect: sect,\n    shy: shy,\n    sup1: sup1,\n    sup2: sup2,\n    sup3: sup3,\n    szlig: szlig,\n    THORN: THORN,\n    thorn: thorn,\n    times: times,\n    Uacute: Uacute,\n    uacute: uacute,\n    Ucirc: Ucirc,\n    ucirc: ucirc,\n    Ugrave: Ugrave,\n    ugrave: ugrave,\n    uml: uml,\n    Uuml: Uuml,\n    uuml: uuml,\n    Yacute: Yacute,\n    yacute: yacute,\n    yen: yen,\n    yuml: yuml\n};\nvar amp = \"&\";\nvar apos = \"'\";\nvar gt = \">\";\nvar lt = \"<\";\nvar quot = \"\\\"\";\nvar require$$0$1 = {\n    amp: amp,\n    apos: apos,\n    gt: gt,\n    lt: lt,\n    quot: quot\n};\nvar decode_codepoint = {};\nvar require$$0 = {\n    \"0\": 65533,\n    \"128\": 8364,\n    \"130\": 8218,\n    \"131\": 402,\n    \"132\": 8222,\n    \"133\": 8230,\n    \"134\": 8224,\n    \"135\": 8225,\n    \"136\": 710,\n    \"137\": 8240,\n    \"138\": 352,\n    \"139\": 8249,\n    \"140\": 338,\n    \"142\": 381,\n    \"145\": 8216,\n    \"146\": 8217,\n    \"147\": 8220,\n    \"148\": 8221,\n    \"149\": 8226,\n    \"150\": 8211,\n    \"151\": 8212,\n    \"152\": 732,\n    \"153\": 8482,\n    \"154\": 353,\n    \"155\": 8250,\n    \"156\": 339,\n    \"158\": 382,\n    \"159\": 376\n};\nvar __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(decode_codepoint, \"__esModule\", { value: true });\nvar decode_json_1 = __importDefault$2(require$$0);\n// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119\nvar fromCodePoint$2 = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.fromCodePoint ||\n    function (codePoint) {\n        var output = \"\";\n        if (codePoint > 0xffff) {\n            codePoint -= 0x10000;\n            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);\n            codePoint = 0xdc00 | (codePoint & 0x3ff);\n        }\n        output += String.fromCharCode(codePoint);\n        return output;\n    };\nfunction decodeCodePoint(codePoint) {\n    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {\n        return \"\\uFFFD\";\n    }\n    if (codePoint in decode_json_1.default) {\n        codePoint = decode_json_1.default[codePoint];\n    }\n    return fromCodePoint$2(codePoint);\n}\ndecode_codepoint.default = decodeCodePoint;\nvar __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(decode, \"__esModule\", { value: true });\ndecode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;\nvar entities_json_1$1 = __importDefault$1(require$$1$1);\nvar legacy_json_1 = __importDefault$1(require$$1);\nvar xml_json_1$1 = __importDefault$1(require$$0$1);\nvar decode_codepoint_1 = __importDefault$1(decode_codepoint);\nvar strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\\da-fA-F]+|#\\d+);/g;\ndecode.decodeXML = getStrictDecoder(xml_json_1$1.default);\ndecode.decodeHTMLStrict = getStrictDecoder(entities_json_1$1.default);\nfunction getStrictDecoder(map) {\n    var replace = getReplacer(map);\n    return function (str) { return String(str).replace(strictEntityRe, replace); };\n}\nvar sorter = function (a, b) { return (a < b ? 1 : -1); };\ndecode.decodeHTML = (function () {\n    var legacy = Object.keys(legacy_json_1.default).sort(sorter);\n    var keys = Object.keys(entities_json_1$1.default).sort(sorter);\n    for (var i = 0, j = 0; i < keys.length; i++) {\n        if (legacy[j] === keys[i]) {\n            keys[i] += \";?\";\n            j++;\n        }\n        else {\n            keys[i] += \";\";\n        }\n    }\n    var re = new RegExp(\"&(?:\" + keys.join(\"|\") + \"|#[xX][\\\\da-fA-F]+;?|#\\\\d+;?)\", \"g\");\n    var replace = getReplacer(entities_json_1$1.default);\n    function replacer(str) {\n        if (str.substr(-1) !== \";\")\n            str += \";\";\n        return replace(str);\n    }\n    // TODO consider creating a merged map\n    return function (str) { return String(str).replace(re, replacer); };\n})();\nfunction getReplacer(map) {\n    return function replace(str) {\n        if (str.charAt(1) === \"#\") {\n            var secondChar = str.charAt(2);\n            if (secondChar === \"X\" || secondChar === \"x\") {\n                return decode_codepoint_1.default(parseInt(str.substr(3), 16));\n            }\n            return decode_codepoint_1.default(parseInt(str.substr(2), 10));\n        }\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        return map[str.slice(1, -1)] || str;\n    };\n}\nvar encode = {};\nvar esm_importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(encode, \"__esModule\", { value: true });\nencode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;\nvar xml_json_1 = esm_importDefault(require$$0$1);\nvar inverseXML = getInverseObj(xml_json_1.default);\nvar xmlReplacer = getInverseReplacer(inverseXML);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeXML = getASCIIEncoder(inverseXML);\nvar entities_json_1 = esm_importDefault(require$$1$1);\nvar inverseHTML = getInverseObj(entities_json_1.default);\nvar htmlReplacer = getInverseReplacer(inverseHTML);\n/**\n * Encodes all entities and non-ASCII characters in the input.\n *\n * This includes characters that are valid ASCII characters in HTML documents.\n * For example `#` will be encoded as `&num;`. To get a more compact output,\n * consider using the `encodeNonAsciiHTML` function.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeHTML = getInverse(inverseHTML, htmlReplacer);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);\nfunction getInverseObj(obj) {\n    return Object.keys(obj)\n        .sort()\n        .reduce(function (inverse, name) {\n        inverse[obj[name]] = \"&\" + name + \";\";\n        return inverse;\n    }, {});\n}\nfunction getInverseReplacer(inverse) {\n    var single = [];\n    var multiple = [];\n    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {\n        var k = _a[_i];\n        if (k.length === 1) {\n            // Add value to single array\n            single.push(\"\\\\\" + k);\n        }\n        else {\n            // Add value to multiple array\n            multiple.push(k);\n        }\n    }\n    // Add ranges to single characters.\n    single.sort();\n    for (var start = 0; start < single.length - 1; start++) {\n        // Find the end of a run of characters\n        var end = start;\n        while (end < single.length - 1 &&\n            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {\n            end += 1;\n        }\n        var count = 1 + end - start;\n        // We want to replace at least three characters\n        if (count < 3)\n            continue;\n        single.splice(start, count, single[start] + \"-\" + single[end]);\n    }\n    multiple.unshift(\"[\" + single.join(\"\") + \"]\");\n    return new RegExp(multiple.join(\"|\"), \"g\");\n}\n// /[^\\0-\\x7F]/gu\nvar reNonASCII = /(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;\nvar getCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null\n    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        function (str) { return str.codePointAt(0); }\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        function (c) {\n            return (c.charCodeAt(0) - 0xd800) * 0x400 +\n                c.charCodeAt(1) -\n                0xdc00 +\n                0x10000;\n        };\nfunction singleCharReplacer(c) {\n    return \"&#x\" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))\n        .toString(16)\n        .toUpperCase() + \";\";\n}\nfunction getInverse(inverse, re) {\n    return function (data) {\n        return data\n            .replace(re, function (name) { return inverse[name]; })\n            .replace(reNonASCII, singleCharReplacer);\n    };\n}\nvar reEscapeChars = new RegExp(xmlReplacer.source + \"|\" + reNonASCII.source, \"g\");\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nfunction esm_escape(data) {\n    return data.replace(reEscapeChars, singleCharReplacer);\n}\nencode.escape = esm_escape;\n/**\n * Encodes all characters not valid in XML documents using numeric hexadecimal\n * reference (eg. `&#xfc;`).\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nfunction escapeUTF8(data) {\n    return data.replace(xmlReplacer, singleCharReplacer);\n}\nencode.escapeUTF8 = escapeUTF8;\nfunction getASCIIEncoder(obj) {\n    return function (data) {\n        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });\n    };\n}\n(function (exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;\n    var decode_1 = decode;\n    var encode_1 = encode;\n    /**\n     * Decodes a string with entities.\n     *\n     * @param data String to decode.\n     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n     * @deprecated Use `decodeXML` or `decodeHTML` directly.\n     */\n    function decode$1(data, level) {\n        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);\n    }\n    exports.decode = decode$1;\n    /**\n     * Decodes a string with entities. Does not allow missing trailing semicolons for entities.\n     *\n     * @param data String to decode.\n     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n     * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.\n     */\n    function decodeStrict(data, level) {\n        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);\n    }\n    exports.decodeStrict = decodeStrict;\n    /**\n     * Encodes a string with entities.\n     *\n     * @param data String to encode.\n     * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.\n     * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.\n     */\n    function encode$1(data, level) {\n        return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);\n    }\n    exports.encode = encode$1;\n    var encode_2 = encode;\n    Object.defineProperty(exports, \"encodeXML\", { enumerable: true, get: function () { return encode_2.encodeXML; } });\n    Object.defineProperty(exports, \"encodeHTML\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\n    Object.defineProperty(exports, \"encodeNonAsciiHTML\", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });\n    Object.defineProperty(exports, \"escape\", { enumerable: true, get: function () { return encode_2.escape; } });\n    Object.defineProperty(exports, \"escapeUTF8\", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });\n    // Legacy aliases (deprecated)\n    Object.defineProperty(exports, \"encodeHTML4\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\n    Object.defineProperty(exports, \"encodeHTML5\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\n    var decode_2 = decode;\n    Object.defineProperty(exports, \"decodeXML\", { enumerable: true, get: function () { return decode_2.decodeXML; } });\n    Object.defineProperty(exports, \"decodeHTML\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\n    Object.defineProperty(exports, \"decodeHTMLStrict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\n    // Legacy aliases (deprecated)\n    Object.defineProperty(exports, \"decodeHTML4\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\n    Object.defineProperty(exports, \"decodeHTML5\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\n    Object.defineProperty(exports, \"decodeHTML4Strict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\n    Object.defineProperty(exports, \"decodeHTML5Strict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\n    Object.defineProperty(exports, \"decodeXMLStrict\", { enumerable: true, get: function () { return decode_2.decodeXML; } });\n}(lib));\nvar ENTITY = '&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});';\nvar C_BACKSLASH$1 = 92;\nvar reBackslashOrAmp = /[\\\\&]/;\nvar ESCAPABLE = '[!\"#$%&\\'()*+,./:;<=>?@[\\\\\\\\\\\\]^_`{|}~-]';\nvar reEntityOrEscapedChar = new RegExp(\"\\\\\\\\\" + ESCAPABLE + \"|\" + ENTITY, 'gi');\nvar XMLSPECIAL = '[&<>\"]';\nvar reXmlSpecial = new RegExp(XMLSPECIAL, 'g');\nvar unescapeChar = function (s) {\n    if (s.charCodeAt(0) === C_BACKSLASH$1) {\n        return s.charAt(1);\n    }\n    return lib.decodeHTML(s);\n};\n// Replace entities and backslash escapes with literal characters.\nfunction unescapeString(s) {\n    if (reBackslashOrAmp.test(s)) {\n        return s.replace(reEntityOrEscapedChar, unescapeChar);\n    }\n    return s;\n}\nfunction normalizeURI(uri) {\n    try {\n        return encode_1(uri);\n    }\n    catch (err) {\n        return uri;\n    }\n}\nfunction replaceUnsafeChar(s) {\n    switch (s) {\n        case '&':\n            return '&amp;';\n        case '<':\n            return '&lt;';\n        case '>':\n            return '&gt;';\n        case '\"':\n            return '&quot;';\n        default:\n            return s;\n    }\n}\nfunction escapeXml(s) {\n    if (reXmlSpecial.test(s)) {\n        return s.replace(reXmlSpecial, replaceUnsafeChar);\n    }\n    return s;\n}\nfunction repeat(str, count) {\n    var arr = [];\n    for (var i = 0; i < count; i++) {\n        arr.push(str);\n    }\n    return arr.join('');\n}\nfunction isEmpty(str) {\n    if (!str) {\n        return true;\n    }\n    return !/[^ \\t]+/.test(str);\n}\nvar NodeWalker = /** @class */ (function () {\n    function NodeWalker(root) {\n        this.current = root;\n        this.root = root;\n        this.entering = true;\n    }\n    NodeWalker.prototype.next = function () {\n        var cur = this.current;\n        var entering = this.entering;\n        if (cur === null) {\n            return null;\n        }\n        var container = isContainer(cur);\n        if (entering && container) {\n            if (cur.firstChild) {\n                this.current = cur.firstChild;\n                this.entering = true;\n            }\n            else {\n                // stay on node but exit\n                this.entering = false;\n            }\n        }\n        else if (cur === this.root) {\n            this.current = null;\n        }\n        else if (cur.next === null) {\n            this.current = cur.parent;\n            this.entering = false;\n        }\n        else {\n            this.current = cur.next;\n            this.entering = true;\n        }\n        return { entering: entering, node: cur };\n    };\n    NodeWalker.prototype.resumeAt = function (node, entering) {\n        this.current = node;\n        this.entering = entering === true;\n    };\n    return NodeWalker;\n}());\nfunction isContainer(node) {\n    switch (node.type) {\n        case 'document':\n        case 'blockQuote':\n        case 'list':\n        case 'item':\n        case 'paragraph':\n        case 'heading':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'table':\n        case 'tableHead':\n        case 'tableBody':\n        case 'tableRow':\n        case 'tableCell':\n        case 'tableDelimRow':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nvar lastNodeId = 1;\nvar nodeMap = {};\nfunction getNodeById(id) {\n    return nodeMap[id];\n}\nfunction removeNodeById(id) {\n    delete nodeMap[id];\n}\nfunction removeAllNode() {\n    nodeMap = {};\n}\nvar esm_Node = /** @class */ (function () {\n    function Node(nodeType, sourcepos) {\n        this.parent = null;\n        this.prev = null;\n        this.next = null;\n        // only for container node\n        this.firstChild = null;\n        this.lastChild = null;\n        // only for leaf node\n        this.literal = null;\n        if (nodeType === 'document') {\n            this.id = -1;\n        }\n        else {\n            this.id = lastNodeId++;\n        }\n        this.type = nodeType;\n        this.sourcepos = sourcepos;\n        nodeMap[this.id] = this;\n    }\n    Node.prototype.isContainer = function () {\n        return isContainer(this);\n    };\n    Node.prototype.unlink = function () {\n        if (this.prev) {\n            this.prev.next = this.next;\n        }\n        else if (this.parent) {\n            this.parent.firstChild = this.next;\n        }\n        if (this.next) {\n            this.next.prev = this.prev;\n        }\n        else if (this.parent) {\n            this.parent.lastChild = this.prev;\n        }\n        this.parent = null;\n        this.next = null;\n        this.prev = null;\n    };\n    Node.prototype.replaceWith = function (node) {\n        this.insertBefore(node);\n        this.unlink();\n    };\n    Node.prototype.insertAfter = function (sibling) {\n        sibling.unlink();\n        sibling.next = this.next;\n        if (sibling.next) {\n            sibling.next.prev = sibling;\n        }\n        sibling.prev = this;\n        this.next = sibling;\n        if (this.parent) {\n            sibling.parent = this.parent;\n            if (!sibling.next) {\n                sibling.parent.lastChild = sibling;\n            }\n        }\n    };\n    Node.prototype.insertBefore = function (sibling) {\n        sibling.unlink();\n        sibling.prev = this.prev;\n        if (sibling.prev) {\n            sibling.prev.next = sibling;\n        }\n        sibling.next = this;\n        this.prev = sibling;\n        sibling.parent = this.parent;\n        if (!sibling.prev) {\n            sibling.parent.firstChild = sibling;\n        }\n    };\n    Node.prototype.appendChild = function (child) {\n        child.unlink();\n        child.parent = this;\n        if (this.lastChild) {\n            this.lastChild.next = child;\n            child.prev = this.lastChild;\n            this.lastChild = child;\n        }\n        else {\n            this.firstChild = child;\n            this.lastChild = child;\n        }\n    };\n    Node.prototype.prependChild = function (child) {\n        child.unlink();\n        child.parent = this;\n        if (this.firstChild) {\n            this.firstChild.prev = child;\n            child.next = this.firstChild;\n            this.firstChild = child;\n        }\n        else {\n            this.firstChild = child;\n            this.lastChild = child;\n        }\n    };\n    Node.prototype.walker = function () {\n        return new NodeWalker(this);\n    };\n    return Node;\n}());\nvar BlockNode = /** @class */ (function (_super) {\n    esm_extends(BlockNode, _super);\n    function BlockNode(nodeType, sourcepos) {\n        var _this = _super.call(this, nodeType, sourcepos) || this;\n        // temporal data (for parsing)\n        _this.open = true;\n        _this.lineOffsets = null;\n        _this.stringContent = null;\n        _this.lastLineBlank = false;\n        _this.lastLineChecked = false;\n        _this.type = nodeType;\n        return _this;\n    }\n    return BlockNode;\n}(esm_Node));\nvar ListNode = /** @class */ (function (_super) {\n    esm_extends(ListNode, _super);\n    function ListNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.listData = null;\n        return _this;\n    }\n    return ListNode;\n}(BlockNode));\nvar HeadingNode = /** @class */ (function (_super) {\n    esm_extends(HeadingNode, _super);\n    function HeadingNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.level = 0;\n        _this.headingType = 'atx';\n        return _this;\n    }\n    return HeadingNode;\n}(BlockNode));\nvar CodeBlockNode = /** @class */ (function (_super) {\n    esm_extends(CodeBlockNode, _super);\n    function CodeBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isFenced = false;\n        _this.fenceChar = null;\n        _this.fenceLength = 0;\n        _this.fenceOffset = -1;\n        _this.info = null;\n        _this.infoPadding = 0;\n        return _this;\n    }\n    return CodeBlockNode;\n}(BlockNode));\nvar TableNode = /** @class */ (function (_super) {\n    esm_extends(TableNode, _super);\n    function TableNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.columns = [];\n        return _this;\n    }\n    return TableNode;\n}(BlockNode));\nvar TableCellNode = /** @class */ (function (_super) {\n    esm_extends(TableCellNode, _super);\n    function TableCellNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.startIdx = 0;\n        _this.endIdx = 0;\n        _this.paddingLeft = 0;\n        _this.paddingRight = 0;\n        _this.ignored = false;\n        return _this;\n    }\n    return TableCellNode;\n}(BlockNode));\nvar RefDefNode = /** @class */ (function (_super) {\n    esm_extends(RefDefNode, _super);\n    function RefDefNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.title = '';\n        _this.dest = '';\n        _this.label = '';\n        return _this;\n    }\n    return RefDefNode;\n}(BlockNode));\nvar CustomBlockNode = /** @class */ (function (_super) {\n    esm_extends(CustomBlockNode, _super);\n    function CustomBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.syntaxLength = 0;\n        _this.offset = -1;\n        _this.info = '';\n        return _this;\n    }\n    return CustomBlockNode;\n}(BlockNode));\nvar HtmlBlockNode = /** @class */ (function (_super) {\n    esm_extends(HtmlBlockNode, _super);\n    function HtmlBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.htmlBlockType = -1;\n        return _this;\n    }\n    return HtmlBlockNode;\n}(BlockNode));\nvar LinkNode = /** @class */ (function (_super) {\n    esm_extends(LinkNode, _super);\n    function LinkNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.destination = null;\n        _this.title = null;\n        _this.extendedAutolink = false;\n        return _this;\n    }\n    return LinkNode;\n}(esm_Node));\nvar CodeNode = /** @class */ (function (_super) {\n    esm_extends(CodeNode, _super);\n    function CodeNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.tickCount = 0;\n        return _this;\n    }\n    return CodeNode;\n}(esm_Node));\nvar CustomInlineNode = /** @class */ (function (_super) {\n    esm_extends(CustomInlineNode, _super);\n    function CustomInlineNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.info = '';\n        return _this;\n    }\n    return CustomInlineNode;\n}(esm_Node));\nfunction createNode(type, sourcepos) {\n    switch (type) {\n        case 'heading':\n            return new HeadingNode(type, sourcepos);\n        case 'list':\n        case 'item':\n            return new ListNode(type, sourcepos);\n        case 'link':\n        case 'image':\n            return new LinkNode(type, sourcepos);\n        case 'codeBlock':\n            return new CodeBlockNode(type, sourcepos);\n        case 'htmlBlock':\n            return new HtmlBlockNode(type, sourcepos);\n        case 'table':\n            return new TableNode(type, sourcepos);\n        case 'tableCell':\n            return new TableCellNode(type, sourcepos);\n        case 'document':\n        case 'paragraph':\n        case 'blockQuote':\n        case 'thematicBreak':\n        case 'tableRow':\n        case 'tableBody':\n        case 'tableHead':\n        case 'frontMatter':\n            return new BlockNode(type, sourcepos);\n        case 'code':\n            return new CodeNode(type, sourcepos);\n        case 'refDef':\n            return new RefDefNode(type, sourcepos);\n        case 'customBlock':\n            return new CustomBlockNode(type, sourcepos);\n        case 'customInline':\n            return new CustomInlineNode(type, sourcepos);\n        default:\n            return new esm_Node(type, sourcepos);\n    }\n}\nfunction isCodeBlock(node) {\n    return node.type === 'codeBlock';\n}\nfunction isHtmlBlock(node) {\n    return node.type === 'htmlBlock';\n}\nfunction isHeading(node) {\n    return node.type === 'heading';\n}\nfunction isList(node) {\n    return node.type === 'list';\n}\nfunction isTable(node) {\n    return node.type === 'table';\n}\nfunction isRefDef(node) {\n    return node.type === 'refDef';\n}\nfunction isCustomBlock(node) {\n    return node.type === 'customBlock';\n}\nfunction isCustomInline(node) {\n    return node.type === 'customInline';\n}\nfunction esm_text(s, sourcepos) {\n    var node = createNode('text', sourcepos);\n    node.literal = s;\n    return node;\n}\nvar TAGNAME = '[A-Za-z][A-Za-z0-9-]*';\nvar ATTRIBUTENAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\nvar UNQUOTEDVALUE = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar SINGLEQUOTEDVALUE = \"'[^']*'\";\nvar DOUBLEQUOTEDVALUE = '\"[^\"]*\"';\nvar ATTRIBUTEVALUE = \"(?:\" + UNQUOTEDVALUE + \"|\" + SINGLEQUOTEDVALUE + \"|\" + DOUBLEQUOTEDVALUE + \")\";\nvar ATTRIBUTEVALUESPEC = \"\" + '(?:\\\\s*=\\\\s*' + ATTRIBUTEVALUE + \")\";\nvar ATTRIBUTE = \"\" + '(?:\\\\s+' + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + \"?)\";\nvar OPENTAG = \"<\" + TAGNAME + ATTRIBUTE + \"*\\\\s*/?>\";\nvar CLOSETAG = \"</\" + TAGNAME + \"\\\\s*[>]\";\nvar HTMLCOMMENT = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';\nvar PROCESSINGINSTRUCTION = '[<][?].*?[?][>]';\nvar DECLARATION = '<![A-Z]+\\\\s+[^>]*>';\nvar CDATA = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>';\nvar HTMLTAG = \"(?:\" + OPENTAG + \"|\" + CLOSETAG + \"|\" + HTMLCOMMENT + \"|\" + PROCESSINGINSTRUCTION + \"|\" + DECLARATION + \"|\" + CDATA + \")\";\nvar reHtmlTag = new RegExp(\"^\" + HTMLTAG, 'i');\n// derived from https://github.com/mathiasbynens/String.fromCodePoint\n/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */\nvar fromCodePoint;\nif (String.fromCodePoint) {\n    fromCodePoint = function (_) {\n        try {\n            return String.fromCodePoint(_);\n        }\n        catch (e) {\n            if (e instanceof RangeError) {\n                return String.fromCharCode(0xfffd);\n            }\n            throw e;\n        }\n    };\n}\nelse {\n    var stringFromCharCode_1 = String.fromCharCode;\n    var floor_1 = Math.floor;\n    fromCodePoint = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = args.length;\n        if (!length) {\n            return '';\n        }\n        var result = '';\n        while (++index < length) {\n            var codePoint = Number(args[index]);\n            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                codePoint < 0 || // not a valid Unicode code point\n                codePoint > 0x10ffff || // not a valid Unicode code point\n                floor_1(codePoint) !== codePoint // not an integer\n            ) {\n                return String.fromCharCode(0xfffd);\n            }\n            if (codePoint <= 0xffff) {\n                // BMP code point\n                codeUnits.push(codePoint);\n            }\n            else {\n                // Astral code point; split in surrogate halves\n                // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                codePoint -= 0x10000;\n                highSurrogate = (codePoint >> 10) + 0xd800;\n                lowSurrogate = (codePoint % 0x400) + 0xdc00;\n                codeUnits.push(highSurrogate, lowSurrogate);\n            }\n            if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                result += stringFromCharCode_1.apply(void 0, codeUnits);\n                codeUnits.length = 0;\n            }\n        }\n        return result;\n    };\n}\nvar fromCodePoint$1 = fromCodePoint;\nvar DOMAIN = '(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+';\nvar PATH = '[^<\\\\s]*[^<?!.,:*_?~\\\\s]';\nvar EMAIL = '[\\\\w.+-]+@(?:[\\\\w-]+\\\\.)+[\\\\w-]+';\nfunction trimUnmatchedTrailingParens(source) {\n    var trailingParen = /\\)+$/.exec(source);\n    if (trailingParen) {\n        var count = 0;\n        for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {\n            var ch = source_1[_i];\n            if (ch === '(') {\n                if (count < 0) {\n                    count = 1;\n                }\n                else {\n                    count += 1;\n                }\n            }\n            else if (ch === ')') {\n                count -= 1;\n            }\n        }\n        if (count < 0) {\n            var trimCount = Math.min(-count, trailingParen[0].length);\n            return source.substring(0, source.length - trimCount);\n        }\n    }\n    return source;\n}\nfunction trimTrailingEntity(source) {\n    return source.replace(/&[A-Za-z0-9]+;$/, '');\n}\nfunction parseEmailLink(source) {\n    var reEmailLink = new RegExp(EMAIL, 'g');\n    var result = [];\n    var m;\n    while ((m = reEmailLink.exec(source))) {\n        var text_1 = m[0];\n        if (!/[_-]+$/.test(text_1)) {\n            result.push({\n                text: text_1,\n                range: [m.index, m.index + text_1.length - 1],\n                url: \"mailto:\" + text_1,\n            });\n        }\n    }\n    return result;\n}\nfunction parseUrlLink(source) {\n    var reWwwAutolink = new RegExp(\"(www|https?://).\" + DOMAIN + PATH, 'g');\n    var result = [];\n    var m;\n    while ((m = reWwwAutolink.exec(source))) {\n        var text_2 = trimTrailingEntity(trimUnmatchedTrailingParens(m[0]));\n        var scheme = m[1] === 'www' ? 'http://' : '';\n        result.push({\n            text: text_2,\n            range: [m.index, m.index + text_2.length - 1],\n            url: \"\" + scheme + text_2,\n        });\n    }\n    return result;\n}\nfunction baseAutolinkParser(source) {\n    return esm_spreadArray(esm_spreadArray([], parseUrlLink(source)), parseEmailLink(source)).sort(function (a, b) { return a.range[0] - b.range[0]; });\n}\nfunction convertExtAutoLinks(walker, autolinkParser) {\n    if (typeof autolinkParser === 'boolean') {\n        autolinkParser = baseAutolinkParser;\n    }\n    var event;\n    var _loop_1 = function () {\n        var entering = event.entering, node = event.node;\n        if (entering && node.type === 'text' && node.parent.type !== 'link') {\n            var literal = node.literal;\n            var linkInfos = autolinkParser(literal);\n            if (!linkInfos || !linkInfos.length) {\n                return \"continue\";\n            }\n            var lastIdx = 0;\n            var _a = node.sourcepos[0], lineNum_1 = _a[0], chPos_1 = _a[1];\n            var sourcepos = function (startIdx, endIdx) {\n                return [\n                    [lineNum_1, chPos_1 + startIdx],\n                    [lineNum_1, chPos_1 + endIdx],\n                ];\n            };\n            var newNodes = [];\n            for (var _i = 0, linkInfos_1 = linkInfos; _i < linkInfos_1.length; _i++) {\n                var _b = linkInfos_1[_i], range = _b.range, url = _b.url, linkText = _b.text;\n                if (range[0] > lastIdx) {\n                    newNodes.push(esm_text(literal.substring(lastIdx, range[0]), sourcepos(lastIdx, range[0] - 1)));\n                }\n                var linkNode = createNode('link', sourcepos.apply(void 0, range));\n                linkNode.appendChild(esm_text(linkText, sourcepos.apply(void 0, range)));\n                linkNode.destination = url;\n                linkNode.extendedAutolink = true;\n                newNodes.push(linkNode);\n                lastIdx = range[1] + 1;\n            }\n            if (lastIdx < literal.length) {\n                newNodes.push(esm_text(literal.substring(lastIdx), sourcepos(lastIdx, literal.length - 1)));\n            }\n            for (var _c = 0, newNodes_1 = newNodes; _c < newNodes_1.length; _c++) {\n                var newNode = newNodes_1[_c];\n                node.insertBefore(newNode);\n            }\n            node.unlink();\n        }\n    };\n    while ((event = walker.next())) {\n        _loop_1();\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n// normalize a reference in reference link (remove []s, trim,\n// collapse internal space, unicode case fold.\n// See commonmark/commonmark.js#168.\nfunction normalizeReference(str) {\n    return str\n        .slice(1, str.length - 1)\n        .trim()\n        .replace(/[ \\t\\r\\n]+/, ' ')\n        .toLowerCase()\n        .toUpperCase();\n}\nfunction iterateObject(obj, iteratee) {\n    Object.keys(obj).forEach(function (key) {\n        iteratee(key, obj[key]);\n    });\n}\nfunction omit(obj) {\n    var propNames = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        propNames[_i - 1] = arguments[_i];\n    }\n    var resultMap = esm_assign({}, obj);\n    propNames.forEach(function (key) {\n        delete resultMap[key];\n    });\n    return resultMap;\n}\nfunction isEmptyObj(obj) {\n    return !Object.keys(obj).length;\n}\nfunction clearObj(obj) {\n    Object.keys(obj).forEach(function (key) {\n        delete obj[key];\n    });\n}\nvar C_NEWLINE = 10;\nvar C_ASTERISK = 42;\nvar C_UNDERSCORE = 95;\nvar C_BACKTICK = 96;\nvar C_OPEN_BRACKET$1 = 91;\nvar C_CLOSE_BRACKET = 93;\nvar C_TILDE = 126;\nvar C_LESSTHAN$1 = 60;\nvar C_BANG = 33;\nvar C_BACKSLASH = 92;\nvar C_AMPERSAND = 38;\nvar C_OPEN_PAREN = 40;\nvar C_CLOSE_PAREN = 41;\nvar C_COLON = 58;\nvar C_SINGLEQUOTE = 39;\nvar C_DOUBLEQUOTE = 34;\nvar C_DOLLAR = 36;\n// Some regexps used in inline parser:\nvar ESCAPED_CHAR = \"\\\\\\\\\" + ESCAPABLE;\nvar rePunctuation = new RegExp(/[!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E42\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC9\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDF3C-\\uDF3E]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]/);\nvar reLinkTitle = new RegExp(\"^(?:\\\"(\" + ESCAPED_CHAR + \"|[^\\\"\\\\x00])*\\\"\" +\n    \"|\" +\n    (\"'(\" + ESCAPED_CHAR + \"|[^'\\\\x00])*'\") +\n    \"|\" +\n    (\"\\\\((\" + ESCAPED_CHAR + \"|[^()\\\\x00])*\\\\))\"));\nvar reLinkDestinationBraces = /^(?:<(?:[^<>\\n\\\\\\x00]|\\\\.)*>)/;\nvar reEscapable = new RegExp(\"^\" + ESCAPABLE);\nvar reEntityHere = new RegExp(\"^\" + ENTITY, 'i');\nvar reTicks = /`+/;\nvar reTicksHere = /^`+/;\nvar reEllipses = /\\.\\.\\./g;\nvar reDash = /--+/g;\nvar reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\\x00-\\x20]*>/i;\nvar reSpnl = /^ *(?:\\n *)?/;\nvar reWhitespaceChar = /^[ \\t\\n\\x0b\\x0c\\x0d]/;\nvar reUnicodeWhitespaceChar = /^\\s/;\nvar reFinalSpace = / *$/;\nvar reInitialSpace = /^ */;\nvar reSpaceAtEndOfLine = /^ *(?:\\n|$)/;\nvar reLinkLabel = /^\\[(?:[^\\\\\\[\\]]|\\\\.){0,1000}\\]/;\n// Matches a string of non-special characters.\nvar reMain = /^[^\\n`\\[\\]\\\\!<&*_'\"~$]+/m;\nvar InlineParser = /** @class */ (function () {\n    function InlineParser(options) {\n        // An InlineParser keeps track of a subject (a string to be parsed)\n        // and a position in that subject.\n        this.subject = '';\n        this.delimiters = null; // used by handleDelim method\n        this.brackets = null;\n        this.pos = 0;\n        this.lineStartNum = 0;\n        this.lineIdx = 0;\n        this.lineOffsets = [0];\n        this.linePosOffset = 0;\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.options = options;\n    }\n    InlineParser.prototype.sourcepos = function (start, end) {\n        var linePosOffset = this.linePosOffset + this.lineOffsets[this.lineIdx];\n        var lineNum = this.lineStartNum + this.lineIdx;\n        var startpos = [lineNum, start + linePosOffset];\n        if (typeof end === 'number') {\n            return [startpos, [lineNum, end + linePosOffset]];\n        }\n        return startpos;\n    };\n    InlineParser.prototype.nextLine = function () {\n        this.lineIdx += 1;\n        this.linePosOffset = -this.pos;\n    };\n    // If re matches at current position in the subject, advance\n    // position in subject and return the match; otherwise return null.\n    InlineParser.prototype.match = function (re) {\n        var m = re.exec(this.subject.slice(this.pos));\n        if (m === null) {\n            return null;\n        }\n        this.pos += m.index + m[0].length;\n        return m[0];\n    };\n    // Returns the code for the character at the current subject position, or -1\n    // there are no more characters.\n    InlineParser.prototype.peek = function () {\n        if (this.pos < this.subject.length) {\n            return this.subject.charCodeAt(this.pos);\n        }\n        return -1;\n    };\n    // Parse zero or more space characters, including at most one newline\n    InlineParser.prototype.spnl = function () {\n        this.match(reSpnl);\n        return true;\n    };\n    // All of the parsers below try to match something at the current position\n    // in the subject.  If they succeed in matching anything, they\n    // return the inline matched, advancing the subject.\n    // Attempt to parse backticks, adding either a backtick code span or a\n    // literal sequence of backticks.\n    InlineParser.prototype.parseBackticks = function (block) {\n        var startpos = this.pos + 1;\n        var ticks = this.match(reTicksHere);\n        if (ticks === null) {\n            return false;\n        }\n        var afterOpenTicks = this.pos;\n        var matched;\n        while ((matched = this.match(reTicks)) !== null) {\n            if (matched === ticks) {\n                var contents = this.subject.slice(afterOpenTicks, this.pos - ticks.length);\n                var sourcepos = this.sourcepos(startpos, this.pos);\n                var lines = contents.split('\\n');\n                if (lines.length > 1) {\n                    var lastLine = last(lines);\n                    this.lineIdx += lines.length - 1;\n                    this.linePosOffset = -(this.pos - lastLine.length - ticks.length);\n                    sourcepos[1] = this.sourcepos(this.pos);\n                    contents = lines.join(' ');\n                }\n                var node = createNode('code', sourcepos);\n                if (contents.length > 0 &&\n                    contents.match(/[^ ]/) !== null &&\n                    contents[0] == ' ' &&\n                    contents[contents.length - 1] == ' ') {\n                    node.literal = contents.slice(1, contents.length - 1);\n                }\n                else {\n                    node.literal = contents;\n                }\n                node.tickCount = ticks.length;\n                block.appendChild(node);\n                return true;\n            }\n        }\n        // If we got here, we didn't match a closing backtick sequence.\n        this.pos = afterOpenTicks;\n        block.appendChild(esm_text(ticks, this.sourcepos(startpos, this.pos - 1)));\n        return true;\n    };\n    // Parse a backslash-escaped special character, adding either the escaped\n    // character, a hard line break (if the backslash is followed by a newline),\n    // or a literal backslash to the block's children.  Assumes current character\n    // is a backslash.\n    InlineParser.prototype.parseBackslash = function (block) {\n        var subj = this.subject;\n        var node;\n        this.pos += 1;\n        var startpos = this.pos;\n        if (this.peek() === C_NEWLINE) {\n            this.pos += 1;\n            node = createNode('linebreak', this.sourcepos(this.pos - 1, this.pos));\n            block.appendChild(node);\n            this.nextLine();\n        }\n        else if (reEscapable.test(subj.charAt(this.pos))) {\n            block.appendChild(esm_text(subj.charAt(this.pos), this.sourcepos(startpos, this.pos)));\n            this.pos += 1;\n        }\n        else {\n            block.appendChild(esm_text('\\\\', this.sourcepos(startpos, startpos)));\n        }\n        return true;\n    };\n    // Attempt to parse an autolink (URL or email in pointy brackets).\n    InlineParser.prototype.parseAutolink = function (block) {\n        var m;\n        var dest;\n        var node;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reEmailAutolink))) {\n            dest = m.slice(1, m.length - 1);\n            node = createNode('link', this.sourcepos(startpos, this.pos));\n            node.destination = normalizeURI(\"mailto:\" + dest);\n            node.title = '';\n            node.appendChild(esm_text(dest, this.sourcepos(startpos + 1, this.pos - 1)));\n            block.appendChild(node);\n            return true;\n        }\n        if ((m = this.match(reAutolink))) {\n            dest = m.slice(1, m.length - 1);\n            node = createNode('link', this.sourcepos(startpos, this.pos));\n            node.destination = normalizeURI(dest);\n            node.title = '';\n            node.appendChild(esm_text(dest, this.sourcepos(startpos + 1, this.pos - 1)));\n            block.appendChild(node);\n            return true;\n        }\n        return false;\n    };\n    // Attempt to parse a raw HTML tag.\n    InlineParser.prototype.parseHtmlTag = function (block) {\n        var startpos = this.pos + 1;\n        var m = this.match(reHtmlTag);\n        if (m === null) {\n            return false;\n        }\n        var node = createNode('htmlInline', this.sourcepos(startpos, this.pos));\n        node.literal = m;\n        block.appendChild(node);\n        return true;\n    };\n    // Scan a sequence of characters with code cc, and return information about\n    // the number of delimiters and whether they are positioned such that\n    // they can open and/or close emphasis or strong emphasis.  A utility\n    // function for strong/emph parsing.\n    InlineParser.prototype.scanDelims = function (cc) {\n        var numdelims = 0;\n        var startpos = this.pos;\n        if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {\n            numdelims++;\n            this.pos++;\n        }\n        else {\n            while (this.peek() === cc) {\n                numdelims++;\n                this.pos++;\n            }\n        }\n        if (numdelims === 0 || (numdelims < 2 && (cc === C_TILDE || cc === C_DOLLAR))) {\n            this.pos = startpos;\n            return null;\n        }\n        var charBefore = startpos === 0 ? '\\n' : this.subject.charAt(startpos - 1);\n        var ccAfter = this.peek();\n        var charAfter;\n        if (ccAfter === -1) {\n            charAfter = '\\n';\n        }\n        else {\n            charAfter = fromCodePoint$1(ccAfter);\n        }\n        var afterIsWhitespace = reUnicodeWhitespaceChar.test(charAfter);\n        var afterIsPunctuation = rePunctuation.test(charAfter);\n        var beforeIsWhitespace = reUnicodeWhitespaceChar.test(charBefore);\n        var beforeIsPunctuation = rePunctuation.test(charBefore);\n        var leftFlanking = !afterIsWhitespace && (!afterIsPunctuation || beforeIsWhitespace || beforeIsPunctuation);\n        var rightFlanking = !beforeIsWhitespace && (!beforeIsPunctuation || afterIsWhitespace || afterIsPunctuation);\n        var canOpen;\n        var canClose;\n        if (cc === C_UNDERSCORE) {\n            canOpen = leftFlanking && (!rightFlanking || beforeIsPunctuation);\n            canClose = rightFlanking && (!leftFlanking || afterIsPunctuation);\n        }\n        else if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {\n            canOpen = leftFlanking && !rightFlanking;\n            canClose = rightFlanking;\n        }\n        else if (cc === C_DOLLAR) {\n            canOpen = !afterIsWhitespace;\n            canClose = !beforeIsWhitespace;\n        }\n        else {\n            canOpen = leftFlanking;\n            canClose = rightFlanking;\n        }\n        this.pos = startpos;\n        return { numdelims: numdelims, canOpen: canOpen, canClose: canClose };\n    };\n    // Handle a delimiter marker for emphasis or a quote.\n    InlineParser.prototype.handleDelim = function (cc, block) {\n        var res = this.scanDelims(cc);\n        if (!res) {\n            return false;\n        }\n        var numdelims = res.numdelims;\n        var startpos = this.pos + 1;\n        var contents;\n        this.pos += numdelims;\n        if (cc === C_SINGLEQUOTE) {\n            contents = '\\u2019';\n        }\n        else if (cc === C_DOUBLEQUOTE) {\n            contents = '\\u201C';\n        }\n        else {\n            contents = this.subject.slice(startpos - 1, this.pos);\n        }\n        var node = esm_text(contents, this.sourcepos(startpos, this.pos));\n        block.appendChild(node);\n        // Add entry to stack for this opener\n        if ((res.canOpen || res.canClose) &&\n            (this.options.smart || (cc !== C_SINGLEQUOTE && cc !== C_DOUBLEQUOTE))) {\n            this.delimiters = {\n                cc: cc,\n                numdelims: numdelims,\n                origdelims: numdelims,\n                node: node,\n                previous: this.delimiters,\n                next: null,\n                canOpen: res.canOpen,\n                canClose: res.canClose,\n            };\n            if (this.delimiters.previous) {\n                this.delimiters.previous.next = this.delimiters;\n            }\n        }\n        return true;\n    };\n    InlineParser.prototype.removeDelimiter = function (delim) {\n        if (delim.previous !== null) {\n            delim.previous.next = delim.next;\n        }\n        if (delim.next === null) {\n            // top of stack\n            this.delimiters = delim.previous;\n        }\n        else {\n            delim.next.previous = delim.previous;\n        }\n    };\n    InlineParser.prototype.removeDelimitersBetween = function (bottom, top) {\n        if (bottom.next !== top) {\n            bottom.next = top;\n            top.previous = bottom;\n        }\n    };\n    /**\n     * Process all delimiters - emphasis, strong emphasis, strikethrough(gfm)\n     * If the smart punctuation options is true,\n     * convert single/double quotes to corresponding unicode characters.\n     **/\n    InlineParser.prototype.processEmphasis = function (stackBottom) {\n        var _a;\n        var opener;\n        var closer;\n        var oldCloser;\n        var openerInl, closerInl;\n        var openerFound;\n        var oddMatch = false;\n        var openersBottom = (_a = {},\n            _a[C_UNDERSCORE] = [stackBottom, stackBottom, stackBottom],\n            _a[C_ASTERISK] = [stackBottom, stackBottom, stackBottom],\n            _a[C_SINGLEQUOTE] = [stackBottom],\n            _a[C_DOUBLEQUOTE] = [stackBottom],\n            _a[C_TILDE] = [stackBottom],\n            _a[C_DOLLAR] = [stackBottom],\n            _a);\n        // find first closer above stackBottom:\n        closer = this.delimiters;\n        while (closer !== null && closer.previous !== stackBottom) {\n            closer = closer.previous;\n        }\n        // move forward, looking for closers, and handling each\n        while (closer !== null) {\n            var closercc = closer.cc;\n            var closerEmph = closercc === C_UNDERSCORE || closercc === C_ASTERISK;\n            if (!closer.canClose) {\n                closer = closer.next;\n            }\n            else {\n                // found emphasis closer. now look back for first matching opener:\n                opener = closer.previous;\n                openerFound = false;\n                while (opener !== null &&\n                    opener !== stackBottom &&\n                    opener !== openersBottom[closercc][closerEmph ? closer.origdelims % 3 : 0]) {\n                    oddMatch =\n                        closerEmph &&\n                            (closer.canOpen || opener.canClose) &&\n                            closer.origdelims % 3 !== 0 &&\n                            (opener.origdelims + closer.origdelims) % 3 === 0;\n                    if (opener.cc === closer.cc && opener.canOpen && !oddMatch) {\n                        openerFound = true;\n                        break;\n                    }\n                    opener = opener.previous;\n                }\n                oldCloser = closer;\n                if (closerEmph || closercc === C_TILDE || closercc === C_DOLLAR) {\n                    if (!openerFound) {\n                        closer = closer.next;\n                    }\n                    else if (opener) {\n                        // (null opener check for type narrowing)\n                        // calculate actual number of delimiters used from closer\n                        var useDelims = closer.numdelims >= 2 && opener.numdelims >= 2 ? 2 : 1;\n                        var emptyDelims = closerEmph ? 0 : 1;\n                        openerInl = opener.node;\n                        closerInl = closer.node;\n                        // build contents for new emph element\n                        var nodeType = closerEmph\n                            ? useDelims === 1\n                                ? 'emph'\n                                : 'strong'\n                            : 'strike';\n                        if (closercc === C_DOLLAR) {\n                            nodeType = 'customInline';\n                        }\n                        var newNode = createNode(nodeType);\n                        var openerEndPos = openerInl.sourcepos[1];\n                        var closerStartPos = closerInl.sourcepos[0];\n                        newNode.sourcepos = [\n                            [openerEndPos[0], openerEndPos[1] - useDelims + 1],\n                            [closerStartPos[0], closerStartPos[1] + useDelims - 1],\n                        ];\n                        openerInl.sourcepos[1][1] -= useDelims;\n                        closerInl.sourcepos[0][1] += useDelims;\n                        openerInl.literal = openerInl.literal.slice(useDelims);\n                        closerInl.literal = closerInl.literal.slice(useDelims);\n                        opener.numdelims -= useDelims;\n                        closer.numdelims -= useDelims;\n                        // remove used delimiters from stack elts and inlines\n                        var tmp = openerInl.next;\n                        var next = void 0;\n                        while (tmp && tmp !== closerInl) {\n                            next = tmp.next;\n                            tmp.unlink();\n                            newNode.appendChild(tmp);\n                            tmp = next;\n                        }\n                        // build custom inline node\n                        if (closercc === C_DOLLAR) {\n                            var textNode = newNode.firstChild;\n                            var literal = textNode.literal || '';\n                            var info = literal.split(/\\s/)[0];\n                            newNode.info = info;\n                            if (literal.length <= info.length) {\n                                textNode.unlink();\n                            }\n                            else {\n                                textNode.sourcepos[0][1] += info.length;\n                                textNode.literal = literal.replace(info + \" \", '');\n                            }\n                        }\n                        openerInl.insertAfter(newNode);\n                        // remove elts between opener and closer in delimiters stack\n                        this.removeDelimitersBetween(opener, closer);\n                        // if opener has 0 delims, remove it and the inline\n                        // if opener has 1 delims and character is tilde, remove delimiter only\n                        if (opener.numdelims <= emptyDelims) {\n                            if (opener.numdelims === 0) {\n                                openerInl.unlink();\n                            }\n                            this.removeDelimiter(opener);\n                        }\n                        // if closer has 0 delims, remove it and the inline\n                        // if closer has 1 delims and character is tilde, remove delimiter only\n                        if (closer.numdelims <= emptyDelims) {\n                            if (closer.numdelims === 0) {\n                                closerInl.unlink();\n                            }\n                            var tempstack = closer.next;\n                            this.removeDelimiter(closer);\n                            closer = tempstack;\n                        }\n                    }\n                }\n                else if (closercc === C_SINGLEQUOTE) {\n                    closer.node.literal = '\\u2019';\n                    if (openerFound) {\n                        opener.node.literal = '\\u2018';\n                    }\n                    closer = closer.next;\n                }\n                else if (closercc === C_DOUBLEQUOTE) {\n                    closer.node.literal = '\\u201D';\n                    if (openerFound) {\n                        opener.node.literal = '\\u201C';\n                    }\n                    closer = closer.next;\n                }\n                if (!openerFound) {\n                    // Set lower bound for future searches for openers:\n                    openersBottom[closercc][closerEmph ? oldCloser.origdelims % 3 : 0] = oldCloser.previous;\n                    if (!oldCloser.canOpen) {\n                        // We can remove a closer that can't be an opener,\n                        // once we've seen there's no matching opener:\n                        this.removeDelimiter(oldCloser);\n                    }\n                }\n            }\n        }\n        // remove all delimiters\n        while (this.delimiters !== null && this.delimiters !== stackBottom) {\n            this.removeDelimiter(this.delimiters);\n        }\n    };\n    // Attempt to parse link title (sans quotes), returning the string\n    // or null if no match.\n    InlineParser.prototype.parseLinkTitle = function () {\n        var title = this.match(reLinkTitle);\n        if (title === null) {\n            return null;\n        }\n        // chop off quotes from title and unescape:\n        return unescapeString(title.substr(1, title.length - 2));\n    };\n    // Attempt to parse link destination, returning the string or null if no match.\n    InlineParser.prototype.parseLinkDestination = function () {\n        var res = this.match(reLinkDestinationBraces);\n        if (res === null) {\n            if (this.peek() === C_LESSTHAN$1) {\n                return null;\n            }\n            // @TODO handrolled parser; res should be null or the string\n            var savepos = this.pos;\n            var openparens = 0;\n            var c = void 0;\n            while ((c = this.peek()) !== -1) {\n                if (c === C_BACKSLASH && reEscapable.test(this.subject.charAt(this.pos + 1))) {\n                    this.pos += 1;\n                    if (this.peek() !== -1) {\n                        this.pos += 1;\n                    }\n                }\n                else if (c === C_OPEN_PAREN) {\n                    this.pos += 1;\n                    openparens += 1;\n                }\n                else if (c === C_CLOSE_PAREN) {\n                    if (openparens < 1) {\n                        break;\n                    }\n                    else {\n                        this.pos += 1;\n                        openparens -= 1;\n                    }\n                }\n                else if (reWhitespaceChar.exec(fromCodePoint$1(c)) !== null) {\n                    break;\n                }\n                else {\n                    this.pos += 1;\n                }\n            }\n            if (this.pos === savepos && c !== C_CLOSE_PAREN) {\n                return null;\n            }\n            if (openparens !== 0) {\n                return null;\n            }\n            res = this.subject.substr(savepos, this.pos - savepos);\n            return normalizeURI(unescapeString(res));\n        } // chop off surrounding <..>:\n        return normalizeURI(unescapeString(res.substr(1, res.length - 2)));\n    };\n    // Attempt to parse a link label, returning number of characters parsed.\n    InlineParser.prototype.parseLinkLabel = function () {\n        var m = this.match(reLinkLabel);\n        if (m === null || m.length > 1001) {\n            return 0;\n        }\n        return m.length;\n    };\n    // Add open bracket to delimiter stack and add a text node to block's children.\n    InlineParser.prototype.parseOpenBracket = function (block) {\n        var startpos = this.pos;\n        this.pos += 1;\n        var node = esm_text('[', this.sourcepos(this.pos, this.pos));\n        block.appendChild(node);\n        // Add entry to stack for this opener\n        this.addBracket(node, startpos, false);\n        return true;\n    };\n    // IF next character is [, and ! delimiter to delimiter stack and\n    // add a text node to block's children.  Otherwise just add a text node.\n    InlineParser.prototype.parseBang = function (block) {\n        var startpos = this.pos;\n        this.pos += 1;\n        if (this.peek() === C_OPEN_BRACKET$1) {\n            this.pos += 1;\n            var node = esm_text('![', this.sourcepos(this.pos - 1, this.pos));\n            block.appendChild(node);\n            // Add entry to stack for this opener\n            this.addBracket(node, startpos + 1, true);\n        }\n        else {\n            var node = esm_text('!', this.sourcepos(this.pos, this.pos));\n            block.appendChild(node);\n        }\n        return true;\n    };\n    // Try to match close bracket against an opening in the delimiter\n    // stack.  Add either a link or image, or a plain [ character,\n    // to block's children.  If there is a matching delimiter,\n    // remove it from the delimiter stack.\n    InlineParser.prototype.parseCloseBracket = function (block) {\n        var dest = null;\n        var title = null;\n        var matched = false;\n        this.pos += 1;\n        var startpos = this.pos;\n        // get last [ or ![\n        var opener = this.brackets;\n        if (opener === null) {\n            // no matched opener, just return a literal\n            block.appendChild(esm_text(']', this.sourcepos(startpos, startpos)));\n            return true;\n        }\n        if (!opener.active) {\n            // no matched opener, just return a literal\n            block.appendChild(esm_text(']', this.sourcepos(startpos, startpos)));\n            // take opener off brackets stack\n            this.removeBracket();\n            return true;\n        }\n        // If we got here, open is a potential opener\n        var isImage = opener.image;\n        // Check to see if we have a link/image\n        var savepos = this.pos;\n        // Inline link?\n        if (this.peek() === C_OPEN_PAREN) {\n            this.pos++;\n            if (this.spnl() &&\n                (dest = this.parseLinkDestination()) !== null &&\n                this.spnl() &&\n                // make sure there's a space before the title:\n                ((reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) &&\n                    (title = this.parseLinkTitle())) ||\n                    true) &&\n                this.spnl() &&\n                this.peek() === C_CLOSE_PAREN) {\n                this.pos += 1;\n                matched = true;\n            }\n            else {\n                this.pos = savepos;\n            }\n        }\n        var refLabel = '';\n        if (!matched) {\n            // Next, see if there's a link label\n            var beforelabel = this.pos;\n            var n = this.parseLinkLabel();\n            if (n > 2) {\n                refLabel = this.subject.slice(beforelabel, beforelabel + n);\n            }\n            else if (!opener.bracketAfter) {\n                // Empty or missing second label means to use the first label as the reference.\n                // The reference must not contain a bracket. If we know there's a bracket, we don't even bother checking it.\n                refLabel = this.subject.slice(opener.index, startpos);\n            }\n            if (n === 0) {\n                // If shortcut reference link, rewind before spaces we skipped.\n                this.pos = savepos;\n            }\n            if (refLabel) {\n                refLabel = normalizeReference(refLabel);\n                // lookup rawlabel in refMap\n                var link = this.refMap[refLabel];\n                if (link) {\n                    dest = link.destination;\n                    title = link.title;\n                    matched = true;\n                }\n            }\n        }\n        if (matched) {\n            var node = createNode(isImage ? 'image' : 'link');\n            node.destination = dest;\n            node.title = title || '';\n            node.sourcepos = [opener.startpos, this.sourcepos(this.pos)];\n            var tmp = opener.node.next;\n            var next = void 0;\n            while (tmp) {\n                next = tmp.next;\n                tmp.unlink();\n                node.appendChild(tmp);\n                tmp = next;\n            }\n            block.appendChild(node);\n            this.processEmphasis(opener.previousDelimiter);\n            this.removeBracket();\n            opener.node.unlink();\n            // We remove this bracket and processEmphasis will remove later delimiters.\n            // Now, for a link, we also deactivate earlier link openers.\n            // (no links in links)\n            if (!isImage) {\n                opener = this.brackets;\n                while (opener !== null) {\n                    if (!opener.image) {\n                        opener.active = false; // deactivate this opener\n                    }\n                    opener = opener.previous;\n                }\n            }\n            if (this.options.referenceDefinition) {\n                this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };\n            }\n            return true;\n        } // no match\n        this.removeBracket(); // remove this opener from stack\n        this.pos = startpos;\n        block.appendChild(esm_text(']', this.sourcepos(startpos, startpos)));\n        if (this.options.referenceDefinition) {\n            this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };\n        }\n        return true;\n    };\n    InlineParser.prototype.addBracket = function (node, index, image) {\n        if (this.brackets !== null) {\n            this.brackets.bracketAfter = true;\n        }\n        this.brackets = {\n            node: node,\n            startpos: this.sourcepos(index + (image ? 0 : 1)),\n            previous: this.brackets,\n            previousDelimiter: this.delimiters,\n            index: index,\n            image: image,\n            active: true,\n        };\n    };\n    InlineParser.prototype.removeBracket = function () {\n        if (this.brackets) {\n            this.brackets = this.brackets.previous;\n        }\n    };\n    // Attempt to parse an entity.\n    InlineParser.prototype.parseEntity = function (block) {\n        var m;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reEntityHere))) {\n            block.appendChild(esm_text(lib.decodeHTML(m), this.sourcepos(startpos, this.pos)));\n            return true;\n        }\n        return false;\n    };\n    // Parse a run of ordinary characters, or a single character with\n    // a special meaning in markdown, as a plain string.\n    InlineParser.prototype.parseString = function (block) {\n        var m;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reMain))) {\n            if (this.options.smart) {\n                var lit = m.replace(reEllipses, '\\u2026').replace(reDash, function (chars) {\n                    var enCount = 0;\n                    var emCount = 0;\n                    if (chars.length % 3 === 0) {\n                        // If divisible by 3, use all em dashes\n                        emCount = chars.length / 3;\n                    }\n                    else if (chars.length % 2 === 0) {\n                        // If divisible by 2, use all en dashes\n                        enCount = chars.length / 2;\n                    }\n                    else if (chars.length % 3 === 2) {\n                        // If 2 extra dashes, use en dash for last 2; em dashes for rest\n                        enCount = 1;\n                        emCount = (chars.length - 2) / 3;\n                    }\n                    else {\n                        // Use en dashes for last 4 hyphens; em dashes for rest\n                        enCount = 2;\n                        emCount = (chars.length - 4) / 3;\n                    }\n                    return repeat('\\u2014', emCount) + repeat('\\u2013', enCount);\n                });\n                block.appendChild(esm_text(lit, this.sourcepos(startpos, this.pos)));\n            }\n            else {\n                var node = esm_text(m, this.sourcepos(startpos, this.pos));\n                block.appendChild(node);\n            }\n            return true;\n        }\n        return false;\n    };\n    // Parse a newline.  If it was preceded by two spaces, return a hard\n    // line break; otherwise a soft line break.\n    InlineParser.prototype.parseNewline = function (block) {\n        this.pos += 1; // assume we're at a \\n\n        // check previous node for trailing spaces\n        var lastc = block.lastChild;\n        if (lastc && lastc.type === 'text' && lastc.literal[lastc.literal.length - 1] === ' ') {\n            var hardbreak = lastc.literal[lastc.literal.length - 2] === ' ';\n            var litLen = lastc.literal.length;\n            lastc.literal = lastc.literal.replace(reFinalSpace, '');\n            var finalSpaceLen = litLen - lastc.literal.length;\n            lastc.sourcepos[1][1] -= finalSpaceLen;\n            block.appendChild(createNode(hardbreak ? 'linebreak' : 'softbreak', this.sourcepos(this.pos - finalSpaceLen, this.pos)));\n        }\n        else {\n            block.appendChild(createNode('softbreak', this.sourcepos(this.pos, this.pos)));\n        }\n        this.nextLine();\n        this.match(reInitialSpace); // gobble leading spaces in next line\n        return true;\n    };\n    // Attempt to parse a link reference, modifying refmap.\n    InlineParser.prototype.parseReference = function (block, refMap) {\n        if (!this.options.referenceDefinition) {\n            return 0;\n        }\n        this.subject = block.stringContent;\n        this.pos = 0;\n        var title = null;\n        var startpos = this.pos;\n        // label:\n        var matchChars = this.parseLinkLabel();\n        if (matchChars === 0) {\n            return 0;\n        }\n        var rawlabel = this.subject.substr(0, matchChars);\n        // colon:\n        if (this.peek() === C_COLON) {\n            this.pos++;\n        }\n        else {\n            this.pos = startpos;\n            return 0;\n        }\n        //  link url\n        this.spnl();\n        var dest = this.parseLinkDestination();\n        if (dest === null) {\n            this.pos = startpos;\n            return 0;\n        }\n        var beforetitle = this.pos;\n        this.spnl();\n        if (this.pos !== beforetitle) {\n            title = this.parseLinkTitle();\n        }\n        if (title === null) {\n            title = '';\n            // rewind before spaces\n            this.pos = beforetitle;\n        }\n        // make sure we're at line end:\n        var atLineEnd = true;\n        if (this.match(reSpaceAtEndOfLine) === null) {\n            if (title === '') {\n                atLineEnd = false;\n            }\n            else {\n                // the potential title we found is not at the line end,\n                // but it could still be a legal link reference if we\n                // discard the title\n                title = '';\n                // rewind before spaces\n                this.pos = beforetitle;\n                // and instead check if the link URL is at the line end\n                atLineEnd = this.match(reSpaceAtEndOfLine) !== null;\n            }\n        }\n        if (!atLineEnd) {\n            this.pos = startpos;\n            return 0;\n        }\n        var normalLabel = normalizeReference(rawlabel);\n        if (normalLabel === '') {\n            // label must contain non-whitespace characters\n            this.pos = startpos;\n            return 0;\n        }\n        var sourcepos = this.getReferenceDefSourcepos(block);\n        block.sourcepos[0][0] = sourcepos[1][0] + 1;\n        var node = createNode('refDef', sourcepos);\n        node.title = title;\n        node.dest = dest;\n        node.label = normalLabel;\n        block.insertBefore(node);\n        if (!refMap[normalLabel]) {\n            refMap[normalLabel] = createRefDefState(node);\n        }\n        else {\n            this.refDefCandidateMap[node.id] = node;\n        }\n        return this.pos - startpos;\n    };\n    InlineParser.prototype.mergeTextNodes = function (walker) {\n        var event;\n        var textNodes = [];\n        while ((event = walker.next())) {\n            var entering = event.entering, node = event.node;\n            if (entering && node.type === 'text') {\n                textNodes.push(node);\n            }\n            else if (textNodes.length === 1) {\n                textNodes = [];\n            }\n            else if (textNodes.length > 1) {\n                var firstNode = textNodes[0];\n                var lastNode = textNodes[textNodes.length - 1];\n                if (firstNode.sourcepos && lastNode.sourcepos) {\n                    firstNode.sourcepos[1] = lastNode.sourcepos[1];\n                }\n                firstNode.next = lastNode.next;\n                if (firstNode.next) {\n                    firstNode.next.prev = firstNode;\n                }\n                for (var i = 1; i < textNodes.length; i += 1) {\n                    firstNode.literal += textNodes[i].literal;\n                    textNodes[i].unlink();\n                }\n                textNodes = [];\n            }\n        }\n    };\n    InlineParser.prototype.getReferenceDefSourcepos = function (block) {\n        var lines = block.stringContent.split(/\\n|\\r\\n/);\n        var passedUrlLine = false;\n        var quotationCount = 0;\n        var lastLineOffset = { line: 0, ch: 0 };\n        for (var i = 0; i < lines.length; i += 1) {\n            var line = lines[i];\n            if (reWhitespaceChar.test(line)) {\n                break;\n            }\n            if (/\\:/.test(line) && quotationCount === 0) {\n                if (passedUrlLine) {\n                    break;\n                }\n                var lineOffset = line.indexOf(':') === line.length - 1 ? i + 1 : i;\n                lastLineOffset = { line: lineOffset, ch: lines[lineOffset].length };\n                passedUrlLine = true;\n            }\n            // should consider extendable title\n            var matched = line.match(/'|\"/g);\n            if (matched) {\n                quotationCount += matched.length;\n            }\n            if (quotationCount === 2) {\n                lastLineOffset = { line: i, ch: line.length };\n                break;\n            }\n        }\n        return [\n            [block.sourcepos[0][0], block.sourcepos[0][1]],\n            [block.sourcepos[0][0] + lastLineOffset.line, lastLineOffset.ch],\n        ];\n    };\n    // Parse the next inline element in subject, advancing subject position.\n    // On success, add the result to block's children and return true.\n    // On failure, return false.\n    InlineParser.prototype.parseInline = function (block) {\n        var _a;\n        var res = false;\n        var c = this.peek();\n        if (c === -1) {\n            return false;\n        }\n        switch (c) {\n            case C_NEWLINE:\n                res = this.parseNewline(block);\n                break;\n            case C_BACKSLASH:\n                res = this.parseBackslash(block);\n                break;\n            case C_BACKTICK:\n                res = this.parseBackticks(block);\n                break;\n            case C_ASTERISK:\n            case C_UNDERSCORE:\n            case C_TILDE:\n            case C_DOLLAR:\n                res = this.handleDelim(c, block);\n                break;\n            case C_SINGLEQUOTE:\n            case C_DOUBLEQUOTE:\n                res = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.smart) && this.handleDelim(c, block);\n                break;\n            case C_OPEN_BRACKET$1:\n                res = this.parseOpenBracket(block);\n                break;\n            case C_BANG:\n                res = this.parseBang(block);\n                break;\n            case C_CLOSE_BRACKET:\n                res = this.parseCloseBracket(block);\n                break;\n            case C_LESSTHAN$1:\n                res = this.parseAutolink(block) || this.parseHtmlTag(block);\n                break;\n            case C_AMPERSAND:\n                if (!block.disabledEntityParse) {\n                    res = this.parseEntity(block);\n                }\n                break;\n            default:\n                res = this.parseString(block);\n                break;\n        }\n        if (!res) {\n            this.pos += 1;\n            block.appendChild(esm_text(fromCodePoint$1(c), this.sourcepos(this.pos, this.pos + 1)));\n        }\n        return true;\n    };\n    // Parse string content in block into inline children,\n    // using refmap to resolve references.\n    InlineParser.prototype.parse = function (block) {\n        this.subject = block.stringContent.trim();\n        this.pos = 0;\n        this.delimiters = null;\n        this.brackets = null;\n        this.lineOffsets = block.lineOffsets || [0];\n        this.lineIdx = 0;\n        this.linePosOffset = 0;\n        this.lineStartNum = block.sourcepos[0][0];\n        if (isHeading(block)) {\n            this.lineOffsets[0] += block.level + 1;\n        }\n        while (this.parseInline(block)) { }\n        block.stringContent = null; // allow raw string to be garbage collected\n        this.processEmphasis(null);\n        this.mergeTextNodes(block.walker());\n        var _a = this.options, extendedAutolinks = _a.extendedAutolinks, customParser = _a.customParser;\n        if (extendedAutolinks) {\n            convertExtAutoLinks(block.walker(), extendedAutolinks);\n        }\n        if (customParser && block.firstChild) {\n            var event_1;\n            var walker = block.firstChild.walker();\n            while ((event_1 = walker.next())) {\n                var node = event_1.node, entering = event_1.entering;\n                if (customParser[node.type]) {\n                    customParser[node.type](node, { entering: entering, options: this.options });\n                }\n            }\n        }\n    };\n    return InlineParser;\n}());\nvar reTaskListItemMarker = /^\\[([ \\txX])\\][ \\t]+/;\n// finalize for block handler\nfunction taskListItemFinalize(_, block) {\n    if (block.firstChild && block.firstChild.type === 'paragraph') {\n        var p = block.firstChild;\n        var m = p.stringContent.match(reTaskListItemMarker);\n        if (m) {\n            var mLen = m[0].length;\n            p.stringContent = p.stringContent.substring(mLen - 1);\n            p.sourcepos[0][1] += mLen;\n            p.lineOffsets[0] += mLen;\n            block.listData.task = true;\n            block.listData.checked = /[xX]/.test(m[1]);\n        }\n    }\n}\nvar table = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableHead' || t === 'tableBody';\n    },\n    acceptsLines: false,\n};\nvar tableBody$1 = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableRow';\n    },\n    acceptsLines: false,\n};\nvar tableHead$1 = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableRow' || t === 'tableDelimRow';\n    },\n    acceptsLines: false,\n};\nvar tableDelimRow = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableDelimCell';\n    },\n    acceptsLines: false,\n};\nvar tableDelimCell = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar tableRow = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableCell';\n    },\n    acceptsLines: false,\n};\nvar tableCell = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar CODE_INDENT = 4;\nvar C_TAB = 9;\nvar C_GREATERTHAN = 62;\nvar C_LESSTHAN = 60;\nvar C_SPACE = 32;\nvar C_OPEN_BRACKET = 91;\nvar reNonSpace = /[^ \\t\\f\\v\\r\\n]/;\nvar reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;\n// Returns true if block ends with a blank line, descending if needed\n// into lists and sublists.\nfunction endsWithBlankLine(block) {\n    var curBlock = block;\n    while (curBlock) {\n        if (curBlock.lastLineBlank) {\n            return true;\n        }\n        var t = curBlock.type;\n        if (!curBlock.lastLineChecked && (t === 'list' || t === 'item')) {\n            curBlock.lastLineChecked = true;\n            curBlock = curBlock.lastChild;\n        }\n        else {\n            curBlock.lastLineChecked = true;\n            break;\n        }\n    }\n    return false;\n}\nfunction peek(ln, pos) {\n    if (pos < ln.length) {\n        return ln.charCodeAt(pos);\n    }\n    return -1;\n}\n// Returns true if string contains only space characters.\nfunction isBlank(s) {\n    return !reNonSpace.test(s);\n}\nfunction isSpaceOrTab(c) {\n    return c === C_SPACE || c === C_TAB;\n}\nvar reClosingCustomBlock = /^\\$\\$$/;\nvar customBlock$1 = {\n    continue: function (parser, container) {\n        var line = parser.currentLine;\n        var match = line.match(reClosingCustomBlock);\n        if (match) {\n            // closing custom block\n            parser.lastLineLength = match[0].length;\n            parser.finalize(container, parser.lineNumber);\n            return 2 /* Finished */;\n        }\n        // skip optional spaces of custom block offset\n        var i = container.offset;\n        while (i > 0 && isSpaceOrTab(peek(line, parser.offset))) {\n            parser.advanceOffset(1, true);\n            i--;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        // first line becomes info string\n        var content = block.stringContent;\n        var newlinePos = content.indexOf('\\n');\n        var firstLine = content.slice(0, newlinePos);\n        var rest = content.slice(newlinePos + 1);\n        var infoString = firstLine.match(/^(\\s*)(.*)/);\n        block.info = unescapeString(infoString[2].trim());\n        block.literal = rest;\n        block.stringContent = null;\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar noop = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar document$1 = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar list = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var item = block.firstChild;\n        while (item) {\n            // check for non-final list item ending with blank line:\n            if (endsWithBlankLine(item) && item.next) {\n                block.listData.tight = false;\n                break;\n            }\n            // recurse into children of list item, to see if there are\n            // spaces between any of them:\n            var subitem = item.firstChild;\n            while (subitem) {\n                if (endsWithBlankLine(subitem) && (item.next || subitem.next)) {\n                    block.listData.tight = false;\n                    break;\n                }\n                subitem = subitem.next;\n            }\n            item = item.next;\n        }\n    },\n    canContain: function (t) {\n        return t === 'item';\n    },\n    acceptsLines: false,\n};\nvar blockQuote$1 = {\n    continue: function (parser) {\n        var ln = parser.currentLine;\n        if (!parser.indented && peek(ln, parser.nextNonspace) === C_GREATERTHAN) {\n            parser.advanceNextNonspace();\n            parser.advanceOffset(1, false);\n            if (isSpaceOrTab(peek(ln, parser.offset))) {\n                parser.advanceOffset(1, true);\n            }\n        }\n        else {\n            return 1 /* Stop */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar item = {\n    continue: function (parser, container) {\n        if (parser.blank) {\n            if (container.firstChild === null) {\n                // Blank line after empty list item\n                return 1 /* Stop */;\n            }\n            parser.advanceNextNonspace();\n        }\n        else if (parser.indent >= container.listData.markerOffset + container.listData.padding) {\n            parser.advanceOffset(container.listData.markerOffset + container.listData.padding, true);\n        }\n        else {\n            return 1 /* Stop */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: taskListItemFinalize,\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar heading = {\n    continue: function () {\n        // a heading can never container > 1 line, so fail to match:\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar thematicBreak$1 = {\n    continue: function () {\n        // a thematic break can never container > 1 line, so fail to match:\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar codeBlock = {\n    continue: function (parser, container) {\n        var ln = parser.currentLine;\n        var indent = parser.indent;\n        if (container.isFenced) {\n            // fenced\n            var match = indent <= 3 &&\n                ln.charAt(parser.nextNonspace) === container.fenceChar &&\n                ln.slice(parser.nextNonspace).match(reClosingCodeFence);\n            if (match && match[0].length >= container.fenceLength) {\n                // closing fence - we're at end of line, so we can return\n                parser.lastLineLength = parser.offset + indent + match[0].length;\n                parser.finalize(container, parser.lineNumber);\n                return 2 /* Finished */;\n            }\n            // skip optional spaces of fence offset\n            var i = container.fenceOffset;\n            while (i > 0 && isSpaceOrTab(peek(ln, parser.offset))) {\n                parser.advanceOffset(1, true);\n                i--;\n            }\n        }\n        else {\n            // indented\n            if (indent >= CODE_INDENT) {\n                parser.advanceOffset(CODE_INDENT, true);\n            }\n            else if (parser.blank) {\n                parser.advanceNextNonspace();\n            }\n            else {\n                return 1 /* Stop */;\n            }\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var _a;\n        if (block.stringContent === null) {\n            return;\n        }\n        if (block.isFenced) {\n            // fenced\n            // first line becomes info string\n            var content = block.stringContent;\n            var newlinePos = content.indexOf('\\n');\n            var firstLine = content.slice(0, newlinePos);\n            var rest = content.slice(newlinePos + 1);\n            var infoString = firstLine.match(/^(\\s*)(.*)/);\n            block.infoPadding = infoString[1].length;\n            block.info = unescapeString(infoString[2].trim());\n            block.literal = rest;\n        }\n        else {\n            // indented\n            block.literal = (_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\\n *)+$/, '\\n');\n        }\n        block.stringContent = null; // allow GC\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar htmlBlock$1 = {\n    continue: function (parser, container) {\n        return parser.blank && (container.htmlBlockType === 6 || container.htmlBlockType === 7)\n            ? 1 /* Stop */\n            : 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var _a;\n        block.literal = ((_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\\n *)+$/, '')) || null;\n        block.stringContent = null; // allow GC\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar paragraph = {\n    continue: function (parser) {\n        return parser.blank ? 1 /* Stop */ : 0 /* Go */;\n    },\n    finalize: function (parser, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        var pos;\n        var hasReferenceDefs = false;\n        // try parsing the beginning as link reference definitions:\n        while (peek(block.stringContent, 0) === C_OPEN_BRACKET &&\n            (pos = parser.inlineParser.parseReference(block, parser.refMap))) {\n            block.stringContent = block.stringContent.slice(pos);\n            hasReferenceDefs = true;\n        }\n        if (hasReferenceDefs && isBlank(block.stringContent)) {\n            block.unlink();\n        }\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar refDef = noop;\nvar frontMatter$2 = noop;\nvar blockHandlers = {\n    document: document$1,\n    list: list,\n    blockQuote: blockQuote$1,\n    item: item,\n    heading: heading,\n    thematicBreak: thematicBreak$1,\n    codeBlock: codeBlock,\n    htmlBlock: htmlBlock$1,\n    paragraph: paragraph,\n    table: table,\n    tableBody: tableBody$1,\n    tableHead: tableHead$1,\n    tableRow: tableRow,\n    tableCell: tableCell,\n    tableDelimRow: tableDelimRow,\n    tableDelimCell: tableDelimCell,\n    refDef: refDef,\n    customBlock: customBlock$1,\n    frontMatter: frontMatter$2,\n};\nfunction parseRowContent(content) {\n    var startIdx = 0;\n    var offset = 0;\n    var cells = [];\n    for (var i = 0; i < content.length; i += 1) {\n        if (content[i] === '|' && content[i - 1] !== '\\\\') {\n            var cell = content.substring(startIdx, i);\n            if (startIdx === 0 && isEmpty(cell)) {\n                offset = i + 1;\n            }\n            else {\n                cells.push(cell);\n            }\n            startIdx = i + 1;\n        }\n    }\n    if (startIdx < content.length) {\n        var cell = content.substring(startIdx, content.length);\n        if (!isEmpty(cell)) {\n            cells.push(cell);\n        }\n    }\n    return [offset, cells];\n}\nfunction generateTableCells(cellType, contents, lineNum, chPos) {\n    var cells = [];\n    for (var _i = 0, contents_1 = contents; _i < contents_1.length; _i++) {\n        var content = contents_1[_i];\n        var preSpaces = content.match(/^[ \\t]+/);\n        var paddingLeft = preSpaces ? preSpaces[0].length : 0;\n        var paddingRight = void 0, trimmed = void 0;\n        if (paddingLeft === content.length) {\n            paddingLeft = 0;\n            paddingRight = 0;\n            trimmed = '';\n        }\n        else {\n            var postSpaces = content.match(/[ \\t]+$/);\n            paddingRight = postSpaces ? postSpaces[0].length : 0;\n            trimmed = content.slice(paddingLeft, content.length - paddingRight);\n        }\n        var chPosStart = chPos + paddingLeft;\n        var tableCell = createNode(cellType, [\n            [lineNum, chPos],\n            [lineNum, chPos + content.length - 1],\n        ]);\n        tableCell.stringContent = trimmed.replace(/\\\\\\|/g, '|'); // replace esacped pipe(\\|)\n        tableCell.startIdx = cells.length;\n        tableCell.endIdx = cells.length;\n        tableCell.lineOffsets = [chPosStart - 1];\n        tableCell.paddingLeft = paddingLeft;\n        tableCell.paddingRight = paddingRight;\n        cells.push(tableCell);\n        chPos += content.length + 1;\n    }\n    return cells;\n}\nfunction getColumnFromDelimCell(cellNode) {\n    var align = null;\n    var content = cellNode.stringContent;\n    var firstCh = content[0];\n    var lastCh = content[content.length - 1];\n    if (lastCh === ':') {\n        align = firstCh === ':' ? 'center' : 'right';\n    }\n    else if (firstCh === ':') {\n        align = 'left';\n    }\n    return { align: align };\n}\nvar tableHead = function (parser, container) {\n    var stringContent = container.stringContent;\n    if (container.type === 'paragraph' && !parser.indented && !parser.blank) {\n        var lastNewLineIdx = stringContent.length - 1;\n        var lastLineStartIdx = stringContent.lastIndexOf('\\n', lastNewLineIdx - 1) + 1;\n        var headerContent = stringContent.slice(lastLineStartIdx, lastNewLineIdx);\n        var delimContent = parser.currentLine.slice(parser.nextNonspace);\n        var _a = parseRowContent(headerContent), headerOffset = _a[0], headerCells = _a[1];\n        var _b = parseRowContent(delimContent), delimOffset = _b[0], delimCells = _b[1];\n        var reValidDelimCell_1 = /^[ \\t]*:?-+:?[ \\t]*$/;\n        if (\n        // not checking if the number of header cells and delimiter cells are the same\n        // to consider the case of merged-column (via plugin)\n        !headerCells.length ||\n            !delimCells.length ||\n            delimCells.some(function (cell) { return !reValidDelimCell_1.test(cell); }) ||\n            // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option\n            (delimCells.length === 1 && delimContent.indexOf('|') !== 0)) {\n            return 0 /* None */;\n        }\n        var lineOffsets = container.lineOffsets;\n        var firstLineNum = parser.lineNumber - 1;\n        var firstLineStart = last(lineOffsets) + 1;\n        var table = createNode('table', [\n            [firstLineNum, firstLineStart],\n            [parser.lineNumber, parser.offset],\n        ]);\n        // eslint-disable-next-line arrow-body-style\n        table.columns = delimCells.map(function () { return ({ align: null }); });\n        container.insertAfter(table);\n        if (lineOffsets.length === 1) {\n            container.unlink();\n        }\n        else {\n            container.stringContent = stringContent.slice(0, lastLineStartIdx);\n            var paraLastLineStartIdx = stringContent.lastIndexOf('\\n', lastLineStartIdx - 2) + 1;\n            var paraLastLineLen = lastLineStartIdx - paraLastLineStartIdx - 1;\n            parser.lastLineLength = lineOffsets[lineOffsets.length - 2] + paraLastLineLen;\n            parser.finalize(container, firstLineNum - 1);\n        }\n        parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n        var tableHead_1 = createNode('tableHead', [\n            [firstLineNum, firstLineStart],\n            [parser.lineNumber, parser.offset],\n        ]);\n        table.appendChild(tableHead_1);\n        var tableHeadRow_1 = createNode('tableRow', [\n            [firstLineNum, firstLineStart],\n            [firstLineNum, firstLineStart + headerContent.length - 1],\n        ]);\n        var tableDelimRow_1 = createNode('tableDelimRow', [\n            [parser.lineNumber, parser.nextNonspace + 1],\n            [parser.lineNumber, parser.offset],\n        ]);\n        tableHead_1.appendChild(tableHeadRow_1);\n        tableHead_1.appendChild(tableDelimRow_1);\n        generateTableCells('tableCell', headerCells, firstLineNum, firstLineStart + headerOffset).forEach(function (cellNode) {\n            tableHeadRow_1.appendChild(cellNode);\n        });\n        var delimCellNodes = generateTableCells('tableDelimCell', delimCells, parser.lineNumber, parser.nextNonspace + 1 + delimOffset);\n        delimCellNodes.forEach(function (cellNode) {\n            tableDelimRow_1.appendChild(cellNode);\n        });\n        table.columns = delimCellNodes.map(getColumnFromDelimCell);\n        parser.tip = table;\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar tableBody = function (parser, container) {\n    if ((container.type !== 'table' && container.type !== 'tableBody') ||\n        (!parser.blank && parser.currentLine.indexOf('|') === -1)) {\n        return 0 /* None */;\n    }\n    parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n    if (parser.blank) {\n        var table_1 = container;\n        if (container.type === 'tableBody') {\n            table_1 = container.parent;\n            parser.finalize(container, parser.lineNumber - 1);\n        }\n        parser.finalize(table_1, parser.lineNumber - 1);\n        return 0 /* None */;\n    }\n    var tableBody = container;\n    if (container.type === 'table') {\n        tableBody = parser.addChild('tableBody', parser.nextNonspace);\n        tableBody.stringContent = null;\n    }\n    var tableRow = createNode('tableRow', [\n        [parser.lineNumber, parser.nextNonspace + 1],\n        [parser.lineNumber, parser.currentLine.length],\n    ]);\n    tableBody.appendChild(tableRow);\n    var table = tableBody.parent;\n    var content = parser.currentLine.slice(parser.nextNonspace);\n    var _a = parseRowContent(content), offset = _a[0], cellContents = _a[1];\n    generateTableCells('tableCell', cellContents, parser.lineNumber, parser.nextNonspace + 1 + offset).forEach(function (cellNode, idx) {\n        if (idx >= table.columns.length) {\n            cellNode.ignored = true;\n        }\n        tableRow.appendChild(cellNode);\n    });\n    return 2 /* Leaf */;\n};\nvar reCustomBlock = /^(\\$\\$)(\\s*[a-zA-Z])+/;\nvar reCanBeCustomInline = /^(\\$\\$)(\\s*[a-zA-Z])+.*(\\$\\$)/;\nvar customBlock = function (parser) {\n    var match;\n    if (!parser.indented &&\n        !reCanBeCustomInline.test(parser.currentLine) &&\n        (match = parser.currentLine.match(reCustomBlock))) {\n        var syntaxLength = match[1].length;\n        parser.closeUnmatchedBlocks();\n        var container = parser.addChild('customBlock', parser.nextNonspace);\n        container.syntaxLength = syntaxLength;\n        container.offset = parser.indent;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(syntaxLength, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar reCodeFence = /^`{3,}(?!.*`)|^~{3,}/;\nvar reHtmlBlockOpen = [\n    /./,\n    /^<(?:script|pre|style)(?:\\s|>|$)/i,\n    /^<!--/,\n    /^<[?]/,\n    /^<![A-Z]/,\n    /^<!\\[CDATA\\[/,\n    /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|[/]?[>]|$)/i,\n    new RegExp(\"^(?:\" + OPENTAG + \"|\" + CLOSETAG + \")\\\\s*$\", 'i'),\n];\nvar reSetextHeadingLine = /^(?:=+|-+)[ \\t]*$/;\nvar reATXHeadingMarker = /^#{1,6}(?:[ \\t]+|$)/;\nvar reThematicBreak = /^(?:(?:\\*[ \\t]*){3,}|(?:_[ \\t]*){3,}|(?:-[ \\t]*){3,})[ \\t]*$/;\nvar reBulletListMarker = /^[*+-]/;\nvar reOrderedListMarker = /^(\\d{1,9})([.)])/;\n// Parse a list marker and return data on the marker (type,\n// start, delimiter, bullet character, padding) or null.\nfunction parseListMarker(parser, container) {\n    var rest = parser.currentLine.slice(parser.nextNonspace);\n    var match;\n    var nextc;\n    var data = {\n        type: 'bullet',\n        tight: true,\n        bulletChar: '',\n        start: 0,\n        delimiter: '',\n        padding: 0,\n        markerOffset: parser.indent,\n        // GFM: Task List Item\n        task: false,\n        checked: false,\n    };\n    if (parser.indent >= 4) {\n        return null;\n    }\n    if ((match = rest.match(reBulletListMarker))) {\n        data.type = 'bullet';\n        data.bulletChar = match[0][0];\n    }\n    else if ((match = rest.match(reOrderedListMarker)) &&\n        (container.type !== 'paragraph' || match[1] === '1')) {\n        data.type = 'ordered';\n        data.start = parseInt(match[1], 10);\n        data.delimiter = match[2];\n    }\n    else {\n        return null;\n    }\n    // make sure we have spaces after\n    nextc = peek(parser.currentLine, parser.nextNonspace + match[0].length);\n    if (!(nextc === -1 || nextc === C_TAB || nextc === C_SPACE)) {\n        return null;\n    }\n    // if it interrupts paragraph, make sure first line isn't blank\n    if (container.type === 'paragraph' &&\n        !parser.currentLine.slice(parser.nextNonspace + match[0].length).match(reNonSpace)) {\n        return null;\n    }\n    // we've got a match! advance offset and calculate padding\n    parser.advanceNextNonspace(); // to start of marker\n    parser.advanceOffset(match[0].length, true); // to end of marker\n    var spacesStartCol = parser.column;\n    var spacesStartOffset = parser.offset;\n    do {\n        parser.advanceOffset(1, true);\n        nextc = peek(parser.currentLine, parser.offset);\n    } while (parser.column - spacesStartCol < 5 && isSpaceOrTab(nextc));\n    var blankItem = peek(parser.currentLine, parser.offset) === -1;\n    var spacesAfterMarker = parser.column - spacesStartCol;\n    if (spacesAfterMarker >= 5 || spacesAfterMarker < 1 || blankItem) {\n        data.padding = match[0].length + 1;\n        parser.column = spacesStartCol;\n        parser.offset = spacesStartOffset;\n        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n            parser.advanceOffset(1, true);\n        }\n    }\n    else {\n        data.padding = match[0].length + spacesAfterMarker;\n    }\n    return data;\n}\n// Returns true if the two list items are of the same type,\n// with the same delimiter and bullet character.  This is used\n// in agglomerating list items into lists.\nfunction listsMatch(listData, itemData) {\n    return (listData.type === itemData.type &&\n        listData.delimiter === itemData.delimiter &&\n        listData.bulletChar === itemData.bulletChar);\n}\nfunction isDisallowedDeepHeading(parser, node) {\n    return parser.options.disallowDeepHeading && (node.type === 'blockQuote' || node.type === 'item');\n}\nvar blockQuote = function (parser) {\n    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN) {\n        parser.advanceNextNonspace();\n        parser.advanceOffset(1, false);\n        // optional following space\n        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n            parser.advanceOffset(1, true);\n        }\n        parser.closeUnmatchedBlocks();\n        parser.addChild('blockQuote', parser.nextNonspace);\n        return 1 /* Container */;\n    }\n    return 0 /* None */;\n};\nvar atxHeading = function (parser, container) {\n    var match;\n    if (!parser.indented &&\n        // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option\n        !isDisallowedDeepHeading(parser, container) &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeadingMarker))) {\n        parser.advanceNextNonspace();\n        parser.advanceOffset(match[0].length, false);\n        parser.closeUnmatchedBlocks();\n        var heading = parser.addChild('heading', parser.nextNonspace);\n        heading.level = match[0].trim().length; // number of #s\n        heading.headingType = 'atx';\n        // remove trailing ###s:\n        heading.stringContent = parser.currentLine\n            .slice(parser.offset)\n            .replace(/^[ \\t]*#+[ \\t]*$/, '')\n            .replace(/[ \\t]+#+[ \\t]*$/, '');\n        parser.advanceOffset(parser.currentLine.length - parser.offset);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar fencedCodeBlock = function (parser) {\n    var match;\n    if (!parser.indented &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence))) {\n        var fenceLength = match[0].length;\n        parser.closeUnmatchedBlocks();\n        var container = parser.addChild('codeBlock', parser.nextNonspace);\n        container.isFenced = true;\n        container.fenceLength = fenceLength;\n        container.fenceChar = match[0][0];\n        container.fenceOffset = parser.indent;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(fenceLength, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar htmlBlock = function (parser, container) {\n    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_LESSTHAN) {\n        var s = parser.currentLine.slice(parser.nextNonspace);\n        var disallowedTags = parser.options.disallowedHtmlBlockTags;\n        var blockType = void 0;\n        for (blockType = 1; blockType <= 7; blockType++) {\n            var matched = s.match(reHtmlBlockOpen[blockType]);\n            if (matched) {\n                if (blockType === 7) {\n                    if (container.type === 'paragraph') {\n                        return 0 /* None */;\n                    }\n                    if (disallowedTags.length > 0) {\n                        var reDisallowedTags = new RegExp(\"</?(?:\" + disallowedTags.join('|') + \")\", 'i');\n                        if (reDisallowedTags.test(matched[0])) {\n                            return 0 /* None */;\n                        }\n                    }\n                }\n                parser.closeUnmatchedBlocks();\n                // We don't adjust parser.offset;\n                // spaces are part of the HTML block:\n                var b = parser.addChild('htmlBlock', parser.offset);\n                b.htmlBlockType = blockType;\n                return 2 /* Leaf */;\n            }\n        }\n    }\n    return 0 /* None */;\n};\nvar seTextHeading = function (parser, container) {\n    var match;\n    if (container.stringContent !== null &&\n        !parser.indented &&\n        container.type === 'paragraph' &&\n        // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option\n        !isDisallowedDeepHeading(parser, container.parent) &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeadingLine))) {\n        parser.closeUnmatchedBlocks();\n        // resolve reference link definitions\n        var pos = void 0;\n        while (peek(container.stringContent, 0) === C_OPEN_BRACKET &&\n            (pos = parser.inlineParser.parseReference(container, parser.refMap))) {\n            container.stringContent = container.stringContent.slice(pos);\n        }\n        if (container.stringContent.length > 0) {\n            var heading = createNode('heading', container.sourcepos);\n            heading.level = match[0][0] === '=' ? 1 : 2;\n            heading.headingType = 'setext';\n            heading.stringContent = container.stringContent;\n            container.insertAfter(heading);\n            container.unlink();\n            parser.tip = heading;\n            parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n            return 2 /* Leaf */;\n        }\n        return 0 /* None */;\n    }\n    return 0 /* None */;\n};\nvar thematicBreak = function (parser) {\n    if (!parser.indented && reThematicBreak.test(parser.currentLine.slice(parser.nextNonspace))) {\n        parser.closeUnmatchedBlocks();\n        parser.addChild('thematicBreak', parser.nextNonspace);\n        parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar listItem = function (parser, container) {\n    var data;\n    var currNode = container;\n    if ((!parser.indented || container.type === 'list') &&\n        (data = parseListMarker(parser, currNode))) {\n        parser.closeUnmatchedBlocks();\n        // add the list if needed\n        if (parser.tip.type !== 'list' || !listsMatch(currNode.listData, data)) {\n            currNode = parser.addChild('list', parser.nextNonspace);\n            currNode.listData = data;\n        }\n        // add the list item\n        currNode = parser.addChild('item', parser.nextNonspace);\n        currNode.listData = data;\n        return 1 /* Container */;\n    }\n    return 0 /* None */;\n};\n// indented code block\nvar indentedCodeBlock = function (parser) {\n    if (parser.indented && parser.tip.type !== 'paragraph' && !parser.blank) {\n        // indented code\n        parser.advanceOffset(CODE_INDENT, true);\n        parser.closeUnmatchedBlocks();\n        parser.addChild('codeBlock', parser.offset);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar blockStarts = [\n    blockQuote,\n    atxHeading,\n    fencedCodeBlock,\n    htmlBlock,\n    seTextHeading,\n    thematicBreak,\n    listItem,\n    indentedCodeBlock,\n    tableHead,\n    tableBody,\n    customBlock,\n];\n// `---` for YAML, `+++` for TOML, `;;;` for JSON\nvar reFrontMatter = /^(-{3}|\\+{3}|;{3})$/;\nvar frontMatter$1 = function (parser, container) {\n    var currentLine = parser.currentLine, lineNumber = parser.lineNumber, indented = parser.indented;\n    if (lineNumber === 1 &&\n        !indented &&\n        container.type === 'document' &&\n        reFrontMatter.test(currentLine)) {\n        parser.closeUnmatchedBlocks();\n        var frontMatter_1 = parser.addChild('frontMatter', parser.nextNonspace);\n        frontMatter_1.stringContent = currentLine;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(currentLine.length, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar frontMatter = {\n    continue: function (parser, container) {\n        var line = parser.currentLine;\n        var match = line.match(reFrontMatter);\n        if (container.type === 'frontMatter' && match) {\n            container.stringContent += line;\n            parser.lastLineLength = match[0].length;\n            parser.finalize(container, parser.lineNumber);\n            return 2 /* Finished */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        block.literal = block.stringContent;\n        block.stringContent = null;\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar reHtmlBlockClose = [\n    /./,\n    /<\\/(?:script|pre|style)>/i,\n    /-->/,\n    /\\?>/,\n    />/,\n    /\\]\\]>/,\n];\nvar reMaybeSpecial = /^[#`~*+_=<>0-9-;$]/;\nvar reLineEnding$1 = /\\r\\n|\\n|\\r/;\nfunction esm_document() {\n    return createNode('document', [\n        [1, 1],\n        [0, 0],\n    ]);\n}\nvar defaultOptions$1 = {\n    smart: false,\n    tagFilter: false,\n    extendedAutolinks: false,\n    disallowedHtmlBlockTags: [],\n    referenceDefinition: false,\n    disallowDeepHeading: false,\n    customParser: null,\n    frontMatter: false,\n};\nvar Parser = /** @class */ (function () {\n    function Parser(options) {\n        this.options = esm_assign(esm_assign({}, defaultOptions$1), options);\n        this.doc = esm_document();\n        this.tip = this.doc;\n        this.oldtip = this.doc;\n        this.lineNumber = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.nextNonspace = 0;\n        this.nextNonspaceColumn = 0;\n        this.indent = 0;\n        this.currentLine = '';\n        this.indented = false;\n        this.blank = false;\n        this.partiallyConsumedTab = false;\n        this.allClosed = true;\n        this.lastMatchedContainer = this.doc;\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.lastLineLength = 0;\n        this.lines = [];\n        if (this.options.frontMatter) {\n            blockHandlers.frontMatter = frontMatter;\n            blockStarts.unshift(frontMatter$1);\n        }\n        this.inlineParser = new InlineParser(this.options);\n    }\n    Parser.prototype.advanceOffset = function (count, columns) {\n        if (columns === void 0) {\n            columns = false;\n        }\n        var currentLine = this.currentLine;\n        var charsToTab, charsToAdvance;\n        var c;\n        while (count > 0 && (c = currentLine[this.offset])) {\n            if (c === '\\t') {\n                charsToTab = 4 - (this.column % 4);\n                if (columns) {\n                    this.partiallyConsumedTab = charsToTab > count;\n                    charsToAdvance = charsToTab > count ? count : charsToTab;\n                    this.column += charsToAdvance;\n                    this.offset += this.partiallyConsumedTab ? 0 : 1;\n                    count -= charsToAdvance;\n                }\n                else {\n                    this.partiallyConsumedTab = false;\n                    this.column += charsToTab;\n                    this.offset += 1;\n                    count -= 1;\n                }\n            }\n            else {\n                this.partiallyConsumedTab = false;\n                this.offset += 1;\n                this.column += 1; // assume ascii; block starts are ascii\n                count -= 1;\n            }\n        }\n    };\n    Parser.prototype.advanceNextNonspace = function () {\n        this.offset = this.nextNonspace;\n        this.column = this.nextNonspaceColumn;\n        this.partiallyConsumedTab = false;\n    };\n    Parser.prototype.findNextNonspace = function () {\n        var currentLine = this.currentLine;\n        var i = this.offset;\n        var cols = this.column;\n        var c;\n        while ((c = currentLine.charAt(i)) !== '') {\n            if (c === ' ') {\n                i++;\n                cols++;\n            }\n            else if (c === '\\t') {\n                i++;\n                cols += 4 - (cols % 4);\n            }\n            else {\n                break;\n            }\n        }\n        this.blank = c === '\\n' || c === '\\r' || c === '';\n        this.nextNonspace = i;\n        this.nextNonspaceColumn = cols;\n        this.indent = this.nextNonspaceColumn - this.column;\n        this.indented = this.indent >= CODE_INDENT;\n    };\n    // Add a line to the block at the tip.  We assume the tip\n    // can accept lines -- that check should be done before calling this.\n    Parser.prototype.addLine = function () {\n        if (this.partiallyConsumedTab) {\n            this.offset += 1; // skip over tab\n            // add space characters:\n            var charsToTab = 4 - (this.column % 4);\n            this.tip.stringContent += repeat(' ', charsToTab);\n        }\n        if (this.tip.lineOffsets) {\n            this.tip.lineOffsets.push(this.offset);\n        }\n        else {\n            this.tip.lineOffsets = [this.offset];\n        }\n        this.tip.stringContent += this.currentLine.slice(this.offset) + \"\\n\";\n    };\n    // Add block of type tag as a child of the tip.  If the tip can't\n    // accept children, close and finalize it and try its parent,\n    // and so on til we find a block that can accept children.\n    Parser.prototype.addChild = function (tag, offset) {\n        while (!blockHandlers[this.tip.type].canContain(tag)) {\n            this.finalize(this.tip, this.lineNumber - 1);\n        }\n        var columnNumber = offset + 1; // offset 0 = column 1\n        var newBlock = createNode(tag, [\n            [this.lineNumber, columnNumber],\n            [0, 0],\n        ]);\n        newBlock.stringContent = '';\n        this.tip.appendChild(newBlock);\n        this.tip = newBlock;\n        return newBlock;\n    };\n    // Finalize and close any unmatched blocks.\n    Parser.prototype.closeUnmatchedBlocks = function () {\n        if (!this.allClosed) {\n            // finalize any blocks not matched\n            while (this.oldtip !== this.lastMatchedContainer) {\n                var parent_1 = this.oldtip.parent;\n                this.finalize(this.oldtip, this.lineNumber - 1);\n                this.oldtip = parent_1;\n            }\n            this.allClosed = true;\n        }\n    };\n    // Finalize a block.  Close it and do any necessary postprocessing,\n    // e.g. creating stringContent from strings, setting the 'tight'\n    // or 'loose' status of a list, and parsing the beginnings\n    // of paragraphs for reference definitions.  Reset the tip to the\n    // parent of the closed block.\n    Parser.prototype.finalize = function (block, lineNumber) {\n        var above = block.parent;\n        block.open = false;\n        block.sourcepos[1] = [lineNumber, this.lastLineLength];\n        blockHandlers[block.type].finalize(this, block);\n        this.tip = above;\n    };\n    // Walk through a block & children recursively, parsing string content\n    // into inline content where appropriate.\n    Parser.prototype.processInlines = function (block) {\n        var event;\n        var customParser = this.options.customParser;\n        var walker = block.walker();\n        this.inlineParser.refMap = this.refMap;\n        this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap;\n        this.inlineParser.refDefCandidateMap = this.refDefCandidateMap;\n        this.inlineParser.options = this.options;\n        while ((event = walker.next())) {\n            var node = event.node, entering = event.entering;\n            var t = node.type;\n            if (customParser && customParser[t]) {\n                customParser[t](node, { entering: entering, options: this.options });\n            }\n            if (!entering &&\n                (t === 'paragraph' ||\n                    t === 'heading' ||\n                    (t === 'tableCell' && !node.ignored))) {\n                this.inlineParser.parse(node);\n            }\n        }\n    };\n    // Analyze a line of text and update the document appropriately.\n    // We parse markdown text by calling this on each line of input,\n    // then finalizing the document.\n    Parser.prototype.incorporateLine = function (ln) {\n        var container = this.doc;\n        this.oldtip = this.tip;\n        this.offset = 0;\n        this.column = 0;\n        this.blank = false;\n        this.partiallyConsumedTab = false;\n        this.lineNumber += 1;\n        // replace NUL characters for security\n        if (ln.indexOf('\\u0000') !== -1) {\n            ln = ln.replace(/\\0/g, '\\uFFFD');\n        }\n        this.currentLine = ln;\n        // For each containing block, try to parse the associated line start.\n        // Bail out on failure: container will point to the last matching block.\n        // Set allMatched to false if not all containers match.\n        var allMatched = true;\n        var lastChild;\n        while ((lastChild = container.lastChild) && lastChild.open) {\n            container = lastChild;\n            this.findNextNonspace();\n            switch (blockHandlers[container.type]['continue'](this, container)) {\n                case 0 /* Go */: // we've matched, keep going\n                    break;\n                case 1 /* Stop */: // we've failed to match a block\n                    allMatched = false;\n                    break;\n                case 2 /* Finished */: // we've hit end of line for fenced code close and can return\n                    this.lastLineLength = ln.length;\n                    return;\n                default:\n                    throw new Error('continue returned illegal value, must be 0, 1, or 2');\n            }\n            if (!allMatched) {\n                container = container.parent; // back up to last matching block\n                break;\n            }\n        }\n        this.allClosed = container === this.oldtip;\n        this.lastMatchedContainer = container;\n        var matchedLeaf = container.type !== 'paragraph' && blockHandlers[container.type].acceptsLines;\n        var blockStartsLen = blockStarts.length;\n        // Unless last matched container is a code block, try new container starts,\n        // adding children to the last matched container:\n        while (!matchedLeaf) {\n            this.findNextNonspace();\n            // this is a little performance optimization:\n            if (container.type !== 'table' &&\n                container.type !== 'tableBody' &&\n                container.type !== 'paragraph' &&\n                !this.indented &&\n                !reMaybeSpecial.test(ln.slice(this.nextNonspace))) {\n                this.advanceNextNonspace();\n                break;\n            }\n            var i = 0;\n            while (i < blockStartsLen) {\n                var res = blockStarts[i](this, container);\n                if (res === 1 /* Container */) {\n                    container = this.tip;\n                    break;\n                }\n                else if (res === 2 /* Leaf */) {\n                    container = this.tip;\n                    matchedLeaf = true;\n                    break;\n                }\n                else {\n                    i++;\n                }\n            }\n            if (i === blockStartsLen) {\n                // nothing matched\n                this.advanceNextNonspace();\n                break;\n            }\n        }\n        // What remains at the offset is a text line.  Add the text to the\n        // appropriate container.\n        // First check for a lazy paragraph continuation:\n        if (!this.allClosed && !this.blank && this.tip.type === 'paragraph') {\n            // lazy paragraph continuation\n            this.addLine();\n        }\n        else {\n            // not a lazy continuation\n            // finalize any blocks not matched\n            this.closeUnmatchedBlocks();\n            if (this.blank && container.lastChild) {\n                container.lastChild.lastLineBlank = true;\n            }\n            var t = container.type;\n            // Block quote lines are never blank as they start with >\n            // and we don't count blanks in fenced code for purposes of tight/loose\n            // lists or breaking out of lists. We also don't set _lastLineBlank\n            // on an empty list item, or if we just closed a fenced block.\n            var lastLineBlank = this.blank &&\n                !(t === 'blockQuote' ||\n                    (isCodeBlock(container) && container.isFenced) ||\n                    (t === 'item' && !container.firstChild && container.sourcepos[0][0] === this.lineNumber));\n            // propagate lastLineBlank up through parents:\n            var cont = container;\n            while (cont) {\n                cont.lastLineBlank = lastLineBlank;\n                cont = cont.parent;\n            }\n            if (blockHandlers[t].acceptsLines) {\n                this.addLine();\n                // if HtmlBlock, check for end condition\n                if (isHtmlBlock(container) &&\n                    container.htmlBlockType >= 1 &&\n                    container.htmlBlockType <= 5 &&\n                    reHtmlBlockClose[container.htmlBlockType].test(this.currentLine.slice(this.offset))) {\n                    this.lastLineLength = ln.length;\n                    this.finalize(container, this.lineNumber);\n                }\n            }\n            else if (this.offset < ln.length && !this.blank) {\n                // create paragraph container for line\n                container = this.addChild('paragraph', this.offset);\n                this.advanceNextNonspace();\n                this.addLine();\n            }\n        }\n        this.lastLineLength = ln.length;\n    };\n    // The main parsing function.  Returns a parsed document AST.\n    Parser.prototype.parse = function (input, lineTexts) {\n        this.doc = esm_document();\n        this.tip = this.doc;\n        this.lineNumber = 0;\n        this.lastLineLength = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.lastMatchedContainer = this.doc;\n        this.currentLine = '';\n        var lines = input.split(reLineEnding$1);\n        var len = lines.length;\n        this.lines = lineTexts ? lineTexts : lines;\n        if (this.options.referenceDefinition) {\n            this.clearRefMaps();\n        }\n        if (input.charCodeAt(input.length - 1) === C_NEWLINE) {\n            // ignore last blank line created by final newline\n            len -= 1;\n        }\n        for (var i = 0; i < len; i++) {\n            this.incorporateLine(lines[i]);\n        }\n        while (this.tip) {\n            this.finalize(this.tip, len);\n        }\n        this.processInlines(this.doc);\n        return this.doc;\n    };\n    Parser.prototype.partialParseStart = function (lineNumber, lines) {\n        this.doc = esm_document();\n        this.tip = this.doc;\n        this.lineNumber = lineNumber - 1;\n        this.lastLineLength = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.lastMatchedContainer = this.doc;\n        this.currentLine = '';\n        var len = lines.length;\n        for (var i = 0; i < len; i++) {\n            this.incorporateLine(lines[i]);\n        }\n        return this.doc;\n    };\n    Parser.prototype.partialParseExtends = function (lines) {\n        for (var i = 0; i < lines.length; i++) {\n            this.incorporateLine(lines[i]);\n        }\n    };\n    Parser.prototype.partialParseFinish = function () {\n        while (this.tip) {\n            this.finalize(this.tip, this.lineNumber);\n        }\n        this.processInlines(this.doc);\n    };\n    Parser.prototype.setRefMaps = function (refMap, refLinkCandidateMap, refDefCandidateMap) {\n        this.refMap = refMap;\n        this.refLinkCandidateMap = refLinkCandidateMap;\n        this.refDefCandidateMap = refDefCandidateMap;\n    };\n    Parser.prototype.clearRefMaps = function () {\n        [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (map) {\n            clearObj(map);\n        });\n    };\n    return Parser;\n}());\nfunction comparePos(p1, p2) {\n    if (p1[0] < p2[0]) {\n        return 1 /* LT */;\n    }\n    if (p1[0] > p2[0]) {\n        return -1 /* GT */;\n    }\n    if (p1[1] < p2[1]) {\n        return 1 /* LT */;\n    }\n    if (p1[1] > p2[1]) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction compareRangeAndPos(_a, pos) {\n    var startPos = _a[0], endPos = _a[1];\n    if (comparePos(endPos, pos) === 1 /* LT */) {\n        return 1 /* LT */;\n    }\n    if (comparePos(startPos, pos) === -1 /* GT */) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction removeNextUntil(node, last) {\n    if (node.parent !== last.parent || node === last) {\n        return;\n    }\n    var next = node.next;\n    while (next && next !== last) {\n        var temp = next.next;\n        for (var _i = 0, _a = ['parent', 'prev', 'next']; _i < _a.length; _i++) {\n            var type = _a[_i];\n            if (next[type]) {\n                removeNodeById(next[type].id);\n                next[type] = null;\n            }\n        }\n        next = temp;\n    }\n    node.next = last.next;\n    if (last.next) {\n        last.next.prev = node;\n    }\n    else {\n        node.parent.lastChild = node;\n    }\n}\nfunction getChildNodes(parent) {\n    var nodes = [];\n    var curr = parent.firstChild;\n    while (curr) {\n        nodes.push(curr);\n        curr = curr.next;\n    }\n    return nodes;\n}\nfunction insertNodesBefore(target, nodes) {\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var node = nodes_1[_i];\n        target.insertBefore(node);\n    }\n}\nfunction prependChildNodes(parent, nodes) {\n    for (var i = nodes.length - 1; i >= 0; i -= 1) {\n        parent.prependChild(nodes[i]);\n    }\n}\nfunction updateNextLineNumbers(base, diff) {\n    if (!base || !base.parent || diff === 0) {\n        return;\n    }\n    var walker = base.parent.walker();\n    walker.resumeAt(base, true);\n    var event;\n    while ((event = walker.next())) {\n        var node = event.node, entering = event.entering;\n        if (entering) {\n            node.sourcepos[0][0] += diff;\n            node.sourcepos[1][0] += diff;\n        }\n    }\n}\nfunction compareRangeAndLine(_a, line) {\n    var startPos = _a[0], endPos = _a[1];\n    if (endPos[0] < line) {\n        return 1 /* LT */;\n    }\n    if (startPos[0] > line) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction findChildNodeAtLine(parent, line) {\n    var node = parent.firstChild;\n    while (node) {\n        var comp = compareRangeAndLine(node.sourcepos, line);\n        if (comp === 0 /* EQ */) {\n            return node;\n        }\n        if (comp === -1 /* GT */) {\n            // To consider that top line is blank line\n            return node.prev || node;\n        }\n        node = node.next;\n    }\n    return parent.lastChild;\n}\nfunction lastLeafNode(node) {\n    while (node.lastChild) {\n        node = node.lastChild;\n    }\n    return node;\n}\nfunction sameLineTopAncestor(node) {\n    while (node.parent &&\n        node.parent.type !== 'document' &&\n        node.parent.sourcepos[0][0] === node.sourcepos[0][0]) {\n        node = node.parent;\n    }\n    return node;\n}\nfunction findFirstNodeAtLine(parent, line) {\n    var node = parent.firstChild;\n    var prev = null;\n    while (node) {\n        var comp = compareRangeAndLine(node.sourcepos, line);\n        if (comp === 0 /* EQ */) {\n            if (node.sourcepos[0][0] === line || !node.firstChild) {\n                return node;\n            }\n            prev = node;\n            node = node.firstChild;\n        }\n        else if (comp === -1 /* GT */) {\n            break;\n        }\n        else {\n            prev = node;\n            node = node.next;\n        }\n    }\n    if (prev) {\n        return sameLineTopAncestor(lastLeafNode(prev));\n    }\n    return null;\n}\nfunction findNodeAtPosition(parent, pos) {\n    var node = parent;\n    var prev = null;\n    while (node) {\n        var comp = compareRangeAndPos(node.sourcepos, pos);\n        if (comp === 0 /* EQ */) {\n            if (node.firstChild) {\n                prev = node;\n                node = node.firstChild;\n            }\n            else {\n                return node;\n            }\n        }\n        else if (comp === -1 /* GT */) {\n            return prev;\n        }\n        else if (node.next) {\n            node = node.next;\n        }\n        else {\n            return prev;\n        }\n    }\n    return node;\n}\nfunction findNodeById(id) {\n    return getNodeById(id) || null;\n}\nfunction invokeNextUntil(callback, start, end) {\n    if (end === void 0) {\n        end = null;\n    }\n    if (start) {\n        var walker = start.walker();\n        while (start && start !== end) {\n            callback(start);\n            var next = walker.next();\n            if (next) {\n                start = next.node;\n            }\n            else {\n                break;\n            }\n        }\n    }\n}\nfunction isUnlinked(id) {\n    var node = findNodeById(id);\n    if (!node) {\n        return true;\n    }\n    while (node && node.type !== 'document') {\n        // eslint-disable-next-line no-loop-func\n        if (!node.parent && !node.prev && !node.next) {\n            return true;\n        }\n        node = node.parent;\n    }\n    return false;\n}\nvar reLineEnding = /\\r\\n|\\n|\\r/;\nfunction canBeContinuedListItem(lineText) {\n    var spaceMatch = lineText.match(/^[ \\t]+/);\n    if (spaceMatch && (spaceMatch[0].length >= 2 || /\\t/.test(spaceMatch[0]))) {\n        return true;\n    }\n    var leftTrimmed = spaceMatch ? lineText.slice(spaceMatch.length) : lineText;\n    return reBulletListMarker.test(leftTrimmed) || reOrderedListMarker.test(leftTrimmed);\n}\nfunction canBeContinuedTableBody(lineText) {\n    return !isBlank(lineText) && lineText.indexOf('|') !== -1;\n}\nfunction createRefDefState(node) {\n    var id = node.id, title = node.title, sourcepos = node.sourcepos, dest = node.dest;\n    return {\n        id: id,\n        title: title,\n        sourcepos: sourcepos,\n        unlinked: false,\n        destination: dest,\n    };\n}\nvar ToastMark = /** @class */ (function () {\n    function ToastMark(contents, options) {\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.referenceDefinition = !!(options === null || options === void 0 ? void 0 : options.referenceDefinition);\n        this.parser = new Parser(options);\n        this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap);\n        this.eventHandlerMap = { change: [] };\n        contents = contents || '';\n        this.lineTexts = contents.split(reLineEnding);\n        this.root = this.parser.parse(contents, this.lineTexts);\n    }\n    ToastMark.prototype.updateLineTexts = function (startPos, endPos, newText) {\n        var _a;\n        var startLine = startPos[0], startCol = startPos[1];\n        var endLine = endPos[0], endCol = endPos[1];\n        var newLines = newText.split(reLineEnding);\n        var newLineLen = newLines.length;\n        var startLineText = this.lineTexts[startLine - 1];\n        var endLineText = this.lineTexts[endLine - 1];\n        newLines[0] = startLineText.slice(0, startCol - 1) + newLines[0];\n        newLines[newLineLen - 1] = newLines[newLineLen - 1] + endLineText.slice(endCol - 1);\n        var removedLineLen = endLine - startLine + 1;\n        (_a = this.lineTexts).splice.apply(_a, esm_spreadArray([startLine - 1, removedLineLen], newLines));\n        return newLineLen - removedLineLen;\n    };\n    ToastMark.prototype.updateRootNodeState = function () {\n        if (this.lineTexts.length === 1 && this.lineTexts[0] === '') {\n            this.root.lastLineBlank = true;\n            this.root.sourcepos = [\n                [1, 1],\n                [1, 0],\n            ];\n            return;\n        }\n        if (this.root.lastChild) {\n            this.root.lastLineBlank = this.root.lastChild.lastLineBlank;\n        }\n        var lineTexts = this.lineTexts;\n        var idx = lineTexts.length - 1;\n        while (lineTexts[idx] === '') {\n            idx -= 1;\n        }\n        if (lineTexts.length - 2 > idx) {\n            idx += 1;\n        }\n        this.root.sourcepos[1] = [idx + 1, lineTexts[idx].length];\n    };\n    ToastMark.prototype.replaceRangeNodes = function (startNode, endNode, newNodes) {\n        if (!startNode) {\n            if (endNode) {\n                insertNodesBefore(endNode, newNodes);\n                removeNodeById(endNode.id);\n                endNode.unlink();\n            }\n            else {\n                prependChildNodes(this.root, newNodes);\n            }\n        }\n        else {\n            insertNodesBefore(startNode, newNodes);\n            removeNextUntil(startNode, endNode);\n            [startNode.id, endNode.id].forEach(function (id) { return removeNodeById(id); });\n            startNode.unlink();\n        }\n    };\n    ToastMark.prototype.getNodeRange = function (startPos, endPos) {\n        var startNode = findChildNodeAtLine(this.root, startPos[0]);\n        var endNode = findChildNodeAtLine(this.root, endPos[0]);\n        // extend node range to include a following block which doesn't have preceding blank line\n        if (endNode && endNode.next && endPos[0] + 1 === endNode.next.sourcepos[0][0]) {\n            endNode = endNode.next;\n        }\n        return [startNode, endNode];\n    };\n    ToastMark.prototype.trigger = function (eventName, param) {\n        this.eventHandlerMap[eventName].forEach(function (handler) {\n            handler(param);\n        });\n    };\n    ToastMark.prototype.extendEndLine = function (line) {\n        while (this.lineTexts[line] === '') {\n            line += 1;\n        }\n        return line;\n    };\n    ToastMark.prototype.parseRange = function (startNode, endNode, startLine, endLine) {\n        // extends starting range if the first node can be a continued list item\n        if (startNode &&\n            startNode.prev &&\n            ((isList(startNode.prev) && canBeContinuedListItem(this.lineTexts[startLine - 1])) ||\n                (isTable(startNode.prev) && canBeContinuedTableBody(this.lineTexts[startLine - 1])))) {\n            startNode = startNode.prev;\n            startLine = startNode.sourcepos[0][0];\n        }\n        var editedLines = this.lineTexts.slice(startLine - 1, endLine);\n        var root = this.parser.partialParseStart(startLine, editedLines);\n        // extends ending range if the following node can be a fenced code block or a continued list item\n        var nextNode = endNode ? endNode.next : this.root.firstChild;\n        var lastChild = root.lastChild;\n        var isOpenedLastChildCodeBlock = lastChild && isCodeBlock(lastChild) && lastChild.open;\n        var isOpenedLastChildCustomBlock = lastChild && isCustomBlock(lastChild) && lastChild.open;\n        var isLastChildList = lastChild && isList(lastChild);\n        while (((isOpenedLastChildCodeBlock || isOpenedLastChildCustomBlock) && nextNode) ||\n            (isLastChildList && nextNode && (nextNode.type === 'list' || nextNode.sourcepos[0][1] >= 2))) {\n            var newEndLine = this.extendEndLine(nextNode.sourcepos[1][0]);\n            this.parser.partialParseExtends(this.lineTexts.slice(endLine, newEndLine));\n            if (!startNode) {\n                startNode = endNode;\n            }\n            endNode = nextNode;\n            endLine = newEndLine;\n            nextNode = nextNode.next;\n        }\n        this.parser.partialParseFinish();\n        var newNodes = getChildNodes(root);\n        return { newNodes: newNodes, extStartNode: startNode, extEndNode: endNode };\n    };\n    ToastMark.prototype.getRemovedNodeRange = function (extStartNode, extEndNode) {\n        if (!extStartNode ||\n            (extStartNode && isRefDef(extStartNode)) ||\n            (extEndNode && isRefDef(extEndNode))) {\n            return null;\n        }\n        return {\n            id: [extStartNode.id, extEndNode.id],\n            line: [extStartNode.sourcepos[0][0] - 1, extEndNode.sourcepos[1][0] - 1],\n        };\n    };\n    ToastMark.prototype.markDeletedRefMap = function (extStartNode, extEndNode) {\n        var _this = this;\n        if (!isEmptyObj(this.refMap)) {\n            var markDeleted = function (node) {\n                if (isRefDef(node)) {\n                    var refDefState = _this.refMap[node.label];\n                    if (refDefState && node.id === refDefState.id) {\n                        refDefState.unlinked = true;\n                    }\n                }\n            };\n            if (extStartNode) {\n                invokeNextUntil(markDeleted, extStartNode.parent, extEndNode);\n            }\n            if (extEndNode) {\n                invokeNextUntil(markDeleted, extEndNode);\n            }\n        }\n    };\n    ToastMark.prototype.replaceWithNewRefDefState = function (nodes) {\n        var _this = this;\n        if (!isEmptyObj(this.refMap)) {\n            var replaceWith_1 = function (node) {\n                if (isRefDef(node)) {\n                    var label = node.label;\n                    var refDefState = _this.refMap[label];\n                    if (!refDefState || refDefState.unlinked) {\n                        _this.refMap[label] = createRefDefState(node);\n                    }\n                }\n            };\n            nodes.forEach(function (node) {\n                invokeNextUntil(replaceWith_1, node);\n            });\n        }\n    };\n    ToastMark.prototype.replaceWithRefDefCandidate = function () {\n        var _this = this;\n        if (!isEmptyObj(this.refDefCandidateMap)) {\n            iterateObject(this.refDefCandidateMap, function (_, candidate) {\n                var label = candidate.label, sourcepos = candidate.sourcepos;\n                var refDefState = _this.refMap[label];\n                if (!refDefState ||\n                    refDefState.unlinked ||\n                    refDefState.sourcepos[0][0] > sourcepos[0][0]) {\n                    _this.refMap[label] = createRefDefState(candidate);\n                }\n            });\n        }\n    };\n    ToastMark.prototype.getRangeWithRefDef = function (startLine, endLine, startNode, endNode, lineDiff) {\n        if (this.referenceDefinition && !isEmptyObj(this.refMap)) {\n            var prevNode = findChildNodeAtLine(this.root, startLine - 1);\n            var nextNode = findChildNodeAtLine(this.root, endLine + 1);\n            if (prevNode && isRefDef(prevNode) && prevNode !== startNode && prevNode !== endNode) {\n                startNode = prevNode;\n                startLine = startNode.sourcepos[0][0];\n            }\n            if (nextNode && isRefDef(nextNode) && nextNode !== startNode && nextNode !== endNode) {\n                endNode = nextNode;\n                endLine = this.extendEndLine(endNode.sourcepos[1][0] + lineDiff);\n            }\n        }\n        return [startNode, endNode, startLine, endLine];\n    };\n    ToastMark.prototype.parse = function (startPos, endPos, lineDiff) {\n        if (lineDiff === void 0) {\n            lineDiff = 0;\n        }\n        var range = this.getNodeRange(startPos, endPos);\n        var startNode = range[0], endNode = range[1];\n        var startLine = startNode ? Math.min(startNode.sourcepos[0][0], startPos[0]) : startPos[0];\n        var endLine = this.extendEndLine((endNode ? Math.max(endNode.sourcepos[1][0], endPos[0]) : endPos[0]) + lineDiff);\n        var parseResult = this.parseRange.apply(this, this.getRangeWithRefDef(startLine, endLine, startNode, endNode, lineDiff));\n        var newNodes = parseResult.newNodes, extStartNode = parseResult.extStartNode, extEndNode = parseResult.extEndNode;\n        var removedNodeRange = this.getRemovedNodeRange(extStartNode, extEndNode);\n        var nextNode = extEndNode ? extEndNode.next : this.root.firstChild;\n        if (this.referenceDefinition) {\n            this.markDeletedRefMap(extStartNode, extEndNode);\n            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);\n            this.replaceWithNewRefDefState(newNodes);\n        }\n        else {\n            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);\n        }\n        return { nodes: newNodes, removedNodeRange: removedNodeRange, nextNode: nextNode };\n    };\n    ToastMark.prototype.parseRefLink = function () {\n        var _this = this;\n        var result = [];\n        if (!isEmptyObj(this.refMap)) {\n            iterateObject(this.refMap, function (label, value) {\n                if (value.unlinked) {\n                    delete _this.refMap[label];\n                }\n                iterateObject(_this.refLinkCandidateMap, function (_, candidate) {\n                    var node = candidate.node, refLabel = candidate.refLabel;\n                    if (refLabel === label) {\n                        result.push(_this.parse(node.sourcepos[0], node.sourcepos[1]));\n                    }\n                });\n            });\n        }\n        return result;\n    };\n    ToastMark.prototype.removeUnlinkedCandidate = function () {\n        if (!isEmptyObj(this.refDefCandidateMap)) {\n            [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (candidateMap) {\n                iterateObject(candidateMap, function (id) {\n                    if (isUnlinked(id)) {\n                        delete candidateMap[id];\n                    }\n                });\n            });\n        }\n    };\n    ToastMark.prototype.editMarkdown = function (startPos, endPos, newText) {\n        var lineDiff = this.updateLineTexts(startPos, endPos, newText);\n        var parseResult = this.parse(startPos, endPos, lineDiff);\n        var editResult = omit(parseResult, 'nextNode');\n        updateNextLineNumbers(parseResult.nextNode, lineDiff);\n        this.updateRootNodeState();\n        var result = [editResult];\n        if (this.referenceDefinition) {\n            this.removeUnlinkedCandidate();\n            this.replaceWithRefDefCandidate();\n            result = result.concat(this.parseRefLink());\n        }\n        this.trigger('change', result);\n        return result;\n    };\n    ToastMark.prototype.getLineTexts = function () {\n        return this.lineTexts;\n    };\n    ToastMark.prototype.getRootNode = function () {\n        return this.root;\n    };\n    ToastMark.prototype.findNodeAtPosition = function (pos) {\n        var node = findNodeAtPosition(this.root, pos);\n        if (!node || node === this.root) {\n            return null;\n        }\n        return node;\n    };\n    ToastMark.prototype.findFirstNodeAtLine = function (line) {\n        return findFirstNodeAtLine(this.root, line);\n    };\n    ToastMark.prototype.on = function (eventName, callback) {\n        this.eventHandlerMap[eventName].push(callback);\n    };\n    ToastMark.prototype.off = function (eventName, callback) {\n        var handlers = this.eventHandlerMap[eventName];\n        var idx = handlers.indexOf(callback);\n        handlers.splice(idx, 1);\n    };\n    ToastMark.prototype.findNodeById = function (id) {\n        return findNodeById(id);\n    };\n    ToastMark.prototype.removeAllNode = function () {\n        removeAllNode();\n    };\n    return ToastMark;\n}());\nvar disallowedTags = [\n    'title',\n    'textarea',\n    'style',\n    'xmp',\n    'iframe',\n    'noembed',\n    'noframes',\n    'script',\n    'plaintext',\n];\nvar reDisallowedTag = new RegExp(\"<(/?(?:\" + disallowedTags.join('|') + \")[^>]*>)\", 'ig');\nfunction filterDisallowedTags(str) {\n    if (reDisallowedTag.test(str)) {\n        return str.replace(reDisallowedTag, function (_, group) { return \"&lt;\" + group; });\n    }\n    return str;\n}\nvar baseConvertors = {\n    heading: function (node, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: \"h\" + node.level,\n            outerNewLine: true,\n        };\n    },\n    text: function (node) {\n        return {\n            type: 'text',\n            content: node.literal,\n        };\n    },\n    softbreak: function (_, _a) {\n        var options = _a.options;\n        return {\n            type: 'html',\n            content: options.softbreak,\n        };\n    },\n    linebreak: function () {\n        return {\n            type: 'html',\n            content: '<br />\\n',\n        };\n    },\n    emph: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'em',\n        };\n    },\n    strong: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'strong',\n        };\n    },\n    paragraph: function (node, _a) {\n        var _b;\n        var entering = _a.entering;\n        var grandparent = (_b = node.parent) === null || _b === void 0 ? void 0 : _b.parent;\n        if (grandparent && grandparent.type === 'list') {\n            if (grandparent.listData.tight) {\n                return null;\n            }\n        }\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'p',\n            outerNewLine: true,\n        };\n    },\n    thematicBreak: function () {\n        return {\n            type: 'openTag',\n            tagName: 'hr',\n            outerNewLine: true,\n            selfClose: true,\n        };\n    },\n    blockQuote: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'blockquote',\n            outerNewLine: true,\n            innerNewLine: true,\n        };\n    },\n    list: function (node, _a) {\n        var entering = _a.entering;\n        var _b = node.listData, type = _b.type, start = _b.start;\n        var tagName = type === 'bullet' ? 'ul' : 'ol';\n        var attributes = {};\n        if (tagName === 'ol' && start !== null && start !== 1) {\n            attributes.start = start.toString();\n        }\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: tagName,\n            attributes: attributes,\n            outerNewLine: true,\n        };\n    },\n    item: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    htmlInline: function (node, _a) {\n        var options = _a.options;\n        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;\n        return { type: 'html', content: content };\n    },\n    htmlBlock: function (node, _a) {\n        var options = _a.options;\n        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;\n        if (options.nodeId) {\n            return [\n                { type: 'openTag', tagName: 'div', outerNewLine: true },\n                { type: 'html', content: content },\n                { type: 'closeTag', tagName: 'div', outerNewLine: true },\n            ];\n        }\n        return { type: 'html', content: content, outerNewLine: true };\n    },\n    code: function (node) {\n        return [\n            { type: 'openTag', tagName: 'code' },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n        ];\n    },\n    codeBlock: function (node) {\n        var infoStr = node.info;\n        var infoWords = infoStr ? infoStr.split(/\\s+/) : [];\n        var codeClassNames = [];\n        if (infoWords.length > 0 && infoWords[0].length > 0) {\n            codeClassNames.push(\"language-\" + escapeXml(infoWords[0]));\n        }\n        return [\n            { type: 'openTag', tagName: 'pre', outerNewLine: true },\n            { type: 'openTag', tagName: 'code', classNames: codeClassNames },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n            { type: 'closeTag', tagName: 'pre', outerNewLine: true },\n        ];\n    },\n    link: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            var _b = node, title = _b.title, destination = _b.destination;\n            return {\n                type: 'openTag',\n                tagName: 'a',\n                attributes: esm_assign({ href: escapeXml(destination) }, (title && { title: escapeXml(title) })),\n            };\n        }\n        return { type: 'closeTag', tagName: 'a' };\n    },\n    image: function (node, _a) {\n        var getChildrenText = _a.getChildrenText, skipChildren = _a.skipChildren;\n        var _b = node, title = _b.title, destination = _b.destination;\n        skipChildren();\n        return {\n            type: 'openTag',\n            tagName: 'img',\n            selfClose: true,\n            attributes: esm_assign({ src: escapeXml(destination), alt: getChildrenText(node) }, (title && { title: escapeXml(title) })),\n        };\n    },\n    customBlock: function (node, context, convertors) {\n        var info = node.info.trim().toLowerCase();\n        var customConvertor = convertors[info];\n        if (customConvertor) {\n            try {\n                return customConvertor(node, context);\n            }\n            catch (e) {\n                console.warn(\"[@toast-ui/editor] - The error occurred when \" + info + \" block node was parsed in markdown renderer: \" + e);\n            }\n        }\n        return [\n            { type: 'openTag', tagName: 'div', outerNewLine: true },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'div', outerNewLine: true },\n        ];\n    },\n    frontMatter: function (node) {\n        return [\n            {\n                type: 'openTag',\n                tagName: 'div',\n                outerNewLine: true,\n                // Because front matter is metadata, it should not be render.\n                attributes: { style: 'white-space: pre; display: none;' },\n            },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'div', outerNewLine: true },\n        ];\n    },\n    customInline: function (node, context, convertors) {\n        var _a = node, info = _a.info, firstChild = _a.firstChild;\n        var nomalizedInfo = info.trim().toLowerCase();\n        var customConvertor = convertors[nomalizedInfo];\n        var entering = context.entering;\n        if (customConvertor) {\n            try {\n                return customConvertor(node, context);\n            }\n            catch (e) {\n                console.warn(\"[@toast-ui/editor] - The error occurred when \" + nomalizedInfo + \" inline node was parsed in markdown renderer: \" + e);\n            }\n        }\n        return entering\n            ? [\n                { type: 'openTag', tagName: 'span' },\n                { type: 'text', content: \"$$\" + info + (firstChild ? ' ' : '') },\n            ]\n            : [\n                { type: 'text', content: '$$' },\n                { type: 'closeTag', tagName: 'span' },\n            ];\n    },\n};\nvar gfmConvertors = {\n    strike: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'del',\n        };\n    },\n    item: function (node, _a) {\n        var entering = _a.entering;\n        var _b = node.listData, checked = _b.checked, task = _b.task;\n        if (entering) {\n            var itemTag = {\n                type: 'openTag',\n                tagName: 'li',\n                outerNewLine: true,\n            };\n            if (task) {\n                return [\n                    itemTag,\n                    {\n                        type: 'openTag',\n                        tagName: 'input',\n                        selfClose: true,\n                        attributes: esm_assign(esm_assign({}, (checked && { checked: '' })), { disabled: '', type: 'checkbox' }),\n                    },\n                    {\n                        type: 'text',\n                        content: ' ',\n                    },\n                ];\n            }\n            return itemTag;\n        }\n        return {\n            type: 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    table: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'table',\n            outerNewLine: true,\n        };\n    },\n    tableHead: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'thead',\n            outerNewLine: true,\n        };\n    },\n    tableBody: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'tbody',\n            outerNewLine: true,\n        };\n    },\n    tableRow: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            return {\n                type: 'openTag',\n                tagName: 'tr',\n                outerNewLine: true,\n            };\n        }\n        var result = [];\n        if (node.lastChild) {\n            var columnLen = node.parent.parent.columns.length;\n            var lastColIdx = node.lastChild.endIdx;\n            for (var i = lastColIdx + 1; i < columnLen; i += 1) {\n                result.push({\n                    type: 'openTag',\n                    tagName: 'td',\n                    outerNewLine: true,\n                }, {\n                    type: 'closeTag',\n                    tagName: 'td',\n                    outerNewLine: true,\n                });\n            }\n        }\n        result.push({\n            type: 'closeTag',\n            tagName: 'tr',\n            outerNewLine: true,\n        });\n        return result;\n    },\n    tableCell: function (node, _a) {\n        var entering = _a.entering;\n        if (node.ignored) {\n            return {\n                type: 'text',\n                content: '',\n            };\n        }\n        var tablePart = node.parent.parent;\n        var tagName = tablePart.type === 'tableHead' ? 'th' : 'td';\n        var table = tablePart.parent;\n        var columnInfo = table.columns[node.startIdx];\n        var attributes = (columnInfo === null || columnInfo === void 0 ? void 0 : columnInfo.align) ? { align: columnInfo.align } : null;\n        if (entering) {\n            return esm_assign({ type: 'openTag', tagName: tagName, outerNewLine: true }, (attributes && { attributes: attributes }));\n        }\n        return {\n            type: 'closeTag',\n            tagName: tagName,\n            outerNewLine: true,\n        };\n    },\n};\nvar defaultOptions = {\n    softbreak: '\\n',\n    gfm: false,\n    tagFilter: false,\n    nodeId: false,\n};\nfunction getChildrenText(node) {\n    var buffer = [];\n    var walker = node.walker();\n    var event = null;\n    while ((event = walker.next())) {\n        var node_1 = event.node;\n        if (node_1.type === 'text') {\n            buffer.push(node_1.literal);\n        }\n    }\n    return buffer.join('');\n}\nvar Renderer = /** @class */ (function () {\n    function Renderer(customOptions) {\n        this.buffer = [];\n        this.options = esm_assign(esm_assign({}, defaultOptions), customOptions);\n        this.convertors = this.createConvertors();\n        delete this.options.convertors;\n    }\n    Renderer.prototype.createConvertors = function () {\n        var convertors = esm_assign({}, baseConvertors);\n        if (this.options.gfm) {\n            convertors = esm_assign(esm_assign({}, convertors), gfmConvertors);\n        }\n        if (this.options.convertors) {\n            var customConvertors_1 = this.options.convertors;\n            var nodeTypes = Object.keys(customConvertors_1);\n            var defaultConvertors_1 = esm_assign(esm_assign({}, baseConvertors), gfmConvertors);\n            nodeTypes.forEach(function (nodeType) {\n                var orgConvertor = convertors[nodeType];\n                var convertor = customConvertors_1[nodeType];\n                var convertorType = Object.keys(defaultConvertors_1).indexOf(nodeType) === -1\n                    ? nodeType.toLowerCase()\n                    : nodeType;\n                if (orgConvertor) {\n                    convertors[convertorType] = function (node, context, convertors) {\n                        context.origin = function () { return orgConvertor(node, context, convertors); };\n                        return convertor(node, context);\n                    };\n                }\n                else {\n                    convertors[convertorType] = convertor;\n                }\n            });\n        }\n        return convertors;\n    };\n    Renderer.prototype.getConvertors = function () {\n        return this.convertors;\n    };\n    Renderer.prototype.getOptions = function () {\n        return this.options;\n    };\n    Renderer.prototype.render = function (rootNode) {\n        var _this = this;\n        this.buffer = [];\n        var walker = rootNode.walker();\n        var event = null;\n        var _loop_1 = function () {\n            var node = event.node, entering = event.entering;\n            var convertor = this_1.convertors[node.type];\n            if (!convertor) {\n                return \"continue\";\n            }\n            var skipped = false;\n            var context = {\n                entering: entering,\n                leaf: !isContainer(node),\n                options: this_1.options,\n                getChildrenText: getChildrenText,\n                skipChildren: function () {\n                    skipped = true;\n                },\n            };\n            var converted = isCustomBlock(node) || isCustomInline(node)\n                ? convertor(node, context, this_1.convertors)\n                : convertor(node, context);\n            if (converted) {\n                var htmlNodes = Array.isArray(converted) ? converted : [converted];\n                htmlNodes.forEach(function (htmlNode, index) {\n                    if (htmlNode.type === 'openTag' && _this.options.nodeId && index === 0) {\n                        if (!htmlNode.attributes) {\n                            htmlNode.attributes = {};\n                        }\n                        htmlNode.attributes['data-nodeid'] = String(node.id);\n                    }\n                    _this.renderHTMLNode(htmlNode);\n                });\n                if (skipped) {\n                    walker.resumeAt(node, false);\n                    walker.next();\n                }\n            }\n        };\n        var this_1 = this;\n        while ((event = walker.next())) {\n            _loop_1();\n        }\n        this.addNewLine();\n        return this.buffer.join('');\n    };\n    Renderer.prototype.renderHTMLNode = function (node) {\n        switch (node.type) {\n            case 'openTag':\n            case 'closeTag':\n                this.renderElementNode(node);\n                break;\n            case 'text':\n                this.renderTextNode(node);\n                break;\n            case 'html':\n                this.renderRawHtmlNode(node);\n                break;\n            // no-default-case\n        }\n    };\n    Renderer.prototype.generateOpenTagString = function (node) {\n        var _this = this;\n        var tagName = node.tagName, classNames = node.classNames, attributes = node.attributes;\n        this.buffer.push(\"<\" + tagName);\n        if (classNames && classNames.length > 0) {\n            this.buffer.push(\" class=\\\"\" + classNames.join(' ') + \"\\\"\");\n        }\n        if (attributes) {\n            Object.keys(attributes).forEach(function (attrName) {\n                var attrValue = attributes[attrName];\n                _this.buffer.push(\" \" + attrName + \"=\\\"\" + attrValue + \"\\\"\");\n            });\n        }\n        if (node.selfClose) {\n            this.buffer.push(' /');\n        }\n        this.buffer.push('>');\n    };\n    Renderer.prototype.generateCloseTagString = function (_a) {\n        var tagName = _a.tagName;\n        this.buffer.push(\"</\" + tagName + \">\");\n    };\n    Renderer.prototype.addNewLine = function () {\n        if (this.buffer.length && last(last(this.buffer)) !== '\\n') {\n            this.buffer.push('\\n');\n        }\n    };\n    Renderer.prototype.addOuterNewLine = function (node) {\n        if (node.outerNewLine) {\n            this.addNewLine();\n        }\n    };\n    Renderer.prototype.addInnerNewLine = function (node) {\n        if (node.innerNewLine) {\n            this.addNewLine();\n        }\n    };\n    Renderer.prototype.renderTextNode = function (node) {\n        this.buffer.push(escapeXml(node.content));\n    };\n    Renderer.prototype.renderRawHtmlNode = function (node) {\n        this.addOuterNewLine(node);\n        this.buffer.push(node.content);\n        this.addOuterNewLine(node);\n    };\n    Renderer.prototype.renderElementNode = function (node) {\n        if (node.type === 'openTag') {\n            this.addOuterNewLine(node);\n            this.generateOpenTagString(node);\n            if (node.selfClose) {\n                this.addOuterNewLine(node);\n            }\n            else {\n                this.addInnerNewLine(node);\n            }\n        }\n        else {\n            this.addInnerNewLine(node);\n            this.generateCloseTagString(node);\n            this.addOuterNewLine(node);\n        }\n    };\n    return Renderer;\n}());\n\n\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/collection/forEachOwnProperties.js\nvar collection_forEachOwnProperties = __nested_webpack_require_87464__(956);\nvar forEachOwnProperties_default = /*#__PURE__*/__nested_webpack_require_87464__.n(collection_forEachOwnProperties);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/object/extend.js\nvar extend = __nested_webpack_require_87464__(969);\nvar extend_default = /*#__PURE__*/__nested_webpack_require_87464__.n(extend);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domEvent/on.js\nvar on = __nested_webpack_require_87464__(348);\nvar on_default = /*#__PURE__*/__nested_webpack_require_87464__.n(on);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domEvent/off.js\nvar off = __nested_webpack_require_87464__(349);\nvar off_default = /*#__PURE__*/__nested_webpack_require_87464__.n(off);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/addClass.js\nvar addClass = __nested_webpack_require_87464__(204);\nvar addClass_default = /*#__PURE__*/__nested_webpack_require_87464__.n(addClass);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/removeClass.js\nvar removeClass = __nested_webpack_require_87464__(462);\nvar removeClass_default = /*#__PURE__*/__nested_webpack_require_87464__.n(removeClass);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/css.js\nvar css = __nested_webpack_require_87464__(522);\nvar css_default = /*#__PURE__*/__nested_webpack_require_87464__.n(css);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/collection/toArray.js\nvar collection_toArray = __nested_webpack_require_87464__(990);\nvar toArray_default = /*#__PURE__*/__nested_webpack_require_87464__.n(collection_toArray);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isArray.js\nvar type_isArray = __nested_webpack_require_87464__(322);\nvar isArray_default = /*#__PURE__*/__nested_webpack_require_87464__.n(type_isArray);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isString.js\nvar type_isString = __nested_webpack_require_87464__(758);\nvar isString_default = /*#__PURE__*/__nested_webpack_require_87464__.n(type_isString);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isUndefined.js\nvar type_isUndefined = __nested_webpack_require_87464__(929);\nvar isUndefined_default = /*#__PURE__*/__nested_webpack_require_87464__.n(type_isUndefined);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/hasClass.js\nvar hasClass = __nested_webpack_require_87464__(714);\nvar hasClass_default = /*#__PURE__*/__nested_webpack_require_87464__.n(hasClass);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/matches.js\nvar domUtil_matches = __nested_webpack_require_87464__(471);\n;// CONCATENATED MODULE: ./src/utils/constants.ts\nvar TAG_NAME = '[A-Za-z][A-Za-z0-9-]*';\nvar ATTRIBUTE_NAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\nvar UNQUOTED_VALUE = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar SINGLE_QUOTED_VALUE = \"'[^']*'\";\nvar DOUBLE_QUOTED_VALUE = '\"[^\"]*\"';\nvar ATTRIBUTE_VALUE = \"(?:\" + UNQUOTED_VALUE + \"|\" + SINGLE_QUOTED_VALUE + \"|\" + DOUBLE_QUOTED_VALUE + \")\";\nvar ATTRIBUTE_VALUE_SPEC = \"\" + '(?:\\\\s*=\\\\s*' + ATTRIBUTE_VALUE + \")\";\nvar constants_ATTRIBUTE = \"\" + '(?:\\\\s+' + ATTRIBUTE_NAME + ATTRIBUTE_VALUE_SPEC + \"?)\";\nvar constants_OPEN_TAG = \"<(\" + TAG_NAME + \")(\" + constants_ATTRIBUTE + \")*\\\\s*/?>\";\nvar CLOSE_TAG = \"</(\" + TAG_NAME + \")\\\\s*[>]\";\nvar constants_HTML_TAG = \"(?:\" + constants_OPEN_TAG + \"|\" + CLOSE_TAG + \")\";\nvar reHTMLTag = new RegExp(\"^\" + constants_HTML_TAG, 'i');\nvar constants_reBR = /<br\\s*\\/*>/i;\nvar reHTMLComment = /<! ---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;\nvar constants_ALTERNATIVE_TAG_FOR_BR = '</p><p>';\n\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isNull.js\nvar type_isNull = __nested_webpack_require_87464__(934);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/request/sendHostname.js\nvar request_sendHostname = __nested_webpack_require_87464__(391);\n;// CONCATENATED MODULE: ./src/utils/common.ts\n\n\n\n\n\nvar isMac = /Mac/.test(navigator.platform);\nvar reSpaceMoreThanOne = /[\\u0020]+/g;\nvar common_reEscapeChars = /[>(){}[\\]+-.!#|]/g;\nvar reEscapeHTML = /<([a-zA-Z_][a-zA-Z0-9\\-._]*)(\\s|[^\\\\>])*\\/?>|<(\\/)([a-zA-Z_][a-zA-Z0-9\\-._]*)\\s*\\/?>|<!--[^-]+-->|<([a-zA-Z_][a-zA-Z0-9\\-.:/]*)>/g;\nvar reEscapeBackSlash = /\\\\[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\\\\]/g;\nvar reEscapePairedChars = /[*_~`]/g;\nvar reMdImageSyntax = /!\\[.*\\]\\(.*\\)/g;\nvar reEscapedCharInLinkSyntax = /[[\\]]/g;\nvar reEscapeBackSlashInSentence = /(?:^|[^\\\\])\\\\(?!\\\\)/g;\nvar common_XMLSPECIAL = '[&<>\"]';\nvar common_reXmlSpecial = new RegExp(common_XMLSPECIAL, 'g');\nfunction common_replaceUnsafeChar(char) {\n    switch (char) {\n        case '&':\n            return '&amp;';\n        case '<':\n            return '&lt;';\n        case '>':\n            return '&gt;';\n        case '\"':\n            return '&quot;';\n        default:\n            return char;\n    }\n}\nfunction common_escapeXml(text) {\n    if (common_reXmlSpecial.test(text)) {\n        return text.replace(common_reXmlSpecial, common_replaceUnsafeChar);\n    }\n    return text;\n}\nfunction sendHostName() {\n    sendHostname('editor', 'UA-129966929-1');\n}\nfunction common_includes(arr, targetItem) {\n    return arr.indexOf(targetItem) !== -1;\n}\nvar availableLinkAttributes = ['rel', 'target', 'hreflang', 'type'];\nvar reMarkdownTextToEscapeMap = {\n    codeblock: /(^ {4}[^\\n]+\\n*)+/,\n    thematicBreak: /^ *((\\* *){3,}|(- *){3,} *|(_ *){3,}) */,\n    atxHeading: /^(#{1,6}) +[\\s\\S]+/,\n    seTextheading: /^([^\\n]+)\\n *(=|-){2,} */,\n    blockquote: /^( *>[^\\n]+.*)+/,\n    list: /^ *(\\*+|-+|\\d+\\.) [\\s\\S]+/,\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? */,\n    link: /!?\\[.*\\]\\(.*\\)/,\n    reflink: /!?\\[.*\\]\\s*\\[([^\\]]*)\\]/,\n    verticalBar: /\\u007C/,\n    fencedCodeblock: /^((`|~){3,})/,\n};\nfunction sanitizeLinkAttribute(attribute) {\n    if (!attribute) {\n        return null;\n    }\n    var linkAttributes = {};\n    availableLinkAttributes.forEach(function (key) {\n        if (!isUndefined_default()(attribute[key])) {\n            linkAttributes[key] = attribute[key];\n        }\n    });\n    return linkAttributes;\n}\nfunction common_repeat(text, count) {\n    var result = '';\n    for (var i = 0; i < count; i += 1) {\n        result += text;\n    }\n    return result;\n}\nfunction isNeedEscapeText(text) {\n    var needEscape = false;\n    forEachOwnProperties(reMarkdownTextToEscapeMap, function (reMarkdownTextToEscape) {\n        if (reMarkdownTextToEscape.test(text)) {\n            needEscape = true;\n        }\n        return !needEscape;\n    });\n    return needEscape;\n}\nfunction escapeTextForLink(text) {\n    var imageSyntaxRanges = [];\n    var result = reMdImageSyntax.exec(text);\n    while (result) {\n        imageSyntaxRanges.push([result.index, result.index + result[0].length]);\n        result = reMdImageSyntax.exec(text);\n    }\n    return text.replace(reEscapedCharInLinkSyntax, function (matched, offset) {\n        var isDelimiter = imageSyntaxRanges.some(function (range) { return offset > range[0] && offset < range[1]; });\n        return isDelimiter ? matched : \"\\\\\" + matched;\n    });\n}\nfunction common_escape(text) {\n    var aheadReplacer = function (matched) { return \"\\\\\" + matched; };\n    var behindReplacer = function (matched) { return matched + \"\\\\\"; };\n    var escapedText = text.replace(reSpaceMoreThanOne, ' ');\n    if (reEscapeBackSlash.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeBackSlash, aheadReplacer);\n    }\n    if (reEscapeBackSlashInSentence.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeBackSlashInSentence, behindReplacer);\n    }\n    escapedText = escapedText.replace(reEscapePairedChars, aheadReplacer);\n    if (reEscapeHTML.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeHTML, aheadReplacer);\n    }\n    if (isNeedEscapeText(escapedText)) {\n        escapedText = escapedText.replace(common_reEscapeChars, aheadReplacer);\n    }\n    return escapedText;\n}\nfunction quote(text) {\n    var result;\n    if (text.indexOf('\"') === -1) {\n        result = '\"\"';\n    }\n    else {\n        result = text.indexOf(\"'\") === -1 ? \"''\" : '()';\n    }\n    return result[0] + text + result[1];\n}\nfunction common_isNil(value) {\n    return isNull(value) || isUndefined(value);\n}\nfunction shallowEqual(o1, o2) {\n    if (o1 === null && o1 === o2) {\n        return true;\n    }\n    if (typeof o1 !== 'object' || typeof o2 !== 'object' || common_isNil(o1) || common_isNil(o2)) {\n        return o1 === o2;\n    }\n    for (var key in o1) {\n        if (o1[key] !== o2[key]) {\n            return false;\n        }\n    }\n    for (var key in o2) {\n        if (!(key in o1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction common_last(arr) {\n    return arr[arr.length - 1];\n}\nfunction common_between(value, min, max) {\n    return value >= min && value <= max;\n}\nfunction isObject(obj) {\n    return typeof obj === 'object' && obj !== null;\n}\nfunction deepMergedCopy(targetObj, obj) {\n    var resultObj = tslib_es6_assign({}, targetObj);\n    if (targetObj && obj) {\n        Object.keys(obj).forEach(function (prop) {\n            if (isObject(resultObj[prop])) {\n                if (Array.isArray(obj[prop])) {\n                    resultObj[prop] = deepCopyArray(obj[prop]);\n                }\n                else if (resultObj.hasOwnProperty(prop)) {\n                    resultObj[prop] = deepMergedCopy(resultObj[prop], obj[prop]);\n                }\n                else {\n                    resultObj[prop] = deepCopy(obj[prop]);\n                }\n            }\n            else {\n                resultObj[prop] = obj[prop];\n            }\n        });\n    }\n    return resultObj;\n}\nfunction deepCopyArray(items) {\n    return items.map(function (item) {\n        if (isObject(item)) {\n            return Array.isArray(item) ? deepCopyArray(item) : deepCopy(item);\n        }\n        return item;\n    });\n}\nfunction deepCopy(obj) {\n    var keys = Object.keys(obj);\n    if (!keys.length) {\n        return obj;\n    }\n    return keys.reduce(function (acc, prop) {\n        if (isObject(obj[prop])) {\n            acc[prop] = Array.isArray(obj[prop]) ? deepCopyArray(obj[prop]) : deepCopy(obj[prop]);\n        }\n        else {\n            acc[prop] = obj[prop];\n        }\n        return acc;\n    }, {});\n}\nfunction common_assign(targetObj, obj) {\n    if (obj === void 0) { obj = {}; }\n    Object.keys(obj).forEach(function (prop) {\n        if (targetObj.hasOwnProperty(prop) && typeof targetObj[prop] === 'object') {\n            if (Array.isArray(obj[prop])) {\n                targetObj[prop] = obj[prop];\n            }\n            else {\n                common_assign(targetObj[prop], obj[prop]);\n            }\n        }\n        else {\n            targetObj[prop] = obj[prop];\n        }\n    });\n    return targetObj;\n}\nfunction getSortedNumPair(valueA, valueB) {\n    return valueA > valueB ? [valueB, valueA] : [valueA, valueB];\n}\n\n;// CONCATENATED MODULE: ./src/utils/dom.ts\n\n\n\n\n\n\n\n\n\n\nfunction isPositionInBox(style, offsetX, offsetY) {\n    var left = parseInt(style.left, 10);\n    var top = parseInt(style.top, 10);\n    var width = parseInt(style.width, 10) + parseInt(style.paddingLeft, 10) + parseInt(style.paddingRight, 10);\n    var height = parseInt(style.height, 10) + parseInt(style.paddingTop, 10) + parseInt(style.paddingBottom, 10);\n    return offsetX >= left && offsetX <= left + width && offsetY >= top && offsetY <= top + height;\n}\nvar CLS_PREFIX = 'toastui-editor-';\nfunction cls() {\n    var names = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        names[_i] = arguments[_i];\n    }\n    var result = [];\n    for (var _a = 0, names_1 = names; _a < names_1.length; _a++) {\n        var name = names_1[_a];\n        var className = void 0;\n        if (Array.isArray(name)) {\n            className = name[0] ? name[1] : null;\n        }\n        else {\n            className = name;\n        }\n        if (className) {\n            result.push(\"\" + CLS_PREFIX + className);\n        }\n    }\n    return result.join(' ');\n}\nfunction clsWithMdPrefix() {\n    var names = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        names[_i] = arguments[_i];\n    }\n    return names.map(function (className) { return CLS_PREFIX + \"md-\" + className; }).join(' ');\n}\nfunction isTextNode(node) {\n    return (node === null || node === void 0 ? void 0 : node.nodeType) === Node.TEXT_NODE;\n}\nfunction isElemNode(node) {\n    return node && node.nodeType === Node.ELEMENT_NODE;\n}\nfunction findNodes(element, selector) {\n    var nodeList = toArray(element.querySelectorAll(selector));\n    if (nodeList.length) {\n        return nodeList;\n    }\n    return [];\n}\nfunction appendNodes(node, nodesToAppend) {\n    nodesToAppend = isArray(nodesToAppend) ? toArray(nodesToAppend) : [nodesToAppend];\n    nodesToAppend.forEach(function (nodeToAppend) {\n        node.appendChild(nodeToAppend);\n    });\n}\nfunction insertBeforeNode(insertedNode, node) {\n    if (node.parentNode) {\n        node.parentNode.insertBefore(insertedNode, node);\n    }\n}\nfunction removeNode(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction unwrapNode(node) {\n    var result = [];\n    while (node.firstChild) {\n        result.push(node.firstChild);\n        if (node.parentNode) {\n            node.parentNode.insertBefore(node.firstChild, node);\n        }\n    }\n    removeNode(node);\n    return result;\n}\nfunction toggleClass(element, className, state) {\n    if (isUndefined_default()(state)) {\n        state = !hasClass_default()(element, className);\n    }\n    var toggleFn = state ? (addClass_default()) : (removeClass_default());\n    toggleFn(element, className);\n}\nfunction createElementWith(contents, target) {\n    var container = document.createElement('div');\n    if (isString_default()(contents)) {\n        container.innerHTML = contents;\n    }\n    else {\n        container.appendChild(contents);\n    }\n    var firstChild = container.firstChild;\n    if (target) {\n        target.appendChild(firstChild);\n    }\n    return firstChild;\n}\nfunction getOuterWidth(el) {\n    var computed = window.getComputedStyle(el);\n    return (['margin-left', 'margin-right'].reduce(function (acc, type) { return acc + parseInt(computed.getPropertyValue(type), 10); }, 0) + el.offsetWidth);\n}\nfunction closest(node, found) {\n    var condition;\n    if (isString(found)) {\n        condition = function (target) { return matches(target, found); };\n    }\n    else {\n        condition = function (target) { return target === found; };\n    }\n    while (node && node !== document) {\n        if (isElemNode(node) && condition(node)) {\n            return node;\n        }\n        node = node.parentNode;\n    }\n    return null;\n}\nfunction getTotalOffset(el, root) {\n    var offsetTop = 0;\n    var offsetLeft = 0;\n    while (el && el !== root) {\n        var top = el.offsetTop, left = el.offsetLeft, offsetParent = el.offsetParent;\n        offsetTop += top;\n        offsetLeft += left;\n        if (offsetParent === root.offsetParent) {\n            break;\n        }\n        el = el.offsetParent;\n    }\n    return { offsetTop: offsetTop, offsetLeft: offsetLeft };\n}\nfunction finalizeHtml(html, needHtmlText) {\n    var result;\n    if (needHtmlText) {\n        result = html.innerHTML;\n    }\n    else {\n        var frag = document.createDocumentFragment();\n        var childNodes = toArray(html.childNodes);\n        var length = childNodes.length;\n        for (var i = 0; i < length; i += 1) {\n            frag.appendChild(childNodes[i]);\n        }\n        result = frag;\n    }\n    return result;\n}\nfunction dom_empty(node) {\n    while (node.firstChild) {\n        node.removeChild(node.firstChild);\n    }\n}\nfunction appendNode(node, appended) {\n    if (isString(appended)) {\n        node.insertAdjacentHTML('beforeend', appended);\n    }\n    else {\n        var nodes = appended.length\n            ? toArray(appended)\n            : [appended];\n        for (var i = 0, len = nodes.length; i < len; i += 1) {\n            node.appendChild(nodes[i]);\n        }\n    }\n}\nfunction prependNode(node, appended) {\n    if (isString(appended)) {\n        node.insertAdjacentHTML('afterbegin', appended);\n    }\n    else {\n        var nodes = appended.length\n            ? toArray(appended)\n            : [appended];\n        for (var i = nodes.length - 1, len = 0; i >= len; i -= 1) {\n            node.insertBefore(nodes[i], node.firstChild);\n        }\n    }\n}\nfunction setAttributes(attributes, element) {\n    Object.keys(attributes).forEach(function (attrName) {\n        if (isNil(attributes[attrName])) {\n            element.removeAttribute(attrName);\n        }\n        else {\n            element.setAttribute(attrName, attributes[attrName]);\n        }\n    });\n}\nfunction replaceBRWithEmptyBlock(html) {\n    // remove br in paragraph to compatible with markdown\n    var replacedHTML = html.replace(/<p><br\\s*\\/*><\\/p>/gi, '<p></p>');\n    var reHTMLTag = new RegExp(HTML_TAG, 'ig');\n    var htmlTagMatched = replacedHTML.match(reHTMLTag);\n    htmlTagMatched === null || htmlTagMatched === void 0 ? void 0 : htmlTagMatched.forEach(function (htmlTag, index) {\n        if (reBR.test(htmlTag)) {\n            var alternativeTag = ALTERNATIVE_TAG_FOR_BR;\n            if (index) {\n                var prevTag = htmlTagMatched[index - 1];\n                var openTagMatched = prevTag.match(OPEN_TAG);\n                if (openTagMatched && !/br/i.test(openTagMatched[1])) {\n                    var tagName = openTagMatched[1];\n                    alternativeTag = \"</\" + tagName + \"><\" + tagName + \">\";\n                }\n            }\n            replacedHTML = replacedHTML.replace(reBR, alternativeTag);\n        }\n    });\n    return replacedHTML;\n}\nfunction removeProseMirrorHackNodes(html) {\n    var reProseMirrorImage = /<img class=\"ProseMirror-separator\" alt=\"\">/g;\n    var reProseMirrorTrailingBreak = / class=\"ProseMirror-trailingBreak\"/g;\n    var resultHTML = html;\n    resultHTML = resultHTML.replace(reProseMirrorImage, '');\n    resultHTML = resultHTML.replace(reProseMirrorTrailingBreak, '');\n    return resultHTML;\n}\n\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isFunction.js\nvar isFunction = __nested_webpack_require_87464__(294);\nvar isFunction_default = /*#__PURE__*/__nested_webpack_require_87464__.n(isFunction);\n;// CONCATENATED MODULE: ./src/utils/markdown.ts\n\nfunction hasSpecificTypeAncestor(mdNode) {\n    var types = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        types[_i - 1] = arguments[_i];\n    }\n    while (mdNode && mdNode.parent && mdNode.parent.type !== 'document') {\n        if (includes(types, mdNode.parent.type)) {\n            return true;\n        }\n        mdNode = mdNode.parent;\n    }\n    return false;\n}\nfunction markdown_getMdStartLine(mdNode) {\n    return mdNode.sourcepos[0][0];\n}\nfunction markdown_getMdEndLine(mdNode) {\n    return mdNode.sourcepos[1][0];\n}\nfunction getMdStartCh(mdNode) {\n    return mdNode.sourcepos[0][1];\n}\nfunction getMdEndCh(mdNode) {\n    return mdNode.sourcepos[1][1];\n}\nfunction isMultiLineNode(mdNode) {\n    var type = mdNode.type;\n    return type === 'codeBlock' || type === 'paragraph';\n}\nfunction isHTMLNode(mdNode) {\n    var type = mdNode.type;\n    return type === 'htmlBlock' || type === 'htmlInline';\n}\nfunction markdown_isStyledInlineNode(mdNode) {\n    var type = mdNode.type;\n    return (type === 'strike' ||\n        type === 'strong' ||\n        type === 'emph' ||\n        type === 'code' ||\n        type === 'link' ||\n        type === 'image');\n}\nfunction isCodeBlockNode(mdNode) {\n    return mdNode && mdNode.type === 'codeBlock';\n}\nfunction isCustomBlockNode(mdNode) {\n    return mdNode && mdNode.type === 'customBlock';\n}\nfunction isListNode(mdNode) {\n    return mdNode && (mdNode.type === 'item' || mdNode.type === 'list');\n}\nfunction isOrderedListNode(mdNode) {\n    return isListNode(mdNode) && mdNode.listData.type === 'ordered';\n}\nfunction isBulletListNode(mdNode) {\n    return isListNode(mdNode) && mdNode.listData.type !== 'ordered';\n}\nfunction isTableCellNode(mdNode) {\n    return mdNode && (mdNode.type === 'tableCell' || mdNode.type === 'tableDelimCell');\n}\nfunction isInlineNode(mdNode) {\n    switch (mdNode.type) {\n        case 'code':\n        case 'text':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'htmlInline':\n        case 'linebreak':\n        case 'softbreak':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction findClosestNode(mdNode, condition, includeSelf) {\n    if (includeSelf === void 0) { includeSelf = true; }\n    mdNode = includeSelf ? mdNode : mdNode.parent;\n    while (mdNode && mdNode.type !== 'document') {\n        if (condition(mdNode)) {\n            return mdNode;\n        }\n        mdNode = mdNode.parent;\n    }\n    return null;\n}\nfunction traverseParentNodes(mdNode, iteratee, includeSelf) {\n    if (includeSelf === void 0) { includeSelf = true; }\n    mdNode = includeSelf ? mdNode : mdNode.parent;\n    while (mdNode && mdNode.type !== 'document') {\n        iteratee(mdNode);\n        mdNode = mdNode.parent;\n    }\n}\nfunction addOffsetPos(originPos, offset) {\n    return [originPos[0], originPos[1] + offset];\n}\nfunction setOffsetPos(originPos, newOffset) {\n    return [originPos[0], newOffset];\n}\nfunction getInlineMarkdownText(mdNode) {\n    var text = mdNode.firstChild.literal;\n    switch (mdNode.type) {\n        case 'emph':\n            return \"*\" + text + \"*\";\n        case 'strong':\n            return \"**\" + text + \"**\";\n        case 'strike':\n            return \"~~\" + text + \"~~\";\n        case 'code':\n            return \"`\" + text + \"`\";\n        case 'link':\n        case 'image':\n            /* eslint-disable no-case-declarations */\n            var _a = mdNode, destination = _a.destination, title = _a.title;\n            var delim = mdNode.type === 'link' ? '' : '!';\n            return delim + \"[\" + text + \"](\" + destination + (title ? \" \\\"\" + title + \"\\\"\" : '') + \")\";\n        default:\n            return null;\n    }\n}\nfunction markdown_isContainer(node) {\n    switch (node.type) {\n        case 'document':\n        case 'blockQuote':\n        case 'list':\n        case 'item':\n        case 'paragraph':\n        case 'heading':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'table':\n        case 'tableHead':\n        case 'tableBody':\n        case 'tableRow':\n        case 'tableCell':\n        case 'tableDelimRow':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction markdown_getChildrenText(node) {\n    var buffer = [];\n    var walker = node.walker();\n    var event = null;\n    while ((event = walker.next())) {\n        var childNode = event.node;\n        if (childNode.type === 'text') {\n            buffer.push(childNode.literal);\n        }\n    }\n    return buffer.join('');\n}\n\n;// CONCATENATED MODULE: ./src/widget/rules.ts\n\nvar widgetRules = (/* unused pure expression or super */ null && (0));\nvar widgetRuleMap = {};\nvar reWidgetPrefix = /\\$\\$widget\\d+\\s/;\nfunction unwrapWidgetSyntax(text) {\n    var index = text.search(reWidgetPrefix);\n    if (index !== -1) {\n        var rest = text.substring(index);\n        var replaced = rest.replace(reWidgetPrefix, '').replace('$$', '');\n        text = text.substring(0, index);\n        text += unwrapWidgetSyntax(replaced);\n    }\n    return text;\n}\nfunction createWidgetContent(info, text) {\n    return \"$$\" + info + \" \" + text + \"$$\";\n}\nfunction widgetToDOM(info, text) {\n    var _a = widgetRuleMap[info], rule = _a.rule, toDOM = _a.toDOM;\n    var matches = unwrapWidgetSyntax(text).match(rule);\n    if (matches) {\n        text = matches[0];\n    }\n    return toDOM(text);\n}\nfunction getWidgetRules() {\n    return widgetRules;\n}\nfunction setWidgetRules(rules) {\n    widgetRules = rules;\n    widgetRules.forEach(function (rule, index) {\n        widgetRuleMap[\"widget\" + index] = rule;\n    });\n}\nfunction mergeNodes(nodes, text, schema, ruleIndex) {\n    return nodes.concat(createNodesWithWidget(text, schema, ruleIndex));\n}\n/**\n * create nodes with plain text and replace text matched to the widget rules with the widget node\n * For example, in case the text and widget rules as below\n *\n * text: $test plain text #test\n * widget rules: [{ rule: /$.+/ }, { rule: /#.+/ }]\n *\n * The creating node process is recursive and is as follows.\n *\n * in first widget rule(/$.+/)\n *  $test -> widget node\n *  plain text -> match with next widget rule\n *  #test -> match with next widget rule\n *\n * in second widget rule(/#.+/)\n *  plain text -> text node(no rule for matching)\n *  #test -> widget node\n */\nfunction createNodesWithWidget(text, schema, ruleIndex) {\n    if (ruleIndex === void 0) { ruleIndex = 0; }\n    var nodes = [];\n    var rule = (widgetRules[ruleIndex] || {}).rule;\n    var nextRuleIndex = ruleIndex + 1;\n    text = unwrapWidgetSyntax(text);\n    if (rule && rule.test(text)) {\n        var index = void 0;\n        while ((index = text.search(rule)) !== -1) {\n            var prev = text.substring(0, index);\n            // get widget node on first splitted text using next widget rule\n            if (prev) {\n                nodes = mergeNodes(nodes, prev, schema, nextRuleIndex);\n            }\n            // build widget node using current widget rule\n            text = text.substring(index);\n            var literal = text.match(rule)[0];\n            var info = \"widget\" + ruleIndex;\n            nodes.push(schema.nodes.widget.create({ info: info }, schema.text(createWidgetContent(info, literal))));\n            text = text.substring(literal.length);\n        }\n        // get widget node on last splitted text using next widget rule\n        if (text) {\n            nodes = mergeNodes(nodes, text, schema, nextRuleIndex);\n        }\n    }\n    else if (text) {\n        nodes =\n            ruleIndex < widgetRules.length - 1\n                ? mergeNodes(nodes, text, schema, nextRuleIndex)\n                : [schema.text(text)];\n    }\n    return nodes;\n}\nfunction getWidgetContent(widgetNode) {\n    var event;\n    var text = '';\n    var walker = widgetNode.walker();\n    while ((event = walker.next())) {\n        var node = event.node, entering = event.entering;\n        if (entering) {\n            if (node !== widgetNode && node.type !== 'text') {\n                text += getInlineMarkdownText(node);\n                // skip the children\n                walker.resumeAt(widgetNode, false);\n                walker.next();\n            }\n            else if (node.type === 'text') {\n                text += node.literal;\n            }\n        }\n    }\n    return text;\n}\n\n// EXTERNAL MODULE: ../../node_modules/dompurify/dist/purify.js\nvar purify = __nested_webpack_require_87464__(368);\nvar purify_default = /*#__PURE__*/__nested_webpack_require_87464__.n(purify);\n;// CONCATENATED MODULE: ./src/sanitizer/htmlSanitizer.ts\n\n\n\nvar CAN_BE_WHITE_TAG_LIST = ['iframe', 'embed'];\nvar whiteTagList = [];\nfunction htmlSanitizer_registerTagWhitelistIfPossible(tagName) {\n    if (common_includes(CAN_BE_WHITE_TAG_LIST, tagName)) {\n        whiteTagList.push(tagName.toLowerCase());\n    }\n}\nfunction sanitizeHTML(html, options) {\n    return purify_default().sanitize(html, tslib_es6_assign({ ADD_TAGS: whiteTagList, ADD_ATTR: ['rel', 'target', 'hreflang', 'type'], FORBID_TAGS: [\n            'input',\n            'script',\n            'textarea',\n            'form',\n            'button',\n            'select',\n            'meta',\n            'style',\n            'link',\n            'title',\n            'object',\n            'base',\n        ] }, options));\n}\n\n;// CONCATENATED MODULE: ./src/wysiwyg/nodes/html.ts\n\n\n\n\nfunction getChildrenHTML(node, typeName) {\n    return node\n        .literal.replace(new RegExp(\"(<\\\\s*\" + typeName + \"[^>]*>)|(</\" + typeName + \"\\\\s*[>])\", 'ig'), '')\n        .trim();\n}\nfunction getHTMLAttrsByHTMLString(html) {\n    html = html.match(reHTMLTag)[0];\n    var attrs = html.match(new RegExp(constants_ATTRIBUTE, 'g'));\n    return attrs\n        ? attrs.reduce(function (acc, attr) {\n            var _a = attr.trim().split('='), name = _a[0], values = _a.slice(1);\n            if (values.length) {\n                acc[name] = values.join('=').replace(/'|\"/g, '').trim();\n            }\n            return acc;\n        }, {})\n        : {};\n}\nfunction getHTMLAttrs(dom) {\n    return toArray_default()(dom.attributes).reduce(function (acc, attr) {\n        acc[attr.nodeName] = attr.nodeValue;\n        return acc;\n    }, {});\n}\nfunction sanitizeDOM(node, typeName, sanitizer, wwToDOMAdaptor) {\n    var dom = wwToDOMAdaptor.getToDOMNode(typeName)(node);\n    var html = sanitizer(dom.outerHTML);\n    var container = document.createElement('div');\n    container.innerHTML = html;\n    dom = container.firstChild;\n    var htmlAttrs = getHTMLAttrs(dom);\n    return { dom: dom, htmlAttrs: htmlAttrs };\n}\nvar schemaFactory = {\n    htmlBlock: function (typeName, sanitizeHTML, wwToDOMAdaptor) {\n        return {\n            atom: true,\n            content: 'block+',\n            group: 'block',\n            attrs: {\n                htmlAttrs: { default: {} },\n                childrenHTML: { default: '' },\n                htmlBlock: { default: true },\n            },\n            parseDOM: [\n                {\n                    tag: typeName,\n                    getAttrs: function (dom) {\n                        return {\n                            htmlAttrs: getHTMLAttrs(dom),\n                            childrenHTML: dom.innerHTML,\n                        };\n                    },\n                },\n            ],\n            toDOM: function (node) {\n                var _a = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor), dom = _a.dom, htmlAttrs = _a.htmlAttrs;\n                htmlAttrs.class = htmlAttrs.class ? htmlAttrs.class + \" html-block\" : 'html-block';\n                return __spreadArray([typeName, htmlAttrs], toArray_default()(dom.childNodes));\n            },\n        };\n    },\n    htmlInline: function (typeName, sanitizeHTML, wwToDOMAdaptor) {\n        return {\n            attrs: {\n                htmlAttrs: { default: {} },\n                htmlInline: { default: true },\n            },\n            parseDOM: [\n                {\n                    tag: typeName,\n                    getAttrs: function (dom) {\n                        return {\n                            htmlAttrs: getHTMLAttrs(dom),\n                        };\n                    },\n                },\n            ],\n            toDOM: function (node) {\n                var htmlAttrs = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor).htmlAttrs;\n                return [typeName, htmlAttrs, 0];\n            },\n        };\n    },\n};\nfunction createHTMLSchemaMap(convertorMap, sanitizeHTML, wwToDOMAdaptor) {\n    var htmlSchemaMap = { nodes: {}, marks: {} };\n    ['htmlBlock', 'htmlInline'].forEach(function (htmlType) {\n        if (convertorMap[htmlType]) {\n            Object.keys(convertorMap[htmlType]).forEach(function (type) {\n                var targetType = htmlType === 'htmlBlock' ? 'nodes' : 'marks';\n                // register tag white list for preventing to remove the html in sanitizer\n                registerTagWhitelistIfPossible(type);\n                htmlSchemaMap[targetType][type] = schemaFactory[htmlType](type, sanitizeHTML, wwToDOMAdaptor);\n            });\n        }\n    });\n    return htmlSchemaMap;\n}\n\n;// CONCATENATED MODULE: ./src/markdown/htmlRenderConvertors.ts\n\n\n\n\n\n\nvar reCloseTag = /^\\s*<\\s*\\//;\nvar htmlRenderConvertors_baseConvertors = {\n    paragraph: function (_, _a) {\n        var entering = _a.entering, origin = _a.origin, options = _a.options;\n        if (options.nodeId) {\n            return {\n                type: entering ? 'openTag' : 'closeTag',\n                outerNewLine: true,\n                tagName: 'p',\n            };\n        }\n        return origin();\n    },\n    softbreak: function (node) {\n        var isPrevNodeHTML = node.prev && node.prev.type === 'htmlInline';\n        var isPrevBR = isPrevNodeHTML && /<br ?\\/?>/.test(node.prev.literal);\n        var content = isPrevBR ? '\\n' : '<br>\\n';\n        return { type: 'html', content: content };\n    },\n    item: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            var attributes = {};\n            var classNames = [];\n            if (node.listData.task) {\n                attributes['data-task'] = '';\n                classNames.push('task-list-item');\n                if (node.listData.checked) {\n                    classNames.push('checked');\n                    attributes['data-task-checked'] = '';\n                }\n            }\n            return {\n                type: 'openTag',\n                tagName: 'li',\n                classNames: classNames,\n                attributes: attributes,\n                outerNewLine: true,\n            };\n        }\n        return {\n            type: 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    code: function (node) {\n        var attributes = { 'data-backticks': String(node.tickCount) };\n        return [\n            { type: 'openTag', tagName: 'code', attributes: attributes },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n        ];\n    },\n    codeBlock: function (node) {\n        var _a = node, fenceLength = _a.fenceLength, info = _a.info;\n        var infoWords = info ? info.split(/\\s+/) : [];\n        var preClasses = [];\n        var codeAttrs = {};\n        if (fenceLength > 3) {\n            codeAttrs['data-backticks'] = fenceLength;\n        }\n        if (infoWords.length > 0 && infoWords[0].length > 0) {\n            var lang = infoWords[0];\n            preClasses.push(\"lang-\" + lang);\n            codeAttrs['data-language'] = lang;\n        }\n        return [\n            { type: 'openTag', tagName: 'pre', classNames: preClasses },\n            { type: 'openTag', tagName: 'code', attributes: codeAttrs },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n            { type: 'closeTag', tagName: 'pre' },\n        ];\n    },\n    customInline: function (node, _a) {\n        var origin = _a.origin, entering = _a.entering, skipChildren = _a.skipChildren;\n        var info = node.info;\n        if (info.indexOf('widget') !== -1 && entering) {\n            skipChildren();\n            var content = getWidgetContent(node);\n            var htmlInline = widgetToDOM(info, content).outerHTML;\n            return [\n                { type: 'openTag', tagName: 'span', classNames: ['tui-widget'] },\n                { type: 'html', content: htmlInline },\n                { type: 'closeTag', tagName: 'span' },\n            ];\n        }\n        return origin();\n    },\n};\nfunction getHTMLRenderConvertors(linkAttributes, customConvertors) {\n    var convertors = tslib_es6_assign({}, htmlRenderConvertors_baseConvertors);\n    if (linkAttributes) {\n        convertors.link = function (_, _a) {\n            var entering = _a.entering, origin = _a.origin;\n            var result = origin();\n            if (entering) {\n                result.attributes = tslib_es6_assign(tslib_es6_assign({}, result.attributes), linkAttributes);\n            }\n            return result;\n        };\n    }\n    if (customConvertors) {\n        Object.keys(customConvertors).forEach(function (nodeType) {\n            var orgConvertor = convertors[nodeType];\n            var customConvertor = customConvertors[nodeType];\n            if (orgConvertor && isFunction_default()(customConvertor)) {\n                convertors[nodeType] = function (node, context) {\n                    var newContext = tslib_es6_assign({}, context);\n                    newContext.origin = function () { return orgConvertor(node, context); };\n                    return customConvertor(node, newContext);\n                };\n            }\n            else if (common_includes(['htmlBlock', 'htmlInline'], nodeType) && !isFunction_default()(customConvertor)) {\n                convertors[nodeType] = function (node, context) {\n                    var matched = node.literal.match(reHTMLTag);\n                    if (matched) {\n                        var rootHTML = matched[0], openTagName = matched[1], closeTagName = matched[3];\n                        var typeName = (openTagName || closeTagName).toLowerCase();\n                        var htmlConvertor = customConvertor[typeName];\n                        var childrenHTML = getChildrenHTML(node, typeName);\n                        if (htmlConvertor) {\n                            // copy for preventing to overwrite the originial property\n                            var newNode = tslib_es6_assign({}, node);\n                            newNode.attrs = getHTMLAttrsByHTMLString(rootHTML);\n                            newNode.childrenHTML = childrenHTML;\n                            newNode.type = typeName;\n                            context.entering = !reCloseTag.test(node.literal);\n                            return htmlConvertor(newNode, context);\n                        }\n                    }\n                    return context.origin();\n                };\n            }\n            else {\n                convertors[nodeType] = customConvertor;\n            }\n        });\n    }\n    return convertors;\n}\n\n;// CONCATENATED MODULE: ./src/markdown/scroll/dom.ts\n\n\nvar nestableTypes = (/* unused pure expression or super */ null && (0));\nvar nestableTagNames = ['UL', 'OL', 'BLOCKQUOTE'];\nfunction isBlankLine(doc, index) {\n    var _a;\n    var pmNode = doc.child(index);\n    return !pmNode.childCount || (pmNode.childCount === 1 && !((_a = pmNode.firstChild.text) === null || _a === void 0 ? void 0 : _a.trim()));\n}\nfunction getEditorRangeHeightInfo(doc, mdNode, children) {\n    var start = getMdStartLine(mdNode) - 1;\n    var end = getMdEndLine(mdNode) - 1;\n    var rect = children[start].getBoundingClientRect();\n    var height = children[end].offsetTop -\n        children[start].offsetTop +\n        children[end].clientHeight;\n    return {\n        height: height <= 0\n            ? children[start].clientHeight\n            : height + getBlankLinesHeight(doc, children, Math.min(end + 1, doc.childCount - 1)),\n        rect: rect,\n    };\n}\nfunction getBlankLinesHeight(doc, children, start) {\n    var end = doc.childCount - 1;\n    var height = 0;\n    while (start <= end && isBlankLine(doc, start)) {\n        height += children[start].clientHeight;\n        start += 1;\n    }\n    return height;\n}\nfunction findAncestorHavingId(el, root) {\n    while (!el.getAttribute('data-nodeid') && el.parentElement !== root) {\n        el = el.parentElement;\n    }\n    return el;\n}\nfunction dom_getTotalOffsetTop(el, root) {\n    var offsetTop = 0;\n    while (el && el !== root) {\n        if (!common_includes(nestableTagNames, el.tagName)) {\n            offsetTop += el.offsetTop;\n        }\n        if (el.offsetParent === root.offsetParent) {\n            break;\n        }\n        el = el.parentElement;\n    }\n    return offsetTop;\n}\nfunction findAdjacentElementToScrollTop(scrollTop, root) {\n    var el = root;\n    var prev = null;\n    while (el) {\n        var firstElementChild = el.firstElementChild;\n        if (!firstElementChild) {\n            break;\n        }\n        var lastSibling = findLastSiblingElementToScrollTop(firstElementChild, scrollTop, dom_getTotalOffsetTop(el, root));\n        prev = el;\n        el = lastSibling;\n    }\n    var adjacentEl = el || prev;\n    return adjacentEl === root ? null : adjacentEl;\n}\nfunction findLastSiblingElementToScrollTop(el, scrollTop, offsetTop) {\n    if (el && scrollTop > offsetTop + el.offsetTop) {\n        return (findLastSiblingElementToScrollTop(el.nextElementSibling, scrollTop, offsetTop) || el);\n    }\n    return null;\n}\nfunction getAdditionalPos(scrollTop, offsetTop, height, targetNodeHeight) {\n    var ratio = Math.min((scrollTop - offsetTop) / height, 1);\n    return ratio * targetNodeHeight;\n}\nfunction getParentNodeObj(previewContent, mdNode) {\n    var el = previewContent.querySelector(\"[data-nodeid=\\\"\" + mdNode.id + \"\\\"]\");\n    while (!el || isStyledInlineNode(mdNode)) {\n        mdNode = mdNode.parent;\n        el = previewContent.querySelector(\"[data-nodeid=\\\"\" + mdNode.id + \"\\\"]\");\n    }\n    return getNonNestableNodeObj({ mdNode: mdNode, el: el });\n}\nfunction getNonNestableNodeObj(_a) {\n    var mdNode = _a.mdNode, el = _a.el;\n    while ((includes(nestableTypes, mdNode.type) || mdNode.type === 'table') && mdNode.firstChild) {\n        mdNode = mdNode.firstChild;\n        el = el.firstElementChild;\n    }\n    return { mdNode: mdNode, el: el };\n}\n\n;// CONCATENATED MODULE: ./src/markdown/scroll/offset.ts\n\n\nvar offsetInfoMap = {};\nfunction setHeight(id, height) {\n    offsetInfoMap[id] = offsetInfoMap[id] || {};\n    offsetInfoMap[id].height = height;\n}\nfunction setOffsetTop(id, offsetTop) {\n    offsetInfoMap[id] = offsetInfoMap[id] || {};\n    offsetInfoMap[id].offsetTop = offsetTop;\n}\nfunction getHeight(id) {\n    return offsetInfoMap[id] && offsetInfoMap[id].height;\n}\nfunction getOffsetTop(id) {\n    return offsetInfoMap[id] && offsetInfoMap[id].offsetTop;\n}\nfunction removeOffsetInfoByNode(node) {\n    if (node) {\n        delete offsetInfoMap[Number(node.getAttribute('data-nodeid'))];\n        toArray_default()(node.children).forEach(function (child) {\n            removeOffsetInfoByNode(child);\n        });\n    }\n}\nfunction getAndSaveOffsetInfo(node, root, mdNodeId) {\n    var cachedHeight = getHeight(mdNodeId);\n    var cachedTop = getOffsetTop(mdNodeId);\n    var nodeHeight = cachedHeight || node.clientHeight;\n    var offsetTop = cachedTop || getTotalOffsetTop(node, root) || node.offsetTop;\n    if (!cachedHeight) {\n        setHeight(mdNodeId, nodeHeight);\n    }\n    if (!cachedTop) {\n        setOffsetTop(mdNodeId, offsetTop);\n    }\n    return { nodeHeight: nodeHeight, offsetTop: offsetTop };\n}\n\n;// CONCATENATED MODULE: ./src/markdown/mdPreview.ts\n\n\n\n\n\n\n\n\n\n\n\nvar CLASS_HIGHLIGHT = cls('md-preview-highlight');\nfunction findTableCell(tableRow, chOffset) {\n    var cell = tableRow.firstChild;\n    while (cell && cell.next) {\n        if (getMdStartCh(cell.next) > chOffset + 1) {\n            break;\n        }\n        cell = cell.next;\n    }\n    return cell;\n}\n/**\n * Class Markdown Preview\n * @param {HTMLElement} el - base element\n * @param {eventEmitter} eventEmitter - event manager\n * @param {object} options\n * @param {boolean} options.isViewer - true for view-only mode\n * @param {boolean} options.highlight - true for using live-highlight feature\n * @param {object} opitons.linkAttributes - attributes for link element\n * @param {object} opitons.customHTMLRenderer - map of custom HTML render functions\n *\n * @ignore\n */\nvar MarkdownPreview = /** @class */ (function () {\n    function MarkdownPreview(eventEmitter, options) {\n        var el = document.createElement('div');\n        this.el = el;\n        this.eventEmitter = eventEmitter;\n        this.isViewer = !!options.isViewer;\n        this.el.className = cls('md-preview');\n        var linkAttributes = options.linkAttributes, customHTMLRenderer = options.customHTMLRenderer, sanitizer = options.sanitizer, _a = options.highlight, highlight = _a === void 0 ? false : _a;\n        this.renderer = new Renderer({\n            gfm: true,\n            nodeId: true,\n            convertors: getHTMLRenderConvertors(linkAttributes, customHTMLRenderer),\n        });\n        this.cursorNodeId = null;\n        this.sanitizer = sanitizer;\n        this.initEvent(highlight);\n        this.initContentSection();\n        // To prevent overflowing contents in the viewer\n        if (this.isViewer) {\n            this.previewContent.style.overflowWrap = 'break-word';\n        }\n    }\n    MarkdownPreview.prototype.initContentSection = function () {\n        this.previewContent = createElementWith(\"<div class=\\\"\" + cls('contents') + \"\\\"></div>\");\n        if (!this.isViewer) {\n            this.el.appendChild(this.previewContent);\n        }\n    };\n    MarkdownPreview.prototype.toggleActive = function (active) {\n        toggleClass(this.el, 'active', active);\n    };\n    MarkdownPreview.prototype.initEvent = function (highlight) {\n        var _this = this;\n        this.eventEmitter.listen('updatePreview', this.update.bind(this));\n        if (this.isViewer) {\n            return;\n        }\n        if (highlight) {\n            this.eventEmitter.listen('changeToolbarState', function (_a) {\n                var mdNode = _a.mdNode, cursorPos = _a.cursorPos;\n                _this.updateCursorNode(mdNode, cursorPos);\n            });\n            this.eventEmitter.listen('blur', function () {\n                _this.removeHighlight();\n            });\n        }\n        on_default()(this.el, 'scroll', function (event) {\n            _this.eventEmitter.emit('scroll', 'preview', findAdjacentElementToScrollTop(event.target.scrollTop, _this.previewContent));\n        });\n        this.eventEmitter.listen('changePreviewTabPreview', function () { return _this.toggleActive(true); });\n        this.eventEmitter.listen('changePreviewTabWrite', function () { return _this.toggleActive(false); });\n    };\n    MarkdownPreview.prototype.removeHighlight = function () {\n        if (this.cursorNodeId) {\n            var currentEl = this.getElementByNodeId(this.cursorNodeId);\n            if (currentEl) {\n                removeClass_default()(currentEl, CLASS_HIGHLIGHT);\n            }\n        }\n    };\n    MarkdownPreview.prototype.updateCursorNode = function (cursorNode, cursorPos) {\n        if (cursorNode) {\n            cursorNode = findClosestNode(cursorNode, function (mdNode) { return !isInlineNode(mdNode); });\n            if (cursorNode.type === 'tableRow') {\n                cursorNode = findTableCell(cursorNode, cursorPos[1]);\n            }\n            else if (cursorNode.type === 'tableBody') {\n                // empty line next to table\n                cursorNode = null;\n            }\n        }\n        var cursorNodeId = cursorNode ? cursorNode.id : null;\n        if (this.cursorNodeId === cursorNodeId) {\n            return;\n        }\n        var oldEL = this.getElementByNodeId(this.cursorNodeId);\n        var newEL = this.getElementByNodeId(cursorNodeId);\n        if (oldEL) {\n            removeClass_default()(oldEL, CLASS_HIGHLIGHT);\n        }\n        if (newEL) {\n            addClass_default()(newEL, CLASS_HIGHLIGHT);\n        }\n        this.cursorNodeId = cursorNodeId;\n    };\n    MarkdownPreview.prototype.getElementByNodeId = function (nodeId) {\n        return nodeId\n            ? this.previewContent.querySelector(\"[data-nodeid=\\\"\" + nodeId + \"\\\"]\")\n            : null;\n    };\n    MarkdownPreview.prototype.update = function (changed) {\n        var _this = this;\n        changed.forEach(function (editResult) { return _this.replaceRangeNodes(editResult); });\n        this.eventEmitter.emit('afterPreviewRender', this);\n    };\n    MarkdownPreview.prototype.replaceRangeNodes = function (editResult) {\n        var _this = this;\n        var nodes = editResult.nodes, removedNodeRange = editResult.removedNodeRange;\n        var contentEl = this.previewContent;\n        var newHtml = this.eventEmitter.emitReduce('beforePreviewRender', this.sanitizer(nodes.map(function (node) { return _this.renderer.render(node); }).join('')));\n        if (!removedNodeRange) {\n            contentEl.insertAdjacentHTML('afterbegin', newHtml);\n        }\n        else {\n            var _a = removedNodeRange.id, startNodeId = _a[0], endNodeId = _a[1];\n            var startEl = this.getElementByNodeId(startNodeId);\n            var endEl = this.getElementByNodeId(endNodeId);\n            if (startEl) {\n                startEl.insertAdjacentHTML('beforebegin', newHtml);\n                var el = startEl;\n                while (el && el !== endEl) {\n                    var nextEl = el.nextElementSibling;\n                    removeNode(el);\n                    removeOffsetInfoByNode(el);\n                    el = nextEl;\n                }\n                if (el === null || el === void 0 ? void 0 : el.parentNode) {\n                    removeNode(el);\n                    removeOffsetInfoByNode(el);\n                }\n            }\n        }\n    };\n    MarkdownPreview.prototype.getRenderer = function () {\n        return this.renderer;\n    };\n    MarkdownPreview.prototype.destroy = function () {\n        off_default()(this.el, 'scroll');\n        this.el = null;\n    };\n    MarkdownPreview.prototype.getElement = function () {\n        return this.el;\n    };\n    MarkdownPreview.prototype.getHTML = function () {\n        return removeProseMirrorHackNodes(this.previewContent.innerHTML);\n    };\n    MarkdownPreview.prototype.setHTML = function (html) {\n        this.previewContent.innerHTML = html;\n    };\n    MarkdownPreview.prototype.setHeight = function (height) {\n        css_default()(this.el, { height: height + \"px\" });\n    };\n    MarkdownPreview.prototype.setMinHeight = function (minHeight) {\n        css_default()(this.el, { minHeight: minHeight + \"px\" });\n    };\n    return MarkdownPreview;\n}());\n/* harmony default export */ var mdPreview = (MarkdownPreview);\n\n// EXTERNAL MODULE: external {\"commonjs\":\"prosemirror-state\",\"commonjs2\":\"prosemirror-state\",\"amd\":\"prosemirror-state\"}\nvar external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_ = __nested_webpack_require_87464__(814);\n// EXTERNAL MODULE: external {\"commonjs\":\"prosemirror-inputrules\",\"commonjs2\":\"prosemirror-inputrules\",\"amd\":\"prosemirror-inputrules\"}\nvar external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_ = __nested_webpack_require_87464__(479);\n// EXTERNAL MODULE: external {\"commonjs\":\"prosemirror-view\",\"commonjs2\":\"prosemirror-view\",\"amd\":\"prosemirror-view\"}\nvar external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_ = __nested_webpack_require_87464__(311);\n// EXTERNAL MODULE: external {\"commonjs\":\"prosemirror-keymap\",\"commonjs2\":\"prosemirror-keymap\",\"amd\":\"prosemirror-keymap\"}\nvar external_commonjs_prosemirror_keymap_commonjs2_prosemirror_keymap_amd_prosemirror_keymap_ = __nested_webpack_require_87464__(481);\n// EXTERNAL MODULE: external {\"commonjs\":\"prosemirror-model\",\"commonjs2\":\"prosemirror-model\",\"amd\":\"prosemirror-model\"}\nvar external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_ = __nested_webpack_require_87464__(43);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/array/inArray.js\nvar inArray = __nested_webpack_require_87464__(928);\nvar inArray_default = /*#__PURE__*/__nested_webpack_require_87464__.n(inArray);\n;// CONCATENATED MODULE: ./src/utils/map.ts\n\n/**\n * @class\n * @ignore\n * @classdesc ES6 Map\n */\nvar map_Map = /** @class */ (function () {\n    function Map() {\n        this.keys = [];\n        this.values = [];\n    }\n    Map.prototype.getKeyIndex = function (key) {\n        return inArray_default()(key, this.keys);\n    };\n    Map.prototype.get = function (key) {\n        return this.values[this.getKeyIndex(key)];\n    };\n    Map.prototype.set = function (key, value) {\n        var keyIndex = this.getKeyIndex(key);\n        if (keyIndex > -1) {\n            this.values[keyIndex] = value;\n        }\n        else {\n            this.keys.push(key);\n            this.values.push(value);\n        }\n        return this;\n    };\n    Map.prototype.has = function (key) {\n        return this.getKeyIndex(key) > -1;\n    };\n    Map.prototype.delete = function (key) {\n        var keyIndex = this.getKeyIndex(key);\n        if (keyIndex > -1) {\n            this.keys.splice(keyIndex, 1);\n            this.values.splice(keyIndex, 1);\n            return true;\n        }\n        return false;\n    };\n    Map.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        if (thisArg === void 0) { thisArg = this; }\n        this.values.forEach(function (value, index) {\n            if (value && _this.keys[index]) {\n                callback.call(thisArg, value, _this.keys[index], _this);\n            }\n        });\n    };\n    Map.prototype.clear = function () {\n        this.keys = [];\n        this.values = [];\n    };\n    return Map;\n}());\n/* harmony default export */ var utils_map = (map_Map);\n\n;// CONCATENATED MODULE: ./src/i18n/i18n.ts\n/**\n * @fileoverview Implements i18n\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n */\n\n\nvar DEFAULT_CODE = 'en-US';\n/**\n * Class I18n\n * @ignore\n */\nvar I18n = /** @class */ (function () {\n    function I18n() {\n        this.code = DEFAULT_CODE;\n        this.langs = new utils_map();\n    }\n    I18n.prototype.setCode = function (code) {\n        this.code = code || DEFAULT_CODE;\n    };\n    /**\n     * Set language set\n     * @param {string|string[]} codes locale code\n     * @param {object} data language set\n     */\n    I18n.prototype.setLanguage = function (codes, data) {\n        var _this = this;\n        codes = [].concat(codes);\n        codes.forEach(function (code) {\n            if (!_this.langs.has(code)) {\n                _this.langs.set(code, data);\n            }\n            else {\n                var langData = _this.langs.get(code);\n                _this.langs.set(code, extend_default()(langData, data));\n            }\n        });\n    };\n    I18n.prototype.get = function (key, code) {\n        if (!code) {\n            code = this.code;\n        }\n        var langSet = this.langs.get(code);\n        if (!langSet) {\n            langSet = this.langs.get(DEFAULT_CODE);\n        }\n        var text = langSet[key];\n        if (!text) {\n            throw new Error(\"There is no text key \\\"\" + key + \"\\\" in \" + code);\n        }\n        return text;\n    };\n    return I18n;\n}());\n\n/* harmony default export */ var i18n = (new I18n());\n\n;// CONCATENATED MODULE: ./src/wysiwyg/helper/node.ts\n\n\nfunction findNodeBy(pos, condition) {\n    var depth = pos.depth;\n    while (depth) {\n        var node = pos.node(depth);\n        if (condition(node, depth)) {\n            return {\n                node: node,\n                depth: depth,\n                offset: depth > 0 ? pos.before(depth) : 0,\n            };\n        }\n        depth -= 1;\n    }\n    return null;\n}\nfunction node_isListNode(_a) {\n    var type = _a.type;\n    return type.name === 'bulletList' || type.name === 'orderedList';\n}\nfunction isInListNode(pos) {\n    return !!findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'listItem' || type.name === 'bulletList' || type.name === 'orderedList';\n    });\n}\nfunction isInTableNode(pos) {\n    return !!findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';\n    });\n}\nfunction findListItem(pos) {\n    return findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'listItem';\n    });\n}\nfunction createDOMInfoParsedRawHTML(tag) {\n    return {\n        tag: tag,\n        getAttrs: function (dom) {\n            var rawHTML = dom.getAttribute('data-raw-html');\n            return __assign({}, (rawHTML && { rawHTML: rawHTML }));\n        },\n    };\n}\nfunction createCellAttrs(attrs) {\n    return Object.keys(attrs).reduce(function (acc, attrName) {\n        if (attrName !== 'rawHTML' && attrs[attrName]) {\n            attrName = attrName === 'className' ? 'class' : attrName;\n            acc[attrName] = attrs[attrName];\n        }\n        return acc;\n    }, {});\n}\nfunction createParsedCellDOM(tag) {\n    return {\n        tag: tag,\n        getAttrs: function (dom) {\n            return ['rawHTML', 'colspan', 'rowspan', 'extended'].reduce(function (acc, attrName) {\n                var attrNameInDOM = attrName === 'rawHTML' ? 'data-raw-html' : attrName;\n                var attrValue = dom.getAttribute(attrNameInDOM);\n                if (attrValue) {\n                    acc[attrName] = includes(['rawHTML', 'extended'], attrName)\n                        ? attrValue\n                        : Number(attrValue);\n                }\n                return acc;\n            }, {});\n        },\n    };\n}\nfunction getDefaultCustomAttrs() {\n    return {\n        htmlAttrs: { default: null },\n        classNames: { default: null },\n    };\n}\nfunction getCustomAttrs(attrs) {\n    var htmlAttrs = attrs.htmlAttrs, classNames = attrs.classNames;\n    return __assign(__assign({}, htmlAttrs), { class: classNames ? classNames.join(' ') : null });\n}\n\n;// CONCATENATED MODULE: ./src/wysiwyg/helper/tableOffsetMap.ts\n\n\nvar cache = new Map();\n/* eslint-disable @typescript-eslint/no-unused-vars */\nvar TableOffsetMap = /** @class */ (function () {\n    function TableOffsetMap(table, tableRows, tableStartPos, rowInfo) {\n        this.table = table;\n        this.tableRows = tableRows;\n        this.tableStartPos = tableStartPos;\n        this.rowInfo = rowInfo;\n    }\n    TableOffsetMap.create = function (cellPos) {\n        var table = findNodeBy(cellPos, function (_a) {\n            var type = _a.type;\n            return type.name === 'table';\n        });\n        if (table) {\n            var node = table.node, depth = table.depth, offset = table.offset;\n            var cached = cache.get(node);\n            if ((cached === null || cached === void 0 ? void 0 : cached.tableStartPos) === offset + 1) {\n                return cached;\n            }\n            var rows_1 = [];\n            var tablePos = cellPos.start(depth);\n            var thead = node.child(0);\n            var tbody = node.child(1);\n            var theadCellInfo = createOffsetMap(thead, tablePos);\n            var tbodyCellInfo = createOffsetMap(tbody, tablePos + thead.nodeSize);\n            thead.forEach(function (row) { return rows_1.push(row); });\n            tbody.forEach(function (row) { return rows_1.push(row); });\n            var map = new TableOffsetMap(node, rows_1, tablePos, theadCellInfo.concat(tbodyCellInfo));\n            cache.set(node, map);\n            return map;\n        }\n        return null;\n    };\n    Object.defineProperty(TableOffsetMap.prototype, \"totalRowCount\", {\n        get: function () {\n            return this.rowInfo.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"totalColumnCount\", {\n        get: function () {\n            return this.rowInfo[0].length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"tableStartOffset\", {\n        get: function () {\n            return this.tableStartPos;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"tableEndOffset\", {\n        get: function () {\n            return this.tableStartPos + this.table.nodeSize - 1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    TableOffsetMap.prototype.getCellInfo = function (rowIdx, colIdx) {\n        return this.rowInfo[rowIdx][colIdx];\n    };\n    TableOffsetMap.prototype.posAt = function (rowIdx, colIdx) {\n        for (var i = 0, rowStart = this.tableStartPos;; i += 1) {\n            var rowEnd = rowStart + this.tableRows[i].nodeSize;\n            if (i === rowIdx) {\n                var index = colIdx;\n                // Skip the cells from previous row(via rowspan)\n                while (index < this.totalColumnCount && this.rowInfo[i][index].offset < rowStart) {\n                    index += 1;\n                }\n                return index === this.totalColumnCount ? rowEnd : this.rowInfo[i][index].offset;\n            }\n            rowStart = rowEnd;\n        }\n    };\n    TableOffsetMap.prototype.getNodeAndPos = function (rowIdx, colIdx) {\n        var cellInfo = this.rowInfo[rowIdx][colIdx];\n        return {\n            node: this.table.nodeAt(cellInfo.offset - this.tableStartOffset),\n            pos: cellInfo.offset,\n        };\n    };\n    TableOffsetMap.prototype.extendedRowspan = function (rowIdx, colIdx) {\n        return false;\n    };\n    TableOffsetMap.prototype.extendedColspan = function (rowIdx, colIdx) {\n        return false;\n    };\n    TableOffsetMap.prototype.getRowspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.getColspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.decreaseColspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.decreaseRowspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.getColspanStartInfo = function (rowIdx, colIdx) {\n        return null;\n    };\n    TableOffsetMap.prototype.getRowspanStartInfo = function (rowIdx, colIdx) {\n        return null;\n    };\n    TableOffsetMap.prototype.getCellStartOffset = function (rowIdx, colIdx) {\n        var offset = this.rowInfo[rowIdx][colIdx].offset;\n        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset;\n    };\n    TableOffsetMap.prototype.getCellEndOffset = function (rowIdx, colIdx) {\n        var _a = this.rowInfo[rowIdx][colIdx], offset = _a.offset, nodeSize = _a.nodeSize;\n        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset + nodeSize;\n    };\n    TableOffsetMap.prototype.getCellIndex = function (cellPos) {\n        for (var rowIdx = 0; rowIdx < this.totalRowCount; rowIdx += 1) {\n            var rowInfo = this.rowInfo[rowIdx];\n            for (var colIdx = 0; colIdx < this.totalColumnCount; colIdx += 1) {\n                if (rowInfo[colIdx].offset + 1 > cellPos.pos) {\n                    return [rowIdx, colIdx];\n                }\n            }\n        }\n        return [0, 0];\n    };\n    TableOffsetMap.prototype.getRectOffsets = function (startCellPos, endCellPos) {\n        var _a, _b, _c;\n        if (endCellPos === void 0) { endCellPos = startCellPos; }\n        if (startCellPos.pos > endCellPos.pos) {\n            _a = [endCellPos, startCellPos], startCellPos = _a[0], endCellPos = _a[1];\n        }\n        var _d = this.getCellIndex(startCellPos), startRowIdx = _d[0], startColIdx = _d[1];\n        var _e = this.getCellIndex(endCellPos), endRowIdx = _e[0], endColIdx = _e[1];\n        _b = getSortedNumPair(startRowIdx, endRowIdx), startRowIdx = _b[0], endRowIdx = _b[1];\n        _c = getSortedNumPair(startColIdx, endColIdx), startColIdx = _c[0], endColIdx = _c[1];\n        return this.getSpannedOffsets({ startRowIdx: startRowIdx, startColIdx: startColIdx, endRowIdx: endRowIdx, endColIdx: endColIdx });\n    };\n    TableOffsetMap.prototype.getSpannedOffsets = function (selectionInfo) {\n        return selectionInfo;\n    };\n    return TableOffsetMap;\n}());\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\nvar createOffsetMap = function (headOrBody, startOffset) {\n    var cellInfoMatrix = [];\n    headOrBody.forEach(function (row, rowOffset) {\n        // get row index based on table(not table head or table body)\n        var rowInfo = { rowspanMap: {}, colspanMap: {}, length: 0 };\n        row.forEach(function (_a, cellOffset) {\n            var nodeSize = _a.nodeSize;\n            var colIdx = 0;\n            while (rowInfo[colIdx]) {\n                colIdx += 1;\n            }\n            rowInfo[colIdx] = {\n                // 2 is the sum of the front and back positions of the tag\n                offset: startOffset + rowOffset + cellOffset + 2,\n                nodeSize: nodeSize,\n            };\n            rowInfo.length += 1;\n        });\n        cellInfoMatrix.push(rowInfo);\n    });\n    return cellInfoMatrix;\n};\nfunction mixinTableOffsetMapPrototype(offsetMapMixin, createOffsetMapMixin) {\n    common_assign(TableOffsetMap.prototype, offsetMapMixin);\n    createOffsetMap = createOffsetMapMixin;\n    return TableOffsetMap;\n}\n\n;// CONCATENATED MODULE: ./src/helper/plugin.ts\n\n\n\n\n\n\n\n\n\n\nfunction execPlugin(pluginInfo) {\n    var plugin = pluginInfo.plugin, eventEmitter = pluginInfo.eventEmitter, usageStatistics = pluginInfo.usageStatistics, instance = pluginInfo.instance;\n    var pmState = { Plugin: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Plugin, PluginKey: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.PluginKey, Selection: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Selection, TextSelection: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.TextSelection };\n    var pmView = { Decoration: external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.Decoration, DecorationSet: external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.DecorationSet };\n    var pmModel = { Fragment: external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment };\n    var pmRules = { InputRule: external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.InputRule, inputRules: external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.inputRules, undoInputRule: external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.undoInputRule };\n    var pmKeymap = { keymap: external_commonjs_prosemirror_keymap_commonjs2_prosemirror_keymap_amd_prosemirror_keymap_.keymap };\n    var context = {\n        eventEmitter: eventEmitter,\n        usageStatistics: usageStatistics,\n        instance: instance,\n        pmState: pmState,\n        pmView: pmView,\n        pmModel: pmModel,\n        pmRules: pmRules,\n        pmKeymap: pmKeymap,\n        i18n: i18n,\n    };\n    if (isArray_default()(plugin)) {\n        var pluginFn = plugin[0], _a = plugin[1], options = _a === void 0 ? {} : _a;\n        return pluginFn(context, options);\n    }\n    return plugin(context);\n}\nfunction getPluginInfo(pluginsInfo) {\n    var plugins = pluginsInfo.plugins, eventEmitter = pluginsInfo.eventEmitter, usageStatistics = pluginsInfo.usageStatistics, instance = pluginsInfo.instance;\n    eventEmitter.listen('mixinTableOffsetMapPrototype', mixinTableOffsetMapPrototype);\n    return (plugins !== null && plugins !== void 0 ? plugins : []).reduce(function (acc, plugin) {\n        var pluginInfoResult = execPlugin({\n            plugin: plugin,\n            eventEmitter: eventEmitter,\n            usageStatistics: usageStatistics,\n            instance: instance,\n        });\n        if (!pluginInfoResult) {\n            throw new Error('The return value of the executed plugin is empty.');\n        }\n        var markdownParsers = pluginInfoResult.markdownParsers, toHTMLRenderers = pluginInfoResult.toHTMLRenderers, toMarkdownRenderers = pluginInfoResult.toMarkdownRenderers, markdownPlugins = pluginInfoResult.markdownPlugins, wysiwygPlugins = pluginInfoResult.wysiwygPlugins, wysiwygNodeViews = pluginInfoResult.wysiwygNodeViews, markdownCommands = pluginInfoResult.markdownCommands, wysiwygCommands = pluginInfoResult.wysiwygCommands, toolbarItems = pluginInfoResult.toolbarItems;\n        if (toHTMLRenderers) {\n            acc.toHTMLRenderers = deepMergedCopy(acc.toHTMLRenderers, toHTMLRenderers);\n        }\n        if (toMarkdownRenderers) {\n            acc.toMarkdownRenderers = deepMergedCopy(acc.toMarkdownRenderers, toMarkdownRenderers);\n        }\n        if (markdownPlugins) {\n            acc.mdPlugins = acc.mdPlugins.concat(markdownPlugins);\n        }\n        if (wysiwygPlugins) {\n            acc.wwPlugins = acc.wwPlugins.concat(wysiwygPlugins);\n        }\n        if (wysiwygNodeViews) {\n            acc.wwNodeViews = tslib_es6_assign(tslib_es6_assign({}, acc.wwNodeViews), wysiwygNodeViews);\n        }\n        if (markdownCommands) {\n            acc.mdCommands = tslib_es6_assign(tslib_es6_assign({}, acc.mdCommands), markdownCommands);\n        }\n        if (wysiwygCommands) {\n            acc.wwCommands = tslib_es6_assign(tslib_es6_assign({}, acc.wwCommands), wysiwygCommands);\n        }\n        if (toolbarItems) {\n            acc.toolbarItems = acc.toolbarItems.concat(toolbarItems);\n        }\n        if (markdownParsers) {\n            acc.markdownParsers = tslib_es6_assign(tslib_es6_assign({}, acc.markdownParsers), markdownParsers);\n        }\n        return acc;\n    }, {\n        toHTMLRenderers: {},\n        toMarkdownRenderers: {},\n        mdPlugins: [],\n        wwPlugins: [],\n        wwNodeViews: {},\n        mdCommands: {},\n        wwCommands: {},\n        toolbarItems: [],\n        markdownParsers: {},\n    });\n}\n\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isFalsy.js\nvar isFalsy = __nested_webpack_require_87464__(404);\nvar isFalsy_default = /*#__PURE__*/__nested_webpack_require_87464__.n(isFalsy);\n;// CONCATENATED MODULE: ./src/event/eventEmitter.ts\n\n\n\n\nvar eventTypeList = [\n    'afterPreviewRender',\n    'updatePreview',\n    'changeMode',\n    'needChangeMode',\n    'command',\n    'changePreviewStyle',\n    'changePreviewTabPreview',\n    'changePreviewTabWrite',\n    'scroll',\n    'contextmenu',\n    'show',\n    'hide',\n    'changeLanguage',\n    'changeToolbarState',\n    'toggleScrollSync',\n    'mixinTableOffsetMapPrototype',\n    'setFocusedNode',\n    'removePopupWidget',\n    'query',\n    // provide event for user\n    'openPopup',\n    'closePopup',\n    'addImageBlobHook',\n    'beforePreviewRender',\n    'beforeConvertWysiwygToMarkdown',\n    'load',\n    'loadUI',\n    'change',\n    'caretChange',\n    'destroy',\n    'focus',\n    'blur',\n    'keydown',\n    'keyup',\n];\n/**\n * Class EventEmitter\n * @ignore\n */\nvar EventEmitter = /** @class */ (function () {\n    function EventEmitter() {\n        var _this = this;\n        this.events = new utils_map();\n        this.eventTypes = eventTypeList.reduce(function (types, type) {\n            return tslib_es6_assign(tslib_es6_assign({}, types), { type: type });\n        }, {});\n        this.hold = false;\n        eventTypeList.forEach(function (eventType) {\n            _this.addEventType(eventType);\n        });\n    }\n    /**\n     * Listen event and bind event handler\n     * @param {string} type Event type string\n     * @param {function} handler Event handler\n     */\n    EventEmitter.prototype.listen = function (type, handler) {\n        var typeInfo = this.getTypeInfo(type);\n        var eventHandlers = this.events.get(typeInfo.type) || [];\n        if (!this.hasEventType(typeInfo.type)) {\n            throw new Error(\"There is no event type \" + typeInfo.type);\n        }\n        if (typeInfo.namespace) {\n            handler.namespace = typeInfo.namespace;\n        }\n        eventHandlers.push(handler);\n        this.events.set(typeInfo.type, eventHandlers);\n    };\n    /**\n     * Emit event\n     * @param {string} eventName Event name to emit\n     * @returns {Array}\n     */\n    EventEmitter.prototype.emit = function (type) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var typeInfo = this.getTypeInfo(type);\n        var eventHandlers = this.events.get(typeInfo.type);\n        var results = [];\n        if (!this.hold && eventHandlers) {\n            eventHandlers.forEach(function (handler) {\n                var result = handler.apply(void 0, args);\n                if (!isUndefined_default()(result)) {\n                    results.push(result);\n                }\n            });\n        }\n        return results;\n    };\n    /**\n     * Emit given event and return result\n     * @param {string} eventName Event name to emit\n     * @param {any} source Source to change\n     * @returns {string}\n     */\n    EventEmitter.prototype.emitReduce = function (type, source) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var eventHandlers = this.events.get(type);\n        if (!this.hold && eventHandlers) {\n            eventHandlers.forEach(function (handler) {\n                var result = handler.apply(void 0, __spreadArray([source], args));\n                if (!isFalsy_default()(result)) {\n                    source = result;\n                }\n            });\n        }\n        return source;\n    };\n    /**\n     * Get event type and namespace\n     * @param {string} type Event type name\n     * @returns {{type: string, namespace: string}}\n     * @private\n     */\n    EventEmitter.prototype.getTypeInfo = function (type) {\n        var splited = type.split('.');\n        return {\n            type: splited[0],\n            namespace: splited[1],\n        };\n    };\n    /**\n     * Check whether event type exists or not\n     * @param {string} type Event type name\n     * @returns {boolean}\n     * @private\n     */\n    EventEmitter.prototype.hasEventType = function (type) {\n        return !isUndefined_default()(this.eventTypes[this.getTypeInfo(type).type]);\n    };\n    /**\n     * Add event type when given event not exists\n     * @param {string} type Event type name\n     */\n    EventEmitter.prototype.addEventType = function (type) {\n        if (this.hasEventType(type)) {\n            throw new Error(\"There is already have event type \" + type);\n        }\n        this.eventTypes[type] = type;\n    };\n    /**\n     * Remove event handler from given event type\n     * @param {string} eventType Event type name\n     * @param {function} [handler] - registered event handler\n     */\n    EventEmitter.prototype.removeEventHandler = function (eventType, handler) {\n        var _this = this;\n        var _a = this.getTypeInfo(eventType), type = _a.type, namespace = _a.namespace;\n        if (type && handler) {\n            this.removeEventHandlerWithHandler(type, handler);\n        }\n        else if (type && !namespace) {\n            this.events.delete(type);\n        }\n        else if (!type && namespace) {\n            this.events.forEach(function (_, evtType) {\n                _this.removeEventHandlerWithTypeInfo(evtType, namespace);\n            });\n        }\n        else if (type && namespace) {\n            this.removeEventHandlerWithTypeInfo(type, namespace);\n        }\n    };\n    /**\n     * Remove event handler with event handler\n     * @param {string} type - event type name\n     * @param {function} handler - event handler\n     * @private\n     */\n    EventEmitter.prototype.removeEventHandlerWithHandler = function (type, handler) {\n        var eventHandlers = this.events.get(type);\n        if (eventHandlers) {\n            var handlerIndex = eventHandlers.indexOf(handler);\n            if (eventHandlers.indexOf(handler) >= 0) {\n                eventHandlers.splice(handlerIndex, 1);\n            }\n        }\n    };\n    /**\n     * Remove event handler with event type information\n     * @param {string} type Event type name\n     * @param {string} namespace Event namespace\n     * @private\n     */\n    EventEmitter.prototype.removeEventHandlerWithTypeInfo = function (type, namespace) {\n        var handlersToSurvive = [];\n        var eventHandlers = this.events.get(type);\n        if (!eventHandlers) {\n            return;\n        }\n        eventHandlers.map(function (handler) {\n            if (handler.namespace !== namespace) {\n                handlersToSurvive.push(handler);\n            }\n            return null;\n        });\n        this.events.set(type, handlersToSurvive);\n    };\n    EventEmitter.prototype.getEvents = function () {\n        return this.events;\n    };\n    EventEmitter.prototype.holdEventInvoke = function (fn) {\n        this.hold = true;\n        fn();\n        this.hold = false;\n    };\n    return EventEmitter;\n}());\n/* harmony default export */ var eventEmitter = (EventEmitter);\n\n;// CONCATENATED MODULE: ./src/viewer.ts\n\n\n\n\n\n\n\n\n\n\n\n\nvar TASK_ATTR_NAME = 'data-task';\nvar DISABLED_TASK_ATTR_NAME = 'data-task-disabled';\nvar TASK_CHECKED_CLASS_NAME = 'checked';\nfunction registerHTMLTagToWhitelist(convertorMap) {\n    ['htmlBlock', 'htmlInline'].forEach(function (htmlType) {\n        if (convertorMap[htmlType]) {\n            // register tag white list for preventing to remove the html in sanitizer\n            Object.keys(convertorMap[htmlType]).forEach(function (type) { return htmlSanitizer_registerTagWhitelistIfPossible(type); });\n        }\n    });\n}\n/**\n * Class ToastUIEditorViewer\n * @param {object} options Option object\n *     @param {HTMLElement} options.el - container element\n *     @param {string} [options.initialValue] Editor's initial value\n *     @param {Object} [options.events] - Events\n *         @param {function} [options.events.load] - It would be emitted when editor fully load\n *         @param {function} [options.events.change] - It would be emitted when content changed\n *         @param {function} [options.events.caretChange] - It would be emitted when format change by cursor position\n *         @param {function} [options.events.focus] - It would be emitted when editor get focus\n *         @param {function} [options.events.blur] - It would be emitted when editor loose focus\n *     @param {Array.<function|Array>} [options.plugins] - Array of plugins. A plugin can be either a function or an array in the form of [function, options].\n *     @param {Object} [options.extendedAutolinks] - Using extended Autolinks specified in GFM spec\n *     @param {Object} [options.linkAttributes] - Attributes of anchor element that should be rel, target, hreflang, type\n *     @param {Object} [options.customHTMLRenderer=null] - Object containing custom renderer functions correspond to change markdown node to preview HTML or wysiwyg node\n *     @param {boolean} [options.referenceDefinition=false] - whether use the specification of link reference definition\n *     @param {function} [options.customHTMLSanitizer=null] - custom HTML sanitizer\n *     @param {boolean} [options.frontMatter=false] - whether use the front matter\n *     @param {string} [options.theme] - The theme to style the viewer with. The default is included in toastui-editor.css.\n */\nvar ToastUIEditorViewer = /** @class */ (function () {\n    function ToastUIEditorViewer(options) {\n        var _this = this;\n        this.options = extend_default()({\n            linkAttributes: null,\n            extendedAutolinks: false,\n            customHTMLRenderer: null,\n            referenceDefinition: false,\n            customHTMLSanitizer: null,\n            frontMatter: false,\n            usageStatistics: true,\n            theme: 'light',\n        }, options);\n        this.eventEmitter = new eventEmitter();\n        var linkAttributes = sanitizeLinkAttribute(this.options.linkAttributes);\n        var _a = getPluginInfo({\n            plugins: this.options.plugins,\n            eventEmitter: this.eventEmitter,\n            usageStatistics: this.options.usageStatistics,\n            instance: this,\n        }) || {}, toHTMLRenderers = _a.toHTMLRenderers, markdownParsers = _a.markdownParsers;\n        var _b = this.options, customHTMLRenderer = _b.customHTMLRenderer, extendedAutolinks = _b.extendedAutolinks, referenceDefinition = _b.referenceDefinition, frontMatter = _b.frontMatter, customHTMLSanitizer = _b.customHTMLSanitizer;\n        var rendererOptions = {\n            linkAttributes: linkAttributes,\n            customHTMLRenderer: tslib_es6_assign(tslib_es6_assign({}, toHTMLRenderers), customHTMLRenderer),\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            frontMatter: frontMatter,\n            sanitizer: customHTMLSanitizer || sanitizeHTML,\n        };\n        registerHTMLTagToWhitelist(rendererOptions.customHTMLRenderer);\n        if (this.options.events) {\n            forEachOwnProperties_default()(this.options.events, function (fn, key) {\n                _this.on(key, fn);\n            });\n        }\n        var _c = this.options, el = _c.el, initialValue = _c.initialValue, theme = _c.theme;\n        var existingHTML = el.innerHTML;\n        if (theme !== 'light') {\n            el.classList.add(cls(theme));\n        }\n        el.innerHTML = '';\n        this.toastMark = new ToastMark('', {\n            disallowedHtmlBlockTags: ['br', 'img'],\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            disallowDeepHeading: true,\n            frontMatter: frontMatter,\n            customParser: markdownParsers,\n        });\n        this.preview = new mdPreview(this.eventEmitter, tslib_es6_assign(tslib_es6_assign({}, rendererOptions), { isViewer: true }));\n        on_default()(this.preview.previewContent, 'mousedown', this.toggleTask.bind(this));\n        if (initialValue) {\n            this.setMarkdown(initialValue);\n        }\n        else if (existingHTML) {\n            this.preview.setHTML(existingHTML);\n        }\n        el.appendChild(this.preview.previewContent);\n        this.eventEmitter.emit('load', this);\n    }\n    /**\n     * Toggle task by detecting mousedown event.\n     * @param {MouseEvent} ev - event\n     * @private\n     */\n    ToastUIEditorViewer.prototype.toggleTask = function (ev) {\n        var element = ev.target;\n        var style = getComputedStyle(element, ':before');\n        if (!element.hasAttribute(DISABLED_TASK_ATTR_NAME) &&\n            element.hasAttribute(TASK_ATTR_NAME) &&\n            isPositionInBox(style, ev.offsetX, ev.offsetY)) {\n            toggleClass(element, TASK_CHECKED_CLASS_NAME);\n            this.eventEmitter.emit('change', {\n                source: 'viewer',\n                date: ev,\n            });\n        }\n    };\n    /**\n     * Set content for preview\n     * @param {string} markdown Markdown text\n     */\n    ToastUIEditorViewer.prototype.setMarkdown = function (markdown) {\n        var lineTexts = this.toastMark.getLineTexts();\n        var length = lineTexts.length;\n        var lastLine = common_last(lineTexts);\n        var endSourcepos = [length, lastLine.length + 1];\n        var editResult = this.toastMark.editMarkdown([1, 1], endSourcepos, markdown || '');\n        this.eventEmitter.emit('updatePreview', editResult);\n    };\n    /**\n     * Bind eventHandler to event type\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorViewer.prototype.on = function (type, handler) {\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Unbind eventHandler from event type\n     * @param {string} type Event type\n     */\n    ToastUIEditorViewer.prototype.off = function (type) {\n        this.eventEmitter.removeEventHandler(type);\n    };\n    /**\n     * Add hook to TUIEditor event\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorViewer.prototype.addHook = function (type, handler) {\n        this.eventEmitter.removeEventHandler(type);\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Remove Viewer preview from document\n     */\n    ToastUIEditorViewer.prototype.destroy = function () {\n        off_default()(this.preview.el, 'mousedown', this.toggleTask.bind(this));\n        this.preview.destroy();\n        this.eventEmitter.emit('destroy');\n    };\n    /**\n     * Return true\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isViewer = function () {\n        return true;\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isMarkdownMode = function () {\n        return false;\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isWysiwygMode = function () {\n        return false;\n    };\n    return ToastUIEditorViewer;\n}());\n/* harmony default export */ var viewer = (ToastUIEditorViewer);\n\n;// CONCATENATED MODULE: ./src/indexViewer.ts\n\n\n/* harmony default export */ var indexViewer = (viewer);\n\n}();\n__nested_webpack_exports__ = __nested_webpack_exports__[\"default\"];\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2VkaXRvci9kaXN0L3RvYXN0dWktZWRpdG9yLXZpZXdlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBeUQ7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsMEZBQXdCLEdBQUcsbUJBQU8sQ0FBQyxrRkFBb0IsR0FBRyxtQkFBTyxDQUFDLGdGQUFtQixHQUFHLG1CQUFPLENBQUMsZ0ZBQW1CLEdBQUcsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDbkwsTUFBTSxFQUs4SjtBQUNwSyxDQUFDO0FBQ0QsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHLEtBQUk7QUFDUCxFQUFFLENBQUM7QUFDSCxDQUFDLHFCQUFxQjs7QUFFdEIscUNBQXFDLDBCQUEwQiwwQ0FBMEMsZ0JBQWdCLE9BQU8sb0JBQW9CLGVBQWUsT0FBTzs7QUFFMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5RkFBeUYsYUFBYTtBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLEVBQUUsaUJBQWlCLEVBQUUsTUFBTTtBQUN6RDtBQUNBLHNEQUFzRDtBQUN0RCwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1R0FBdUcscUJBQXFCLG1CQUFtQjs7QUFFL0ksdUNBQXVDLDBCQUEwQiwwQ0FBMEMsZ0JBQWdCLE9BQU8sb0JBQW9CLGVBQWUsT0FBTzs7QUFFNUs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDLGFBQWEsVUFBVTtBQUN2QixjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RDtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdC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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLHdEQUF3RCxhQUFhO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFIQUFxSCxpQ0FBaUM7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxlQUFlLEVBQUU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEVBQUUsZ0NBQWdDLEtBQUssNkNBQTZDLEtBQUs7QUFDOUksMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDJDQUEyQztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxHQUFHLEdBQUcsR0FBRztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0JBQXdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMseUJBQXlCLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkNBQTJDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGdCQUFnQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsNEJBQTRCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFlBQVksWUFBWTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7Ozs7O0FBV0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSw0Q0FBNEMsd0NBQXdDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsNkRBQTZEO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0NBQW1CO0FBQ3BDLHNDQUFzQyxnQ0FBbUI7QUFDekQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELGtFQUFrRSxDQUFFO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYSxJQUFJLGFBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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c0IsZ0JBQWdCO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxDQUFDOzs7QUFHRDs7QUFFQSxDQUFDO0FBQ0QsMEJBQW1CLEdBQUcsMEJBQW1CO0FBQ3pDLGlCQUFpQiwwQkFBbUI7QUFDcEMsVUFBVTtBQUNWO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWNvbnRlbnQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9lZGl0b3IvZGlzdC90b2FzdHVpLWVkaXRvci12aWV3ZXIuanM/M2IzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEB0b2FzdC11aS9lZGl0b3JcbiAqIEB2ZXJzaW9uIDMuMi4yIHwgRnJpIEZlYiAxNyAyMDIzXG4gKiBAYXV0aG9yIE5ITiBDbG91ZCBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJwcm9zZW1pcnJvci1pbnB1dHJ1bGVzXCIpLCByZXF1aXJlKFwicHJvc2VtaXJyb3Ita2V5bWFwXCIpLCByZXF1aXJlKFwicHJvc2VtaXJyb3ItbW9kZWxcIiksIHJlcXVpcmUoXCJwcm9zZW1pcnJvci1zdGF0ZVwiKSwgcmVxdWlyZShcInByb3NlbWlycm9yLXZpZXdcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wicHJvc2VtaXJyb3ItaW5wdXRydWxlc1wiLCBcInByb3NlbWlycm9yLWtleW1hcFwiLCBcInByb3NlbWlycm9yLW1vZGVsXCIsIFwicHJvc2VtaXJyb3Itc3RhdGVcIiwgXCJwcm9zZW1pcnJvci12aWV3XCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInRvYXN0dWlcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJwcm9zZW1pcnJvci1pbnB1dHJ1bGVzXCIpLCByZXF1aXJlKFwicHJvc2VtaXJyb3Ita2V5bWFwXCIpLCByZXF1aXJlKFwicHJvc2VtaXJyb3ItbW9kZWxcIiksIHJlcXVpcmUoXCJwcm9zZW1pcnJvci1zdGF0ZVwiKSwgcmVxdWlyZShcInByb3NlbWlycm9yLXZpZXdcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInRvYXN0dWlcIl0gPSByb290W1widG9hc3R1aVwiXSB8fCB7fSwgcm9vdFtcInRvYXN0dWlcIl1bXCJFZGl0b3JcIl0gPSBmYWN0b3J5KHJvb3RbdW5kZWZpbmVkXSwgcm9vdFt1bmRlZmluZWRdLCByb290W3VuZGVmaW5lZF0sIHJvb3RbdW5kZWZpbmVkXSwgcm9vdFt1bmRlZmluZWRdKTtcbn0pKHNlbGYsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ3OV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180ODFfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDNfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fODE0X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzMxMV9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKCkgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gMzY4OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKiEgQGxpY2Vuc2UgRE9NUHVyaWZ5IDIuMy4zIHwgKGMpIEN1cmU1MyBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHwgUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBsaWNlbnNlIDIuMCBhbmQgTW96aWxsYSBQdWJsaWMgTGljZW5zZSAyLjAgfCBnaXRodWIuY29tL2N1cmU1My9ET01QdXJpZnkvYmxvYi8yLjMuMy9MSUNFTlNFICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0cnVlID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAwO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QuaGFzT3duUHJvcGVydHksXG4gICAgICBzZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZixcbiAgICAgIGlzRnJvemVuID0gT2JqZWN0LmlzRnJvemVuLFxuICAgICAgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICB2YXIgZnJlZXplID0gT2JqZWN0LmZyZWV6ZSxcbiAgICAgIHNlYWwgPSBPYmplY3Quc2VhbCxcbiAgICAgIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLW11dGFibGUtZXhwb3J0c1xuXG4gIHZhciBfcmVmID0gdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3QsXG4gICAgICBhcHBseSA9IF9yZWYuYXBwbHksXG4gICAgICBjb25zdHJ1Y3QgPSBfcmVmLmNvbnN0cnVjdDtcblxuICBpZiAoIWFwcGx5KSB7XG4gICAgYXBwbHkgPSBmdW5jdGlvbiBhcHBseShmdW4sIHRoaXNWYWx1ZSwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bi5hcHBseSh0aGlzVmFsdWUsIGFyZ3MpO1xuICAgIH07XG4gIH1cblxuICBpZiAoIWZyZWV6ZSkge1xuICAgIGZyZWV6ZSA9IGZ1bmN0aW9uIGZyZWV6ZSh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFzZWFsKSB7XG4gICAgc2VhbCA9IGZ1bmN0aW9uIHNlYWwoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghY29uc3RydWN0KSB7XG4gICAgY29uc3RydWN0ID0gZnVuY3Rpb24gY29uc3RydWN0KEZ1bmMsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KEZ1bmMsIFtudWxsXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKSkpKCk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBhcnJheUZvckVhY2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKTtcbiAgdmFyIGFycmF5UG9wID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUucG9wKTtcbiAgdmFyIGFycmF5UHVzaCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuXG4gIHZhciBzdHJpbmdUb0xvd2VyQ2FzZSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS50b0xvd2VyQ2FzZSk7XG4gIHZhciBzdHJpbmdNYXRjaCA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5tYXRjaCk7XG4gIHZhciBzdHJpbmdSZXBsYWNlID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xuICB2YXIgc3RyaW5nSW5kZXhPZiA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mKTtcbiAgdmFyIHN0cmluZ1RyaW0gPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudHJpbSk7XG5cbiAgdmFyIHJlZ0V4cFRlc3QgPSB1bmFwcGx5KFJlZ0V4cC5wcm90b3R5cGUudGVzdCk7XG5cbiAgdmFyIHR5cGVFcnJvckNyZWF0ZSA9IHVuY29uc3RydWN0KFR5cGVFcnJvcik7XG5cbiAgZnVuY3Rpb24gdW5hcHBseShmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0aGlzQXJnKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdW5jb25zdHJ1Y3QoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb25zdHJ1Y3QoZnVuYywgYXJncyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qIEFkZCBwcm9wZXJ0aWVzIHRvIGEgbG9va3VwIHRhYmxlICovXG4gIGZ1bmN0aW9uIGFkZFRvU2V0KHNldCwgYXJyYXkpIHtcbiAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIC8vIE1ha2UgJ2luJyBhbmQgdHJ1dGh5IGNoZWNrcyBsaWtlIEJvb2xlYW4oc2V0LmNvbnN0cnVjdG9yKVxuICAgICAgLy8gaW5kZXBlbmRlbnQgb2YgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiBPYmplY3QucHJvdG90eXBlLlxuICAgICAgLy8gUHJldmVudCBwcm90b3R5cGUgc2V0dGVycyBmcm9tIGludGVyY2VwdGluZyBzZXQgYXMgYSB0aGlzIHZhbHVlLlxuICAgICAgc2V0UHJvdG90eXBlT2Yoc2V0LCBudWxsKTtcbiAgICB9XG5cbiAgICB2YXIgbCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobC0tKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGFycmF5W2xdO1xuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgbGNFbGVtZW50ID0gc3RyaW5nVG9Mb3dlckNhc2UoZWxlbWVudCk7XG4gICAgICAgIGlmIChsY0VsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBDb25maWcgcHJlc2V0cyAoZS5nLiB0YWdzLmpzLCBhdHRycy5qcykgYXJlIGltbXV0YWJsZS5cbiAgICAgICAgICBpZiAoIWlzRnJvemVuKGFycmF5KSkge1xuICAgICAgICAgICAgYXJyYXlbbF0gPSBsY0VsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudCA9IGxjRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXRbZWxlbWVudF0gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBzZXQ7XG4gIH1cblxuICAvKiBTaGFsbG93IGNsb25lIGFuIG9iamVjdCAqL1xuICBmdW5jdGlvbiBjbG9uZShvYmplY3QpIHtcbiAgICB2YXIgbmV3T2JqZWN0ID0gY3JlYXRlKG51bGwpO1xuXG4gICAgdmFyIHByb3BlcnR5ID0gdm9pZCAwO1xuICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAoYXBwbHkoaGFzT3duUHJvcGVydHksIG9iamVjdCwgW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgbmV3T2JqZWN0W3Byb3BlcnR5XSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld09iamVjdDtcbiAgfVxuXG4gIC8qIElFMTAgZG9lc24ndCBzdXBwb3J0IF9fbG9va3VwR2V0dGVyX18gc28gbGV0cydcbiAgICogc2ltdWxhdGUgaXQuIEl0IGFsc28gYXV0b21hdGljYWxseSBjaGVja3NcbiAgICogaWYgdGhlIHByb3AgaXMgZnVuY3Rpb24gb3IgZ2V0dGVyIGFuZCBiZWhhdmVzXG4gICAqIGFjY29yZGluZ2x5LiAqL1xuICBmdW5jdGlvbiBsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wKSB7XG4gICAgd2hpbGUgKG9iamVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRlc2MgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wKTtcbiAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICAgIHJldHVybiB1bmFwcGx5KGRlc2MuZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVzYy52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB1bmFwcGx5KGRlc2MudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmFsbGJhY2tWYWx1ZShlbGVtZW50KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2ZhbGxiYWNrIHZhbHVlIGZvcicsIGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbGxiYWNrVmFsdWU7XG4gIH1cblxuICB2YXIgaHRtbCA9IGZyZWV6ZShbJ2EnLCAnYWJicicsICdhY3JvbnltJywgJ2FkZHJlc3MnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2F1ZGlvJywgJ2InLCAnYmRpJywgJ2JkbycsICdiaWcnLCAnYmxpbmsnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYW52YXMnLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY2l0ZScsICdjb2RlJywgJ2NvbCcsICdjb2xncm91cCcsICdjb250ZW50JywgJ2RhdGEnLCAnZGF0YWxpc3QnLCAnZGQnLCAnZGVjb3JhdG9yJywgJ2RlbCcsICdkZXRhaWxzJywgJ2RmbicsICdkaWFsb2cnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbGVtZW50JywgJ2VtJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2ZvbnQnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaScsICdpbWcnLCAnaW5wdXQnLCAnaW5zJywgJ2tiZCcsICdsYWJlbCcsICdsZWdlbmQnLCAnbGknLCAnbWFpbicsICdtYXAnLCAnbWFyaycsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0ZXInLCAnbmF2JywgJ25vYnInLCAnb2wnLCAnb3B0Z3JvdXAnLCAnb3B0aW9uJywgJ291dHB1dCcsICdwJywgJ3BpY3R1cmUnLCAncHJlJywgJ3Byb2dyZXNzJywgJ3EnLCAncnAnLCAncnQnLCAncnVieScsICdzJywgJ3NhbXAnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc2hhZG93JywgJ3NtYWxsJywgJ3NvdXJjZScsICdzcGFjZXInLCAnc3BhbicsICdzdHJpa2UnLCAnc3Ryb25nJywgJ3N0eWxlJywgJ3N1YicsICdzdW1tYXJ5JywgJ3N1cCcsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aW1lJywgJ3RyJywgJ3RyYWNrJywgJ3R0JywgJ3UnLCAndWwnLCAndmFyJywgJ3ZpZGVvJywgJ3diciddKTtcblxuICAvLyBTVkdcbiAgdmFyIHN2ZyA9IGZyZWV6ZShbJ3N2ZycsICdhJywgJ2FsdGdseXBoJywgJ2FsdGdseXBoZGVmJywgJ2FsdGdseXBoaXRlbScsICdhbmltYXRlY29sb3InLCAnYW5pbWF0ZW1vdGlvbicsICdhbmltYXRldHJhbnNmb3JtJywgJ2NpcmNsZScsICdjbGlwcGF0aCcsICdkZWZzJywgJ2Rlc2MnLCAnZWxsaXBzZScsICdmaWx0ZXInLCAnZm9udCcsICdnJywgJ2dseXBoJywgJ2dseXBocmVmJywgJ2hrZXJuJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyZ3JhZGllbnQnLCAnbWFya2VyJywgJ21hc2snLCAnbWV0YWRhdGEnLCAnbXBhdGgnLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsZ3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3N0eWxlJywgJ3N3aXRjaCcsICdzeW1ib2wnLCAndGV4dCcsICd0ZXh0cGF0aCcsICd0aXRsZScsICd0cmVmJywgJ3RzcGFuJywgJ3ZpZXcnLCAndmtlcm4nXSk7XG5cbiAgdmFyIHN2Z0ZpbHRlcnMgPSBmcmVlemUoWydmZUJsZW5kJywgJ2ZlQ29sb3JNYXRyaXgnLCAnZmVDb21wb25lbnRUcmFuc2ZlcicsICdmZUNvbXBvc2l0ZScsICdmZUNvbnZvbHZlTWF0cml4JywgJ2ZlRGlmZnVzZUxpZ2h0aW5nJywgJ2ZlRGlzcGxhY2VtZW50TWFwJywgJ2ZlRGlzdGFudExpZ2h0JywgJ2ZlRmxvb2QnLCAnZmVGdW5jQScsICdmZUZ1bmNCJywgJ2ZlRnVuY0cnLCAnZmVGdW5jUicsICdmZUdhdXNzaWFuQmx1cicsICdmZU1lcmdlJywgJ2ZlTWVyZ2VOb2RlJywgJ2ZlTW9ycGhvbG9neScsICdmZU9mZnNldCcsICdmZVBvaW50TGlnaHQnLCAnZmVTcGVjdWxhckxpZ2h0aW5nJywgJ2ZlU3BvdExpZ2h0JywgJ2ZlVGlsZScsICdmZVR1cmJ1bGVuY2UnXSk7XG5cbiAgLy8gTGlzdCBvZiBTVkcgZWxlbWVudHMgdGhhdCBhcmUgZGlzYWxsb3dlZCBieSBkZWZhdWx0LlxuICAvLyBXZSBzdGlsbCBuZWVkIHRvIGtub3cgdGhlbSBzbyB0aGF0IHdlIGNhbiBkbyBuYW1lc3BhY2VcbiAgLy8gY2hlY2tzIHByb3Blcmx5IGluIGNhc2Ugb25lIHdhbnRzIHRvIGFkZCB0aGVtIHRvXG4gIC8vIGFsbG93LWxpc3QuXG4gIHZhciBzdmdEaXNhbGxvd2VkID0gZnJlZXplKFsnYW5pbWF0ZScsICdjb2xvci1wcm9maWxlJywgJ2N1cnNvcicsICdkaXNjYXJkJywgJ2ZlZHJvcHNoYWRvdycsICdmZWltYWdlJywgJ2ZvbnQtZmFjZScsICdmb250LWZhY2UtZm9ybWF0JywgJ2ZvbnQtZmFjZS1uYW1lJywgJ2ZvbnQtZmFjZS1zcmMnLCAnZm9udC1mYWNlLXVyaScsICdmb3JlaWdub2JqZWN0JywgJ2hhdGNoJywgJ2hhdGNocGF0aCcsICdtZXNoJywgJ21lc2hncmFkaWVudCcsICdtZXNocGF0Y2gnLCAnbWVzaHJvdycsICdtaXNzaW5nLWdseXBoJywgJ3NjcmlwdCcsICdzZXQnLCAnc29saWRjb2xvcicsICd1bmtub3duJywgJ3VzZSddKTtcblxuICB2YXIgbWF0aE1sID0gZnJlZXplKFsnbWF0aCcsICdtZW5jbG9zZScsICdtZXJyb3InLCAnbWZlbmNlZCcsICdtZnJhYycsICdtZ2x5cGgnLCAnbWknLCAnbWxhYmVsZWR0cicsICdtbXVsdGlzY3JpcHRzJywgJ21uJywgJ21vJywgJ21vdmVyJywgJ21wYWRkZWQnLCAnbXBoYW50b20nLCAnbXJvb3QnLCAnbXJvdycsICdtcycsICdtc3BhY2UnLCAnbXNxcnQnLCAnbXN0eWxlJywgJ21zdWInLCAnbXN1cCcsICdtc3Vic3VwJywgJ210YWJsZScsICdtdGQnLCAnbXRleHQnLCAnbXRyJywgJ211bmRlcicsICdtdW5kZXJvdmVyJ10pO1xuXG4gIC8vIFNpbWlsYXJseSB0byBTVkcsIHdlIHdhbnQgdG8ga25vdyBhbGwgTWF0aE1MIGVsZW1lbnRzLFxuICAvLyBldmVuIHRob3NlIHRoYXQgd2UgZGlzYWxsb3cgYnkgZGVmYXVsdC5cbiAgdmFyIG1hdGhNbERpc2FsbG93ZWQgPSBmcmVlemUoWydtYWN0aW9uJywgJ21hbGlnbmdyb3VwJywgJ21hbGlnbm1hcmsnLCAnbWxvbmdkaXYnLCAnbXNjYXJyaWVzJywgJ21zY2FycnknLCAnbXNncm91cCcsICdtc3RhY2snLCAnbXNsaW5lJywgJ21zcm93JywgJ3NlbWFudGljcycsICdhbm5vdGF0aW9uJywgJ2Fubm90YXRpb24teG1sJywgJ21wcmVzY3JpcHRzJywgJ25vbmUnXSk7XG5cbiAgdmFyIHRleHQgPSBmcmVlemUoWycjdGV4dCddKTtcblxuICB2YXIgaHRtbCQxID0gZnJlZXplKFsnYWNjZXB0JywgJ2FjdGlvbicsICdhbGlnbicsICdhbHQnLCAnYXV0b2NhcGl0YWxpemUnLCAnYXV0b2NvbXBsZXRlJywgJ2F1dG9waWN0dXJlaW5waWN0dXJlJywgJ2F1dG9wbGF5JywgJ2JhY2tncm91bmQnLCAnYmdjb2xvcicsICdib3JkZXInLCAnY2FwdHVyZScsICdjZWxscGFkZGluZycsICdjZWxsc3BhY2luZycsICdjaGVja2VkJywgJ2NpdGUnLCAnY2xhc3MnLCAnY2xlYXInLCAnY29sb3InLCAnY29scycsICdjb2xzcGFuJywgJ2NvbnRyb2xzJywgJ2NvbnRyb2xzbGlzdCcsICdjb29yZHMnLCAnY3Jvc3NvcmlnaW4nLCAnZGF0ZXRpbWUnLCAnZGVjb2RpbmcnLCAnZGVmYXVsdCcsICdkaXInLCAnZGlzYWJsZWQnLCAnZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmUnLCAnZGlzYWJsZXJlbW90ZXBsYXliYWNrJywgJ2Rvd25sb2FkJywgJ2RyYWdnYWJsZScsICdlbmN0eXBlJywgJ2VudGVya2V5aGludCcsICdmYWNlJywgJ2ZvcicsICdoZWFkZXJzJywgJ2hlaWdodCcsICdoaWRkZW4nLCAnaGlnaCcsICdocmVmJywgJ2hyZWZsYW5nJywgJ2lkJywgJ2lucHV0bW9kZScsICdpbnRlZ3JpdHknLCAnaXNtYXAnLCAna2luZCcsICdsYWJlbCcsICdsYW5nJywgJ2xpc3QnLCAnbG9hZGluZycsICdsb29wJywgJ2xvdycsICdtYXgnLCAnbWF4bGVuZ3RoJywgJ21lZGlhJywgJ21ldGhvZCcsICdtaW4nLCAnbWlubGVuZ3RoJywgJ211bHRpcGxlJywgJ211dGVkJywgJ25hbWUnLCAnbm9zaGFkZScsICdub3ZhbGlkYXRlJywgJ25vd3JhcCcsICdvcGVuJywgJ29wdGltdW0nLCAncGF0dGVybicsICdwbGFjZWhvbGRlcicsICdwbGF5c2lubGluZScsICdwb3N0ZXInLCAncHJlbG9hZCcsICdwdWJkYXRlJywgJ3JhZGlvZ3JvdXAnLCAncmVhZG9ubHknLCAncmVsJywgJ3JlcXVpcmVkJywgJ3JldicsICdyZXZlcnNlZCcsICdyb2xlJywgJ3Jvd3MnLCAncm93c3BhbicsICdzcGVsbGNoZWNrJywgJ3Njb3BlJywgJ3NlbGVjdGVkJywgJ3NoYXBlJywgJ3NpemUnLCAnc2l6ZXMnLCAnc3BhbicsICdzcmNsYW5nJywgJ3N0YXJ0JywgJ3NyYycsICdzcmNzZXQnLCAnc3RlcCcsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmluZGV4JywgJ3RpdGxlJywgJ3RyYW5zbGF0ZScsICd0eXBlJywgJ3VzZW1hcCcsICd2YWxpZ24nLCAndmFsdWUnLCAnd2lkdGgnLCAneG1sbnMnLCAnc2xvdCddKTtcblxuICB2YXIgc3ZnJDEgPSBmcmVlemUoWydhY2NlbnQtaGVpZ2h0JywgJ2FjY3VtdWxhdGUnLCAnYWRkaXRpdmUnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FzY2VudCcsICdhdHRyaWJ1dGVuYW1lJywgJ2F0dHJpYnV0ZXR5cGUnLCAnYXppbXV0aCcsICdiYXNlZnJlcXVlbmN5JywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2JlZ2luJywgJ2JpYXMnLCAnYnknLCAnY2xhc3MnLCAnY2xpcCcsICdjbGlwcGF0aHVuaXRzJywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3InLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnY3gnLCAnY3knLCAnZCcsICdkeCcsICdkeScsICdkaWZmdXNlY29uc3RhbnQnLCAnZGlyZWN0aW9uJywgJ2Rpc3BsYXknLCAnZGl2aXNvcicsICdkdXInLCAnZWRnZW1vZGUnLCAnZWxldmF0aW9uJywgJ2VuZCcsICdmaWxsJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmlsdGVyJywgJ2ZpbHRlcnVuaXRzJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2Z4JywgJ2Z5JywgJ2cxJywgJ2cyJywgJ2dseXBoLW5hbWUnLCAnZ2x5cGhyZWYnLCAnZ3JhZGllbnR1bml0cycsICdncmFkaWVudHRyYW5zZm9ybScsICdoZWlnaHQnLCAnaHJlZicsICdpZCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnaW4nLCAnaW4yJywgJ2snLCAnazEnLCAnazInLCAnazMnLCAnazQnLCAna2VybmluZycsICdrZXlwb2ludHMnLCAna2V5c3BsaW5lcycsICdrZXl0aW1lcycsICdsYW5nJywgJ2xlbmd0aGFkanVzdCcsICdsZXR0ZXItc3BhY2luZycsICdrZXJuZWxtYXRyaXgnLCAna2VybmVsdW5pdGxlbmd0aCcsICdsaWdodGluZy1jb2xvcicsICdsb2NhbCcsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ21hcmtlcmhlaWdodCcsICdtYXJrZXJ1bml0cycsICdtYXJrZXJ3aWR0aCcsICdtYXNrY29udGVudHVuaXRzJywgJ21hc2t1bml0cycsICdtYXgnLCAnbWFzaycsICdtZWRpYScsICdtZXRob2QnLCAnbW9kZScsICdtaW4nLCAnbmFtZScsICdudW1vY3RhdmVzJywgJ29mZnNldCcsICdvcGVyYXRvcicsICdvcGFjaXR5JywgJ29yZGVyJywgJ29yaWVudCcsICdvcmllbnRhdGlvbicsICdvcmlnaW4nLCAnb3ZlcmZsb3cnLCAncGFpbnQtb3JkZXInLCAncGF0aCcsICdwYXRobGVuZ3RoJywgJ3BhdHRlcm5jb250ZW50dW5pdHMnLCAncGF0dGVybnRyYW5zZm9ybScsICdwYXR0ZXJudW5pdHMnLCAncG9pbnRzJywgJ3ByZXNlcnZlYWxwaGEnLCAncHJlc2VydmVhc3BlY3RyYXRpbycsICdwcmltaXRpdmV1bml0cycsICdyJywgJ3J4JywgJ3J5JywgJ3JhZGl1cycsICdyZWZ4JywgJ3JlZnknLCAncmVwZWF0Y291bnQnLCAncmVwZWF0ZHVyJywgJ3Jlc3RhcnQnLCAncmVzdWx0JywgJ3JvdGF0ZScsICdzY2FsZScsICdzZWVkJywgJ3NoYXBlLXJlbmRlcmluZycsICdzcGVjdWxhcmNvbnN0YW50JywgJ3NwZWN1bGFyZXhwb25lbnQnLCAnc3ByZWFkbWV0aG9kJywgJ3N0YXJ0b2Zmc2V0JywgJ3N0ZGRldmlhdGlvbicsICdzdGl0Y2h0aWxlcycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2UnLCAnc3Ryb2tlLXdpZHRoJywgJ3N0eWxlJywgJ3N1cmZhY2VzY2FsZScsICdzeXN0ZW1sYW5ndWFnZScsICd0YWJpbmRleCcsICd0YXJnZXR4JywgJ3RhcmdldHknLCAndHJhbnNmb3JtJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd0ZXh0bGVuZ3RoJywgJ3R5cGUnLCAndTEnLCAndTInLCAndW5pY29kZScsICd2YWx1ZXMnLCAndmlld2JveCcsICd2aXNpYmlsaXR5JywgJ3ZlcnNpb24nLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd2lkdGgnLCAnd29yZC1zcGFjaW5nJywgJ3dyYXAnLCAnd3JpdGluZy1tb2RlJywgJ3hjaGFubmVsc2VsZWN0b3InLCAneWNoYW5uZWxzZWxlY3RvcicsICd4JywgJ3gxJywgJ3gyJywgJ3htbG5zJywgJ3knLCAneTEnLCAneTInLCAneicsICd6b29tYW5kcGFuJ10pO1xuXG4gIHZhciBtYXRoTWwkMSA9IGZyZWV6ZShbJ2FjY2VudCcsICdhY2NlbnR1bmRlcicsICdhbGlnbicsICdiZXZlbGxlZCcsICdjbG9zZScsICdjb2x1bW5zYWxpZ24nLCAnY29sdW1ubGluZXMnLCAnY29sdW1uc3BhbicsICdkZW5vbWFsaWduJywgJ2RlcHRoJywgJ2RpcicsICdkaXNwbGF5JywgJ2Rpc3BsYXlzdHlsZScsICdlbmNvZGluZycsICdmZW5jZScsICdmcmFtZScsICdoZWlnaHQnLCAnaHJlZicsICdpZCcsICdsYXJnZW9wJywgJ2xlbmd0aCcsICdsaW5ldGhpY2tuZXNzJywgJ2xzcGFjZScsICdscXVvdGUnLCAnbWF0aGJhY2tncm91bmQnLCAnbWF0aGNvbG9yJywgJ21hdGhzaXplJywgJ21hdGh2YXJpYW50JywgJ21heHNpemUnLCAnbWluc2l6ZScsICdtb3ZhYmxlbGltaXRzJywgJ25vdGF0aW9uJywgJ251bWFsaWduJywgJ29wZW4nLCAncm93YWxpZ24nLCAncm93bGluZXMnLCAncm93c3BhY2luZycsICdyb3dzcGFuJywgJ3JzcGFjZScsICdycXVvdGUnLCAnc2NyaXB0bGV2ZWwnLCAnc2NyaXB0bWluc2l6ZScsICdzY3JpcHRzaXplbXVsdGlwbGllcicsICdzZWxlY3Rpb24nLCAnc2VwYXJhdG9yJywgJ3NlcGFyYXRvcnMnLCAnc3RyZXRjaHknLCAnc3Vic2NyaXB0c2hpZnQnLCAnc3Vwc2NyaXB0c2hpZnQnLCAnc3ltbWV0cmljJywgJ3ZvZmZzZXQnLCAnd2lkdGgnLCAneG1sbnMnXSk7XG5cbiAgdmFyIHhtbCA9IGZyZWV6ZShbJ3hsaW5rOmhyZWYnLCAneG1sOmlkJywgJ3hsaW5rOnRpdGxlJywgJ3htbDpzcGFjZScsICd4bWxuczp4bGluayddKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9iZXR0ZXItcmVnZXhcbiAgdmFyIE1VU1RBQ0hFX0VYUFIgPSBzZWFsKC9cXHtcXHtbXFxzXFxTXSp8W1xcc1xcU10qXFx9XFx9L2dtKTsgLy8gU3BlY2lmeSB0ZW1wbGF0ZSBkZXRlY3Rpb24gcmVnZXggZm9yIFNBRkVfRk9SX1RFTVBMQVRFUyBtb2RlXG4gIHZhciBFUkJfRVhQUiA9IHNlYWwoLzwlW1xcc1xcU10qfFtcXHNcXFNdKiU+L2dtKTtcbiAgdmFyIERBVEFfQVRUUiA9IHNlYWwoL15kYXRhLVtcXC1cXHcuXFx1MDBCNy1cXHVGRkZGXS8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gIHZhciBBUklBX0FUVFIgPSBzZWFsKC9eYXJpYS1bXFwtXFx3XSskLyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgdmFyIElTX0FMTE9XRURfVVJJID0gc2VhbCgvXig/Oig/Oig/OmZ8aHQpdHBzP3xtYWlsdG98dGVsfGNhbGx0b3xjaWR8eG1wcCk6fFteYS16XXxbYS16Ky5cXC1dKyg/OlteYS16Ky5cXC06XXwkKSkvaSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICk7XG4gIHZhciBJU19TQ1JJUFRfT1JfREFUQSA9IHNlYWwoL14oPzpcXHcrc2NyaXB0fGRhdGEpOi9pKTtcbiAgdmFyIEFUVFJfV0hJVEVTUEFDRSA9IHNlYWwoL1tcXHUwMDAwLVxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMjlcXHUyMDVGXFx1MzAwMF0vZyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgKTtcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5JDEoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuICB2YXIgZ2V0R2xvYmFsID0gZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuby1vcCBwb2xpY3kgZm9yIGludGVybmFsIHVzZSBvbmx5LlxuICAgKiBEb24ndCBleHBvcnQgdGhpcyBmdW5jdGlvbiBvdXRzaWRlIHRoaXMgbW9kdWxlIVxuICAgKiBAcGFyYW0gez9UcnVzdGVkVHlwZVBvbGljeUZhY3Rvcnl9IHRydXN0ZWRUeXBlcyBUaGUgcG9saWN5IGZhY3RvcnkuXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY3VtZW50IFRoZSBkb2N1bWVudCBvYmplY3QgKHRvIGRldGVybWluZSBwb2xpY3kgbmFtZSBzdWZmaXgpXG4gICAqIEByZXR1cm4gez9UcnVzdGVkVHlwZVBvbGljeX0gVGhlIHBvbGljeSBjcmVhdGVkIChvciBudWxsLCBpZiBUcnVzdGVkIFR5cGVzXG4gICAqIGFyZSBub3Qgc3VwcG9ydGVkKS5cbiAgICovXG4gIHZhciBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5ID0gZnVuY3Rpb24gX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSh0cnVzdGVkVHlwZXMsIGRvY3VtZW50KSB7XG4gICAgaWYgKCh0eXBlb2YgdHJ1c3RlZFR5cGVzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0cnVzdGVkVHlwZXMpKSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEFsbG93IHRoZSBjYWxsZXJzIHRvIGNvbnRyb2wgdGhlIHVuaXF1ZSBwb2xpY3kgbmFtZVxuICAgIC8vIGJ5IGFkZGluZyBhIGRhdGEtdHQtcG9saWN5LXN1ZmZpeCB0byB0aGUgc2NyaXB0IGVsZW1lbnQgd2l0aCB0aGUgRE9NUHVyaWZ5LlxuICAgIC8vIFBvbGljeSBjcmVhdGlvbiB3aXRoIGR1cGxpY2F0ZSBuYW1lcyB0aHJvd3MgaW4gVHJ1c3RlZCBUeXBlcy5cbiAgICB2YXIgc3VmZml4ID0gbnVsbDtcbiAgICB2YXIgQVRUUl9OQU1FID0gJ2RhdGEtdHQtcG9saWN5LXN1ZmZpeCc7XG4gICAgaWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdC5oYXNBdHRyaWJ1dGUoQVRUUl9OQU1FKSkge1xuICAgICAgc3VmZml4ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKTtcbiAgICB9XG5cbiAgICB2YXIgcG9saWN5TmFtZSA9ICdkb21wdXJpZnknICsgKHN1ZmZpeCA/ICcjJyArIHN1ZmZpeCA6ICcnKTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShwb2xpY3lOYW1lLCB7XG4gICAgICAgIGNyZWF0ZUhUTUw6IGZ1bmN0aW9uIGNyZWF0ZUhUTUwoaHRtbCQkMSkge1xuICAgICAgICAgIHJldHVybiBodG1sJCQxO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAvLyBQb2xpY3kgY3JlYXRpb24gZmFpbGVkIChtb3N0IGxpa2VseSBhbm90aGVyIERPTVB1cmlmeSBzY3JpcHQgaGFzXG4gICAgICAvLyBhbHJlYWR5IHJ1bikuIFNraXAgY3JlYXRpbmcgdGhlIHBvbGljeSwgYXMgdGhpcyB3aWxsIG9ubHkgY2F1c2UgZXJyb3JzXG4gICAgICAvLyBpZiBUVCBhcmUgZW5mb3JjZWQuXG4gICAgICBjb25zb2xlLndhcm4oJ1RydXN0ZWRUeXBlcyBwb2xpY3kgJyArIHBvbGljeU5hbWUgKyAnIGNvdWxkIG5vdCBiZSBjcmVhdGVkLicpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZURPTVB1cmlmeSgpIHtcbiAgICB2YXIgd2luZG93ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBnZXRHbG9iYWwoKTtcblxuICAgIHZhciBET01QdXJpZnkgPSBmdW5jdGlvbiBET01QdXJpZnkocm9vdCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZURPTVB1cmlmeShyb290KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyc2lvbiBsYWJlbCwgZXhwb3NlZCBmb3IgZWFzaWVyIGNoZWNrc1xuICAgICAqIGlmIERPTVB1cmlmeSBpcyB1cCB0byBkYXRlIG9yIG5vdFxuICAgICAqL1xuICAgIERPTVB1cmlmeS52ZXJzaW9uID0gJzIuMy4zJztcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgRE9NUHVyaWZ5IHJlbW92ZWQgZHVyaW5nIHNhbml0YXRpb24uXG4gICAgICogRW1wdHkgaWYgbm90aGluZyB3YXMgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBET01QdXJpZnkucmVtb3ZlZCA9IFtdO1xuXG4gICAgaWYgKCF3aW5kb3cgfHwgIXdpbmRvdy5kb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQubm9kZVR5cGUgIT09IDkpIHtcbiAgICAgIC8vIE5vdCBydW5uaW5nIGluIGEgYnJvd3NlciwgcHJvdmlkZSBhIGZhY3RvcnkgZnVuY3Rpb25cbiAgICAgIC8vIHNvIHRoYXQgeW91IGNhbiBwYXNzIHlvdXIgb3duIFdpbmRvd1xuICAgICAgRE9NUHVyaWZ5LmlzU3VwcG9ydGVkID0gZmFsc2U7XG5cbiAgICAgIHJldHVybiBET01QdXJpZnk7XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbmFsRG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbiAgICB2YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgdmFyIERvY3VtZW50RnJhZ21lbnQgPSB3aW5kb3cuRG9jdW1lbnRGcmFnbWVudCxcbiAgICAgICAgSFRNTFRlbXBsYXRlRWxlbWVudCA9IHdpbmRvdy5IVE1MVGVtcGxhdGVFbGVtZW50LFxuICAgICAgICBOb2RlID0gd2luZG93Lk5vZGUsXG4gICAgICAgIEVsZW1lbnQgPSB3aW5kb3cuRWxlbWVudCxcbiAgICAgICAgTm9kZUZpbHRlciA9IHdpbmRvdy5Ob2RlRmlsdGVyLFxuICAgICAgICBfd2luZG93JE5hbWVkTm9kZU1hcCA9IHdpbmRvdy5OYW1lZE5vZGVNYXAsXG4gICAgICAgIE5hbWVkTm9kZU1hcCA9IF93aW5kb3ckTmFtZWROb2RlTWFwID09PSB1bmRlZmluZWQgPyB3aW5kb3cuTmFtZWROb2RlTWFwIHx8IHdpbmRvdy5Nb3pOYW1lZEF0dHJNYXAgOiBfd2luZG93JE5hbWVkTm9kZU1hcCxcbiAgICAgICAgVGV4dCA9IHdpbmRvdy5UZXh0LFxuICAgICAgICBDb21tZW50ID0gd2luZG93LkNvbW1lbnQsXG4gICAgICAgIERPTVBhcnNlciA9IHdpbmRvdy5ET01QYXJzZXIsXG4gICAgICAgIHRydXN0ZWRUeXBlcyA9IHdpbmRvdy50cnVzdGVkVHlwZXM7XG5cblxuICAgIHZhciBFbGVtZW50UHJvdG90eXBlID0gRWxlbWVudC5wcm90b3R5cGU7XG5cbiAgICB2YXIgY2xvbmVOb2RlID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdjbG9uZU5vZGUnKTtcbiAgICB2YXIgZ2V0TmV4dFNpYmxpbmcgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ25leHRTaWJsaW5nJyk7XG4gICAgdmFyIGdldENoaWxkTm9kZXMgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ2NoaWxkTm9kZXMnKTtcbiAgICB2YXIgZ2V0UGFyZW50Tm9kZSA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAncGFyZW50Tm9kZScpO1xuXG4gICAgLy8gQXMgcGVyIGlzc3VlICM0NywgdGhlIHdlYi1jb21wb25lbnRzIHJlZ2lzdHJ5IGlzIGluaGVyaXRlZCBieSBhXG4gICAgLy8gbmV3IGRvY3VtZW50IGNyZWF0ZWQgdmlhIGNyZWF0ZUhUTUxEb2N1bWVudC4gQXMgcGVyIHRoZSBzcGVjXG4gICAgLy8gKGh0dHA6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2NyZWF0aW5nLWFuZC1wYXNzaW5nLXJlZ2lzdHJpZXMpXG4gICAgLy8gYSBuZXcgZW1wdHkgcmVnaXN0cnkgaXMgdXNlZCB3aGVuIGNyZWF0aW5nIGEgdGVtcGxhdGUgY29udGVudHMgb3duZXJcbiAgICAvLyBkb2N1bWVudCwgc28gd2UgdXNlIHRoYXQgYXMgb3VyIHBhcmVudCBkb2N1bWVudCB0byBlbnN1cmUgbm90aGluZ1xuICAgIC8vIGlzIGluaGVyaXRlZC5cbiAgICBpZiAodHlwZW9mIEhUTUxUZW1wbGF0ZUVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICBpZiAodGVtcGxhdGUuY29udGVudCAmJiB0ZW1wbGF0ZS5jb250ZW50Lm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgZG9jdW1lbnQgPSB0ZW1wbGF0ZS5jb250ZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRydXN0ZWRUeXBlc1BvbGljeSA9IF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kodHJ1c3RlZFR5cGVzLCBvcmlnaW5hbERvY3VtZW50KTtcbiAgICB2YXIgZW1wdHlIVE1MID0gdHJ1c3RlZFR5cGVzUG9saWN5ICYmIFJFVFVSTl9UUlVTVEVEX1RZUEUgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTCgnJykgOiAnJztcblxuICAgIHZhciBfZG9jdW1lbnQgPSBkb2N1bWVudCxcbiAgICAgICAgaW1wbGVtZW50YXRpb24gPSBfZG9jdW1lbnQuaW1wbGVtZW50YXRpb24sXG4gICAgICAgIGNyZWF0ZU5vZGVJdGVyYXRvciA9IF9kb2N1bWVudC5jcmVhdGVOb2RlSXRlcmF0b3IsXG4gICAgICAgIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSBfZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCxcbiAgICAgICAgZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBfZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWU7XG4gICAgdmFyIGltcG9ydE5vZGUgPSBvcmlnaW5hbERvY3VtZW50LmltcG9ydE5vZGU7XG5cblxuICAgIHZhciBkb2N1bWVudE1vZGUgPSB7fTtcbiAgICB0cnkge1xuICAgICAgZG9jdW1lbnRNb2RlID0gY2xvbmUoZG9jdW1lbnQpLmRvY3VtZW50TW9kZSA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IHt9O1xuICAgIH0gY2F0Y2ggKF8pIHt9XG5cbiAgICB2YXIgaG9va3MgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEV4cG9zZSB3aGV0aGVyIHRoaXMgYnJvd3NlciBzdXBwb3J0cyBydW5uaW5nIHRoZSBmdWxsIERPTVB1cmlmeS5cbiAgICAgKi9cbiAgICBET01QdXJpZnkuaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZ2V0UGFyZW50Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbXBsZW1lbnRhdGlvbiAmJiB0eXBlb2YgaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudE1vZGUgIT09IDk7XG5cbiAgICB2YXIgTVVTVEFDSEVfRVhQUiQkMSA9IE1VU1RBQ0hFX0VYUFIsXG4gICAgICAgIEVSQl9FWFBSJCQxID0gRVJCX0VYUFIsXG4gICAgICAgIERBVEFfQVRUUiQkMSA9IERBVEFfQVRUUixcbiAgICAgICAgQVJJQV9BVFRSJCQxID0gQVJJQV9BVFRSLFxuICAgICAgICBJU19TQ1JJUFRfT1JfREFUQSQkMSA9IElTX1NDUklQVF9PUl9EQVRBLFxuICAgICAgICBBVFRSX1dISVRFU1BBQ0UkJDEgPSBBVFRSX1dISVRFU1BBQ0U7XG4gICAgdmFyIElTX0FMTE9XRURfVVJJJCQxID0gSVNfQUxMT1dFRF9VUkk7XG5cbiAgICAvKipcbiAgICAgKiBXZSBjb25zaWRlciB0aGUgZWxlbWVudHMgYW5kIGF0dHJpYnV0ZXMgYmVsb3cgdG8gYmUgc2FmZS4gSWRlYWxseVxuICAgICAqIGRvbid0IGFkZCBhbnkgbmV3IG9uZXMgYnV0IGZlZWwgZnJlZSB0byByZW1vdmUgdW53YW50ZWQgb25lcy5cbiAgICAgKi9cblxuICAgIC8qIGFsbG93ZWQgZWxlbWVudCBuYW1lcyAqL1xuXG4gICAgdmFyIEFMTE9XRURfVEFHUyA9IG51bGw7XG4gICAgdmFyIERFRkFVTFRfQUxMT1dFRF9UQUdTID0gYWRkVG9TZXQoe30sIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkkMShodG1sKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEoc3ZnKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEoc3ZnRmlsdGVycyksIF90b0NvbnN1bWFibGVBcnJheSQxKG1hdGhNbCksIF90b0NvbnN1bWFibGVBcnJheSQxKHRleHQpKSk7XG5cbiAgICAvKiBBbGxvd2VkIGF0dHJpYnV0ZSBuYW1lcyAqL1xuICAgIHZhciBBTExPV0VEX0FUVFIgPSBudWxsO1xuICAgIHZhciBERUZBVUxUX0FMTE9XRURfQVRUUiA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5JDEoaHRtbCQxKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEoc3ZnJDEpLCBfdG9Db25zdW1hYmxlQXJyYXkkMShtYXRoTWwkMSksIF90b0NvbnN1bWFibGVBcnJheSQxKHhtbCkpKTtcblxuICAgIC8qIEV4cGxpY2l0bHkgZm9yYmlkZGVuIHRhZ3MgKG92ZXJyaWRlcyBBTExPV0VEX1RBR1MvQUREX1RBR1MpICovXG4gICAgdmFyIEZPUkJJRF9UQUdTID0gbnVsbDtcblxuICAgIC8qIEV4cGxpY2l0bHkgZm9yYmlkZGVuIGF0dHJpYnV0ZXMgKG92ZXJyaWRlcyBBTExPV0VEX0FUVFIvQUREX0FUVFIpICovXG4gICAgdmFyIEZPUkJJRF9BVFRSID0gbnVsbDtcblxuICAgIC8qIERlY2lkZSBpZiBBUklBIGF0dHJpYnV0ZXMgYXJlIG9rYXkgKi9cbiAgICB2YXIgQUxMT1dfQVJJQV9BVFRSID0gdHJ1ZTtcblxuICAgIC8qIERlY2lkZSBpZiBjdXN0b20gZGF0YSBhdHRyaWJ1dGVzIGFyZSBva2F5ICovXG4gICAgdmFyIEFMTE9XX0RBVEFfQVRUUiA9IHRydWU7XG5cbiAgICAvKiBEZWNpZGUgaWYgdW5rbm93biBwcm90b2NvbHMgYXJlIG9rYXkgKi9cbiAgICB2YXIgQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgPSBmYWxzZTtcblxuICAgIC8qIE91dHB1dCBzaG91bGQgYmUgc2FmZSBmb3IgY29tbW9uIHRlbXBsYXRlIGVuZ2luZXMuXG4gICAgICogVGhpcyBtZWFucywgRE9NUHVyaWZ5IHJlbW92ZXMgZGF0YSBhdHRyaWJ1dGVzLCBtdXN0YWNoZXMgYW5kIEVSQlxuICAgICAqL1xuICAgIHZhciBTQUZFX0ZPUl9URU1QTEFURVMgPSBmYWxzZTtcblxuICAgIC8qIERlY2lkZSBpZiBkb2N1bWVudCB3aXRoIDxodG1sPi4uLiBzaG91bGQgYmUgcmV0dXJuZWQgKi9cbiAgICB2YXIgV0hPTEVfRE9DVU1FTlQgPSBmYWxzZTtcblxuICAgIC8qIFRyYWNrIHdoZXRoZXIgY29uZmlnIGlzIGFscmVhZHkgc2V0IG9uIHRoaXMgaW5zdGFuY2Ugb2YgRE9NUHVyaWZ5LiAqL1xuICAgIHZhciBTRVRfQ09ORklHID0gZmFsc2U7XG5cbiAgICAvKiBEZWNpZGUgaWYgYWxsIGVsZW1lbnRzIChlLmcuIHN0eWxlLCBzY3JpcHQpIG11c3QgYmUgY2hpbGRyZW4gb2ZcbiAgICAgKiBkb2N1bWVudC5ib2R5LiBCeSBkZWZhdWx0LCBicm93c2VycyBtaWdodCBtb3ZlIHRoZW0gdG8gZG9jdW1lbnQuaGVhZCAqL1xuICAgIHZhciBGT1JDRV9CT0RZID0gZmFsc2U7XG5cbiAgICAvKiBEZWNpZGUgaWYgYSBET00gYEhUTUxCb2R5RWxlbWVudGAgc2hvdWxkIGJlIHJldHVybmVkLCBpbnN0ZWFkIG9mIGEgaHRtbFxuICAgICAqIHN0cmluZyAob3IgYSBUcnVzdGVkSFRNTCBvYmplY3QgaWYgVHJ1c3RlZCBUeXBlcyBhcmUgc3VwcG9ydGVkKS5cbiAgICAgKiBJZiBgV0hPTEVfRE9DVU1FTlRgIGlzIGVuYWJsZWQgYSBgSFRNTEh0bWxFbGVtZW50YCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWRcbiAgICAgKi9cbiAgICB2YXIgUkVUVVJOX0RPTSA9IGZhbHNlO1xuXG4gICAgLyogRGVjaWRlIGlmIGEgRE9NIGBEb2N1bWVudEZyYWdtZW50YCBzaG91bGQgYmUgcmV0dXJuZWQsIGluc3RlYWQgb2YgYSBodG1sXG4gICAgICogc3RyaW5nICAob3IgYSBUcnVzdGVkSFRNTCBvYmplY3QgaWYgVHJ1c3RlZCBUeXBlcyBhcmUgc3VwcG9ydGVkKSAqL1xuICAgIHZhciBSRVRVUk5fRE9NX0ZSQUdNRU5UID0gZmFsc2U7XG5cbiAgICAvKiBJZiBgUkVUVVJOX0RPTWAgb3IgYFJFVFVSTl9ET01fRlJBR01FTlRgIGlzIGVuYWJsZWQsIGRlY2lkZSBpZiB0aGUgcmV0dXJuZWQgRE9NXG4gICAgICogYE5vZGVgIGlzIGltcG9ydGVkIGludG8gdGhlIGN1cnJlbnQgYERvY3VtZW50YC4gSWYgdGhpcyBmbGFnIGlzIG5vdCBlbmFibGVkIHRoZVxuICAgICAqIGBOb2RlYCB3aWxsIGJlbG9uZyAoaXRzIG93bmVyRG9jdW1lbnQpIHRvIGEgZnJlc2ggYEhUTUxEb2N1bWVudGAsIGNyZWF0ZWQgYnlcbiAgICAgKiBET01QdXJpZnkuXG4gICAgICpcbiAgICAgKiBUaGlzIGRlZmF1bHRzIHRvIGB0cnVlYCBzdGFydGluZyBET01QdXJpZnkgMi4yLjAuIE5vdGUgdGhhdCBzZXR0aW5nIGl0IHRvIGBmYWxzZWBcbiAgICAgKiBtaWdodCBjYXVzZSBYU1MgZnJvbSBhdHRhY2tzIGhpZGRlbiBpbiBjbG9zZWQgc2hhZG93cm9vdHMgaW4gY2FzZSB0aGUgYnJvd3NlclxuICAgICAqIHN1cHBvcnRzIERlY2xhcmF0aXZlIFNoYWRvdzogRE9NIGh0dHBzOi8vd2ViLmRldi9kZWNsYXJhdGl2ZS1zaGFkb3ctZG9tL1xuICAgICAqL1xuICAgIHZhciBSRVRVUk5fRE9NX0lNUE9SVCA9IHRydWU7XG5cbiAgICAvKiBUcnkgdG8gcmV0dXJuIGEgVHJ1c3RlZCBUeXBlIG9iamVjdCBpbnN0ZWFkIG9mIGEgc3RyaW5nLCByZXR1cm4gYSBzdHJpbmcgaW5cbiAgICAgKiBjYXNlIFRydXN0ZWQgVHlwZXMgYXJlIG5vdCBzdXBwb3J0ZWQgICovXG4gICAgdmFyIFJFVFVSTl9UUlVTVEVEX1RZUEUgPSBmYWxzZTtcblxuICAgIC8qIE91dHB1dCBzaG91bGQgYmUgZnJlZSBmcm9tIERPTSBjbG9iYmVyaW5nIGF0dGFja3M/ICovXG4gICAgdmFyIFNBTklUSVpFX0RPTSA9IHRydWU7XG5cbiAgICAvKiBLZWVwIGVsZW1lbnQgY29udGVudCB3aGVuIHJlbW92aW5nIGVsZW1lbnQ/ICovXG4gICAgdmFyIEtFRVBfQ09OVEVOVCA9IHRydWU7XG5cbiAgICAvKiBJZiBhIGBOb2RlYCBpcyBwYXNzZWQgdG8gc2FuaXRpemUoKSwgdGhlbiBwZXJmb3JtcyBzYW5pdGl6YXRpb24gaW4tcGxhY2UgaW5zdGVhZFxuICAgICAqIG9mIGltcG9ydGluZyBpdCBpbnRvIGEgbmV3IERvY3VtZW50IGFuZCByZXR1cm5pbmcgYSBzYW5pdGl6ZWQgY29weSAqL1xuICAgIHZhciBJTl9QTEFDRSA9IGZhbHNlO1xuXG4gICAgLyogQWxsb3cgdXNhZ2Ugb2YgcHJvZmlsZXMgbGlrZSBodG1sLCBzdmcgYW5kIG1hdGhNbCAqL1xuICAgIHZhciBVU0VfUFJPRklMRVMgPSB7fTtcblxuICAgIC8qIFRhZ3MgdG8gaWdub3JlIGNvbnRlbnQgb2Ygd2hlbiBLRUVQX0NPTlRFTlQgaXMgdHJ1ZSAqL1xuICAgIHZhciBGT1JCSURfQ09OVEVOVFMgPSBudWxsO1xuICAgIHZhciBERUZBVUxUX0ZPUkJJRF9DT05URU5UUyA9IGFkZFRvU2V0KHt9LCBbJ2Fubm90YXRpb24teG1sJywgJ2F1ZGlvJywgJ2NvbGdyb3VwJywgJ2Rlc2MnLCAnZm9yZWlnbm9iamVjdCcsICdoZWFkJywgJ2lmcmFtZScsICdtYXRoJywgJ21pJywgJ21uJywgJ21vJywgJ21zJywgJ210ZXh0JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAncGxhaW50ZXh0JywgJ3NjcmlwdCcsICdzdHlsZScsICdzdmcnLCAndGVtcGxhdGUnLCAndGhlYWQnLCAndGl0bGUnLCAndmlkZW8nLCAneG1wJ10pO1xuXG4gICAgLyogVGFncyB0aGF0IGFyZSBzYWZlIGZvciBkYXRhOiBVUklzICovXG4gICAgdmFyIERBVEFfVVJJX1RBR1MgPSBudWxsO1xuICAgIHZhciBERUZBVUxUX0RBVEFfVVJJX1RBR1MgPSBhZGRUb1NldCh7fSwgWydhdWRpbycsICd2aWRlbycsICdpbWcnLCAnc291cmNlJywgJ2ltYWdlJywgJ3RyYWNrJ10pO1xuXG4gICAgLyogQXR0cmlidXRlcyBzYWZlIGZvciB2YWx1ZXMgbGlrZSBcImphdmFzY3JpcHQ6XCIgKi9cbiAgICB2YXIgVVJJX1NBRkVfQVRUUklCVVRFUyA9IG51bGw7XG4gICAgdmFyIERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUyA9IGFkZFRvU2V0KHt9LCBbJ2FsdCcsICdjbGFzcycsICdmb3InLCAnaWQnLCAnbGFiZWwnLCAnbmFtZScsICdwYXR0ZXJuJywgJ3BsYWNlaG9sZGVyJywgJ3JvbGUnLCAnc3VtbWFyeScsICd0aXRsZScsICd2YWx1ZScsICdzdHlsZScsICd4bWxucyddKTtcblxuICAgIHZhciBNQVRITUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xuICAgIHZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgICB2YXIgSFRNTF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG4gICAgLyogRG9jdW1lbnQgbmFtZXNwYWNlICovXG4gICAgdmFyIE5BTUVTUEFDRSA9IEhUTUxfTkFNRVNQQUNFO1xuICAgIHZhciBJU19FTVBUWV9JTlBVVCA9IGZhbHNlO1xuXG4gICAgLyogUGFyc2luZyBvZiBzdHJpY3QgWEhUTUwgZG9jdW1lbnRzICovXG4gICAgdmFyIFBBUlNFUl9NRURJQV9UWVBFID0gdm9pZCAwO1xuICAgIHZhciBTVVBQT1JURURfUEFSU0VSX01FRElBX1RZUEVTID0gWydhcHBsaWNhdGlvbi94aHRtbCt4bWwnLCAndGV4dC9odG1sJ107XG4gICAgdmFyIERFRkFVTFRfUEFSU0VSX01FRElBX1RZUEUgPSAndGV4dC9odG1sJztcbiAgICB2YXIgdHJhbnNmb3JtQ2FzZUZ1bmMgPSB2b2lkIDA7XG5cbiAgICAvKiBLZWVwIGEgcmVmZXJlbmNlIHRvIGNvbmZpZyB0byBwYXNzIHRvIGhvb2tzICovXG4gICAgdmFyIENPTkZJRyA9IG51bGw7XG5cbiAgICAvKiBJZGVhbGx5LCBkbyBub3QgdG91Y2ggYW55dGhpbmcgYmVsb3cgdGhpcyBsaW5lICovXG4gICAgLyogX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyAqL1xuXG4gICAgdmFyIGZvcm1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuXG4gICAgLyoqXG4gICAgICogX3BhcnNlQ29uZmlnXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGNmZyBvcHRpb25hbCBjb25maWcgbGl0ZXJhbFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgdmFyIF9wYXJzZUNvbmZpZyA9IGZ1bmN0aW9uIF9wYXJzZUNvbmZpZyhjZmcpIHtcbiAgICAgIGlmIChDT05GSUcgJiYgQ09ORklHID09PSBjZmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvKiBTaGllbGQgY29uZmlndXJhdGlvbiBvYmplY3QgZnJvbSB0YW1wZXJpbmcgKi9cbiAgICAgIGlmICghY2ZnIHx8ICh0eXBlb2YgY2ZnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjZmcpKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgY2ZnID0ge307XG4gICAgICB9XG5cbiAgICAgIC8qIFNoaWVsZCBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHByb3RvdHlwZSBwb2xsdXRpb24gKi9cbiAgICAgIGNmZyA9IGNsb25lKGNmZyk7XG5cbiAgICAgIC8qIFNldCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgKi9cbiAgICAgIEFMTE9XRURfVEFHUyA9ICdBTExPV0VEX1RBR1MnIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9UQUdTKSA6IERFRkFVTFRfQUxMT1dFRF9UQUdTO1xuICAgICAgQUxMT1dFRF9BVFRSID0gJ0FMTE9XRURfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5BTExPV0VEX0FUVFIpIDogREVGQVVMVF9BTExPV0VEX0FUVFI7XG4gICAgICBVUklfU0FGRV9BVFRSSUJVVEVTID0gJ0FERF9VUklfU0FGRV9BVFRSJyBpbiBjZmcgPyBhZGRUb1NldChjbG9uZShERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMpLCBjZmcuQUREX1VSSV9TQUZFX0FUVFIpIDogREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTO1xuICAgICAgREFUQV9VUklfVEFHUyA9ICdBRERfREFUQV9VUklfVEFHUycgaW4gY2ZnID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9EQVRBX1VSSV9UQUdTKSwgY2ZnLkFERF9EQVRBX1VSSV9UQUdTKSA6IERFRkFVTFRfREFUQV9VUklfVEFHUztcbiAgICAgIEZPUkJJRF9DT05URU5UUyA9ICdGT1JCSURfQ09OVEVOVFMnIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX0NPTlRFTlRTKSA6IERFRkFVTFRfRk9SQklEX0NPTlRFTlRTO1xuICAgICAgRk9SQklEX1RBR1MgPSAnRk9SQklEX1RBR1MnIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX1RBR1MpIDoge307XG4gICAgICBGT1JCSURfQVRUUiA9ICdGT1JCSURfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfQVRUUikgOiB7fTtcbiAgICAgIFVTRV9QUk9GSUxFUyA9ICdVU0VfUFJPRklMRVMnIGluIGNmZyA/IGNmZy5VU0VfUFJPRklMRVMgOiBmYWxzZTtcbiAgICAgIEFMTE9XX0FSSUFfQVRUUiA9IGNmZy5BTExPV19BUklBX0FUVFIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICAgIEFMTE9XX0RBVEFfQVRUUiA9IGNmZy5BTExPV19EQVRBX0FUVFIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICAgIEFMTE9XX1VOS05PV05fUFJPVE9DT0xTID0gY2ZnLkFMTE9XX1VOS05PV05fUFJPVE9DT0xTIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgICBTQUZFX0ZPUl9URU1QTEFURVMgPSBjZmcuU0FGRV9GT1JfVEVNUExBVEVTIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgICBXSE9MRV9ET0NVTUVOVCA9IGNmZy5XSE9MRV9ET0NVTUVOVCB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgICAgUkVUVVJOX0RPTSA9IGNmZy5SRVRVUk5fRE9NIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgICBSRVRVUk5fRE9NX0ZSQUdNRU5UID0gY2ZnLlJFVFVSTl9ET01fRlJBR01FTlQgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICAgIFJFVFVSTl9ET01fSU1QT1JUID0gY2ZnLlJFVFVSTl9ET01fSU1QT1JUICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgICBSRVRVUk5fVFJVU1RFRF9UWVBFID0gY2ZnLlJFVFVSTl9UUlVTVEVEX1RZUEUgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICAgIEZPUkNFX0JPRFkgPSBjZmcuRk9SQ0VfQk9EWSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgICAgU0FOSVRJWkVfRE9NID0gY2ZnLlNBTklUSVpFX0RPTSAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgICAgS0VFUF9DT05URU5UID0gY2ZnLktFRVBfQ09OVEVOVCAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgICAgSU5fUExBQ0UgPSBjZmcuSU5fUExBQ0UgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICAgIElTX0FMTE9XRURfVVJJJCQxID0gY2ZnLkFMTE9XRURfVVJJX1JFR0VYUCB8fCBJU19BTExPV0VEX1VSSSQkMTtcbiAgICAgIE5BTUVTUEFDRSA9IGNmZy5OQU1FU1BBQ0UgfHwgSFRNTF9OQU1FU1BBQ0U7XG5cbiAgICAgIFBBUlNFUl9NRURJQV9UWVBFID1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgICAgU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUy5pbmRleE9mKGNmZy5QQVJTRVJfTUVESUFfVFlQRSkgPT09IC0xID8gUEFSU0VSX01FRElBX1RZUEUgPSBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFIDogUEFSU0VSX01FRElBX1RZUEUgPSBjZmcuUEFSU0VSX01FRElBX1RZUEU7XG5cbiAgICAgIC8vIEhUTUwgdGFncyBhbmQgYXR0cmlidXRlcyBhcmUgbm90IGNhc2Utc2Vuc2l0aXZlLCBjb252ZXJ0aW5nIHRvIGxvd2VyY2FzZS4gS2VlcGluZyBYSFRNTCBhcyBpcy5cbiAgICAgIHRyYW5zZm9ybUNhc2VGdW5jID0gUEFSU0VSX01FRElBX1RZUEUgPT09ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9IDogc3RyaW5nVG9Mb3dlckNhc2U7XG5cbiAgICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgICAgQUxMT1dfREFUQV9BVFRSID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7XG4gICAgICAgIFJFVFVSTl9ET00gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBQYXJzZSBwcm9maWxlIGluZm8gKi9cbiAgICAgIGlmIChVU0VfUFJPRklMRVMpIHtcbiAgICAgICAgQUxMT1dFRF9UQUdTID0gYWRkVG9TZXQoe30sIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkkMSh0ZXh0KSkpO1xuICAgICAgICBBTExPV0VEX0FUVFIgPSBbXTtcbiAgICAgICAgaWYgKFVTRV9QUk9GSUxFUy5odG1sID09PSB0cnVlKSB7XG4gICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBodG1sKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIGh0bWwkMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVVNFX1BST0ZJTEVTLnN2ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgc3ZnKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHN2ZyQxKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVVNFX1BST0ZJTEVTLnN2Z0ZpbHRlcnMgPT09IHRydWUpIHtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2Z0ZpbHRlcnMpO1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgc3ZnJDEpO1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgeG1sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChVU0VfUFJPRklMRVMubWF0aE1sID09PSB0cnVlKSB7XG4gICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBtYXRoTWwpO1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgbWF0aE1sJDEpO1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgeG1sKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiBNZXJnZSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgKi9cbiAgICAgIGlmIChjZmcuQUREX1RBR1MpIHtcbiAgICAgICAgaWYgKEFMTE9XRURfVEFHUyA9PT0gREVGQVVMVF9BTExPV0VEX1RBR1MpIHtcbiAgICAgICAgICBBTExPV0VEX1RBR1MgPSBjbG9uZShBTExPV0VEX1RBR1MpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBjZmcuQUREX1RBR1MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ZnLkFERF9BVFRSKSB7XG4gICAgICAgIGlmIChBTExPV0VEX0FUVFIgPT09IERFRkFVTFRfQUxMT1dFRF9BVFRSKSB7XG4gICAgICAgICAgQUxMT1dFRF9BVFRSID0gY2xvbmUoQUxMT1dFRF9BVFRSKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgY2ZnLkFERF9BVFRSKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNmZy5BRERfVVJJX1NBRkVfQVRUUikge1xuICAgICAgICBhZGRUb1NldChVUklfU0FGRV9BVFRSSUJVVEVTLCBjZmcuQUREX1VSSV9TQUZFX0FUVFIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ZnLkZPUkJJRF9DT05URU5UUykge1xuICAgICAgICBpZiAoRk9SQklEX0NPTlRFTlRTID09PSBERUZBVUxUX0ZPUkJJRF9DT05URU5UUykge1xuICAgICAgICAgIEZPUkJJRF9DT05URU5UUyA9IGNsb25lKEZPUkJJRF9DT05URU5UUyk7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRUb1NldChGT1JCSURfQ09OVEVOVFMsIGNmZy5GT1JCSURfQ09OVEVOVFMpO1xuICAgICAgfVxuXG4gICAgICAvKiBBZGQgI3RleHQgaW4gY2FzZSBLRUVQX0NPTlRFTlQgaXMgc2V0IHRvIHRydWUgKi9cbiAgICAgIGlmIChLRUVQX0NPTlRFTlQpIHtcbiAgICAgICAgQUxMT1dFRF9UQUdTWycjdGV4dCddID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogQWRkIGh0bWwsIGhlYWQgYW5kIGJvZHkgdG8gQUxMT1dFRF9UQUdTIGluIGNhc2UgV0hPTEVfRE9DVU1FTlQgaXMgdHJ1ZSAqL1xuICAgICAgaWYgKFdIT0xFX0RPQ1VNRU5UKSB7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgWydodG1sJywgJ2hlYWQnLCAnYm9keSddKTtcbiAgICAgIH1cblxuICAgICAgLyogQWRkIHRib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIHRhYmxlcyBhcmUgcGVybWl0dGVkLCBzZWUgIzI4NiwgIzM2NSAqL1xuICAgICAgaWYgKEFMTE9XRURfVEFHUy50YWJsZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIFsndGJvZHknXSk7XG4gICAgICAgIGRlbGV0ZSBGT1JCSURfVEFHUy50Ym9keTtcbiAgICAgIH1cblxuICAgICAgLy8gUHJldmVudCBmdXJ0aGVyIG1hbmlwdWxhdGlvbiBvZiBjb25maWd1cmF0aW9uLlxuICAgICAgLy8gTm90IGF2YWlsYWJsZSBpbiBJRTgsIFNhZmFyaSA1LCBldGMuXG4gICAgICBpZiAoZnJlZXplKSB7XG4gICAgICAgIGZyZWV6ZShjZmcpO1xuICAgICAgfVxuXG4gICAgICBDT05GSUcgPSBjZmc7XG4gICAgfTtcblxuICAgIHZhciBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFMgPSBhZGRUb1NldCh7fSwgWydtaScsICdtbycsICdtbicsICdtcycsICdtdGV4dCddKTtcblxuICAgIHZhciBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UUyA9IGFkZFRvU2V0KHt9LCBbJ2ZvcmVpZ25vYmplY3QnLCAnZGVzYycsICd0aXRsZScsICdhbm5vdGF0aW9uLXhtbCddKTtcblxuICAgIC8qIEtlZXAgdHJhY2sgb2YgYWxsIHBvc3NpYmxlIFNWRyBhbmQgTWF0aE1MIHRhZ3NcbiAgICAgKiBzbyB0aGF0IHdlIGNhbiBwZXJmb3JtIHRoZSBuYW1lc3BhY2UgY2hlY2tzXG4gICAgICogY29ycmVjdGx5LiAqL1xuICAgIHZhciBBTExfU1ZHX1RBR1MgPSBhZGRUb1NldCh7fSwgc3ZnKTtcbiAgICBhZGRUb1NldChBTExfU1ZHX1RBR1MsIHN2Z0ZpbHRlcnMpO1xuICAgIGFkZFRvU2V0KEFMTF9TVkdfVEFHUywgc3ZnRGlzYWxsb3dlZCk7XG5cbiAgICB2YXIgQUxMX01BVEhNTF9UQUdTID0gYWRkVG9TZXQoe30sIG1hdGhNbCk7XG4gICAgYWRkVG9TZXQoQUxMX01BVEhNTF9UQUdTLCBtYXRoTWxEaXNhbGxvd2VkKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtFbGVtZW50fSBlbGVtZW50IGEgRE9NIGVsZW1lbnQgd2hvc2UgbmFtZXNwYWNlIGlzIGJlaW5nIGNoZWNrZWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJuIGZhbHNlIGlmIHRoZSBlbGVtZW50IGhhcyBhXG4gICAgICogIG5hbWVzcGFjZSB0aGF0IGEgc3BlYy1jb21wbGlhbnQgcGFyc2VyIHdvdWxkIG5ldmVyXG4gICAgICogIHJldHVybi4gUmV0dXJuIHRydWUgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHZhciBfY2hlY2tWYWxpZE5hbWVzcGFjZSA9IGZ1bmN0aW9uIF9jaGVja1ZhbGlkTmFtZXNwYWNlKGVsZW1lbnQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gICAgICAvLyBJbiBKU0RPTSwgaWYgd2UncmUgaW5zaWRlIHNoYWRvdyBET00sIHRoZW4gcGFyZW50Tm9kZVxuICAgICAgLy8gY2FuIGJlIG51bGwuIFdlIGp1c3Qgc2ltdWxhdGUgcGFyZW50IGluIHRoaXMgY2FzZS5cbiAgICAgIGlmICghcGFyZW50IHx8ICFwYXJlbnQudGFnTmFtZSkge1xuICAgICAgICBwYXJlbnQgPSB7XG4gICAgICAgICAgbmFtZXNwYWNlVVJJOiBIVE1MX05BTUVTUEFDRSxcbiAgICAgICAgICB0YWdOYW1lOiAndGVtcGxhdGUnXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciB0YWdOYW1lID0gc3RyaW5nVG9Mb3dlckNhc2UoZWxlbWVudC50YWdOYW1lKTtcbiAgICAgIHZhciBwYXJlbnRUYWdOYW1lID0gc3RyaW5nVG9Mb3dlckNhc2UocGFyZW50LnRhZ05hbWUpO1xuXG4gICAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UpIHtcbiAgICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIEhUTUwgbmFtZXNwYWNlIHRvIFNWR1xuICAgICAgICAvLyBpcyB2aWEgPHN2Zz4uIElmIGl0IGhhcHBlbnMgdmlhIGFueSBvdGhlciB0YWcsIHRoZW5cbiAgICAgICAgLy8gaXQgc2hvdWxkIGJlIGtpbGxlZC5cbiAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIE1hdGhNTCB0byBTVkcgaXMgdmlhXG4gICAgICAgIC8vIHN2ZyBpZiBwYXJlbnQgaXMgZWl0aGVyIDxhbm5vdGF0aW9uLXhtbD4gb3IgTWF0aE1MXG4gICAgICAgIC8vIHRleHQgaW50ZWdyYXRpb24gcG9pbnRzLlxuICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnc3ZnJyAmJiAocGFyZW50VGFnTmFtZSA9PT0gJ2Fubm90YXRpb24teG1sJyB8fCBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Ugb25seSBhbGxvdyBlbGVtZW50cyB0aGF0IGFyZSBkZWZpbmVkIGluIFNWR1xuICAgICAgICAvLyBzcGVjLiBBbGwgb3RoZXJzIGFyZSBkaXNhbGxvd2VkIGluIFNWRyBuYW1lc3BhY2UuXG4gICAgICAgIHJldHVybiBCb29sZWFuKEFMTF9TVkdfVEFHU1t0YWdOYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSkge1xuICAgICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gSFRNTCBuYW1lc3BhY2UgdG8gTWF0aE1MXG4gICAgICAgIC8vIGlzIHZpYSA8bWF0aD4uIElmIGl0IGhhcHBlbnMgdmlhIGFueSBvdGhlciB0YWcsIHRoZW5cbiAgICAgICAgLy8gaXQgc2hvdWxkIGJlIGtpbGxlZC5cbiAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdtYXRoJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBTVkcgdG8gTWF0aE1MIGlzIHZpYVxuICAgICAgICAvLyA8bWF0aD4gYW5kIEhUTUwgaW50ZWdyYXRpb24gcG9pbnRzXG4gICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdtYXRoJyAmJiBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIG9ubHkgYWxsb3cgZWxlbWVudHMgdGhhdCBhcmUgZGVmaW5lZCBpbiBNYXRoTUxcbiAgICAgICAgLy8gc3BlYy4gQWxsIG90aGVycyBhcmUgZGlzYWxsb3dlZCBpbiBNYXRoTUwgbmFtZXNwYWNlLlxuICAgICAgICByZXR1cm4gQm9vbGVhbihBTExfTUFUSE1MX1RBR1NbdGFnTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBTVkcgdG8gSFRNTCBpcyB2aWFcbiAgICAgICAgLy8gSFRNTCBpbnRlZ3JhdGlvbiBwb2ludHMsIGFuZCBmcm9tIE1hdGhNTCB0byBIVE1MXG4gICAgICAgIC8vIGlzIHZpYSBNYXRoTUwgdGV4dCBpbnRlZ3JhdGlvbiBwb2ludHNcbiAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UgJiYgIUhUTUxfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UgJiYgIU1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENlcnRhaW4gZWxlbWVudHMgYXJlIGFsbG93ZWQgaW4gYm90aCBTVkcgYW5kIEhUTUxcbiAgICAgICAgLy8gbmFtZXNwYWNlLiBXZSBuZWVkIHRvIHNwZWNpZnkgdGhlbSBleHBsaWNpdGx5XG4gICAgICAgIC8vIHNvIHRoYXQgdGhleSBkb24ndCBnZXQgZXJyb25vdXNseSBkZWxldGVkIGZyb21cbiAgICAgICAgLy8gSFRNTCBuYW1lc3BhY2UuXG4gICAgICAgIHZhciBjb21tb25TdmdBbmRIVE1MRWxlbWVudHMgPSBhZGRUb1NldCh7fSwgWyd0aXRsZScsICdzdHlsZScsICdmb250JywgJ2EnLCAnc2NyaXB0J10pO1xuXG4gICAgICAgIC8vIFdlIGRpc2FsbG93IHRhZ3MgdGhhdCBhcmUgc3BlY2lmaWMgZm9yIE1hdGhNTFxuICAgICAgICAvLyBvciBTVkcgYW5kIHNob3VsZCBuZXZlciBhcHBlYXIgaW4gSFRNTCBuYW1lc3BhY2VcbiAgICAgICAgcmV0dXJuICFBTExfTUFUSE1MX1RBR1NbdGFnTmFtZV0gJiYgKGNvbW1vblN2Z0FuZEhUTUxFbGVtZW50c1t0YWdOYW1lXSB8fCAhQUxMX1NWR19UQUdTW3RhZ05hbWVdKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvZGUgc2hvdWxkIG5ldmVyIHJlYWNoIHRoaXMgcGxhY2UgKHRoaXMgbWVhbnNcbiAgICAgIC8vIHRoYXQgdGhlIGVsZW1lbnQgc29tZWhvdyBnb3QgbmFtZXNwYWNlIHRoYXQgaXMgbm90XG4gICAgICAvLyBIVE1MLCBTVkcgb3IgTWF0aE1MKS4gUmV0dXJuIGZhbHNlIGp1c3QgaW4gY2FzZS5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogX2ZvcmNlUmVtb3ZlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOb2RlfSBub2RlIGEgRE9NIG5vZGVcbiAgICAgKi9cbiAgICB2YXIgX2ZvcmNlUmVtb3ZlID0gZnVuY3Rpb24gX2ZvcmNlUmVtb3ZlKG5vZGUpIHtcbiAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwgeyBlbGVtZW50OiBub2RlIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLXJlbW92ZVxuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm9kZS5vdXRlckhUTUwgPSBlbXB0eUhUTUw7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9yZW1vdmVBdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBhbiBBdHRyaWJ1dGUgbmFtZVxuICAgICAqIEBwYXJhbSAge05vZGV9IG5vZGUgYSBET00gbm9kZVxuICAgICAqL1xuICAgIHZhciBfcmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBub2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgICAgICBhdHRyaWJ1dGU6IG5vZGUuZ2V0QXR0cmlidXRlTm9kZShuYW1lKSxcbiAgICAgICAgICBmcm9tOiBub2RlXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgICAgICBhdHRyaWJ1dGU6IG51bGwsXG4gICAgICAgICAgZnJvbTogbm9kZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cbiAgICAgIC8vIFdlIHZvaWQgYXR0cmlidXRlIHZhbHVlcyBmb3IgdW5yZW1vdmFibGUgXCJpc1wiXCIgYXR0cmlidXRlc1xuICAgICAgaWYgKG5hbWUgPT09ICdpcycgJiYgIUFMTE9XRURfQVRUUltuYW1lXSkge1xuICAgICAgICBpZiAoUkVUVVJOX0RPTSB8fCBSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF9mb3JjZVJlbW92ZShub2RlKTtcbiAgICAgICAgICB9IGNhdGNoIChfKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyk7XG4gICAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBfaW5pdERvY3VtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcnR5IGEgc3RyaW5nIG9mIGRpcnR5IG1hcmt1cFxuICAgICAqIEByZXR1cm4ge0RvY3VtZW50fSBhIERPTSwgZmlsbGVkIHdpdGggdGhlIGRpcnR5IG1hcmt1cFxuICAgICAqL1xuICAgIHZhciBfaW5pdERvY3VtZW50ID0gZnVuY3Rpb24gX2luaXREb2N1bWVudChkaXJ0eSkge1xuICAgICAgLyogQ3JlYXRlIGEgSFRNTCBkb2N1bWVudCAqL1xuICAgICAgdmFyIGRvYyA9IHZvaWQgMDtcbiAgICAgIHZhciBsZWFkaW5nV2hpdGVzcGFjZSA9IHZvaWQgMDtcblxuICAgICAgaWYgKEZPUkNFX0JPRFkpIHtcbiAgICAgICAgZGlydHkgPSAnPHJlbW92ZT48L3JlbW92ZT4nICsgZGlydHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBJZiBGT1JDRV9CT0RZIGlzbid0IHVzZWQsIGxlYWRpbmcgd2hpdGVzcGFjZSBuZWVkcyB0byBiZSBwcmVzZXJ2ZWQgbWFudWFsbHkgKi9cbiAgICAgICAgdmFyIG1hdGNoZXMgPSBzdHJpbmdNYXRjaChkaXJ0eSwgL15bXFxyXFxuXFx0IF0rLyk7XG4gICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoUEFSU0VSX01FRElBX1RZUEUgPT09ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnKSB7XG4gICAgICAgIC8vIFJvb3Qgb2YgWEhUTUwgZG9jIG11c3QgY29udGFpbiB4bWxucyBkZWNsYXJhdGlvbiAoc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi94aHRtbDEvbm9ybWF0aXZlLmh0bWwjc3RyaWN0KVxuICAgICAgICBkaXJ0eSA9ICc8aHRtbCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj48aGVhZD48L2hlYWQ+PGJvZHk+JyArIGRpcnR5ICsgJzwvYm9keT48L2h0bWw+JztcbiAgICAgIH1cblxuICAgICAgdmFyIGRpcnR5UGF5bG9hZCA9IHRydXN0ZWRUeXBlc1BvbGljeSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKGRpcnR5KSA6IGRpcnR5O1xuICAgICAgLypcbiAgICAgICAqIFVzZSB0aGUgRE9NUGFyc2VyIEFQSSBieSBkZWZhdWx0LCBmYWxsYmFjayBsYXRlciBpZiBuZWVkcyBiZVxuICAgICAgICogRE9NUGFyc2VyIG5vdCB3b3JrIGZvciBzdmcgd2hlbiBoYXMgbXVsdGlwbGUgcm9vdCBlbGVtZW50LlxuICAgICAgICovXG4gICAgICBpZiAoTkFNRVNQQUNFID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoZGlydHlQYXlsb2FkLCBQQVJTRVJfTUVESUFfVFlQRSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICB9XG5cbiAgICAgIC8qIFVzZSBjcmVhdGVIVE1MRG9jdW1lbnQgaW4gY2FzZSBET01QYXJzZXIgaXMgbm90IGF2YWlsYWJsZSAqL1xuICAgICAgaWYgKCFkb2MgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgZG9jID0gaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoTkFNRVNQQUNFLCAndGVtcGxhdGUnLCBudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkb2MuZG9jdW1lbnRFbGVtZW50LmlubmVySFRNTCA9IElTX0VNUFRZX0lOUFVUID8gJycgOiBkaXJ0eVBheWxvYWQ7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAvLyBTeW50YXggZXJyb3IgaWYgZGlydHlQYXlsb2FkIGlzIGludmFsaWQgeG1sXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGJvZHkgPSBkb2MuYm9keSB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICBpZiAoZGlydHkgJiYgbGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgYm9keS5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGVhZGluZ1doaXRlc3BhY2UpLCBib2R5LmNoaWxkTm9kZXNbMF0gfHwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIC8qIFdvcmsgb24gd2hvbGUgZG9jdW1lbnQgb3IganVzdCBpdHMgYm9keSAqL1xuICAgICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIGdldEVsZW1lbnRzQnlUYWdOYW1lLmNhbGwoZG9jLCBXSE9MRV9ET0NVTUVOVCA/ICdodG1sJyA6ICdib2R5JylbMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBXSE9MRV9ET0NVTUVOVCA/IGRvYy5kb2N1bWVudEVsZW1lbnQgOiBib2R5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBfY3JlYXRlSXRlcmF0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0RvY3VtZW50fSByb290IGRvY3VtZW50L2ZyYWdtZW50IHRvIGNyZWF0ZSBpdGVyYXRvciBmb3JcbiAgICAgKiBAcmV0dXJuIHtJdGVyYXRvcn0gaXRlcmF0b3IgaW5zdGFuY2VcbiAgICAgKi9cbiAgICB2YXIgX2NyZWF0ZUl0ZXJhdG9yID0gZnVuY3Rpb24gX2NyZWF0ZUl0ZXJhdG9yKHJvb3QpIHtcbiAgICAgIHJldHVybiBjcmVhdGVOb2RlSXRlcmF0b3IuY2FsbChyb290Lm93bmVyRG9jdW1lbnQgfHwgcm9vdCwgcm9vdCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfQ09NTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19URVhULCBudWxsLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9pc0Nsb2JiZXJlZFxuICAgICAqXG4gICAgICogQHBhcmFtICB7Tm9kZX0gZWxtIGVsZW1lbnQgdG8gY2hlY2sgZm9yIGNsb2JiZXJpbmcgYXR0YWNrc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgY2xvYmJlcmVkLCBmYWxzZSBpZiBzYWZlXG4gICAgICovXG4gICAgdmFyIF9pc0Nsb2JiZXJlZCA9IGZ1bmN0aW9uIF9pc0Nsb2JiZXJlZChlbG0pIHtcbiAgICAgIGlmIChlbG0gaW5zdGFuY2VvZiBUZXh0IHx8IGVsbSBpbnN0YW5jZW9mIENvbW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGVsbS5ub2RlTmFtZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsbS50ZXh0Q29udGVudCAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsbS5yZW1vdmVDaGlsZCAhPT0gJ2Z1bmN0aW9uJyB8fCAhKGVsbS5hdHRyaWJ1dGVzIGluc3RhbmNlb2YgTmFtZWROb2RlTWFwKSB8fCB0eXBlb2YgZWxtLnJlbW92ZUF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxtLnNldEF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxtLm5hbWVzcGFjZVVSSSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsbS5pbnNlcnRCZWZvcmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogX2lzTm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtICB7Tm9kZX0gb2JqIG9iamVjdCB0byBjaGVjayB3aGV0aGVyIGl0J3MgYSBET00gbm9kZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaXMgb2JqZWN0IGlzIGEgRE9NIG5vZGVcbiAgICAgKi9cbiAgICB2YXIgX2lzTm9kZSA9IGZ1bmN0aW9uIF9pc05vZGUob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiBOb2RlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihOb2RlKSkgPT09ICdvYmplY3QnID8gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSA6IG9iamVjdCAmJiAodHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqZWN0KSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBfZXhlY3V0ZUhvb2tcbiAgICAgKiBFeGVjdXRlIHVzZXIgY29uZmlndXJhYmxlIGhvb2tzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVudHJ5UG9pbnQgIE5hbWUgb2YgdGhlIGhvb2sncyBlbnRyeSBwb2ludFxuICAgICAqIEBwYXJhbSAge05vZGV9IGN1cnJlbnROb2RlIG5vZGUgdG8gd29yayBvbiB3aXRoIHRoZSBob29rXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIGFkZGl0aW9uYWwgaG9vayBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgdmFyIF9leGVjdXRlSG9vayA9IGZ1bmN0aW9uIF9leGVjdXRlSG9vayhlbnRyeVBvaW50LCBjdXJyZW50Tm9kZSwgZGF0YSkge1xuICAgICAgaWYgKCFob29rc1tlbnRyeVBvaW50XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFycmF5Rm9yRWFjaChob29rc1tlbnRyeVBvaW50XSwgZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgaG9vay5jYWxsKERPTVB1cmlmeSwgY3VycmVudE5vZGUsIGRhdGEsIENPTkZJRyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogX3Nhbml0aXplRWxlbWVudHNcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0IG5vZGVOYW1lXG4gICAgICogQHByb3RlY3QgdGV4dENvbnRlbnRcbiAgICAgKiBAcHJvdGVjdCByZW1vdmVDaGlsZFxuICAgICAqXG4gICAgICogQHBhcmFtICAge05vZGV9IGN1cnJlbnROb2RlIHRvIGNoZWNrIGZvciBwZXJtaXNzaW9uIHRvIGV4aXN0XG4gICAgICogQHJldHVybiAge0Jvb2xlYW59IHRydWUgaWYgbm9kZSB3YXMga2lsbGVkLCBmYWxzZSBpZiBsZWZ0IGFsaXZlXG4gICAgICovXG4gICAgdmFyIF9zYW5pdGl6ZUVsZW1lbnRzID0gZnVuY3Rpb24gX3Nhbml0aXplRWxlbWVudHMoY3VycmVudE5vZGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gdm9pZCAwO1xuXG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBfZXhlY3V0ZUhvb2soJ2JlZm9yZVNhbml0aXplRWxlbWVudHMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG5cbiAgICAgIC8qIENoZWNrIGlmIGVsZW1lbnQgaXMgY2xvYmJlcmVkIG9yIGNhbiBjbG9iYmVyICovXG4gICAgICBpZiAoX2lzQ2xvYmJlcmVkKGN1cnJlbnROb2RlKSkge1xuICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogQ2hlY2sgaWYgdGFnbmFtZSBjb250YWlucyBVbmljb2RlICovXG4gICAgICBpZiAoc3RyaW5nTWF0Y2goY3VycmVudE5vZGUubm9kZU5hbWUsIC9bXFx1MDA4MC1cXHVGRkZGXS8pKSB7XG4gICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBOb3cgbGV0J3MgY2hlY2sgdGhlIGVsZW1lbnQncyB0eXBlIGFuZCBuYW1lICovXG4gICAgICB2YXIgdGFnTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcblxuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVFbGVtZW50JywgY3VycmVudE5vZGUsIHtcbiAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgICAgYWxsb3dlZFRhZ3M6IEFMTE9XRURfVEFHU1xuICAgICAgfSk7XG5cbiAgICAgIC8qIERldGVjdCBtWFNTIGF0dGVtcHRzIGFidXNpbmcgbmFtZXNwYWNlIGNvbmZ1c2lvbiAqL1xuICAgICAgaWYgKCFfaXNOb2RlKGN1cnJlbnROb2RlLmZpcnN0RWxlbWVudENoaWxkKSAmJiAoIV9pc05vZGUoY3VycmVudE5vZGUuY29udGVudCkgfHwgIV9pc05vZGUoY3VycmVudE5vZGUuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZCkpICYmIHJlZ0V4cFRlc3QoLzxbL1xcd10vZywgY3VycmVudE5vZGUuaW5uZXJIVE1MKSAmJiByZWdFeHBUZXN0KC88Wy9cXHddL2csIGN1cnJlbnROb2RlLnRleHRDb250ZW50KSkge1xuICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogTWl0aWdhdGUgYSBwcm9ibGVtIHdpdGggdGVtcGxhdGVzIGluc2lkZSBzZWxlY3QgKi9cbiAgICAgIGlmICh0YWdOYW1lID09PSAnc2VsZWN0JyAmJiByZWdFeHBUZXN0KC88dGVtcGxhdGUvaSwgY3VycmVudE5vZGUuaW5uZXJIVE1MKSkge1xuICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogUmVtb3ZlIGVsZW1lbnQgaWYgYW55dGhpbmcgZm9yYmlkcyBpdHMgcHJlc2VuY2UgKi9cbiAgICAgIGlmICghQUxMT1dFRF9UQUdTW3RhZ05hbWVdIHx8IEZPUkJJRF9UQUdTW3RhZ05hbWVdKSB7XG4gICAgICAgIC8qIEtlZXAgY29udGVudCBleGNlcHQgZm9yIGJhZC1saXN0ZWQgZWxlbWVudHMgKi9cbiAgICAgICAgaWYgKEtFRVBfQ09OVEVOVCAmJiAhRk9SQklEX0NPTlRFTlRTW3RhZ05hbWVdKSB7XG4gICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKSB8fCBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gZ2V0Q2hpbGROb2RlcyhjdXJyZW50Tm9kZSkgfHwgY3VycmVudE5vZGUuY2hpbGROb2RlcztcblxuICAgICAgICAgIGlmIChjaGlsZE5vZGVzICYmIHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZENvdW50ID0gY2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBjaGlsZENvdW50IC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2xvbmVOb2RlKGNoaWxkTm9kZXNbaV0sIHRydWUpLCBnZXROZXh0U2libGluZyhjdXJyZW50Tm9kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBDaGVjayB3aGV0aGVyIGVsZW1lbnQgaGFzIGEgdmFsaWQgbmFtZXNwYWNlICovXG4gICAgICBpZiAoY3VycmVudE5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmICFfY2hlY2tWYWxpZE5hbWVzcGFjZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgodGFnTmFtZSA9PT0gJ25vc2NyaXB0JyB8fCB0YWdOYW1lID09PSAnbm9lbWJlZCcpICYmIHJlZ0V4cFRlc3QoLzxcXC9ubyhzY3JpcHR8ZW1iZWQpL2ksIGN1cnJlbnROb2RlLmlubmVySFRNTCkpIHtcbiAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIFNhbml0aXplIGVsZW1lbnQgY29udGVudCB0byBiZSB0ZW1wbGF0ZS1zYWZlICovXG4gICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTICYmIGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIC8qIEdldCB0aGUgZWxlbWVudCdzIHRleHQgY29udGVudCAqL1xuICAgICAgICBjb250ZW50ID0gY3VycmVudE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIGNvbnRlbnQgPSBzdHJpbmdSZXBsYWNlKGNvbnRlbnQsIE1VU1RBQ0hFX0VYUFIkJDEsICcgJyk7XG4gICAgICAgIGNvbnRlbnQgPSBzdHJpbmdSZXBsYWNlKGNvbnRlbnQsIEVSQl9FWFBSJCQxLCAnICcpO1xuICAgICAgICBpZiAoY3VycmVudE5vZGUudGV4dENvbnRlbnQgIT09IGNvbnRlbnQpIHtcbiAgICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHsgZWxlbWVudDogY3VycmVudE5vZGUuY2xvbmVOb2RlKCkgfSk7XG4gICAgICAgICAgY3VycmVudE5vZGUudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgIF9leGVjdXRlSG9vaygnYWZ0ZXJTYW5pdGl6ZUVsZW1lbnRzJywgY3VycmVudE5vZGUsIG51bGwpO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9pc1ZhbGlkQXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGxjVGFnIExvd2VyY2FzZSB0YWcgbmFtZSBvZiBjb250YWluaW5nIGVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBsY05hbWUgTG93ZXJjYXNlIGF0dHJpYnV0ZSBuYW1lLlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICB2YXIgX2lzVmFsaWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSkge1xuICAgICAgLyogTWFrZSBzdXJlIGF0dHJpYnV0ZSBjYW5ub3QgY2xvYmJlciAqL1xuICAgICAgaWYgKFNBTklUSVpFX0RPTSAmJiAobGNOYW1lID09PSAnaWQnIHx8IGxjTmFtZSA9PT0gJ25hbWUnKSAmJiAodmFsdWUgaW4gZG9jdW1lbnQgfHwgdmFsdWUgaW4gZm9ybUVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyogQWxsb3cgdmFsaWQgZGF0YS0qIGF0dHJpYnV0ZXM6IEF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgYWZ0ZXIgXCItXCJcbiAgICAgICAgICAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjZW1iZWRkaW5nLWN1c3RvbS1ub24tdmlzaWJsZS1kYXRhLXdpdGgtdGhlLWRhdGEtKi1hdHRyaWJ1dGVzKVxuICAgICAgICAgIFhNTC1jb21wYXRpYmxlIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmZyYXN0cnVjdHVyZS5odG1sI3htbC1jb21wYXRpYmxlIGFuZCBodHRwOi8vd3d3LnczLm9yZy9UUi94bWwvI2QwZTgwNClcbiAgICAgICAgICBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIHRoZSB2YWx1ZTsgaXQncyBhbHdheXMgVVJJIHNhZmUuICovXG4gICAgICBpZiAoQUxMT1dfREFUQV9BVFRSICYmICFGT1JCSURfQVRUUltsY05hbWVdICYmIHJlZ0V4cFRlc3QoREFUQV9BVFRSJCQxLCBsY05hbWUpKSA7IGVsc2UgaWYgKEFMTE9XX0FSSUFfQVRUUiAmJiByZWdFeHBUZXN0KEFSSUFfQVRUUiQkMSwgbGNOYW1lKSkgOyBlbHNlIGlmICghQUxMT1dFRF9BVFRSW2xjTmFtZV0gfHwgRk9SQklEX0FUVFJbbGNOYW1lXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgLyogQ2hlY2sgdmFsdWUgaXMgc2FmZS4gRmlyc3QsIGlzIGF0dHIgaW5lcnQ/IElmIHNvLCBpcyBzYWZlICovXG4gICAgICB9IGVsc2UgaWYgKFVSSV9TQUZFX0FUVFJJQlVURVNbbGNOYW1lXSkgOyBlbHNlIGlmIChyZWdFeHBUZXN0KElTX0FMTE9XRURfVVJJJCQxLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UkJDEsICcnKSkpIDsgZWxzZSBpZiAoKGxjTmFtZSA9PT0gJ3NyYycgfHwgbGNOYW1lID09PSAneGxpbms6aHJlZicgfHwgbGNOYW1lID09PSAnaHJlZicpICYmIGxjVGFnICE9PSAnc2NyaXB0JyAmJiBzdHJpbmdJbmRleE9mKHZhbHVlLCAnZGF0YTonKSA9PT0gMCAmJiBEQVRBX1VSSV9UQUdTW2xjVGFnXSkgOyBlbHNlIGlmIChBTExPV19VTktOT1dOX1BST1RPQ09MUyAmJiAhcmVnRXhwVGVzdChJU19TQ1JJUFRfT1JfREFUQSQkMSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFJCQxLCAnJykpKSA7IGVsc2UgaWYgKCF2YWx1ZSkgOyBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogX3Nhbml0aXplQXR0cmlidXRlc1xuICAgICAqXG4gICAgICogQHByb3RlY3QgYXR0cmlidXRlc1xuICAgICAqIEBwcm90ZWN0IG5vZGVOYW1lXG4gICAgICogQHByb3RlY3QgcmVtb3ZlQXR0cmlidXRlXG4gICAgICogQHByb3RlY3Qgc2V0QXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOb2RlfSBjdXJyZW50Tm9kZSB0byBzYW5pdGl6ZVxuICAgICAqL1xuICAgIHZhciBfc2FuaXRpemVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gX3Nhbml0aXplQXR0cmlidXRlcyhjdXJyZW50Tm9kZSkge1xuICAgICAgdmFyIGF0dHIgPSB2b2lkIDA7XG4gICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG4gICAgICB2YXIgbGNOYW1lID0gdm9pZCAwO1xuICAgICAgdmFyIGwgPSB2b2lkIDA7XG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBfZXhlY3V0ZUhvb2soJ2JlZm9yZVNhbml0aXplQXR0cmlidXRlcycsIGN1cnJlbnROb2RlLCBudWxsKTtcblxuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBjdXJyZW50Tm9kZS5hdHRyaWJ1dGVzO1xuXG4gICAgICAvKiBDaGVjayBpZiB3ZSBoYXZlIGF0dHJpYnV0ZXM7IGlmIG5vdCB3ZSBtaWdodCBoYXZlIGEgdGV4dCBub2RlICovXG5cbiAgICAgIGlmICghYXR0cmlidXRlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBob29rRXZlbnQgPSB7XG4gICAgICAgIGF0dHJOYW1lOiAnJyxcbiAgICAgICAgYXR0clZhbHVlOiAnJyxcbiAgICAgICAga2VlcEF0dHI6IHRydWUsXG4gICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBBTExPV0VEX0FUVFJcbiAgICAgIH07XG4gICAgICBsID0gYXR0cmlidXRlcy5sZW5ndGg7XG5cbiAgICAgIC8qIEdvIGJhY2t3YXJkcyBvdmVyIGFsbCBhdHRyaWJ1dGVzOyBzYWZlbHkgcmVtb3ZlIGJhZCBvbmVzICovXG4gICAgICB3aGlsZSAobC0tKSB7XG4gICAgICAgIGF0dHIgPSBhdHRyaWJ1dGVzW2xdO1xuICAgICAgICB2YXIgX2F0dHIgPSBhdHRyLFxuICAgICAgICAgICAgbmFtZSA9IF9hdHRyLm5hbWUsXG4gICAgICAgICAgICBuYW1lc3BhY2VVUkkgPSBfYXR0ci5uYW1lc3BhY2VVUkk7XG5cbiAgICAgICAgdmFsdWUgPSBzdHJpbmdUcmltKGF0dHIudmFsdWUpO1xuICAgICAgICBsY05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhuYW1lKTtcblxuICAgICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICAgIGhvb2tFdmVudC5hdHRyTmFtZSA9IGxjTmFtZTtcbiAgICAgICAgaG9va0V2ZW50LmF0dHJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBob29rRXZlbnQua2VlcEF0dHIgPSB0cnVlO1xuICAgICAgICBob29rRXZlbnQuZm9yY2VLZWVwQXR0ciA9IHVuZGVmaW5lZDsgLy8gQWxsb3dzIGRldmVsb3BlcnMgdG8gc2VlIHRoaXMgaXMgYSBwcm9wZXJ0eSB0aGV5IGNhbiBzZXRcbiAgICAgICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVBdHRyaWJ1dGUnLCBjdXJyZW50Tm9kZSwgaG9va0V2ZW50KTtcbiAgICAgICAgdmFsdWUgPSBob29rRXZlbnQuYXR0clZhbHVlO1xuICAgICAgICAvKiBEaWQgdGhlIGhvb2tzIGFwcHJvdmUgb2YgdGhlIGF0dHJpYnV0ZT8gKi9cbiAgICAgICAgaWYgKGhvb2tFdmVudC5mb3JjZUtlZXBBdHRyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBSZW1vdmUgYXR0cmlidXRlICovXG4gICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuXG4gICAgICAgIC8qIERpZCB0aGUgaG9va3MgYXBwcm92ZSBvZiB0aGUgYXR0cmlidXRlPyAqL1xuICAgICAgICBpZiAoIWhvb2tFdmVudC5rZWVwQXR0cikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogV29yayBhcm91bmQgYSBzZWN1cml0eSBpc3N1ZSBpbiBqUXVlcnkgMy4wICovXG4gICAgICAgIGlmIChyZWdFeHBUZXN0KC9cXC8+L2ksIHZhbHVlKSkge1xuICAgICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogU2FuaXRpemUgYXR0cmlidXRlIGNvbnRlbnQgdG8gYmUgdGVtcGxhdGUtc2FmZSAqL1xuICAgICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICAgICAgdmFsdWUgPSBzdHJpbmdSZXBsYWNlKHZhbHVlLCBNVVNUQUNIRV9FWFBSJCQxLCAnICcpO1xuICAgICAgICAgIHZhbHVlID0gc3RyaW5nUmVwbGFjZSh2YWx1ZSwgRVJCX0VYUFIkJDEsICcgJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBJcyBgdmFsdWVgIHZhbGlkIGZvciB0aGlzIGF0dHJpYnV0ZT8gKi9cbiAgICAgICAgdmFyIGxjVGFnID0gdHJhbnNmb3JtQ2FzZUZ1bmMoY3VycmVudE5vZGUubm9kZU5hbWUpO1xuICAgICAgICBpZiAoIV9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogSGFuZGxlIGludmFsaWQgZGF0YS0qIGF0dHJpYnV0ZSBzZXQgYnkgdHJ5LWNhdGNoaW5nIGl0ICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKG5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgY3VycmVudE5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlVVJJLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIEZhbGxiYWNrIHRvIHNldEF0dHJpYnV0ZSgpIGZvciBicm93c2VyLXVucmVjb2duaXplZCBuYW1lc3BhY2VzIGUuZy4gXCJ4LXNjaGVtYVwiLiAqL1xuICAgICAgICAgICAgY3VycmVudE5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnJheVBvcChET01QdXJpZnkucmVtb3ZlZCk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICB9XG5cbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgIF9leGVjdXRlSG9vaygnYWZ0ZXJTYW5pdGl6ZUF0dHJpYnV0ZXMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9zYW5pdGl6ZVNoYWRvd0RPTVxuICAgICAqXG4gICAgICogQHBhcmFtICB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ21lbnQgdG8gaXRlcmF0ZSBvdmVyIHJlY3Vyc2l2ZWx5XG4gICAgICovXG4gICAgdmFyIF9zYW5pdGl6ZVNoYWRvd0RPTSA9IGZ1bmN0aW9uIF9zYW5pdGl6ZVNoYWRvd0RPTShmcmFnbWVudCkge1xuICAgICAgdmFyIHNoYWRvd05vZGUgPSB2b2lkIDA7XG4gICAgICB2YXIgc2hhZG93SXRlcmF0b3IgPSBfY3JlYXRlSXRlcmF0b3IoZnJhZ21lbnQpO1xuXG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBfZXhlY3V0ZUhvb2soJ2JlZm9yZVNhbml0aXplU2hhZG93RE9NJywgZnJhZ21lbnQsIG51bGwpO1xuXG4gICAgICB3aGlsZSAoc2hhZG93Tm9kZSA9IHNoYWRvd0l0ZXJhdG9yLm5leHROb2RlKCkpIHtcbiAgICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgICBfZXhlY3V0ZUhvb2soJ3Vwb25TYW5pdGl6ZVNoYWRvd05vZGUnLCBzaGFkb3dOb2RlLCBudWxsKTtcblxuICAgICAgICAvKiBTYW5pdGl6ZSB0YWdzIGFuZCBlbGVtZW50cyAqL1xuICAgICAgICBpZiAoX3Nhbml0aXplRWxlbWVudHMoc2hhZG93Tm9kZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIERlZXAgc2hhZG93IERPTSBkZXRlY3RlZCAqL1xuICAgICAgICBpZiAoc2hhZG93Tm9kZS5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICAgIF9zYW5pdGl6ZVNoYWRvd0RPTShzaGFkb3dOb2RlLmNvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogQ2hlY2sgYXR0cmlidXRlcywgc2FuaXRpemUgaWYgbmVjZXNzYXJ5ICovXG4gICAgICAgIF9zYW5pdGl6ZUF0dHJpYnV0ZXMoc2hhZG93Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgIF9leGVjdXRlSG9vaygnYWZ0ZXJTYW5pdGl6ZVNoYWRvd0RPTScsIGZyYWdtZW50LCBudWxsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2FuaXRpemVcbiAgICAgKiBQdWJsaWMgbWV0aG9kIHByb3ZpZGluZyBjb3JlIHNhbml0YXRpb24gZnVuY3Rpb25hbGl0eVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8Tm9kZX0gZGlydHkgc3RyaW5nIG9yIERPTSBub2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBET01QdXJpZnkuc2FuaXRpemUgPSBmdW5jdGlvbiAoZGlydHksIGNmZykge1xuICAgICAgdmFyIGJvZHkgPSB2b2lkIDA7XG4gICAgICB2YXIgaW1wb3J0ZWROb2RlID0gdm9pZCAwO1xuICAgICAgdmFyIGN1cnJlbnROb2RlID0gdm9pZCAwO1xuICAgICAgdmFyIG9sZE5vZGUgPSB2b2lkIDA7XG4gICAgICB2YXIgcmV0dXJuTm9kZSA9IHZvaWQgMDtcbiAgICAgIC8qIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgc3RyaW5nIHRvIHNhbml0aXplLlxuICAgICAgICBETyBOT1QgcmV0dXJuIGVhcmx5LCBhcyB0aGlzIHdpbGwgcmV0dXJuIHRoZSB3cm9uZyB0eXBlIGlmXG4gICAgICAgIHRoZSB1c2VyIGhhcyByZXF1ZXN0ZWQgYSBET00gb2JqZWN0IHJhdGhlciB0aGFuIGEgc3RyaW5nICovXG4gICAgICBJU19FTVBUWV9JTlBVVCA9ICFkaXJ0eTtcbiAgICAgIGlmIChJU19FTVBUWV9JTlBVVCkge1xuICAgICAgICBkaXJ0eSA9ICc8IS0tPic7XG4gICAgICB9XG5cbiAgICAgIC8qIFN0cmluZ2lmeSwgaW4gY2FzZSBkaXJ0eSBpcyBhbiBvYmplY3QgKi9cbiAgICAgIGlmICh0eXBlb2YgZGlydHkgIT09ICdzdHJpbmcnICYmICFfaXNOb2RlKGRpcnR5KSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVnYXRlZC1jb25kaXRpb25cbiAgICAgICAgaWYgKHR5cGVvZiBkaXJ0eS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgndG9TdHJpbmcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXJ0eSA9IGRpcnR5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkaXJ0eSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgnZGlydHkgaXMgbm90IGEgc3RyaW5nLCBhYm9ydGluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiBDaGVjayB3ZSBjYW4gcnVuLiBPdGhlcndpc2UgZmFsbCBiYWNrIG9yIGlnbm9yZSAqL1xuICAgICAgaWYgKCFET01QdXJpZnkuaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgaWYgKF90eXBlb2Yod2luZG93LnRvU3RhdGljSFRNTCkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB3aW5kb3cudG9TdGF0aWNIVE1MID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkaXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cudG9TdGF0aWNIVE1MKGRpcnR5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2lzTm9kZShkaXJ0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cudG9TdGF0aWNIVE1MKGRpcnR5Lm91dGVySFRNTCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpcnR5O1xuICAgICAgfVxuXG4gICAgICAvKiBBc3NpZ24gY29uZmlnIHZhcnMgKi9cbiAgICAgIGlmICghU0VUX0NPTkZJRykge1xuICAgICAgICBfcGFyc2VDb25maWcoY2ZnKTtcbiAgICAgIH1cblxuICAgICAgLyogQ2xlYW4gdXAgcmVtb3ZlZCBlbGVtZW50cyAqL1xuICAgICAgRE9NUHVyaWZ5LnJlbW92ZWQgPSBbXTtcblxuICAgICAgLyogQ2hlY2sgaWYgZGlydHkgaXMgY29ycmVjdGx5IHR5cGVkIGZvciBJTl9QTEFDRSAqL1xuICAgICAgaWYgKHR5cGVvZiBkaXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgSU5fUExBQ0UgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKElOX1BMQUNFKSA7IGVsc2UgaWYgKGRpcnR5IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAvKiBJZiBkaXJ0eSBpcyBhIERPTSBlbGVtZW50LCBhcHBlbmQgdG8gYW4gZW1wdHkgZG9jdW1lbnQgdG8gYXZvaWRcbiAgICAgICAgICAgZWxlbWVudHMgYmVpbmcgc3RyaXBwZWQgYnkgdGhlIHBhcnNlciAqL1xuICAgICAgICBib2R5ID0gX2luaXREb2N1bWVudCgnPCEtLS0tPicpO1xuICAgICAgICBpbXBvcnRlZE5vZGUgPSBib2R5Lm93bmVyRG9jdW1lbnQuaW1wb3J0Tm9kZShkaXJ0eSwgdHJ1ZSk7XG4gICAgICAgIGlmIChpbXBvcnRlZE5vZGUubm9kZVR5cGUgPT09IDEgJiYgaW1wb3J0ZWROb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgICAvKiBOb2RlIGlzIGFscmVhZHkgYSBib2R5LCB1c2UgYXMgaXMgKi9cbiAgICAgICAgICBib2R5ID0gaW1wb3J0ZWROb2RlO1xuICAgICAgICB9IGVsc2UgaWYgKGltcG9ydGVkTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItZG9tLW5vZGUtYXBwZW5kXG4gICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChpbXBvcnRlZE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBFeGl0IGRpcmVjdGx5IGlmIHdlIGhhdmUgbm90aGluZyB0byBkbyAqL1xuICAgICAgICBpZiAoIVJFVFVSTl9ET00gJiYgIVNBRkVfRk9SX1RFTVBMQVRFUyAmJiAhV0hPTEVfRE9DVU1FTlQgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWluY2x1ZGVzXG4gICAgICAgIGRpcnR5LmluZGV4T2YoJzwnKSA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1c3RlZFR5cGVzUG9saWN5ICYmIFJFVFVSTl9UUlVTVEVEX1RZUEUgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSkgOiBkaXJ0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIEluaXRpYWxpemUgdGhlIGRvY3VtZW50IHRvIHdvcmsgb24gKi9cbiAgICAgICAgYm9keSA9IF9pbml0RG9jdW1lbnQoZGlydHkpO1xuXG4gICAgICAgIC8qIENoZWNrIHdlIGhhdmUgYSBET00gbm9kZSBmcm9tIHRoZSBkYXRhICovXG4gICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgIHJldHVybiBSRVRVUk5fRE9NID8gbnVsbCA6IGVtcHR5SFRNTDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiBSZW1vdmUgZmlyc3QgZWxlbWVudCBub2RlIChvdXJzKSBpZiBGT1JDRV9CT0RZIGlzIHNldCAqL1xuICAgICAgaWYgKGJvZHkgJiYgRk9SQ0VfQk9EWSkge1xuICAgICAgICBfZm9yY2VSZW1vdmUoYm9keS5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgLyogR2V0IG5vZGUgaXRlcmF0b3IgKi9cbiAgICAgIHZhciBub2RlSXRlcmF0b3IgPSBfY3JlYXRlSXRlcmF0b3IoSU5fUExBQ0UgPyBkaXJ0eSA6IGJvZHkpO1xuXG4gICAgICAvKiBOb3cgc3RhcnQgaXRlcmF0aW5nIG92ZXIgdGhlIGNyZWF0ZWQgZG9jdW1lbnQgKi9cbiAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSA9IG5vZGVJdGVyYXRvci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgIC8qIEZpeCBJRSdzIHN0cmFuZ2UgYmVoYXZpb3Igd2l0aCBtYW5pcHVsYXRlZCB0ZXh0Tm9kZXMgIzg5ICovXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMyAmJiBjdXJyZW50Tm9kZSA9PT0gb2xkTm9kZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogU2FuaXRpemUgdGFncyBhbmQgZWxlbWVudHMgKi9cbiAgICAgICAgaWYgKF9zYW5pdGl6ZUVsZW1lbnRzKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogU2hhZG93IERPTSBkZXRlY3RlZCwgc2FuaXRpemUgaXQgKi9cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLmNvbnRlbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NKGN1cnJlbnROb2RlLmNvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogQ2hlY2sgYXR0cmlidXRlcywgc2FuaXRpemUgaWYgbmVjZXNzYXJ5ICovXG4gICAgICAgIF9zYW5pdGl6ZUF0dHJpYnV0ZXMoY3VycmVudE5vZGUpO1xuXG4gICAgICAgIG9sZE5vZGUgPSBjdXJyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgb2xkTm9kZSA9IG51bGw7XG5cbiAgICAgIC8qIElmIHdlIHNhbml0aXplZCBgZGlydHlgIGluLXBsYWNlLCByZXR1cm4gaXQuICovXG4gICAgICBpZiAoSU5fUExBQ0UpIHtcbiAgICAgICAgcmV0dXJuIGRpcnR5O1xuICAgICAgfVxuXG4gICAgICAvKiBSZXR1cm4gc2FuaXRpemVkIHN0cmluZyBvciBET00gKi9cbiAgICAgIGlmIChSRVRVUk5fRE9NKSB7XG4gICAgICAgIGlmIChSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7XG4gICAgICAgICAgcmV0dXJuTm9kZSA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQuY2FsbChib2R5Lm93bmVyRG9jdW1lbnQpO1xuXG4gICAgICAgICAgd2hpbGUgKGJvZHkuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLWFwcGVuZFxuICAgICAgICAgICAgcmV0dXJuTm9kZS5hcHBlbmRDaGlsZChib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5Ob2RlID0gYm9keTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChSRVRVUk5fRE9NX0lNUE9SVCkge1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICBBZG9wdE5vZGUoKSBpcyBub3QgdXNlZCBiZWNhdXNlIGludGVybmFsIHN0YXRlIGlzIG5vdCByZXNldFxuICAgICAgICAgICAgKGUuZy4gdGhlIHBhc3QgbmFtZXMgbWFwIG9mIGEgSFRNTEZvcm1FbGVtZW50KSwgdGhpcyBpcyBzYWZlXG4gICAgICAgICAgICBpbiB0aGVvcnkgYnV0IHdlIHdvdWxkIHJhdGhlciBub3QgcmlzayBhbm90aGVyIGF0dGFjayB2ZWN0b3IuXG4gICAgICAgICAgICBUaGUgc3RhdGUgdGhhdCBpcyBjbG9uZWQgYnkgaW1wb3J0Tm9kZSgpIGlzIGV4cGxpY2l0bHkgZGVmaW5lZFxuICAgICAgICAgICAgYnkgdGhlIHNwZWNzLlxuICAgICAgICAgICovXG4gICAgICAgICAgcmV0dXJuTm9kZSA9IGltcG9ydE5vZGUuY2FsbChvcmlnaW5hbERvY3VtZW50LCByZXR1cm5Ob2RlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXR1cm5Ob2RlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VyaWFsaXplZEhUTUwgPSBXSE9MRV9ET0NVTUVOVCA/IGJvZHkub3V0ZXJIVE1MIDogYm9keS5pbm5lckhUTUw7XG5cbiAgICAgIC8qIFNhbml0aXplIGZpbmFsIHN0cmluZyB0ZW1wbGF0ZS1zYWZlICovXG4gICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICAgIHNlcmlhbGl6ZWRIVE1MID0gc3RyaW5nUmVwbGFjZShzZXJpYWxpemVkSFRNTCwgTVVTVEFDSEVfRVhQUiQkMSwgJyAnKTtcbiAgICAgICAgc2VyaWFsaXplZEhUTUwgPSBzdHJpbmdSZXBsYWNlKHNlcmlhbGl6ZWRIVE1MLCBFUkJfRVhQUiQkMSwgJyAnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoc2VyaWFsaXplZEhUTUwpIDogc2VyaWFsaXplZEhUTUw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBtZXRob2QgdG8gc2V0IHRoZSBjb25maWd1cmF0aW9uIG9uY2VcbiAgICAgKiBzZXRDb25maWdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICBET01QdXJpZnkuc2V0Q29uZmlnID0gZnVuY3Rpb24gKGNmZykge1xuICAgICAgX3BhcnNlQ29uZmlnKGNmZyk7XG4gICAgICBTRVRfQ09ORklHID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgdGhlIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBjbGVhckNvbmZpZ1xuICAgICAqXG4gICAgICovXG4gICAgRE9NUHVyaWZ5LmNsZWFyQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgQ09ORklHID0gbnVsbDtcbiAgICAgIFNFVF9DT05GSUcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHVibGljIG1ldGhvZCB0byBjaGVjayBpZiBhbiBhdHRyaWJ1dGUgdmFsdWUgaXMgdmFsaWQuXG4gICAgICogVXNlcyBsYXN0IHNldCBjb25maWcsIGlmIGFueS4gT3RoZXJ3aXNlLCB1c2VzIGNvbmZpZyBkZWZhdWx0cy5cbiAgICAgKiBpc1ZhbGlkQXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZyBUYWcgbmFtZSBvZiBjb250YWluaW5nIGVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBhdHRyIEF0dHJpYnV0ZSBuYW1lLlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLiBPdGhlcndpc2UsIHJldHVybnMgZmFsc2UuXG4gICAgICovXG4gICAgRE9NUHVyaWZ5LmlzVmFsaWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodGFnLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgLyogSW5pdGlhbGl6ZSBzaGFyZWQgY29uZmlnIHZhcnMgaWYgbmVjZXNzYXJ5LiAqL1xuICAgICAgaWYgKCFDT05GSUcpIHtcbiAgICAgICAgX3BhcnNlQ29uZmlnKHt9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxjVGFnID0gdHJhbnNmb3JtQ2FzZUZ1bmModGFnKTtcbiAgICAgIHZhciBsY05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhhdHRyKTtcbiAgICAgIHJldHVybiBfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZEhvb2tcbiAgICAgKiBQdWJsaWMgbWV0aG9kIHRvIGFkZCBET01QdXJpZnkgaG9va3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbnRyeVBvaW50IGVudHJ5IHBvaW50IGZvciB0aGUgaG9vayB0byBhZGRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rRnVuY3Rpb24gZnVuY3Rpb24gdG8gZXhlY3V0ZVxuICAgICAqL1xuICAgIERPTVB1cmlmeS5hZGRIb29rID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQsIGhvb2tGdW5jdGlvbikge1xuICAgICAgaWYgKHR5cGVvZiBob29rRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBob29rc1tlbnRyeVBvaW50XSA9IGhvb2tzW2VudHJ5UG9pbnRdIHx8IFtdO1xuICAgICAgYXJyYXlQdXNoKGhvb2tzW2VudHJ5UG9pbnRdLCBob29rRnVuY3Rpb24pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVIb29rXG4gICAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYSBET01QdXJpZnkgaG9vayBhdCBhIGdpdmVuIGVudHJ5UG9pbnRcbiAgICAgKiAocG9wcyBpdCBmcm9tIHRoZSBzdGFjayBvZiBob29rcyBpZiBtb3JlIGFyZSBwcmVzZW50KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVudHJ5UG9pbnQgZW50cnkgcG9pbnQgZm9yIHRoZSBob29rIHRvIHJlbW92ZVxuICAgICAqL1xuICAgIERPTVB1cmlmeS5yZW1vdmVIb29rID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQpIHtcbiAgICAgIGlmIChob29rc1tlbnRyeVBvaW50XSkge1xuICAgICAgICBhcnJheVBvcChob29rc1tlbnRyeVBvaW50XSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZUhvb2tzXG4gICAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYWxsIERPTVB1cmlmeSBob29rcyBhdCBhIGdpdmVuIGVudHJ5UG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZW50cnlQb2ludCBlbnRyeSBwb2ludCBmb3IgdGhlIGhvb2tzIHRvIHJlbW92ZVxuICAgICAqL1xuICAgIERPTVB1cmlmeS5yZW1vdmVIb29rcyA9IGZ1bmN0aW9uIChlbnRyeVBvaW50KSB7XG4gICAgICBpZiAoaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgICAgaG9va3NbZW50cnlQb2ludF0gPSBbXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlQWxsSG9va3NcbiAgICAgKiBQdWJsaWMgbWV0aG9kIHRvIHJlbW92ZSBhbGwgRE9NUHVyaWZ5IGhvb2tzXG4gICAgICpcbiAgICAgKi9cbiAgICBET01QdXJpZnkucmVtb3ZlQWxsSG9va3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBob29rcyA9IHt9O1xuICAgIH07XG5cbiAgICByZXR1cm4gRE9NUHVyaWZ5O1xuICB9XG5cbiAgdmFyIHB1cmlmeSA9IGNyZWF0ZURPTVB1cmlmeSgpO1xuXG4gIHJldHVybiBwdXJpZnk7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1cmlmeS5qcy5tYXBcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTI4OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIGFycmF5LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMjIpO1xuXG4vKipcbiAqIEBtb2R1bGUgYXJyYXlcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIGFycmF5XG4gKiBmcm9tIHN0YXJ0IGluZGV4KGRlZmF1bHQgMCksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICogSXQgY29tcGFyZXMgc2VhcmNoRWxlbWVudCB0byBlbGVtZW50cyBvZiB0aGUgQXJyYXkgdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gKiAodGhlIHNhbWUgbWV0aG9kIHVzZWQgYnkgdGhlID09PSwgb3IgdHJpcGxlLWVxdWFscywgb3BlcmF0b3IpLlxuICogQHBhcmFtIHsqfSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IFN0YXJ0IGluZGV4IGluIGFycmF5IGZvciBzZWFyY2hpbmcgKGRlZmF1bHQgMClcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBGaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmFycmF5XG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgaW5BcnJheSBmcm9tICd0dWktY29kZS1zbmlwcGV0L2FycmF5L2luQXJyYXknO1xuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgaW5BcnJheSA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvYXJyYXkvaW5BcnJheScpO1xuICpcbiAqIGNvbnN0IGFyciA9IFsnb25lJywgJ3R3bycsICd0aHJlZScsICdmb3VyJ107XG4gKiBjb25zdCBpZHgxID0gaW5BcnJheSgnb25lJywgYXJyLCAzKTsgLy8gLTFcbiAqIGNvbnN0IGlkeDIgPSBpbkFycmF5KCdvbmUnLCBhcnIpOyAvLyAwXG4gKi9cbmZ1bmN0aW9uIGluQXJyYXkoc2VhcmNoRWxlbWVudCwgYXJyYXksIHN0YXJ0SW5kZXgpIHtcbiAgdmFyIGk7XG4gIHZhciBsZW5ndGg7XG4gIHN0YXJ0SW5kZXggPSBzdGFydEluZGV4IHx8IDA7XG5cbiAgaWYgKCFpc0FycmF5KGFycmF5KSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGFycmF5LCBzZWFyY2hFbGVtZW50LCBzdGFydEluZGV4KTtcbiAgfVxuXG4gIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZm9yIChpID0gc3RhcnRJbmRleDsgc3RhcnRJbmRleCA+PSAwICYmIGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChhcnJheVtpXSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY5MDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIHByb3BlcnR5IG9mIG9iamVjdChvciBlbGVtZW50IG9mIGFycmF5KSB3aGljaCBhY3R1YWxseSBleGlzdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIyKTtcbnZhciBmb3JFYWNoQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5Myk7XG52YXIgZm9yRWFjaE93blByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1Nik7XG5cbi8qKlxuICogQG1vZHVsZSBjb2xsZWN0aW9uXG4gKi9cblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIHByb3BlcnR5IG9mIG9iamVjdChvciBlbGVtZW50IG9mIGFycmF5KSB3aGljaCBhY3R1YWxseSBleGlzdC5cbiAqIElmIHRoZSBvYmplY3QgaXMgQXJyYXktbGlrZSBvYmplY3QoZXgtYXJndW1lbnRzIG9iamVjdCksIEl0IG5lZWRzIHRvIHRyYW5zZm9ybSB0byBBcnJheS4oc2VlICdleDInIG9mIGV4YW1wbGUpLlxuICogSWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UsIHRoZSBsb29wIHdpbGwgYmUgc3RvcHBlZC5cbiAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogIDEpIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkob3IgVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50KVxuICogIDIpIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eShvciBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQpXG4gKiAgMykgVGhlIG9iamVjdCBiZWluZyB0cmF2ZXJzZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSBDYWxsYmFjayBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0KHRoaXMpIG9mIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBmb3JFYWNoIGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoJzsgXG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBmb3JFYWNoID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL2ZvckVhY2gnKTsgXG4gKlxuICogbGV0IHN1bSA9IDA7XG4gKlxuICogZm9yRWFjaChbMSwyLDNdLCBmdW5jdGlvbih2YWx1ZSl7XG4gKiAgIHN1bSArPSB2YWx1ZTtcbiAqIH0pO1xuICogYWxlcnQoc3VtKTsgLy8gNlxuICpcbiAqIC8vIEluIGNhc2Ugb2YgQXJyYXktbGlrZSBvYmplY3RcbiAqIGNvbnN0IGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTsgLy8gY2hhbmdlIHRvIGFycmF5XG4gKiBmb3JFYWNoKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gKiAgIHN1bSArPSB2YWx1ZTtcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIGZvckVhY2hBcnJheShvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoT3duUHJvcGVydGllcyhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg5Mzpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5KG9yIEFycmF5LWxpa2Ugb2JqZWN0KSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIGVsZW1lbnQgcHJlc2VudFxuICogaW4gdGhlIGFycmF5KG9yIEFycmF5LWxpa2Ugb2JqZWN0KSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKiBJZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSwgdGhlIGxvb3Agd2lsbCBiZSBzdG9wcGVkLlxuICogQ2FsbGJhY2sgZnVuY3Rpb24oaXRlcmF0ZWUpIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAgMSkgVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50XG4gKiAgMikgVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50XG4gKiAgMykgVGhlIGFycmF5KG9yIEFycmF5LWxpa2Ugb2JqZWN0KSBiZWluZyB0cmF2ZXJzZWRcbiAqIEBwYXJhbSB7QXJyYXl8QXJndW1lbnRzfE5vZGVMaXN0fSBhcnIgVGhlIGFycmF5KG9yIEFycmF5LWxpa2Ugb2JqZWN0KSB0aGF0IHdpbGwgYmUgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSBDYWxsYmFjayBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0KHRoaXMpIG9mIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBmb3JFYWNoQXJyYXkgZnJvbSAndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL2ZvckVhY2hBcnJheSc7XG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBmb3JFYWNoQXJyYXkgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vZm9yRWFjaEFycmF5Jyk7IFxuICpcbiAqIGxldCBzdW0gPSAwO1xuICpcbiAqIGZvckVhY2hBcnJheShbMSwyLDNdLCBmdW5jdGlvbih2YWx1ZSl7XG4gKiAgIHN1bSArPSB2YWx1ZTtcbiAqIH0pO1xuICogYWxlcnQoc3VtKTsgLy8gNlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcblxuICBjb250ZXh0ID0gY29udGV4dCB8fCBudWxsO1xuXG4gIGZvciAoOyBpbmRleCA8IGxlbjsgaW5kZXggKz0gMSkge1xuICAgIGlmIChpdGVyYXRlZS5jYWxsKGNvbnRleHQsIGFycltpbmRleF0sIGluZGV4LCBhcnIpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaEFycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NTY6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEV4ZWN1dGUgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggcHJvcGVydHkgb2Ygb2JqZWN0IHdoaWNoIGFjdHVhbGx5IGV4aXN0LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBvYmplY3Qgd2hpY2ggYWN0dWFsbHkgZXhpc3QuXG4gKiBJZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSwgdGhlIGxvb3Agd2lsbCBiZSBzdG9wcGVkLlxuICogQ2FsbGJhY2sgZnVuY3Rpb24oaXRlcmF0ZWUpIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAgMSkgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICogIDIpIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICogIDMpIFRoZSBvYmplY3QgYmVpbmcgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQodGhpcykgb2YgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29sbGVjdGlvblxuICogQGV4YW1wbGVcbiAqIC8vIEVTNlxuICogaW1wb3J0IGZvckVhY2hPd25Qcm9wZXJ0aWVzIGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoT3duUHJvcGVydGllcyc7XG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBmb3JFYWNoT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoT3duUHJvcGVydGllcycpOyBcbiAqXG4gKiBsZXQgc3VtID0gMDtcbiAqXG4gKiBmb3JFYWNoT3duUHJvcGVydGllcyh7YToxLGI6MixjOjN9LCBmdW5jdGlvbih2YWx1ZSl7XG4gKiAgIHN1bSArPSB2YWx1ZTtcbiAqIH0pO1xuICogYWxlcnQoc3VtKTsgLy8gNlxuICovXG5mdW5jdGlvbiBmb3JFYWNoT3duUHJvcGVydGllcyhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gIHZhciBrZXk7XG5cbiAgY29udGV4dCA9IGNvbnRleHQgfHwgbnVsbDtcblxuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGlmIChpdGVyYXRlZS5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hPd25Qcm9wZXJ0aWVzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5OTA6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVHJhbnNmb3JtIHRoZSBBcnJheS1saWtlIG9iamVjdCB0byBBcnJheS5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgZm9yRWFjaEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OTMpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgQXJyYXktbGlrZSBvYmplY3QgdG8gQXJyYXkuXG4gKiBJbiBsb3cgSUUgKGJlbG93IDgpLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCBpcyBub3QgcGVyZmVjdC4gU28sIHRyeS1jYXRjaCBzdGF0ZW1lbnQgaXMgdXNlZC5cbiAqIEBwYXJhbSB7Kn0gYXJyYXlMaWtlIEFycmF5LWxpa2Ugb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCB0b0FycmF5IGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi90b0FycmF5JzsgXG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCB0b0FycmF5ID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL3RvQXJyYXknKTsgXG4gKlxuICogY29uc3QgYXJyYXlMaWtlID0ge1xuICogICAwOiAnb25lJyxcbiAqICAgMTogJ3R3bycsXG4gKiAgIDI6ICd0aHJlZScsXG4gKiAgIDM6ICdmb3VyJyxcbiAqICAgbGVuZ3RoOiA0XG4gKiB9O1xuICogY29uc3QgcmVzdWx0ID0gdG9BcnJheShhcnJheUxpa2UpO1xuICpcbiAqIGFsZXJ0KHJlc3VsdCBpbnN0YW5jZW9mIEFycmF5KTsgLy8gdHJ1ZVxuICogYWxlcnQocmVzdWx0KTsgLy8gb25lLHR3byx0aHJlZSxmb3VyXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkoYXJyYXlMaWtlKSB7XG4gIHZhciBhcnI7XG4gIHRyeSB7XG4gICAgYXJyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFyciA9IFtdO1xuICAgIGZvckVhY2hBcnJheShhcnJheUxpa2UsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBhcnIucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc1NTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgR2V0IGV2ZW50IGNvbGxlY3Rpb24gZm9yIHNwZWNpZmljIEhUTUwgZWxlbWVudFxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbnZhciBFVkVOVF9LRVkgPSAnX2ZlRXZlbnRLZXknO1xuXG4vKipcbiAqIEdldCBldmVudCBjb2xsZWN0aW9uIGZvciBzcGVjaWZpYyBIVE1MIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBIVE1MIGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZVxuICogQHJldHVybnMge2FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2FmZUV2ZW50KGVsZW1lbnQsIHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IGVsZW1lbnRbRVZFTlRfS0VZXTtcbiAgdmFyIGhhbmRsZXJzO1xuXG4gIGlmICghZXZlbnRzKSB7XG4gICAgZXZlbnRzID0gZWxlbWVudFtFVkVOVF9LRVldID0ge307XG4gIH1cblxuICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKCFoYW5kbGVycykge1xuICAgIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdID0gW107XG4gIH1cblxuICByZXR1cm4gaGFuZGxlcnM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2FmZUV2ZW50O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNDk6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVW5iaW5kIERPTSBldmVudHNcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1OCk7XG52YXIgZm9yRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oNjkwKTtcblxudmFyIHNhZmVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNzU1KTtcblxuLyoqXG4gKiBVbmJpbmQgRE9NIGV2ZW50c1xuICogSWYgYSBoYW5kbGVyIGZ1bmN0aW9uIGlzIG5vdCBwYXNzZWQsIHJlbW92ZSBhbGwgZXZlbnRzIG9mIHRoYXQgdHlwZS5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIHVuYmluZCBldmVudHNcbiAqIEBwYXJhbSB7KHN0cmluZ3xvYmplY3QpfSB0eXBlcyAtIFNwYWNlIHNwbGl0dGVkIGV2ZW50cyBuYW1lcyBvciBldmVudE5hbWU6aGFuZGxlciBvYmplY3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtoYW5kbGVyXSAtIGhhbmRsZXIgZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tRXZlbnRcbiAqIEBleGFtcGxlXG4gKiAvLyBGb2xsb3dpbmcgdGhlIGV4YW1wbGUgb2YgZG9tRXZlbnQjb25cbiAqIFxuICogLy8gVW5iaW5kIG9uZSBldmVudCBmcm9tIGFuIGVsZW1lbnQuXG4gKiBvZmYoZGl2LCAnY2xpY2snLCB0b2dnbGUpO1xuICogXG4gKiAvLyBVbmJpbmQgbXVsdGlwbGUgZXZlbnRzIHdpdGggYSBzYW1lIGhhbmRsZXIgZnJvbSBtdWx0aXBsZSBlbGVtZW50cyBhdCBvbmNlLlxuICogLy8gVXNlIGV2ZW50IG5hbWVzIHNwbGl0dGVkIGJ5IGEgc3BhY2UuXG4gKiBvZmYoZWxlbWVudCwgJ21vdXNlZW50ZXIgbW91c2VsZWF2ZScsIGNoYW5nZUNvbG9yKTtcbiAqIFxuICogLy8gVW5iaW5kIG11bHRpcGxlIGV2ZW50cyB3aXRoIGRpZmZlcmVudCBoYW5kbGVycyBmcm9tIGFuIGVsZW1lbnQgYXQgb25jZS5cbiAqIC8vIFVzZSBhbiBvYmplY3Qgd2hpY2ggb2Yga2V5IGlzIGFuIGV2ZW50IG5hbWUgYW5kIHZhbHVlIGlzIGEgaGFuZGxlciBmdW5jdGlvbi5cbiAqIG9mZihkaXYsIHtcbiAqICAga2V5ZG93bjogaGlnaGxpZ2h0LFxuICogICBrZXl1cDogZGVoaWdobGlnaHRcbiAqIH0pO1xuICogXG4gKiAvLyBVbmJpbmQgZXZlbnRzIHdpdGhvdXQgaGFuZGxlcnMuXG4gKiBvZmYoZGl2LCAnZHJhZycpO1xuICovXG5mdW5jdGlvbiBvZmYoZWxlbWVudCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgaWYgKGlzU3RyaW5nKHR5cGVzKSkge1xuICAgIGZvckVhY2godHlwZXMuc3BsaXQoL1xccysvZyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHVuYmluZEV2ZW50KGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yRWFjaCh0eXBlcywgZnVuY3Rpb24oZnVuYywgdHlwZSkge1xuICAgIHVuYmluZEV2ZW50KGVsZW1lbnQsIHR5cGUsIGZ1bmMpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBVbmJpbmQgRE9NIGV2ZW50c1xuICogSWYgYSBoYW5kbGVyIGZ1bmN0aW9uIGlzIG5vdCBwYXNzZWQsIHJlbW92ZSBhbGwgZXZlbnRzIG9mIHRoYXQgdHlwZS5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIHVuYmluZCBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnRzIG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtoYW5kbGVyXSAtIGhhbmRsZXIgZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVuYmluZEV2ZW50KGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgdmFyIGV2ZW50cyA9IHNhZmVFdmVudChlbGVtZW50LCB0eXBlKTtcbiAgdmFyIGluZGV4O1xuXG4gIGlmICghaGFuZGxlcikge1xuICAgIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIHR5cGUsIGl0ZW0ud3JhcHBlZEhhbmRsZXIpO1xuICAgIH0pO1xuICAgIGV2ZW50cy5zcGxpY2UoMCwgZXZlbnRzLmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGl0ZW0sIGlkeCkge1xuICAgICAgaWYgKGhhbmRsZXIgPT09IGl0ZW0uaGFuZGxlcikge1xuICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIHR5cGUsIGl0ZW0ud3JhcHBlZEhhbmRsZXIpO1xuICAgICAgICBpbmRleCA9IGlkeDtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBBbiBlbGVtZW50IHRvIHJlbW92ZSBhbiBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBldmVudCB0eXBlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gZXZlbnQgaGFuZGxlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gZWxlbWVudCkge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgfSBlbHNlIGlmICgnZGV0YWNoRXZlbnQnIGluIGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9mZjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzQ4OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEJpbmQgRE9NIGV2ZW50c1xuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbnZhciBpc1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oNzU4KTtcbnZhciBmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTApO1xuXG52YXIgc2FmZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NTUpO1xuXG4vKipcbiAqIEJpbmQgRE9NIGV2ZW50cy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGJpbmQgZXZlbnRzXG4gKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gdHlwZXMgLSBTcGFjZSBzcGxpdHRlZCBldmVudHMgbmFtZXMgb3IgZXZlbnROYW1lOmhhbmRsZXIgb2JqZWN0XG4gKiBAcGFyYW0geyhmdW5jdGlvbnxvYmplY3QpfSBoYW5kbGVyIC0gaGFuZGxlciBmdW5jdGlvbiBvciBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZFxuICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSBjb250ZXh0IC0gY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2QuXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbUV2ZW50XG4gKiBAZXhhbXBsZVxuICogY29uc3QgZGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZGl2Jyk7XG4gKiBcbiAqIC8vIEJpbmQgb25lIGV2ZW50IHRvIGFuIGVsZW1lbnQuXG4gKiBvbihkaXYsICdjbGljaycsIHRvZ2dsZSk7XG4gKiBcbiAqIC8vIEJpbmQgbXVsdGlwbGUgZXZlbnRzIHdpdGggYSBzYW1lIGhhbmRsZXIgdG8gbXVsdGlwbGUgZWxlbWVudHMgYXQgb25jZS5cbiAqIC8vIFVzZSBldmVudCBuYW1lcyBzcGxpdHRlZCBieSBhIHNwYWNlLlxuICogb24oZGl2LCAnbW91c2VlbnRlciBtb3VzZWxlYXZlJywgY2hhbmdlQ29sb3IpO1xuICogXG4gKiAvLyBCaW5kIG11bHRpcGxlIGV2ZW50cyB3aXRoIGRpZmZlcmVudCBoYW5kbGVycyB0byBhbiBlbGVtZW50IGF0IG9uY2UuXG4gKiAvLyBVc2UgYW4gb2JqZWN0IHdoaWNoIG9mIGtleSBpcyBhbiBldmVudCBuYW1lIGFuZCB2YWx1ZSBpcyBhIGhhbmRsZXIgZnVuY3Rpb24uXG4gKiBvbihkaXYsIHtcbiAqICAga2V5ZG93bjogaGlnaGxpZ2h0LFxuICogICBrZXl1cDogZGVoaWdobGlnaHRcbiAqIH0pO1xuICogXG4gKiAvLyBTZXQgYSBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZC5cbiAqIGNvbnN0IG5hbWUgPSAnZ2xvYmFsJztcbiAqIGNvbnN0IHJlcG9zaXRvcnkgPSB7bmFtZTogJ0NvZGVTbmlwcGV0J307XG4gKiBvbihkaXYsICdkcmFnJywgZnVuY3Rpb24oKSB7XG4gKiAgIGNvbnNvbGUubG9nKHRoaXMubmFtZSk7XG4gKiB9LCByZXBvc2l0b3J5KTtcbiAqIC8vIFJlc3VsdCB3aGVuIHlvdSBkcmFnIGEgZGl2OiBcIkNvZGVTbmlwcGV0XCJcbiAqL1xuZnVuY3Rpb24gb24oZWxlbWVudCwgdHlwZXMsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgaWYgKGlzU3RyaW5nKHR5cGVzKSkge1xuICAgIGZvckVhY2godHlwZXMuc3BsaXQoL1xccysvZyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBjb250ZXh0KTtcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvckVhY2godHlwZXMsIGZ1bmN0aW9uKGZ1bmMsIHR5cGUpIHtcbiAgICBiaW5kRXZlbnQoZWxlbWVudCwgdHlwZSwgZnVuYywgaGFuZGxlcik7XG4gIH0pO1xufVxuXG4vKipcbiAqIEJpbmQgRE9NIGV2ZW50c1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gYmluZCBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnRzIG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBoYW5kbGVyIGZ1bmN0aW9uIG9yIGNvbnRleHQgZm9yIGhhbmRsZXIgbWV0aG9kXG4gKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIGNvbnRleHQgLSBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gIC8qKlxuICAgICAqIEV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIC0gZXZlbnQgb2JqZWN0XG4gICAgICovXG4gIGZ1bmN0aW9uIGV2ZW50SGFuZGxlcihlKSB7XG4gICAgaGFuZGxlci5jYWxsKGNvbnRleHQgfHwgZWxlbWVudCwgZSB8fCB3aW5kb3cuZXZlbnQpO1xuICB9XG5cbiAgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBlbGVtZW50KSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGV2ZW50SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBlbGVtZW50KSB7XG4gICAgZWxlbWVudC5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgZXZlbnRIYW5kbGVyKTtcbiAgfVxuICBtZW1vcml6ZUhhbmRsZXIoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgZXZlbnRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBNZW1vcml6ZSBET00gZXZlbnQgaGFuZGxlciBmb3IgdW5iaW5kaW5nLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gYmluZCBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnRzIG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBoYW5kbGVyIGZ1bmN0aW9uIHRoYXQgdXNlciBwYXNzZWQgYXQgb24oKSB1c2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHdyYXBwZWRIYW5kbGVyIC0gaGFuZGxlciBmdW5jdGlvbiB0aGF0IHdyYXBwZWQgYnkgZG9tZXZlbnQgZm9yIGltcGxlbWVudGluZyBzb21lIGZlYXR1cmVzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtZW1vcml6ZUhhbmRsZXIoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgd3JhcHBlZEhhbmRsZXIpIHtcbiAgdmFyIGV2ZW50cyA9IHNhZmVFdmVudChlbGVtZW50LCB0eXBlKTtcbiAgdmFyIGV4aXN0SW5FdmVudHMgPSBmYWxzZTtcblxuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICBleGlzdEluRXZlbnRzID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICBpZiAoIWV4aXN0SW5FdmVudHMpIHtcbiAgICBldmVudHMucHVzaCh7XG4gICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgd3JhcHBlZEhhbmRsZXI6IHdyYXBwZWRIYW5kbGVyXG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjQ6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2V0IGNsYXNzTmFtZSB2YWx1ZVxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMjIpO1xudmFyIGlzVW5kZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjkpO1xuXG4vKipcbiAqIFNldCBjbGFzc05hbWUgdmFsdWVcbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IC0gdGFyZ2V0IGVsZW1lbnRcbiAqIEBwYXJhbSB7KHN0cmluZ3xzdHJpbmdbXSl9IGNzc0NsYXNzIC0gY2xhc3MgbmFtZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldENsYXNzTmFtZShlbGVtZW50LCBjc3NDbGFzcykge1xuICBjc3NDbGFzcyA9IGlzQXJyYXkoY3NzQ2xhc3MpID8gY3NzQ2xhc3Muam9pbignICcpIDogY3NzQ2xhc3M7XG5cbiAgY3NzQ2xhc3MgPSBjc3NDbGFzcy5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuXG4gIGlmIChpc1VuZGVmaW5lZChlbGVtZW50LmNsYXNzTmFtZS5iYXNlVmFsKSkge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY3NzQ2xhc3M7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50LmNsYXNzTmFtZS5iYXNlVmFsID0gY3NzQ2xhc3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2xhc3NOYW1lO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMDQ6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQWRkIGNzcyBjbGFzcyB0byBlbGVtZW50XG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxudmFyIGZvckVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5MCk7XG52YXIgaW5BcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oOTI4KTtcbnZhciBnZXRDbGFzcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTAyKTtcbnZhciBzZXRDbGFzc05hbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblxuLyoqXG4gKiBkb21VdGlsIG1vZHVsZVxuICogQG1vZHVsZSBkb21VdGlsXG4gKi9cblxuLyoqXG4gKiBBZGQgY3NzIGNsYXNzIHRvIGVsZW1lbnRcbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IC0gdGFyZ2V0IGVsZW1lbnRcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBjc3NDbGFzcyAtIGNzcyBjbGFzc2VzIHRvIGFkZFxuICogQG1lbWJlcm9mIG1vZHVsZTpkb21VdGlsXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQpIHtcbiAgdmFyIGNzc0NsYXNzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGNsYXNzTGlzdCA9IGVsZW1lbnQuY2xhc3NMaXN0O1xuICB2YXIgbmV3Q2xhc3MgPSBbXTtcbiAgdmFyIG9yaWdpbjtcblxuICBpZiAoY2xhc3NMaXN0KSB7XG4gICAgZm9yRWFjaChjc3NDbGFzcywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3JpZ2luID0gZ2V0Q2xhc3MoZWxlbWVudCk7XG5cbiAgaWYgKG9yaWdpbikge1xuICAgIGNzc0NsYXNzID0gW10uY29uY2F0KG9yaWdpbi5zcGxpdCgvXFxzKy8pLCBjc3NDbGFzcyk7XG4gIH1cblxuICBmb3JFYWNoKGNzc0NsYXNzLCBmdW5jdGlvbihjbHMpIHtcbiAgICBpZiAoaW5BcnJheShjbHMsIG5ld0NsYXNzKSA8IDApIHtcbiAgICAgIG5ld0NsYXNzLnB1c2goY2xzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHNldENsYXNzTmFtZShlbGVtZW50LCBuZXdDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkQ2xhc3M7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUyMjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTZXR0aW5nIGVsZW1lbnQgc3R5bGVcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1OCk7XG52YXIgZm9yRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oNjkwKTtcblxuLyoqXG4gKiBTZXR0aW5nIGVsZW1lbnQgc3R5bGVcbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IC0gZWxlbWVudCB0byBzZXR0aW5nIHN0eWxlXG4gKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0ga2V5IC0gc3R5bGUgcHJvcCBuYW1lIG9yIHtwcm9wOiB2YWx1ZX0gcGFpciBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdmFsdWVdIC0gc3R5bGUgdmFsdWVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiBjc3MoZWxlbWVudCwga2V5LCB2YWx1ZSkge1xuICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXG4gIGlmIChpc1N0cmluZyhrZXkpKSB7XG4gICAgc3R5bGVba2V5XSA9IHZhbHVlO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yRWFjaChrZXksIGZ1bmN0aW9uKHYsIGspIHtcbiAgICBzdHlsZVtrXSA9IHY7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNzcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTAyOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEdldCBIVE1MIGVsZW1lbnQncyBkZXNpZ24gY2xhc3Nlcy5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOSk7XG5cbi8qKlxuICogR2V0IEhUTUwgZWxlbWVudCdzIGRlc2lnbiBjbGFzc2VzLlxuICogQHBhcmFtIHsoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudCl9IGVsZW1lbnQgdGFyZ2V0IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGVsZW1lbnQgY3NzIGNsYXNzIG5hbWVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiBnZXRDbGFzcyhlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5jbGFzc05hbWUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoaXNVbmRlZmluZWQoZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCkpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWU7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRDbGFzcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzE0OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIGVsZW1lbnQgaGFzIHNwZWNpZmljIGNzcyBjbGFzc1xuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbnZhciBpbkFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjgpO1xudmFyIGdldENsYXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDIpO1xuXG4vKipcbiAqIENoZWNrIGVsZW1lbnQgaGFzIHNwZWNpZmljIGNzcyBjbGFzc1xuICogQHBhcmFtIHsoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudCl9IGVsZW1lbnQgLSB0YXJnZXQgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGNzc0NsYXNzIC0gY3NzIGNsYXNzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBjc3NDbGFzcykge1xuICB2YXIgb3JpZ2luO1xuXG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjc3NDbGFzcyk7XG4gIH1cblxuICBvcmlnaW4gPSBnZXRDbGFzcyhlbGVtZW50KS5zcGxpdCgvXFxzKy8pO1xuXG4gIHJldHVybiBpbkFycmF5KGNzc0NsYXNzLCBvcmlnaW4pID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQ2xhc3M7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ3MTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayBlbGVtZW50IG1hdGNoIHNlbGVjdG9yXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxudmFyIGluQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOCk7XG52YXIgdG9BcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oOTkwKTtcblxudmFyIGVsUHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZTtcbnZhciBtYXRjaFNlbGVjdG9yID0gZWxQcm90by5tYXRjaGVzIHx8XG4gICAgZWxQcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBlbFByb3RvLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgIGVsUHJvdG8ubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jdW1lbnQgfHwgdGhpcy5vd25lckRvY3VtZW50O1xuXG4gICAgICByZXR1cm4gaW5BcnJheSh0aGlzLCB0b0FycmF5KGRvYy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkpID4gLTE7XG4gICAgfTtcblxuLyoqXG4gKiBDaGVjayBlbGVtZW50IG1hdGNoIHNlbGVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byBjaGVja1xuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gc2VsZWN0b3IgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSBpcyBzZWxlY3RvciBtYXRjaGVkIHRvIGVsZW1lbnQ/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICByZXR1cm4gbWF0Y2hTZWxlY3Rvci5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaGVzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NjI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVtb3ZlIGNzcyBjbGFzcyBmcm9tIGVsZW1lbnRcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgZm9yRWFjaEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OTMpO1xudmFyIGluQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOCk7XG52YXIgZ2V0Q2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMik7XG52YXIgc2V0Q2xhc3NOYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cbi8qKlxuICogUmVtb3ZlIGNzcyBjbGFzcyBmcm9tIGVsZW1lbnRcbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IC0gdGFyZ2V0IGVsZW1lbnRcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBjc3NDbGFzcyAtIGNzcyBjbGFzc2VzIHRvIHJlbW92ZVxuICogQG1lbWJlcm9mIG1vZHVsZTpkb21VdGlsXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQpIHtcbiAgdmFyIGNzc0NsYXNzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGNsYXNzTGlzdCA9IGVsZW1lbnQuY2xhc3NMaXN0O1xuICB2YXIgb3JpZ2luLCBuZXdDbGFzcztcblxuICBpZiAoY2xhc3NMaXN0KSB7XG4gICAgZm9yRWFjaEFycmF5KGNzc0NsYXNzLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBjbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3JpZ2luID0gZ2V0Q2xhc3MoZWxlbWVudCkuc3BsaXQoL1xccysvKTtcbiAgbmV3Q2xhc3MgPSBbXTtcbiAgZm9yRWFjaEFycmF5KG9yaWdpbiwgZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChpbkFycmF5KG5hbWUsIGNzc0NsYXNzKSA8IDApIHtcbiAgICAgIG5ld0NsYXNzLnB1c2gobmFtZSk7XG4gICAgfVxuICB9KTtcblxuICBzZXRDbGFzc05hbWUoZWxlbWVudCwgbmV3Q2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbW92ZUNsYXNzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5Njk6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEV4dGVuZCB0aGUgdGFyZ2V0IG9iamVjdCBmcm9tIG90aGVyIG9iamVjdHMuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxuLyoqXG4gKiBAbW9kdWxlIG9iamVjdFxuICovXG5cbi8qKlxuICogRXh0ZW5kIHRoZSB0YXJnZXQgb2JqZWN0IGZyb20gb3RoZXIgb2JqZWN0cy5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgdGhhdCB3aWxsIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0gey4uLm9iamVjdH0gb2JqZWN0cyAtIE9iamVjdHMgYXMgc291cmNlc1xuICogQHJldHVybnMge29iamVjdH0gRXh0ZW5kZWQgb2JqZWN0XG4gKiBAbWVtYmVyb2YgbW9kdWxlOm9iamVjdFxuICovXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBvYmplY3RzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIGhhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgc291cmNlLCBwcm9wLCBpLCBsZW47XG5cbiAgZm9yIChpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAocHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSkge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHRlbmQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI1NDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBSZXF1ZXN0IGltYWdlIHBpbmcuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxudmFyIGZvckVhY2hPd25Qcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTYpO1xuXG4vKipcbiAqIEBtb2R1bGUgcmVxdWVzdFxuICovXG5cbi8qKlxuICogUmVxdWVzdCBpbWFnZSBwaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHVybCB1cmwgZm9yIHBpbmcgcmVxdWVzdFxuICogQHBhcmFtIHtPYmplY3R9IHRyYWNraW5nSW5mbyBpbmZvcyBmb3IgbWFrZSBxdWVyeSBzdHJpbmdcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAqIEBtZW1iZXJvZiBtb2R1bGU6cmVxdWVzdFxuICogQGV4YW1wbGVcbiAqIC8vIEVTNlxuICogaW1wb3J0IGltYWdlUGluZyBmcm9tICd0dWktY29kZS1zbmlwcGV0L3JlcXVlc3QvaW1hZ2VQaW5nJztcbiAqIFxuICogLy8gQ29tbW9uSlNcbiAqIGNvbnN0IGltYWdlUGluZyA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvcmVxdWVzdC9pbWFnZVBpbmcnKTtcbiAqXG4gKiBpbWFnZVBpbmcoJ2h0dHBzOi8vd3d3Lmdvb2dsZS1hbmFseXRpY3MuY29tL2NvbGxlY3QnLCB7XG4gKiAgIHY6IDEsXG4gKiAgIHQ6ICdldmVudCcsXG4gKiAgIHRpZDogJ3RyYWNraW5naWQnLFxuICogICBjaWQ6ICdjaWQnLFxuICogICBkcDogJ2RwJyxcbiAqICAgZGg6ICdkaCdcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBpbWFnZVBpbmcodXJsLCB0cmFja2luZ0luZm8pIHtcbiAgdmFyIHRyYWNraW5nRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICB2YXIgcXVlcnlTdHJpbmcgPSAnJztcbiAgZm9yRWFjaE93blByb3BlcnRpZXModHJhY2tpbmdJbmZvLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcXVlcnlTdHJpbmcgKz0gJyYnICsga2V5ICsgJz0nICsgdmFsdWU7XG4gIH0pO1xuICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnN1YnN0cmluZygxKTtcblxuICB0cmFja2luZ0VsZW1lbnQuc3JjID0gdXJsICsgJz8nICsgcXVlcnlTdHJpbmc7XG5cbiAgdHJhY2tpbmdFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodHJhY2tpbmdFbGVtZW50KTtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0cmFja2luZ0VsZW1lbnQpO1xuXG4gIHJldHVybiB0cmFja2luZ0VsZW1lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW1hZ2VQaW5nO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzOTE6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2VuZCBob3N0bmFtZSBvbiBET01Db250ZW50TG9hZGVkLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbnZhciBpc1VuZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5KTtcbnZhciBpbWFnZVBpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1NCk7XG5cbnZhciBtczdkYXlzID0gNyAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGRhdGUgaGFzIHBhc3NlZCA3IGRheXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkYXRlIC0gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzRXhwaXJlZChkYXRlKSB7XG4gIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICByZXR1cm4gbm93IC0gZGF0ZSA+IG1zN2RheXM7XG59XG5cbi8qKlxuICogU2VuZCBob3N0bmFtZSBvbiBET01Db250ZW50TG9hZGVkLlxuICogVG8gcHJldmVudCBob3N0bmFtZSBzZXQgdHVpLnVzYWdlU3RhdGlzdGljcyB0byBmYWxzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcHBOYW1lIC0gYXBwbGljYXRpb24gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHRyYWNraW5nSWQgLSBHQSB0cmFja2luZyBJRFxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBzZW5kSG9zdG5hbWUoYXBwTmFtZSwgdHJhY2tpbmdJZCkge1xuICB2YXIgdXJsID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZS1hbmFseXRpY3MuY29tL2NvbGxlY3QnO1xuICB2YXIgaG9zdG5hbWUgPSBsb2NhdGlvbi5ob3N0bmFtZTtcbiAgdmFyIGhpdFR5cGUgPSAnZXZlbnQnO1xuICB2YXIgZXZlbnRDYXRlZ29yeSA9ICd1c2UnO1xuICB2YXIgYXBwbGljYXRpb25LZXlGb3JTdG9yYWdlID0gJ1RPQVNUIFVJICcgKyBhcHBOYW1lICsgJyBmb3IgJyArIGhvc3RuYW1lICsgJzogU3RhdGlzdGljcyc7XG4gIHZhciBkYXRlID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGFwcGxpY2F0aW9uS2V5Rm9yU3RvcmFnZSk7XG5cbiAgLy8gc2tpcCBpZiB0aGUgZmxhZyBpcyBkZWZpbmVkIGFuZCBpcyBzZXQgdG8gZmFsc2UgZXhwbGljaXRseVxuICBpZiAoIWlzVW5kZWZpbmVkKHdpbmRvdy50dWkpICYmIHdpbmRvdy50dWkudXNhZ2VTdGF0aXN0aWNzID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNraXAgaWYgbm90IHBhc3Mgc2V2ZW4gZGF5cyBvbGRcbiAgaWYgKGRhdGUgJiYgIWlzRXhwaXJlZChkYXRlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShhcHBsaWNhdGlvbktleUZvclN0b3JhZ2UsIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGltYWdlUGluZyh1cmwsIHtcbiAgICAgICAgdjogMSxcbiAgICAgICAgdDogaGl0VHlwZSxcbiAgICAgICAgdGlkOiB0cmFja2luZ0lkLFxuICAgICAgICBjaWQ6IGhvc3RuYW1lLFxuICAgICAgICBkcDogaG9zdG5hbWUsXG4gICAgICAgIGRoOiBhcHBOYW1lLFxuICAgICAgICBlbDogYXBwTmFtZSxcbiAgICAgICAgZWM6IGV2ZW50Q2F0ZWdvcnlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgMTAwMCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2VuZEhvc3RuYW1lO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMjI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIGluc3RhbmNlIG9mIEFycmF5IG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIGluc3RhbmNlIG9mIEFycmF5IG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBpbnN0YW5jZSBvZiBBcnJheSwgcmV0dXJuIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBhcnJheSBpbnN0YW5jZT9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjU6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgZXhpc3Rpbmcgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbnZhciBpc1VuZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5KTtcbnZhciBpc051bGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzNCk7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgZXhpc3Rpbmcgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIG5vdCBudWxsIGFuZCBub3QgdW5kZWZpbmVkLCByZXR1cm5zIHRydWUuXG4gKiBAcGFyYW0geyp9IHBhcmFtIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIGV4aXN0eT9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICogQGV4YW1wbGVcbiAqIC8vIEVTNlxuICogaW1wb3J0IGlzRXhpc3R5IGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvdHlwZS9pc0V4aXN0eScpO1xuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgaXNFeGlzdHkgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L3R5cGUvaXNFeGlzdHknKTtcbiAqXG4gKiBpc0V4aXN0eSgnJyk7IC8vdHJ1ZVxuICogaXNFeGlzdHkoMCk7IC8vdHJ1ZVxuICogaXNFeGlzdHkoW10pOyAvL3RydWVcbiAqIGlzRXhpc3R5KHt9KTsgLy90cnVlXG4gKiBpc0V4aXN0eShudWxsKTsgLy9mYWxzZVxuICogaXNFeGlzdHkodW5kZWZpbmVkKTsgLy9mYWxzZVxuKi9cbmZ1bmN0aW9uIGlzRXhpc3R5KHBhcmFtKSB7XG4gIHJldHVybiAhaXNVbmRlZmluZWQocGFyYW0pICYmICFpc051bGwocGFyYW0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXhpc3R5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MDQ6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgZmFsc3kgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbnZhciBpc1RydXRoeSA9IF9fd2VicGFja19yZXF1aXJlX18oNzkwKTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBmYWxzeSBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgbnVsbCBvciB1bmRlZmluZWQgb3IgZmFsc2UsIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIGZhbHN5P1xuICogQG1lbWJlcm9mIG1vZHVsZTp0eXBlXG4gKi9cbmZ1bmN0aW9uIGlzRmFsc3kob2JqKSB7XG4gIHJldHVybiAhaXNUcnV0aHkob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZhbHN5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyOTQ6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24gb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvbiBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvbiwgcmV0dXJuIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBmdW5jdGlvbj9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRnVuY3Rpb247XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTM0OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBudWxsIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIG51bGwgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlKGFyZ3VtZW50c1swXSkgaXMgbnVsbCwgcmV0dXJucyB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgbnVsbD9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc051bGwob2JqKSB7XG4gIHJldHVybiBvYmogPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdWxsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NTg6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgc3RyaW5nIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgc3RyaW5nIG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIHN0cmluZywgcmV0dXJuIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBzdHJpbmc/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyB8fCBvYmogaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc5MDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyB0cnV0aHkgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbnZhciBpc0V4aXN0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIHRydXRoeSBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgbm90IG51bGwgb3Igbm90IHVuZGVmaW5lZCBvciBub3QgZmFsc2UsIHJldHVybnMgdHJ1ZS5cbiAqIChJdCByZWdhcmRzIDAgYXMgdHJ1ZSlcbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIHRydXRoeT9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc1RydXRoeShvYmopIHtcbiAgcmV0dXJuIGlzRXhpc3R5KG9iaikgJiYgb2JqICE9PSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RydXRoeTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTI5OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyB1bmRlZmluZWQgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgdW5kZWZpbmVkIG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIHVuZGVmaW5lZD9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmaW5lZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVW5kZWZpbmVkO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0Nzk6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NzlfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIDQ4MTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ4MV9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNDM6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180M19fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gODE0OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fODE0X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMTE6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zMTFfXztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9nbG9iYWwgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRcdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuLyoqKioqKi8gXHRcdFx0dHJ5IHtcbi8qKioqKiovIFx0XHRcdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4vKioqKioqLyBcdFx0XHR9IGNhdGNoIChlKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9KSgpO1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGluIHN0cmljdCBtb2RlLlxuIWZ1bmN0aW9uKCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIFwiZGVmYXVsdFwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gaW5kZXhWaWV3ZXI7IH1cbn0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qc1xuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciB0c2xpYl9lczZfYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0c2xpYl9lczZfYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRzbGliX2VzNl9hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5mdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9saWJzL3RvYXN0bWFyay9kaXN0L2VzbS9pbmRleC5qc1xuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xudmFyIGVzbV9leHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBlc21fZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYilcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpXG4gICAgICAgICAgICAgICAgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGVzbV9leHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcbmZ1bmN0aW9uIGVzbV9leHRlbmRzKGQsIGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgZXNtX2V4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxudmFyIGVzbV9hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gICAgZXNtX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gZXNtX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIGVzbV9zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhcilcbiAgICAgICAgICAgICAgICAgICAgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn1cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX3JlcXVpcmVfXy5nIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xudmFyIGVuY29kZUNhY2hlID0ge307XG4vLyBDcmVhdGUgYSBsb29rdXAgYXJyYXkgd2hlcmUgYW55dGhpbmcgYnV0IGNoYXJhY3RlcnMgaW4gYGNoYXJzYCBzdHJpbmdcbi8vIGFuZCBhbHBoYW51bWVyaWMgY2hhcnMgaXMgcGVyY2VudC1lbmNvZGVkLlxuLy9cbmZ1bmN0aW9uIGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgICB2YXIgaSwgY2gsIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV07XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gICAgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgICAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgICAgIGlmICgvXlswLTlhLXpdJC9pLnRlc3QoY2gpKSB7XG4gICAgICAgICAgICAvLyBhbHdheXMgYWxsb3cgdW5lbmNvZGVkIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICAgICAgICBjYWNoZS5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlLnB1c2goJyUnICsgKCcwJyArIGkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FjaGVbZXhjbHVkZS5jaGFyQ29kZUF0KGkpXSA9IGV4Y2x1ZGVbaV07XG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbn1cbi8vIEVuY29kZSB1bnNhZmUgY2hhcmFjdGVycyB3aXRoIHBlcmNlbnQtZW5jb2RpbmcsIHNraXBwaW5nIGFscmVhZHlcbi8vIGVuY29kZWQgc2VxdWVuY2VzLlxuLy9cbi8vICAtIHN0cmluZyAgICAgICAtIHN0cmluZyB0byBlbmNvZGVcbi8vICAtIGV4Y2x1ZGUgICAgICAtIGxpc3Qgb2YgY2hhcmFjdGVycyB0byBpZ25vcmUgKGluIGFkZGl0aW9uIHRvIGEtekEtWjAtOSlcbi8vICAtIGtlZXBFc2NhcGVkICAtIGRvbid0IGVuY29kZSAnJScgaW4gYSBjb3JyZWN0IGVzY2FwZSBzZXF1ZW5jZSAoZGVmYXVsdDogdHJ1ZSlcbi8vXG5mdW5jdGlvbiBlbmNvZGUkMShzdHJpbmcsIGV4Y2x1ZGUsIGtlZXBFc2NhcGVkKSB7XG4gICAgdmFyIGksIGwsIGNvZGUsIG5leHRDb2RlLCBjYWNoZSwgcmVzdWx0ID0gJyc7XG4gICAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBlbmNvZGUoc3RyaW5nLCBrZWVwRXNjYXBlZClcbiAgICAgICAga2VlcEVzY2FwZWQgPSBleGNsdWRlO1xuICAgICAgICBleGNsdWRlID0gZW5jb2RlJDEuZGVmYXVsdENoYXJzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGtlZXBFc2NhcGVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBrZWVwRXNjYXBlZCA9IHRydWU7XG4gICAgfVxuICAgIGNhY2hlID0gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSk7XG4gICAgZm9yIChpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoa2VlcEVzY2FwZWQgJiYgY29kZSA9PT0gMHgyNSAvKiAlICovICYmIGkgKyAyIDwgbCkge1xuICAgICAgICAgICAgaWYgKC9eWzAtOWEtZl17Mn0kL2kudGVzdChzdHJpbmcuc2xpY2UoaSArIDEsIGkgKyAzKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nLnNsaWNlKGksIGkgKyAzKTtcbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGUgPCAxMjgpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjYWNoZVtjb2RlXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhEQkZGICYmIGkgKyAxIDwgbCkge1xuICAgICAgICAgICAgICAgIG5leHRDb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Q29kZSA+PSAweERDMDAgJiYgbmV4dENvZGUgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nW2ldICsgc3RyaW5nW2kgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9ICclRUYlQkYlQkQnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZW5jb2RlJDEuZGVmYXVsdENoYXJzID0gXCI7Lz86QCY9KyQsLV8uIX4qJygpI1wiO1xuZW5jb2RlJDEuY29tcG9uZW50Q2hhcnMgPSBcIi1fLiF+KicoKVwiO1xudmFyIGVuY29kZV8xID0gZW5jb2RlJDE7XG52YXIgbGliID0ge307XG52YXIgZGVjb2RlID0ge307XG52YXIgQWFjdXRlJDEgPSBcIsOBXCI7XG52YXIgYWFjdXRlJDEgPSBcIsOhXCI7XG52YXIgQWJyZXZlID0gXCLEglwiO1xudmFyIGFicmV2ZSA9IFwixINcIjtcbnZhciBhYyA9IFwi4oi+XCI7XG52YXIgYWNkID0gXCLiiL9cIjtcbnZhciBhY0UgPSBcIuKIvsyzXCI7XG52YXIgQWNpcmMkMSA9IFwiw4JcIjtcbnZhciBhY2lyYyQxID0gXCLDolwiO1xudmFyIGFjdXRlJDEgPSBcIsK0XCI7XG52YXIgQWN5ID0gXCLQkFwiO1xudmFyIGFjeSA9IFwi0LBcIjtcbnZhciBBRWxpZyQxID0gXCLDhlwiO1xudmFyIGFlbGlnJDEgPSBcIsOmXCI7XG52YXIgYWYgPSBcIuKBoVwiO1xudmFyIEFmciA9IFwi8J2UhFwiO1xudmFyIGFmciA9IFwi8J2UnlwiO1xudmFyIEFncmF2ZSQxID0gXCLDgFwiO1xudmFyIGFncmF2ZSQxID0gXCLDoFwiO1xudmFyIGFsZWZzeW0gPSBcIuKEtVwiO1xudmFyIGFsZXBoID0gXCLihLVcIjtcbnZhciBBbHBoYSA9IFwizpFcIjtcbnZhciBhbHBoYSA9IFwizrFcIjtcbnZhciBBbWFjciA9IFwixIBcIjtcbnZhciBhbWFjciA9IFwixIFcIjtcbnZhciBhbWFsZyA9IFwi4qi/XCI7XG52YXIgYW1wJDIgPSBcIiZcIjtcbnZhciBBTVAkMSA9IFwiJlwiO1xudmFyIGFuZGFuZCA9IFwi4qmVXCI7XG52YXIgQW5kID0gXCLiqZNcIjtcbnZhciBhbmQgPSBcIuKIp1wiO1xudmFyIGFuZGQgPSBcIuKpnFwiO1xudmFyIGFuZHNsb3BlID0gXCLiqZhcIjtcbnZhciBhbmR2ID0gXCLiqZpcIjtcbnZhciBhbmcgPSBcIuKIoFwiO1xudmFyIGFuZ2UgPSBcIuKmpFwiO1xudmFyIGFuZ2xlID0gXCLiiKBcIjtcbnZhciBhbmdtc2RhYSA9IFwi4qaoXCI7XG52YXIgYW5nbXNkYWIgPSBcIuKmqVwiO1xudmFyIGFuZ21zZGFjID0gXCLipqpcIjtcbnZhciBhbmdtc2RhZCA9IFwi4qarXCI7XG52YXIgYW5nbXNkYWUgPSBcIuKmrFwiO1xudmFyIGFuZ21zZGFmID0gXCLipq1cIjtcbnZhciBhbmdtc2RhZyA9IFwi4qauXCI7XG52YXIgYW5nbXNkYWggPSBcIuKmr1wiO1xudmFyIGFuZ21zZCA9IFwi4oihXCI7XG52YXIgYW5ncnQgPSBcIuKIn1wiO1xudmFyIGFuZ3J0dmIgPSBcIuKKvlwiO1xudmFyIGFuZ3J0dmJkID0gXCLipp1cIjtcbnZhciBhbmdzcGggPSBcIuKIolwiO1xudmFyIGFuZ3N0ID0gXCLDhVwiO1xudmFyIGFuZ3phcnIgPSBcIuKNvFwiO1xudmFyIEFvZ29uID0gXCLEhFwiO1xudmFyIGFvZ29uID0gXCLEhVwiO1xudmFyIEFvcGYgPSBcIvCdlLhcIjtcbnZhciBhb3BmID0gXCLwnZWSXCI7XG52YXIgYXBhY2lyID0gXCLiqa9cIjtcbnZhciBhcCA9IFwi4omIXCI7XG52YXIgYXBFID0gXCLiqbBcIjtcbnZhciBhcGUgPSBcIuKJilwiO1xudmFyIGFwaWQgPSBcIuKJi1wiO1xudmFyIGFwb3MkMSA9IFwiJ1wiO1xudmFyIEFwcGx5RnVuY3Rpb24gPSBcIuKBoVwiO1xudmFyIGFwcHJveCA9IFwi4omIXCI7XG52YXIgYXBwcm94ZXEgPSBcIuKJilwiO1xudmFyIEFyaW5nJDEgPSBcIsOFXCI7XG52YXIgYXJpbmckMSA9IFwiw6VcIjtcbnZhciBBc2NyID0gXCLwnZKcXCI7XG52YXIgYXNjciA9IFwi8J2StlwiO1xudmFyIEFzc2lnbiA9IFwi4omUXCI7XG52YXIgYXN0ID0gXCIqXCI7XG52YXIgYXN5bXAgPSBcIuKJiFwiO1xudmFyIGFzeW1wZXEgPSBcIuKJjVwiO1xudmFyIEF0aWxkZSQxID0gXCLDg1wiO1xudmFyIGF0aWxkZSQxID0gXCLDo1wiO1xudmFyIEF1bWwkMSA9IFwiw4RcIjtcbnZhciBhdW1sJDEgPSBcIsOkXCI7XG52YXIgYXdjb25pbnQgPSBcIuKIs1wiO1xudmFyIGF3aW50ID0gXCLiqJFcIjtcbnZhciBiYWNrY29uZyA9IFwi4omMXCI7XG52YXIgYmFja2Vwc2lsb24gPSBcIs+2XCI7XG52YXIgYmFja3ByaW1lID0gXCLigLVcIjtcbnZhciBiYWNrc2ltID0gXCLiiL1cIjtcbnZhciBiYWNrc2ltZXEgPSBcIuKLjVwiO1xudmFyIEJhY2tzbGFzaCA9IFwi4oiWXCI7XG52YXIgQmFydiA9IFwi4qunXCI7XG52YXIgYmFydmVlID0gXCLiir1cIjtcbnZhciBiYXJ3ZWQgPSBcIuKMhVwiO1xudmFyIEJhcndlZCA9IFwi4oyGXCI7XG52YXIgYmFyd2VkZ2UgPSBcIuKMhVwiO1xudmFyIGJicmsgPSBcIuKOtVwiO1xudmFyIGJicmt0YnJrID0gXCLijrZcIjtcbnZhciBiY29uZyA9IFwi4omMXCI7XG52YXIgQmN5ID0gXCLQkVwiO1xudmFyIGJjeSA9IFwi0LFcIjtcbnZhciBiZHF1byA9IFwi4oCeXCI7XG52YXIgYmVjYXVzID0gXCLiiLVcIjtcbnZhciBiZWNhdXNlID0gXCLiiLVcIjtcbnZhciBCZWNhdXNlID0gXCLiiLVcIjtcbnZhciBiZW1wdHl2ID0gXCLiprBcIjtcbnZhciBiZXBzaSA9IFwiz7ZcIjtcbnZhciBiZXJub3UgPSBcIuKErFwiO1xudmFyIEJlcm5vdWxsaXMgPSBcIuKErFwiO1xudmFyIEJldGEgPSBcIs6SXCI7XG52YXIgYmV0YSA9IFwizrJcIjtcbnZhciBiZXRoID0gXCLihLZcIjtcbnZhciBiZXR3ZWVuID0gXCLiiaxcIjtcbnZhciBCZnIgPSBcIvCdlIVcIjtcbnZhciBiZnIgPSBcIvCdlJ9cIjtcbnZhciBiaWdjYXAgPSBcIuKLglwiO1xudmFyIGJpZ2NpcmMgPSBcIuKXr1wiO1xudmFyIGJpZ2N1cCA9IFwi4ouDXCI7XG52YXIgYmlnb2RvdCA9IFwi4qiAXCI7XG52YXIgYmlnb3BsdXMgPSBcIuKogVwiO1xudmFyIGJpZ290aW1lcyA9IFwi4qiCXCI7XG52YXIgYmlnc3FjdXAgPSBcIuKohlwiO1xudmFyIGJpZ3N0YXIgPSBcIuKYhVwiO1xudmFyIGJpZ3RyaWFuZ2xlZG93biA9IFwi4pa9XCI7XG52YXIgYmlndHJpYW5nbGV1cCA9IFwi4pazXCI7XG52YXIgYmlndXBsdXMgPSBcIuKohFwiO1xudmFyIGJpZ3ZlZSA9IFwi4ouBXCI7XG52YXIgYmlnd2VkZ2UgPSBcIuKLgFwiO1xudmFyIGJrYXJvdyA9IFwi4qSNXCI7XG52YXIgYmxhY2tsb3plbmdlID0gXCLip6tcIjtcbnZhciBibGFja3NxdWFyZSA9IFwi4paqXCI7XG52YXIgYmxhY2t0cmlhbmdsZSA9IFwi4pa0XCI7XG52YXIgYmxhY2t0cmlhbmdsZWRvd24gPSBcIuKWvlwiO1xudmFyIGJsYWNrdHJpYW5nbGVsZWZ0ID0gXCLil4JcIjtcbnZhciBibGFja3RyaWFuZ2xlcmlnaHQgPSBcIuKWuFwiO1xudmFyIGJsYW5rID0gXCLikKNcIjtcbnZhciBibGsxMiA9IFwi4paSXCI7XG52YXIgYmxrMTQgPSBcIuKWkVwiO1xudmFyIGJsazM0ID0gXCLilpNcIjtcbnZhciBibG9jayA9IFwi4paIXCI7XG52YXIgYm5lID0gXCI94oOlXCI7XG52YXIgYm5lcXVpdiA9IFwi4omh4oOlXCI7XG52YXIgYk5vdCA9IFwi4qutXCI7XG52YXIgYm5vdCA9IFwi4oyQXCI7XG52YXIgQm9wZiA9IFwi8J2UuVwiO1xudmFyIGJvcGYgPSBcIvCdlZNcIjtcbnZhciBib3QgPSBcIuKKpVwiO1xudmFyIGJvdHRvbSA9IFwi4oqlXCI7XG52YXIgYm93dGllID0gXCLii4hcIjtcbnZhciBib3hib3ggPSBcIuKniVwiO1xudmFyIGJveGRsID0gXCLilJBcIjtcbnZhciBib3hkTCA9IFwi4pWVXCI7XG52YXIgYm94RGwgPSBcIuKVllwiO1xudmFyIGJveERMID0gXCLilZdcIjtcbnZhciBib3hkciA9IFwi4pSMXCI7XG52YXIgYm94ZFIgPSBcIuKVklwiO1xudmFyIGJveERyID0gXCLilZNcIjtcbnZhciBib3hEUiA9IFwi4pWUXCI7XG52YXIgYm94aCA9IFwi4pSAXCI7XG52YXIgYm94SCA9IFwi4pWQXCI7XG52YXIgYm94aGQgPSBcIuKUrFwiO1xudmFyIGJveEhkID0gXCLilaRcIjtcbnZhciBib3hoRCA9IFwi4pWlXCI7XG52YXIgYm94SEQgPSBcIuKVplwiO1xudmFyIGJveGh1ID0gXCLilLRcIjtcbnZhciBib3hIdSA9IFwi4pWnXCI7XG52YXIgYm94aFUgPSBcIuKVqFwiO1xudmFyIGJveEhVID0gXCLilalcIjtcbnZhciBib3htaW51cyA9IFwi4oqfXCI7XG52YXIgYm94cGx1cyA9IFwi4oqeXCI7XG52YXIgYm94dGltZXMgPSBcIuKKoFwiO1xudmFyIGJveHVsID0gXCLilJhcIjtcbnZhciBib3h1TCA9IFwi4pWbXCI7XG52YXIgYm94VWwgPSBcIuKVnFwiO1xudmFyIGJveFVMID0gXCLilZ1cIjtcbnZhciBib3h1ciA9IFwi4pSUXCI7XG52YXIgYm94dVIgPSBcIuKVmFwiO1xudmFyIGJveFVyID0gXCLilZlcIjtcbnZhciBib3hVUiA9IFwi4pWaXCI7XG52YXIgYm94diA9IFwi4pSCXCI7XG52YXIgYm94ViA9IFwi4pWRXCI7XG52YXIgYm94dmggPSBcIuKUvFwiO1xudmFyIGJveHZIID0gXCLilapcIjtcbnZhciBib3hWaCA9IFwi4pWrXCI7XG52YXIgYm94VkggPSBcIuKVrFwiO1xudmFyIGJveHZsID0gXCLilKRcIjtcbnZhciBib3h2TCA9IFwi4pWhXCI7XG52YXIgYm94VmwgPSBcIuKVolwiO1xudmFyIGJveFZMID0gXCLilaNcIjtcbnZhciBib3h2ciA9IFwi4pScXCI7XG52YXIgYm94dlIgPSBcIuKVnlwiO1xudmFyIGJveFZyID0gXCLilZ9cIjtcbnZhciBib3hWUiA9IFwi4pWgXCI7XG52YXIgYnByaW1lID0gXCLigLVcIjtcbnZhciBicmV2ZSA9IFwiy5hcIjtcbnZhciBCcmV2ZSA9IFwiy5hcIjtcbnZhciBicnZiYXIkMSA9IFwiwqZcIjtcbnZhciBic2NyID0gXCLwnZK3XCI7XG52YXIgQnNjciA9IFwi4oSsXCI7XG52YXIgYnNlbWkgPSBcIuKBj1wiO1xudmFyIGJzaW0gPSBcIuKIvVwiO1xudmFyIGJzaW1lID0gXCLii41cIjtcbnZhciBic29sYiA9IFwi4qeFXCI7XG52YXIgYnNvbCA9IFwiXFxcXFwiO1xudmFyIGJzb2xoc3ViID0gXCLin4hcIjtcbnZhciBidWxsID0gXCLigKJcIjtcbnZhciBidWxsZXQgPSBcIuKAolwiO1xudmFyIGJ1bXAgPSBcIuKJjlwiO1xudmFyIGJ1bXBFID0gXCLiqq5cIjtcbnZhciBidW1wZSA9IFwi4omPXCI7XG52YXIgQnVtcGVxID0gXCLiiY5cIjtcbnZhciBidW1wZXEgPSBcIuKJj1wiO1xudmFyIENhY3V0ZSA9IFwixIZcIjtcbnZhciBjYWN1dGUgPSBcIsSHXCI7XG52YXIgY2FwYW5kID0gXCLiqYRcIjtcbnZhciBjYXBicmN1cCA9IFwi4qmJXCI7XG52YXIgY2FwY2FwID0gXCLiqYtcIjtcbnZhciBjYXAgPSBcIuKIqVwiO1xudmFyIENhcCA9IFwi4ouSXCI7XG52YXIgY2FwY3VwID0gXCLiqYdcIjtcbnZhciBjYXBkb3QgPSBcIuKpgFwiO1xudmFyIENhcGl0YWxEaWZmZXJlbnRpYWxEID0gXCLihYVcIjtcbnZhciBjYXBzID0gXCLiiKnvuIBcIjtcbnZhciBjYXJldCA9IFwi4oGBXCI7XG52YXIgY2Fyb24gPSBcIsuHXCI7XG52YXIgQ2F5bGV5cyA9IFwi4oStXCI7XG52YXIgY2NhcHMgPSBcIuKpjVwiO1xudmFyIENjYXJvbiA9IFwixIxcIjtcbnZhciBjY2Fyb24gPSBcIsSNXCI7XG52YXIgQ2NlZGlsJDEgPSBcIsOHXCI7XG52YXIgY2NlZGlsJDEgPSBcIsOnXCI7XG52YXIgQ2NpcmMgPSBcIsSIXCI7XG52YXIgY2NpcmMgPSBcIsSJXCI7XG52YXIgQ2NvbmludCA9IFwi4oiwXCI7XG52YXIgY2N1cHMgPSBcIuKpjFwiO1xudmFyIGNjdXBzc20gPSBcIuKpkFwiO1xudmFyIENkb3QgPSBcIsSKXCI7XG52YXIgY2RvdCA9IFwixItcIjtcbnZhciBjZWRpbCQxID0gXCLCuFwiO1xudmFyIENlZGlsbGEgPSBcIsK4XCI7XG52YXIgY2VtcHR5diA9IFwi4qayXCI7XG52YXIgY2VudCQxID0gXCLColwiO1xudmFyIGNlbnRlcmRvdCA9IFwiwrdcIjtcbnZhciBDZW50ZXJEb3QgPSBcIsK3XCI7XG52YXIgY2ZyID0gXCLwnZSgXCI7XG52YXIgQ2ZyID0gXCLihK1cIjtcbnZhciBDSGN5ID0gXCLQp1wiO1xudmFyIGNoY3kgPSBcItGHXCI7XG52YXIgY2hlY2sgPSBcIuKck1wiO1xudmFyIGNoZWNrbWFyayA9IFwi4pyTXCI7XG52YXIgQ2hpID0gXCLOp1wiO1xudmFyIGNoaSA9IFwiz4dcIjtcbnZhciBjaXJjID0gXCLLhlwiO1xudmFyIGNpcmNlcSA9IFwi4omXXCI7XG52YXIgY2lyY2xlYXJyb3dsZWZ0ID0gXCLihrpcIjtcbnZhciBjaXJjbGVhcnJvd3JpZ2h0ID0gXCLihrtcIjtcbnZhciBjaXJjbGVkYXN0ID0gXCLiiptcIjtcbnZhciBjaXJjbGVkY2lyYyA9IFwi4oqaXCI7XG52YXIgY2lyY2xlZGRhc2ggPSBcIuKKnVwiO1xudmFyIENpcmNsZURvdCA9IFwi4oqZXCI7XG52YXIgY2lyY2xlZFIgPSBcIsKuXCI7XG52YXIgY2lyY2xlZFMgPSBcIuKTiFwiO1xudmFyIENpcmNsZU1pbnVzID0gXCLiipZcIjtcbnZhciBDaXJjbGVQbHVzID0gXCLiipVcIjtcbnZhciBDaXJjbGVUaW1lcyA9IFwi4oqXXCI7XG52YXIgY2lyID0gXCLil4tcIjtcbnZhciBjaXJFID0gXCLip4NcIjtcbnZhciBjaXJlID0gXCLiiZdcIjtcbnZhciBjaXJmbmludCA9IFwi4qiQXCI7XG52YXIgY2lybWlkID0gXCLiq69cIjtcbnZhciBjaXJzY2lyID0gXCLip4JcIjtcbnZhciBDbG9ja3dpc2VDb250b3VySW50ZWdyYWwgPSBcIuKIslwiO1xudmFyIENsb3NlQ3VybHlEb3VibGVRdW90ZSA9IFwi4oCdXCI7XG52YXIgQ2xvc2VDdXJseVF1b3RlID0gXCLigJlcIjtcbnZhciBjbHVicyA9IFwi4pmjXCI7XG52YXIgY2x1YnN1aXQgPSBcIuKZo1wiO1xudmFyIGNvbG9uID0gXCI6XCI7XG52YXIgQ29sb24gPSBcIuKIt1wiO1xudmFyIENvbG9uZSA9IFwi4qm0XCI7XG52YXIgY29sb25lID0gXCLiiZRcIjtcbnZhciBjb2xvbmVxID0gXCLiiZRcIjtcbnZhciBjb21tYSA9IFwiLFwiO1xudmFyIGNvbW1hdCA9IFwiQFwiO1xudmFyIGNvbXAgPSBcIuKIgVwiO1xudmFyIGNvbXBmbiA9IFwi4oiYXCI7XG52YXIgY29tcGxlbWVudCA9IFwi4oiBXCI7XG52YXIgY29tcGxleGVzID0gXCLihIJcIjtcbnZhciBjb25nID0gXCLiiYVcIjtcbnZhciBjb25nZG90ID0gXCLiqa1cIjtcbnZhciBDb25ncnVlbnQgPSBcIuKJoVwiO1xudmFyIGNvbmludCA9IFwi4oiuXCI7XG52YXIgQ29uaW50ID0gXCLiiK9cIjtcbnZhciBDb250b3VySW50ZWdyYWwgPSBcIuKIrlwiO1xudmFyIGNvcGYgPSBcIvCdlZRcIjtcbnZhciBDb3BmID0gXCLihIJcIjtcbnZhciBjb3Byb2QgPSBcIuKIkFwiO1xudmFyIENvcHJvZHVjdCA9IFwi4oiQXCI7XG52YXIgY29weSQxID0gXCLCqVwiO1xudmFyIENPUFkkMSA9IFwiwqlcIjtcbnZhciBjb3B5c3IgPSBcIuKEl1wiO1xudmFyIENvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwgPSBcIuKIs1wiO1xudmFyIGNyYXJyID0gXCLihrVcIjtcbnZhciBjcm9zcyA9IFwi4pyXXCI7XG52YXIgQ3Jvc3MgPSBcIuKor1wiO1xudmFyIENzY3IgPSBcIvCdkp5cIjtcbnZhciBjc2NyID0gXCLwnZK4XCI7XG52YXIgY3N1YiA9IFwi4quPXCI7XG52YXIgY3N1YmUgPSBcIuKrkVwiO1xudmFyIGNzdXAgPSBcIuKrkFwiO1xudmFyIGNzdXBlID0gXCLiq5JcIjtcbnZhciBjdGRvdCA9IFwi4ouvXCI7XG52YXIgY3VkYXJybCA9IFwi4qS4XCI7XG52YXIgY3VkYXJyciA9IFwi4qS1XCI7XG52YXIgY3VlcHIgPSBcIuKLnlwiO1xudmFyIGN1ZXNjID0gXCLii59cIjtcbnZhciBjdWxhcnIgPSBcIuKGtlwiO1xudmFyIGN1bGFycnAgPSBcIuKkvVwiO1xudmFyIGN1cGJyY2FwID0gXCLiqYhcIjtcbnZhciBjdXBjYXAgPSBcIuKphlwiO1xudmFyIEN1cENhcCA9IFwi4omNXCI7XG52YXIgY3VwID0gXCLiiKpcIjtcbnZhciBDdXAgPSBcIuKLk1wiO1xudmFyIGN1cGN1cCA9IFwi4qmKXCI7XG52YXIgY3VwZG90ID0gXCLiio1cIjtcbnZhciBjdXBvciA9IFwi4qmFXCI7XG52YXIgY3VwcyA9IFwi4oiq77iAXCI7XG52YXIgY3VyYXJyID0gXCLihrdcIjtcbnZhciBjdXJhcnJtID0gXCLipLxcIjtcbnZhciBjdXJseWVxcHJlYyA9IFwi4oueXCI7XG52YXIgY3VybHllcXN1Y2MgPSBcIuKLn1wiO1xudmFyIGN1cmx5dmVlID0gXCLii45cIjtcbnZhciBjdXJseXdlZGdlID0gXCLii49cIjtcbnZhciBjdXJyZW4kMSA9IFwiwqRcIjtcbnZhciBjdXJ2ZWFycm93bGVmdCA9IFwi4oa2XCI7XG52YXIgY3VydmVhcnJvd3JpZ2h0ID0gXCLihrdcIjtcbnZhciBjdXZlZSA9IFwi4ouOXCI7XG52YXIgY3V3ZWQgPSBcIuKLj1wiO1xudmFyIGN3Y29uaW50ID0gXCLiiLJcIjtcbnZhciBjd2ludCA9IFwi4oixXCI7XG52YXIgY3lsY3R5ID0gXCLijK1cIjtcbnZhciBkYWdnZXIgPSBcIuKAoFwiO1xudmFyIERhZ2dlciA9IFwi4oChXCI7XG52YXIgZGFsZXRoID0gXCLihLhcIjtcbnZhciBkYXJyID0gXCLihpNcIjtcbnZhciBEYXJyID0gXCLihqFcIjtcbnZhciBkQXJyID0gXCLih5NcIjtcbnZhciBkYXNoID0gXCLigJBcIjtcbnZhciBEYXNodiA9IFwi4qukXCI7XG52YXIgZGFzaHYgPSBcIuKKo1wiO1xudmFyIGRia2Fyb3cgPSBcIuKkj1wiO1xudmFyIGRibGFjID0gXCLLnVwiO1xudmFyIERjYXJvbiA9IFwixI5cIjtcbnZhciBkY2Fyb24gPSBcIsSPXCI7XG52YXIgRGN5ID0gXCLQlFwiO1xudmFyIGRjeSA9IFwi0LRcIjtcbnZhciBkZGFnZ2VyID0gXCLigKFcIjtcbnZhciBkZGFyciA9IFwi4oeKXCI7XG52YXIgREQgPSBcIuKFhVwiO1xudmFyIGRkID0gXCLihYZcIjtcbnZhciBERG90cmFoZCA9IFwi4qSRXCI7XG52YXIgZGRvdHNlcSA9IFwi4qm3XCI7XG52YXIgZGVnJDEgPSBcIsKwXCI7XG52YXIgRGVsID0gXCLiiIdcIjtcbnZhciBEZWx0YSA9IFwizpRcIjtcbnZhciBkZWx0YSA9IFwizrRcIjtcbnZhciBkZW1wdHl2ID0gXCLiprFcIjtcbnZhciBkZmlzaHQgPSBcIuKlv1wiO1xudmFyIERmciA9IFwi8J2Uh1wiO1xudmFyIGRmciA9IFwi8J2UoVwiO1xudmFyIGRIYXIgPSBcIuKlpVwiO1xudmFyIGRoYXJsID0gXCLih4NcIjtcbnZhciBkaGFyciA9IFwi4oeCXCI7XG52YXIgRGlhY3JpdGljYWxBY3V0ZSA9IFwiwrRcIjtcbnZhciBEaWFjcml0aWNhbERvdCA9IFwiy5lcIjtcbnZhciBEaWFjcml0aWNhbERvdWJsZUFjdXRlID0gXCLLnVwiO1xudmFyIERpYWNyaXRpY2FsR3JhdmUgPSBcImBcIjtcbnZhciBEaWFjcml0aWNhbFRpbGRlID0gXCLLnFwiO1xudmFyIGRpYW0gPSBcIuKLhFwiO1xudmFyIGRpYW1vbmQgPSBcIuKLhFwiO1xudmFyIERpYW1vbmQgPSBcIuKLhFwiO1xudmFyIGRpYW1vbmRzdWl0ID0gXCLimaZcIjtcbnZhciBkaWFtcyA9IFwi4pmmXCI7XG52YXIgZGllID0gXCLCqFwiO1xudmFyIERpZmZlcmVudGlhbEQgPSBcIuKFhlwiO1xudmFyIGRpZ2FtbWEgPSBcIs+dXCI7XG52YXIgZGlzaW4gPSBcIuKLslwiO1xudmFyIGRpdiA9IFwiw7dcIjtcbnZhciBkaXZpZGUkMSA9IFwiw7dcIjtcbnZhciBkaXZpZGVvbnRpbWVzID0gXCLii4dcIjtcbnZhciBkaXZvbnggPSBcIuKLh1wiO1xudmFyIERKY3kgPSBcItCCXCI7XG52YXIgZGpjeSA9IFwi0ZJcIjtcbnZhciBkbGNvcm4gPSBcIuKMnlwiO1xudmFyIGRsY3JvcCA9IFwi4oyNXCI7XG52YXIgZG9sbGFyID0gXCIkXCI7XG52YXIgRG9wZiA9IFwi8J2Uu1wiO1xudmFyIGRvcGYgPSBcIvCdlZVcIjtcbnZhciBEb3QgPSBcIsKoXCI7XG52YXIgZG90ID0gXCLLmVwiO1xudmFyIERvdERvdCA9IFwi4oOcXCI7XG52YXIgZG90ZXEgPSBcIuKJkFwiO1xudmFyIGRvdGVxZG90ID0gXCLiiZFcIjtcbnZhciBEb3RFcXVhbCA9IFwi4omQXCI7XG52YXIgZG90bWludXMgPSBcIuKIuFwiO1xudmFyIGRvdHBsdXMgPSBcIuKIlFwiO1xudmFyIGRvdHNxdWFyZSA9IFwi4oqhXCI7XG52YXIgZG91YmxlYmFyd2VkZ2UgPSBcIuKMhlwiO1xudmFyIERvdWJsZUNvbnRvdXJJbnRlZ3JhbCA9IFwi4oivXCI7XG52YXIgRG91YmxlRG90ID0gXCLCqFwiO1xudmFyIERvdWJsZURvd25BcnJvdyA9IFwi4oeTXCI7XG52YXIgRG91YmxlTGVmdEFycm93ID0gXCLih5BcIjtcbnZhciBEb3VibGVMZWZ0UmlnaHRBcnJvdyA9IFwi4oeUXCI7XG52YXIgRG91YmxlTGVmdFRlZSA9IFwi4qukXCI7XG52YXIgRG91YmxlTG9uZ0xlZnRBcnJvdyA9IFwi4p+4XCI7XG52YXIgRG91YmxlTG9uZ0xlZnRSaWdodEFycm93ID0gXCLin7pcIjtcbnZhciBEb3VibGVMb25nUmlnaHRBcnJvdyA9IFwi4p+5XCI7XG52YXIgRG91YmxlUmlnaHRBcnJvdyA9IFwi4oeSXCI7XG52YXIgRG91YmxlUmlnaHRUZWUgPSBcIuKKqFwiO1xudmFyIERvdWJsZVVwQXJyb3cgPSBcIuKHkVwiO1xudmFyIERvdWJsZVVwRG93bkFycm93ID0gXCLih5VcIjtcbnZhciBEb3VibGVWZXJ0aWNhbEJhciA9IFwi4oilXCI7XG52YXIgRG93bkFycm93QmFyID0gXCLipJNcIjtcbnZhciBkb3duYXJyb3cgPSBcIuKGk1wiO1xudmFyIERvd25BcnJvdyA9IFwi4oaTXCI7XG52YXIgRG93bmFycm93ID0gXCLih5NcIjtcbnZhciBEb3duQXJyb3dVcEFycm93ID0gXCLih7VcIjtcbnZhciBEb3duQnJldmUgPSBcIsyRXCI7XG52YXIgZG93bmRvd25hcnJvd3MgPSBcIuKHilwiO1xudmFyIGRvd25oYXJwb29ubGVmdCA9IFwi4oeDXCI7XG52YXIgZG93bmhhcnBvb25yaWdodCA9IFwi4oeCXCI7XG52YXIgRG93bkxlZnRSaWdodFZlY3RvciA9IFwi4qWQXCI7XG52YXIgRG93bkxlZnRUZWVWZWN0b3IgPSBcIuKlnlwiO1xudmFyIERvd25MZWZ0VmVjdG9yQmFyID0gXCLipZZcIjtcbnZhciBEb3duTGVmdFZlY3RvciA9IFwi4oa9XCI7XG52YXIgRG93blJpZ2h0VGVlVmVjdG9yID0gXCLipZ9cIjtcbnZhciBEb3duUmlnaHRWZWN0b3JCYXIgPSBcIuKll1wiO1xudmFyIERvd25SaWdodFZlY3RvciA9IFwi4oeBXCI7XG52YXIgRG93blRlZUFycm93ID0gXCLihqdcIjtcbnZhciBEb3duVGVlID0gXCLiiqRcIjtcbnZhciBkcmJrYXJvdyA9IFwi4qSQXCI7XG52YXIgZHJjb3JuID0gXCLijJ9cIjtcbnZhciBkcmNyb3AgPSBcIuKMjFwiO1xudmFyIERzY3IgPSBcIvCdkp9cIjtcbnZhciBkc2NyID0gXCLwnZK5XCI7XG52YXIgRFNjeSA9IFwi0IVcIjtcbnZhciBkc2N5ID0gXCLRlVwiO1xudmFyIGRzb2wgPSBcIuKntlwiO1xudmFyIERzdHJvayA9IFwixJBcIjtcbnZhciBkc3Ryb2sgPSBcIsSRXCI7XG52YXIgZHRkb3QgPSBcIuKLsVwiO1xudmFyIGR0cmkgPSBcIuKWv1wiO1xudmFyIGR0cmlmID0gXCLilr5cIjtcbnZhciBkdWFyciA9IFwi4oe1XCI7XG52YXIgZHVoYXIgPSBcIuKlr1wiO1xudmFyIGR3YW5nbGUgPSBcIuKmplwiO1xudmFyIERaY3kgPSBcItCPXCI7XG52YXIgZHpjeSA9IFwi0Z9cIjtcbnZhciBkemlncmFyciA9IFwi4p+/XCI7XG52YXIgRWFjdXRlJDEgPSBcIsOJXCI7XG52YXIgZWFjdXRlJDEgPSBcIsOpXCI7XG52YXIgZWFzdGVyID0gXCLiqa5cIjtcbnZhciBFY2Fyb24gPSBcIsSaXCI7XG52YXIgZWNhcm9uID0gXCLEm1wiO1xudmFyIEVjaXJjJDEgPSBcIsOKXCI7XG52YXIgZWNpcmMkMSA9IFwiw6pcIjtcbnZhciBlY2lyID0gXCLiiZZcIjtcbnZhciBlY29sb24gPSBcIuKJlVwiO1xudmFyIEVjeSA9IFwi0K1cIjtcbnZhciBlY3kgPSBcItGNXCI7XG52YXIgZUREb3QgPSBcIuKpt1wiO1xudmFyIEVkb3QgPSBcIsSWXCI7XG52YXIgZWRvdCA9IFwixJdcIjtcbnZhciBlRG90ID0gXCLiiZFcIjtcbnZhciBlZSA9IFwi4oWHXCI7XG52YXIgZWZEb3QgPSBcIuKJklwiO1xudmFyIEVmciA9IFwi8J2UiFwiO1xudmFyIGVmciA9IFwi8J2UolwiO1xudmFyIGVnID0gXCLiqppcIjtcbnZhciBFZ3JhdmUkMSA9IFwiw4hcIjtcbnZhciBlZ3JhdmUkMSA9IFwiw6hcIjtcbnZhciBlZ3MgPSBcIuKqllwiO1xudmFyIGVnc2RvdCA9IFwi4qqYXCI7XG52YXIgZWwgPSBcIuKqmVwiO1xudmFyIEVsZW1lbnQgPSBcIuKIiFwiO1xudmFyIGVsaW50ZXJzID0gXCLij6dcIjtcbnZhciBlbGwgPSBcIuKEk1wiO1xudmFyIGVscyA9IFwi4qqVXCI7XG52YXIgZWxzZG90ID0gXCLiqpdcIjtcbnZhciBFbWFjciA9IFwixJJcIjtcbnZhciBlbWFjciA9IFwixJNcIjtcbnZhciBlbXB0eSA9IFwi4oiFXCI7XG52YXIgZW1wdHlzZXQgPSBcIuKIhVwiO1xudmFyIEVtcHR5U21hbGxTcXVhcmUgPSBcIuKXu1wiO1xudmFyIGVtcHR5diA9IFwi4oiFXCI7XG52YXIgRW1wdHlWZXJ5U21hbGxTcXVhcmUgPSBcIuKWq1wiO1xudmFyIGVtc3AxMyA9IFwi4oCEXCI7XG52YXIgZW1zcDE0ID0gXCLigIVcIjtcbnZhciBlbXNwID0gXCLigINcIjtcbnZhciBFTkcgPSBcIsWKXCI7XG52YXIgZW5nID0gXCLFi1wiO1xudmFyIGVuc3AgPSBcIuKAglwiO1xudmFyIEVvZ29uID0gXCLEmFwiO1xudmFyIGVvZ29uID0gXCLEmVwiO1xudmFyIEVvcGYgPSBcIvCdlLxcIjtcbnZhciBlb3BmID0gXCLwnZWWXCI7XG52YXIgZXBhciA9IFwi4ouVXCI7XG52YXIgZXBhcnNsID0gXCLip6NcIjtcbnZhciBlcGx1cyA9IFwi4qmxXCI7XG52YXIgZXBzaSA9IFwizrVcIjtcbnZhciBFcHNpbG9uID0gXCLOlVwiO1xudmFyIGVwc2lsb24gPSBcIs61XCI7XG52YXIgZXBzaXYgPSBcIs+1XCI7XG52YXIgZXFjaXJjID0gXCLiiZZcIjtcbnZhciBlcWNvbG9uID0gXCLiiZVcIjtcbnZhciBlcXNpbSA9IFwi4omCXCI7XG52YXIgZXFzbGFudGd0ciA9IFwi4qqWXCI7XG52YXIgZXFzbGFudGxlc3MgPSBcIuKqlVwiO1xudmFyIEVxdWFsID0gXCLiqbVcIjtcbnZhciBlcXVhbHMgPSBcIj1cIjtcbnZhciBFcXVhbFRpbGRlID0gXCLiiYJcIjtcbnZhciBlcXVlc3QgPSBcIuKJn1wiO1xudmFyIEVxdWlsaWJyaXVtID0gXCLih4xcIjtcbnZhciBlcXVpdiA9IFwi4omhXCI7XG52YXIgZXF1aXZERCA9IFwi4qm4XCI7XG52YXIgZXF2cGFyc2wgPSBcIuKnpVwiO1xudmFyIGVyYXJyID0gXCLipbFcIjtcbnZhciBlckRvdCA9IFwi4omTXCI7XG52YXIgZXNjciA9IFwi4oSvXCI7XG52YXIgRXNjciA9IFwi4oSwXCI7XG52YXIgZXNkb3QgPSBcIuKJkFwiO1xudmFyIEVzaW0gPSBcIuKps1wiO1xudmFyIGVzaW0gPSBcIuKJglwiO1xudmFyIEV0YSA9IFwizpdcIjtcbnZhciBldGEgPSBcIs63XCI7XG52YXIgRVRIJDEgPSBcIsOQXCI7XG52YXIgZXRoJDEgPSBcIsOwXCI7XG52YXIgRXVtbCQxID0gXCLDi1wiO1xudmFyIGV1bWwkMSA9IFwiw6tcIjtcbnZhciBldXJvID0gXCLigqxcIjtcbnZhciBleGNsID0gXCIhXCI7XG52YXIgZXhpc3QgPSBcIuKIg1wiO1xudmFyIEV4aXN0cyA9IFwi4oiDXCI7XG52YXIgZXhwZWN0YXRpb24gPSBcIuKEsFwiO1xudmFyIGV4cG9uZW50aWFsZSA9IFwi4oWHXCI7XG52YXIgRXhwb25lbnRpYWxFID0gXCLihYdcIjtcbnZhciBmYWxsaW5nZG90c2VxID0gXCLiiZJcIjtcbnZhciBGY3kgPSBcItCkXCI7XG52YXIgZmN5ID0gXCLRhFwiO1xudmFyIGZlbWFsZSA9IFwi4pmAXCI7XG52YXIgZmZpbGlnID0gXCLvrINcIjtcbnZhciBmZmxpZyA9IFwi76yAXCI7XG52YXIgZmZsbGlnID0gXCLvrIRcIjtcbnZhciBGZnIgPSBcIvCdlIlcIjtcbnZhciBmZnIgPSBcIvCdlKNcIjtcbnZhciBmaWxpZyA9IFwi76yBXCI7XG52YXIgRmlsbGVkU21hbGxTcXVhcmUgPSBcIuKXvFwiO1xudmFyIEZpbGxlZFZlcnlTbWFsbFNxdWFyZSA9IFwi4paqXCI7XG52YXIgZmpsaWcgPSBcImZqXCI7XG52YXIgZmxhdCA9IFwi4pmtXCI7XG52YXIgZmxsaWcgPSBcIu+sglwiO1xudmFyIGZsdG5zID0gXCLilrFcIjtcbnZhciBmbm9mID0gXCLGklwiO1xudmFyIEZvcGYgPSBcIvCdlL1cIjtcbnZhciBmb3BmID0gXCLwnZWXXCI7XG52YXIgZm9yYWxsID0gXCLiiIBcIjtcbnZhciBGb3JBbGwgPSBcIuKIgFwiO1xudmFyIGZvcmsgPSBcIuKLlFwiO1xudmFyIGZvcmt2ID0gXCLiq5lcIjtcbnZhciBGb3VyaWVydHJmID0gXCLihLFcIjtcbnZhciBmcGFydGludCA9IFwi4qiNXCI7XG52YXIgZnJhYzEyJDEgPSBcIsK9XCI7XG52YXIgZnJhYzEzID0gXCLihZNcIjtcbnZhciBmcmFjMTQkMSA9IFwiwrxcIjtcbnZhciBmcmFjMTUgPSBcIuKFlVwiO1xudmFyIGZyYWMxNiA9IFwi4oWZXCI7XG52YXIgZnJhYzE4ID0gXCLihZtcIjtcbnZhciBmcmFjMjMgPSBcIuKFlFwiO1xudmFyIGZyYWMyNSA9IFwi4oWWXCI7XG52YXIgZnJhYzM0JDEgPSBcIsK+XCI7XG52YXIgZnJhYzM1ID0gXCLihZdcIjtcbnZhciBmcmFjMzggPSBcIuKFnFwiO1xudmFyIGZyYWM0NSA9IFwi4oWYXCI7XG52YXIgZnJhYzU2ID0gXCLihZpcIjtcbnZhciBmcmFjNTggPSBcIuKFnVwiO1xudmFyIGZyYWM3OCA9IFwi4oWeXCI7XG52YXIgZnJhc2wgPSBcIuKBhFwiO1xudmFyIGZyb3duID0gXCLijKJcIjtcbnZhciBmc2NyID0gXCLwnZK7XCI7XG52YXIgRnNjciA9IFwi4oSxXCI7XG52YXIgZ2FjdXRlID0gXCLHtVwiO1xudmFyIEdhbW1hID0gXCLOk1wiO1xudmFyIGdhbW1hID0gXCLOs1wiO1xudmFyIEdhbW1hZCA9IFwiz5xcIjtcbnZhciBnYW1tYWQgPSBcIs+dXCI7XG52YXIgZ2FwID0gXCLiqoZcIjtcbnZhciBHYnJldmUgPSBcIsSeXCI7XG52YXIgZ2JyZXZlID0gXCLEn1wiO1xudmFyIEdjZWRpbCA9IFwixKJcIjtcbnZhciBHY2lyYyA9IFwixJxcIjtcbnZhciBnY2lyYyA9IFwixJ1cIjtcbnZhciBHY3kgPSBcItCTXCI7XG52YXIgZ2N5ID0gXCLQs1wiO1xudmFyIEdkb3QgPSBcIsSgXCI7XG52YXIgZ2RvdCA9IFwixKFcIjtcbnZhciBnZSA9IFwi4omlXCI7XG52YXIgZ0UgPSBcIuKJp1wiO1xudmFyIGdFbCA9IFwi4qqMXCI7XG52YXIgZ2VsID0gXCLii5tcIjtcbnZhciBnZXEgPSBcIuKJpVwiO1xudmFyIGdlcXEgPSBcIuKJp1wiO1xudmFyIGdlcXNsYW50ID0gXCLiqb5cIjtcbnZhciBnZXNjYyA9IFwi4qqpXCI7XG52YXIgZ2VzID0gXCLiqb5cIjtcbnZhciBnZXNkb3QgPSBcIuKqgFwiO1xudmFyIGdlc2RvdG8gPSBcIuKqglwiO1xudmFyIGdlc2RvdG9sID0gXCLiqoRcIjtcbnZhciBnZXNsID0gXCLii5vvuIBcIjtcbnZhciBnZXNsZXMgPSBcIuKqlFwiO1xudmFyIEdmciA9IFwi8J2UilwiO1xudmFyIGdmciA9IFwi8J2UpFwiO1xudmFyIGdnID0gXCLiiatcIjtcbnZhciBHZyA9IFwi4ouZXCI7XG52YXIgZ2dnID0gXCLii5lcIjtcbnZhciBnaW1lbCA9IFwi4oS3XCI7XG52YXIgR0pjeSA9IFwi0INcIjtcbnZhciBnamN5ID0gXCLRk1wiO1xudmFyIGdsYSA9IFwi4qqlXCI7XG52YXIgZ2wgPSBcIuKJt1wiO1xudmFyIGdsRSA9IFwi4qqSXCI7XG52YXIgZ2xqID0gXCLiqqRcIjtcbnZhciBnbmFwID0gXCLiqopcIjtcbnZhciBnbmFwcHJveCA9IFwi4qqKXCI7XG52YXIgZ25lID0gXCLiqohcIjtcbnZhciBnbkUgPSBcIuKJqVwiO1xudmFyIGduZXEgPSBcIuKqiFwiO1xudmFyIGduZXFxID0gXCLiialcIjtcbnZhciBnbnNpbSA9IFwi4ounXCI7XG52YXIgR29wZiA9IFwi8J2UvlwiO1xudmFyIGdvcGYgPSBcIvCdlZhcIjtcbnZhciBncmF2ZSA9IFwiYFwiO1xudmFyIEdyZWF0ZXJFcXVhbCA9IFwi4omlXCI7XG52YXIgR3JlYXRlckVxdWFsTGVzcyA9IFwi4oubXCI7XG52YXIgR3JlYXRlckZ1bGxFcXVhbCA9IFwi4omnXCI7XG52YXIgR3JlYXRlckdyZWF0ZXIgPSBcIuKqolwiO1xudmFyIEdyZWF0ZXJMZXNzID0gXCLiibdcIjtcbnZhciBHcmVhdGVyU2xhbnRFcXVhbCA9IFwi4qm+XCI7XG52YXIgR3JlYXRlclRpbGRlID0gXCLiibNcIjtcbnZhciBHc2NyID0gXCLwnZKiXCI7XG52YXIgZ3NjciA9IFwi4oSKXCI7XG52YXIgZ3NpbSA9IFwi4omzXCI7XG52YXIgZ3NpbWUgPSBcIuKqjlwiO1xudmFyIGdzaW1sID0gXCLiqpBcIjtcbnZhciBndGNjID0gXCLiqqdcIjtcbnZhciBndGNpciA9IFwi4qm6XCI7XG52YXIgZ3QkMiA9IFwiPlwiO1xudmFyIEdUJDEgPSBcIj5cIjtcbnZhciBHdCA9IFwi4omrXCI7XG52YXIgZ3Rkb3QgPSBcIuKLl1wiO1xudmFyIGd0bFBhciA9IFwi4qaVXCI7XG52YXIgZ3RxdWVzdCA9IFwi4qm8XCI7XG52YXIgZ3RyYXBwcm94ID0gXCLiqoZcIjtcbnZhciBndHJhcnIgPSBcIuKluFwiO1xudmFyIGd0cmRvdCA9IFwi4ouXXCI7XG52YXIgZ3RyZXFsZXNzID0gXCLii5tcIjtcbnZhciBndHJlcXFsZXNzID0gXCLiqoxcIjtcbnZhciBndHJsZXNzID0gXCLiibdcIjtcbnZhciBndHJzaW0gPSBcIuKJs1wiO1xudmFyIGd2ZXJ0bmVxcSA9IFwi4omp77iAXCI7XG52YXIgZ3ZuRSA9IFwi4omp77iAXCI7XG52YXIgSGFjZWsgPSBcIsuHXCI7XG52YXIgaGFpcnNwID0gXCLigIpcIjtcbnZhciBoYWxmID0gXCLCvVwiO1xudmFyIGhhbWlsdCA9IFwi4oSLXCI7XG52YXIgSEFSRGN5ID0gXCLQqlwiO1xudmFyIGhhcmRjeSA9IFwi0YpcIjtcbnZhciBoYXJyY2lyID0gXCLipYhcIjtcbnZhciBoYXJyID0gXCLihpRcIjtcbnZhciBoQXJyID0gXCLih5RcIjtcbnZhciBoYXJydyA9IFwi4oatXCI7XG52YXIgSGF0ID0gXCJeXCI7XG52YXIgaGJhciA9IFwi4oSPXCI7XG52YXIgSGNpcmMgPSBcIsSkXCI7XG52YXIgaGNpcmMgPSBcIsSlXCI7XG52YXIgaGVhcnRzID0gXCLimaVcIjtcbnZhciBoZWFydHN1aXQgPSBcIuKZpVwiO1xudmFyIGhlbGxpcCA9IFwi4oCmXCI7XG52YXIgaGVyY29uID0gXCLiirlcIjtcbnZhciBoZnIgPSBcIvCdlKVcIjtcbnZhciBIZnIgPSBcIuKEjFwiO1xudmFyIEhpbGJlcnRTcGFjZSA9IFwi4oSLXCI7XG52YXIgaGtzZWFyb3cgPSBcIuKkpVwiO1xudmFyIGhrc3dhcm93ID0gXCLipKZcIjtcbnZhciBob2FyciA9IFwi4oe/XCI7XG52YXIgaG9tdGh0ID0gXCLiiLtcIjtcbnZhciBob29rbGVmdGFycm93ID0gXCLihqlcIjtcbnZhciBob29rcmlnaHRhcnJvdyA9IFwi4oaqXCI7XG52YXIgaG9wZiA9IFwi8J2VmVwiO1xudmFyIEhvcGYgPSBcIuKEjVwiO1xudmFyIGhvcmJhciA9IFwi4oCVXCI7XG52YXIgSG9yaXpvbnRhbExpbmUgPSBcIuKUgFwiO1xudmFyIGhzY3IgPSBcIvCdkr1cIjtcbnZhciBIc2NyID0gXCLihItcIjtcbnZhciBoc2xhc2ggPSBcIuKEj1wiO1xudmFyIEhzdHJvayA9IFwixKZcIjtcbnZhciBoc3Ryb2sgPSBcIsSnXCI7XG52YXIgSHVtcERvd25IdW1wID0gXCLiiY5cIjtcbnZhciBIdW1wRXF1YWwgPSBcIuKJj1wiO1xudmFyIGh5YnVsbCA9IFwi4oGDXCI7XG52YXIgaHlwaGVuID0gXCLigJBcIjtcbnZhciBJYWN1dGUkMSA9IFwiw41cIjtcbnZhciBpYWN1dGUkMSA9IFwiw61cIjtcbnZhciBpYyA9IFwi4oGjXCI7XG52YXIgSWNpcmMkMSA9IFwiw45cIjtcbnZhciBpY2lyYyQxID0gXCLDrlwiO1xudmFyIEljeSA9IFwi0JhcIjtcbnZhciBpY3kgPSBcItC4XCI7XG52YXIgSWRvdCA9IFwixLBcIjtcbnZhciBJRWN5ID0gXCLQlVwiO1xudmFyIGllY3kgPSBcItC1XCI7XG52YXIgaWV4Y2wkMSA9IFwiwqFcIjtcbnZhciBpZmYgPSBcIuKHlFwiO1xudmFyIGlmciA9IFwi8J2UplwiO1xudmFyIElmciA9IFwi4oSRXCI7XG52YXIgSWdyYXZlJDEgPSBcIsOMXCI7XG52YXIgaWdyYXZlJDEgPSBcIsOsXCI7XG52YXIgaWkgPSBcIuKFiFwiO1xudmFyIGlpaWludCA9IFwi4qiMXCI7XG52YXIgaWlpbnQgPSBcIuKIrVwiO1xudmFyIGlpbmZpbiA9IFwi4qecXCI7XG52YXIgaWlvdGEgPSBcIuKEqVwiO1xudmFyIElKbGlnID0gXCLEslwiO1xudmFyIGlqbGlnID0gXCLEs1wiO1xudmFyIEltYWNyID0gXCLEqlwiO1xudmFyIGltYWNyID0gXCLEq1wiO1xudmFyIGVzbV9pbWFnZSA9IFwi4oSRXCI7XG52YXIgSW1hZ2luYXJ5SSA9IFwi4oWIXCI7XG52YXIgaW1hZ2xpbmUgPSBcIuKEkFwiO1xudmFyIGltYWdwYXJ0ID0gXCLihJFcIjtcbnZhciBpbWF0aCA9IFwixLFcIjtcbnZhciBJbSA9IFwi4oSRXCI7XG52YXIgaW1vZiA9IFwi4oq3XCI7XG52YXIgaW1wZWQgPSBcIsa1XCI7XG52YXIgSW1wbGllcyA9IFwi4oeSXCI7XG52YXIgaW5jYXJlID0gXCLihIVcIjtcbnZhciBpbmZpbiA9IFwi4oieXCI7XG52YXIgaW5maW50aWUgPSBcIuKnnVwiO1xudmFyIGlub2RvdCA9IFwixLFcIjtcbnZhciBpbnRjYWwgPSBcIuKKulwiO1xudmFyIGVzbV9pbnQgPSBcIuKIq1wiO1xudmFyIEludCA9IFwi4oisXCI7XG52YXIgaW50ZWdlcnMgPSBcIuKEpFwiO1xudmFyIEludGVncmFsID0gXCLiiKtcIjtcbnZhciBpbnRlcmNhbCA9IFwi4oq6XCI7XG52YXIgSW50ZXJzZWN0aW9uID0gXCLii4JcIjtcbnZhciBpbnRsYXJoayA9IFwi4qiXXCI7XG52YXIgaW50cHJvZCA9IFwi4qi8XCI7XG52YXIgSW52aXNpYmxlQ29tbWEgPSBcIuKBo1wiO1xudmFyIEludmlzaWJsZVRpbWVzID0gXCLigaJcIjtcbnZhciBJT2N5ID0gXCLQgVwiO1xudmFyIGlvY3kgPSBcItGRXCI7XG52YXIgSW9nb24gPSBcIsSuXCI7XG52YXIgaW9nb24gPSBcIsSvXCI7XG52YXIgSW9wZiA9IFwi8J2VgFwiO1xudmFyIGlvcGYgPSBcIvCdlZpcIjtcbnZhciBJb3RhID0gXCLOmVwiO1xudmFyIGlvdGEgPSBcIs65XCI7XG52YXIgaXByb2QgPSBcIuKovFwiO1xudmFyIGlxdWVzdCQxID0gXCLCv1wiO1xudmFyIGlzY3IgPSBcIvCdkr5cIjtcbnZhciBJc2NyID0gXCLihJBcIjtcbnZhciBpc2luID0gXCLiiIhcIjtcbnZhciBpc2luZG90ID0gXCLii7VcIjtcbnZhciBpc2luRSA9IFwi4ou5XCI7XG52YXIgaXNpbnMgPSBcIuKLtFwiO1xudmFyIGlzaW5zdiA9IFwi4ouzXCI7XG52YXIgaXNpbnYgPSBcIuKIiFwiO1xudmFyIGl0ID0gXCLigaJcIjtcbnZhciBJdGlsZGUgPSBcIsSoXCI7XG52YXIgaXRpbGRlID0gXCLEqVwiO1xudmFyIEl1a2N5ID0gXCLQhlwiO1xudmFyIGl1a2N5ID0gXCLRllwiO1xudmFyIEl1bWwkMSA9IFwiw49cIjtcbnZhciBpdW1sJDEgPSBcIsOvXCI7XG52YXIgSmNpcmMgPSBcIsS0XCI7XG52YXIgamNpcmMgPSBcIsS1XCI7XG52YXIgSmN5ID0gXCLQmVwiO1xudmFyIGpjeSA9IFwi0LlcIjtcbnZhciBKZnIgPSBcIvCdlI1cIjtcbnZhciBqZnIgPSBcIvCdlKdcIjtcbnZhciBqbWF0aCA9IFwiyLdcIjtcbnZhciBKb3BmID0gXCLwnZWBXCI7XG52YXIgam9wZiA9IFwi8J2Vm1wiO1xudmFyIEpzY3IgPSBcIvCdkqVcIjtcbnZhciBqc2NyID0gXCLwnZK/XCI7XG52YXIgSnNlcmN5ID0gXCLQiFwiO1xudmFyIGpzZXJjeSA9IFwi0ZhcIjtcbnZhciBKdWtjeSA9IFwi0IRcIjtcbnZhciBqdWtjeSA9IFwi0ZRcIjtcbnZhciBLYXBwYSA9IFwizppcIjtcbnZhciBrYXBwYSA9IFwizrpcIjtcbnZhciBrYXBwYXYgPSBcIs+wXCI7XG52YXIgS2NlZGlsID0gXCLEtlwiO1xudmFyIGtjZWRpbCA9IFwixLdcIjtcbnZhciBLY3kgPSBcItCaXCI7XG52YXIga2N5ID0gXCLQulwiO1xudmFyIEtmciA9IFwi8J2UjlwiO1xudmFyIGtmciA9IFwi8J2UqFwiO1xudmFyIGtncmVlbiA9IFwixLhcIjtcbnZhciBLSGN5ID0gXCLQpVwiO1xudmFyIGtoY3kgPSBcItGFXCI7XG52YXIgS0pjeSA9IFwi0IxcIjtcbnZhciBramN5ID0gXCLRnFwiO1xudmFyIEtvcGYgPSBcIvCdlYJcIjtcbnZhciBrb3BmID0gXCLwnZWcXCI7XG52YXIgS3NjciA9IFwi8J2SplwiO1xudmFyIGtzY3IgPSBcIvCdk4BcIjtcbnZhciBsQWFyciA9IFwi4oeaXCI7XG52YXIgTGFjdXRlID0gXCLEuVwiO1xudmFyIGxhY3V0ZSA9IFwixLpcIjtcbnZhciBsYWVtcHR5diA9IFwi4qa0XCI7XG52YXIgbGFncmFuID0gXCLihJJcIjtcbnZhciBMYW1iZGEgPSBcIs6bXCI7XG52YXIgbGFtYmRhID0gXCLOu1wiO1xudmFyIGxhbmcgPSBcIuKfqFwiO1xudmFyIExhbmcgPSBcIuKfqlwiO1xudmFyIGxhbmdkID0gXCLippFcIjtcbnZhciBsYW5nbGUgPSBcIuKfqFwiO1xudmFyIGxhcCA9IFwi4qqFXCI7XG52YXIgTGFwbGFjZXRyZiA9IFwi4oSSXCI7XG52YXIgbGFxdW8kMSA9IFwiwqtcIjtcbnZhciBsYXJyYiA9IFwi4oekXCI7XG52YXIgbGFycmJmcyA9IFwi4qSfXCI7XG52YXIgbGFyciA9IFwi4oaQXCI7XG52YXIgTGFyciA9IFwi4oaeXCI7XG52YXIgbEFyciA9IFwi4oeQXCI7XG52YXIgbGFycmZzID0gXCLipJ1cIjtcbnZhciBsYXJyaGsgPSBcIuKGqVwiO1xudmFyIGxhcnJscCA9IFwi4oarXCI7XG52YXIgbGFycnBsID0gXCLipLlcIjtcbnZhciBsYXJyc2ltID0gXCLipbNcIjtcbnZhciBsYXJydGwgPSBcIuKGolwiO1xudmFyIGxhdGFpbCA9IFwi4qSZXCI7XG52YXIgbEF0YWlsID0gXCLipJtcIjtcbnZhciBsYXQgPSBcIuKqq1wiO1xudmFyIGxhdGUgPSBcIuKqrVwiO1xudmFyIGxhdGVzID0gXCLiqq3vuIBcIjtcbnZhciBsYmFyciA9IFwi4qSMXCI7XG52YXIgbEJhcnIgPSBcIuKkjlwiO1xudmFyIGxiYnJrID0gXCLinbJcIjtcbnZhciBsYnJhY2UgPSBcIntcIjtcbnZhciBsYnJhY2sgPSBcIltcIjtcbnZhciBsYnJrZSA9IFwi4qaLXCI7XG52YXIgbGJya3NsZCA9IFwi4qaPXCI7XG52YXIgbGJya3NsdSA9IFwi4qaNXCI7XG52YXIgTGNhcm9uID0gXCLEvVwiO1xudmFyIGxjYXJvbiA9IFwixL5cIjtcbnZhciBMY2VkaWwgPSBcIsS7XCI7XG52YXIgbGNlZGlsID0gXCLEvFwiO1xudmFyIGxjZWlsID0gXCLijIhcIjtcbnZhciBsY3ViID0gXCJ7XCI7XG52YXIgTGN5ID0gXCLQm1wiO1xudmFyIGxjeSA9IFwi0LtcIjtcbnZhciBsZGNhID0gXCLipLZcIjtcbnZhciBsZHF1byA9IFwi4oCcXCI7XG52YXIgbGRxdW9yID0gXCLigJ5cIjtcbnZhciBsZHJkaGFyID0gXCLipadcIjtcbnZhciBsZHJ1c2hhciA9IFwi4qWLXCI7XG52YXIgbGRzaCA9IFwi4oayXCI7XG52YXIgbGUgPSBcIuKJpFwiO1xudmFyIGxFID0gXCLiiaZcIjtcbnZhciBMZWZ0QW5nbGVCcmFja2V0ID0gXCLin6hcIjtcbnZhciBMZWZ0QXJyb3dCYXIgPSBcIuKHpFwiO1xudmFyIGxlZnRhcnJvdyA9IFwi4oaQXCI7XG52YXIgTGVmdEFycm93ID0gXCLihpBcIjtcbnZhciBMZWZ0YXJyb3cgPSBcIuKHkFwiO1xudmFyIExlZnRBcnJvd1JpZ2h0QXJyb3cgPSBcIuKHhlwiO1xudmFyIGxlZnRhcnJvd3RhaWwgPSBcIuKGolwiO1xudmFyIExlZnRDZWlsaW5nID0gXCLijIhcIjtcbnZhciBMZWZ0RG91YmxlQnJhY2tldCA9IFwi4p+mXCI7XG52YXIgTGVmdERvd25UZWVWZWN0b3IgPSBcIuKloVwiO1xudmFyIExlZnREb3duVmVjdG9yQmFyID0gXCLipZlcIjtcbnZhciBMZWZ0RG93blZlY3RvciA9IFwi4oeDXCI7XG52YXIgTGVmdEZsb29yID0gXCLijIpcIjtcbnZhciBsZWZ0aGFycG9vbmRvd24gPSBcIuKGvVwiO1xudmFyIGxlZnRoYXJwb29udXAgPSBcIuKGvFwiO1xudmFyIGxlZnRsZWZ0YXJyb3dzID0gXCLih4dcIjtcbnZhciBsZWZ0cmlnaHRhcnJvdyA9IFwi4oaUXCI7XG52YXIgTGVmdFJpZ2h0QXJyb3cgPSBcIuKGlFwiO1xudmFyIExlZnRyaWdodGFycm93ID0gXCLih5RcIjtcbnZhciBsZWZ0cmlnaHRhcnJvd3MgPSBcIuKHhlwiO1xudmFyIGxlZnRyaWdodGhhcnBvb25zID0gXCLih4tcIjtcbnZhciBsZWZ0cmlnaHRzcXVpZ2Fycm93ID0gXCLihq1cIjtcbnZhciBMZWZ0UmlnaHRWZWN0b3IgPSBcIuKljlwiO1xudmFyIExlZnRUZWVBcnJvdyA9IFwi4oakXCI7XG52YXIgTGVmdFRlZSA9IFwi4oqjXCI7XG52YXIgTGVmdFRlZVZlY3RvciA9IFwi4qWaXCI7XG52YXIgbGVmdHRocmVldGltZXMgPSBcIuKLi1wiO1xudmFyIExlZnRUcmlhbmdsZUJhciA9IFwi4qePXCI7XG52YXIgTGVmdFRyaWFuZ2xlID0gXCLiirJcIjtcbnZhciBMZWZ0VHJpYW5nbGVFcXVhbCA9IFwi4oq0XCI7XG52YXIgTGVmdFVwRG93blZlY3RvciA9IFwi4qWRXCI7XG52YXIgTGVmdFVwVGVlVmVjdG9yID0gXCLipaBcIjtcbnZhciBMZWZ0VXBWZWN0b3JCYXIgPSBcIuKlmFwiO1xudmFyIExlZnRVcFZlY3RvciA9IFwi4oa/XCI7XG52YXIgTGVmdFZlY3RvckJhciA9IFwi4qWSXCI7XG52YXIgTGVmdFZlY3RvciA9IFwi4oa8XCI7XG52YXIgbEVnID0gXCLiqotcIjtcbnZhciBsZWcgPSBcIuKLmlwiO1xudmFyIGxlcSA9IFwi4omkXCI7XG52YXIgbGVxcSA9IFwi4ommXCI7XG52YXIgbGVxc2xhbnQgPSBcIuKpvVwiO1xudmFyIGxlc2NjID0gXCLiqqhcIjtcbnZhciBsZXMgPSBcIuKpvVwiO1xudmFyIGxlc2RvdCA9IFwi4qm/XCI7XG52YXIgbGVzZG90byA9IFwi4qqBXCI7XG52YXIgbGVzZG90b3IgPSBcIuKqg1wiO1xudmFyIGxlc2cgPSBcIuKLmu+4gFwiO1xudmFyIGxlc2dlcyA9IFwi4qqTXCI7XG52YXIgbGVzc2FwcHJveCA9IFwi4qqFXCI7XG52YXIgbGVzc2RvdCA9IFwi4ouWXCI7XG52YXIgbGVzc2VxZ3RyID0gXCLii5pcIjtcbnZhciBsZXNzZXFxZ3RyID0gXCLiqotcIjtcbnZhciBMZXNzRXF1YWxHcmVhdGVyID0gXCLii5pcIjtcbnZhciBMZXNzRnVsbEVxdWFsID0gXCLiiaZcIjtcbnZhciBMZXNzR3JlYXRlciA9IFwi4om2XCI7XG52YXIgbGVzc2d0ciA9IFwi4om2XCI7XG52YXIgTGVzc0xlc3MgPSBcIuKqoVwiO1xudmFyIGxlc3NzaW0gPSBcIuKJslwiO1xudmFyIExlc3NTbGFudEVxdWFsID0gXCLiqb1cIjtcbnZhciBMZXNzVGlsZGUgPSBcIuKJslwiO1xudmFyIGxmaXNodCA9IFwi4qW8XCI7XG52YXIgbGZsb29yID0gXCLijIpcIjtcbnZhciBMZnIgPSBcIvCdlI9cIjtcbnZhciBsZnIgPSBcIvCdlKlcIjtcbnZhciBsZyA9IFwi4om2XCI7XG52YXIgbGdFID0gXCLiqpFcIjtcbnZhciBsSGFyID0gXCLipaJcIjtcbnZhciBsaGFyZCA9IFwi4oa9XCI7XG52YXIgbGhhcnUgPSBcIuKGvFwiO1xudmFyIGxoYXJ1bCA9IFwi4qWqXCI7XG52YXIgbGhibGsgPSBcIuKWhFwiO1xudmFyIExKY3kgPSBcItCJXCI7XG52YXIgbGpjeSA9IFwi0ZlcIjtcbnZhciBsbGFyciA9IFwi4oeHXCI7XG52YXIgbGwgPSBcIuKJqlwiO1xudmFyIExsID0gXCLii5hcIjtcbnZhciBsbGNvcm5lciA9IFwi4oyeXCI7XG52YXIgTGxlZnRhcnJvdyA9IFwi4oeaXCI7XG52YXIgbGxoYXJkID0gXCLipatcIjtcbnZhciBsbHRyaSA9IFwi4pe6XCI7XG52YXIgTG1pZG90ID0gXCLEv1wiO1xudmFyIGxtaWRvdCA9IFwixYBcIjtcbnZhciBsbW91c3RhY2hlID0gXCLijrBcIjtcbnZhciBsbW91c3QgPSBcIuKOsFwiO1xudmFyIGxuYXAgPSBcIuKqiVwiO1xudmFyIGxuYXBwcm94ID0gXCLiqolcIjtcbnZhciBsbmUgPSBcIuKqh1wiO1xudmFyIGxuRSA9IFwi4omoXCI7XG52YXIgbG5lcSA9IFwi4qqHXCI7XG52YXIgbG5lcXEgPSBcIuKJqFwiO1xudmFyIGxuc2ltID0gXCLii6ZcIjtcbnZhciBsb2FuZyA9IFwi4p+sXCI7XG52YXIgbG9hcnIgPSBcIuKHvVwiO1xudmFyIGxvYnJrID0gXCLin6ZcIjtcbnZhciBsb25nbGVmdGFycm93ID0gXCLin7VcIjtcbnZhciBMb25nTGVmdEFycm93ID0gXCLin7VcIjtcbnZhciBMb25nbGVmdGFycm93ID0gXCLin7hcIjtcbnZhciBsb25nbGVmdHJpZ2h0YXJyb3cgPSBcIuKft1wiO1xudmFyIExvbmdMZWZ0UmlnaHRBcnJvdyA9IFwi4p+3XCI7XG52YXIgTG9uZ2xlZnRyaWdodGFycm93ID0gXCLin7pcIjtcbnZhciBsb25nbWFwc3RvID0gXCLin7xcIjtcbnZhciBsb25ncmlnaHRhcnJvdyA9IFwi4p+2XCI7XG52YXIgTG9uZ1JpZ2h0QXJyb3cgPSBcIuKftlwiO1xudmFyIExvbmdyaWdodGFycm93ID0gXCLin7lcIjtcbnZhciBsb29wYXJyb3dsZWZ0ID0gXCLihqtcIjtcbnZhciBsb29wYXJyb3dyaWdodCA9IFwi4oasXCI7XG52YXIgbG9wYXIgPSBcIuKmhVwiO1xudmFyIExvcGYgPSBcIvCdlYNcIjtcbnZhciBsb3BmID0gXCLwnZWdXCI7XG52YXIgbG9wbHVzID0gXCLiqK1cIjtcbnZhciBsb3RpbWVzID0gXCLiqLRcIjtcbnZhciBsb3dhc3QgPSBcIuKIl1wiO1xudmFyIGxvd2JhciA9IFwiX1wiO1xudmFyIExvd2VyTGVmdEFycm93ID0gXCLihplcIjtcbnZhciBMb3dlclJpZ2h0QXJyb3cgPSBcIuKGmFwiO1xudmFyIGxveiA9IFwi4peKXCI7XG52YXIgbG96ZW5nZSA9IFwi4peKXCI7XG52YXIgbG96ZiA9IFwi4qerXCI7XG52YXIgbHBhciA9IFwiKFwiO1xudmFyIGxwYXJsdCA9IFwi4qaTXCI7XG52YXIgbHJhcnIgPSBcIuKHhlwiO1xudmFyIGxyY29ybmVyID0gXCLijJ9cIjtcbnZhciBscmhhciA9IFwi4oeLXCI7XG52YXIgbHJoYXJkID0gXCLipa1cIjtcbnZhciBscm0gPSBcIuKAjlwiO1xudmFyIGxydHJpID0gXCLiir9cIjtcbnZhciBsc2FxdW8gPSBcIuKAuVwiO1xudmFyIGxzY3IgPSBcIvCdk4FcIjtcbnZhciBMc2NyID0gXCLihJJcIjtcbnZhciBsc2ggPSBcIuKGsFwiO1xudmFyIExzaCA9IFwi4oawXCI7XG52YXIgbHNpbSA9IFwi4omyXCI7XG52YXIgbHNpbWUgPSBcIuKqjVwiO1xudmFyIGxzaW1nID0gXCLiqo9cIjtcbnZhciBsc3FiID0gXCJbXCI7XG52YXIgbHNxdW8gPSBcIuKAmFwiO1xudmFyIGxzcXVvciA9IFwi4oCaXCI7XG52YXIgTHN0cm9rID0gXCLFgVwiO1xudmFyIGxzdHJvayA9IFwixYJcIjtcbnZhciBsdGNjID0gXCLiqqZcIjtcbnZhciBsdGNpciA9IFwi4qm5XCI7XG52YXIgbHQkMiA9IFwiPFwiO1xudmFyIExUJDEgPSBcIjxcIjtcbnZhciBMdCA9IFwi4omqXCI7XG52YXIgbHRkb3QgPSBcIuKLllwiO1xudmFyIGx0aHJlZSA9IFwi4ouLXCI7XG52YXIgbHRpbWVzID0gXCLii4lcIjtcbnZhciBsdGxhcnIgPSBcIuKltlwiO1xudmFyIGx0cXVlc3QgPSBcIuKpu1wiO1xudmFyIGx0cmkgPSBcIuKXg1wiO1xudmFyIGx0cmllID0gXCLiirRcIjtcbnZhciBsdHJpZiA9IFwi4peCXCI7XG52YXIgbHRyUGFyID0gXCLippZcIjtcbnZhciBsdXJkc2hhciA9IFwi4qWKXCI7XG52YXIgbHVydWhhciA9IFwi4qWmXCI7XG52YXIgbHZlcnRuZXFxID0gXCLiiajvuIBcIjtcbnZhciBsdm5FID0gXCLiiajvuIBcIjtcbnZhciBtYWNyJDEgPSBcIsKvXCI7XG52YXIgbWFsZSA9IFwi4pmCXCI7XG52YXIgbWFsdCA9IFwi4pygXCI7XG52YXIgbWFsdGVzZSA9IFwi4pygXCI7XG52YXIgbWFwID0gXCLihqZcIjtcbnZhciBtYXBzdG8gPSBcIuKGplwiO1xudmFyIG1hcHN0b2Rvd24gPSBcIuKGp1wiO1xudmFyIG1hcHN0b2xlZnQgPSBcIuKGpFwiO1xudmFyIG1hcHN0b3VwID0gXCLihqVcIjtcbnZhciBtYXJrZXIgPSBcIuKWrlwiO1xudmFyIG1jb21tYSA9IFwi4qipXCI7XG52YXIgTWN5ID0gXCLQnFwiO1xudmFyIG1jeSA9IFwi0LxcIjtcbnZhciBtZGFzaCA9IFwi4oCUXCI7XG52YXIgbUREb3QgPSBcIuKIulwiO1xudmFyIG1lYXN1cmVkYW5nbGUgPSBcIuKIoVwiO1xudmFyIE1lZGl1bVNwYWNlID0gXCLigZ9cIjtcbnZhciBNZWxsaW50cmYgPSBcIuKEs1wiO1xudmFyIE1mciA9IFwi8J2UkFwiO1xudmFyIG1mciA9IFwi8J2UqlwiO1xudmFyIG1obyA9IFwi4oSnXCI7XG52YXIgbWljcm8kMSA9IFwiwrVcIjtcbnZhciBtaWRhc3QgPSBcIipcIjtcbnZhciBtaWRjaXIgPSBcIuKrsFwiO1xudmFyIG1pZCA9IFwi4oijXCI7XG52YXIgbWlkZG90JDEgPSBcIsK3XCI7XG52YXIgbWludXNiID0gXCLiip9cIjtcbnZhciBtaW51cyA9IFwi4oiSXCI7XG52YXIgbWludXNkID0gXCLiiLhcIjtcbnZhciBtaW51c2R1ID0gXCLiqKpcIjtcbnZhciBNaW51c1BsdXMgPSBcIuKIk1wiO1xudmFyIG1sY3AgPSBcIuKrm1wiO1xudmFyIG1sZHIgPSBcIuKAplwiO1xudmFyIG1ucGx1cyA9IFwi4oiTXCI7XG52YXIgbW9kZWxzID0gXCLiiqdcIjtcbnZhciBNb3BmID0gXCLwnZWEXCI7XG52YXIgbW9wZiA9IFwi8J2VnlwiO1xudmFyIG1wID0gXCLiiJNcIjtcbnZhciBtc2NyID0gXCLwnZOCXCI7XG52YXIgTXNjciA9IFwi4oSzXCI7XG52YXIgbXN0cG9zID0gXCLiiL5cIjtcbnZhciBNdSA9IFwizpxcIjtcbnZhciBtdSA9IFwizrxcIjtcbnZhciBtdWx0aW1hcCA9IFwi4oq4XCI7XG52YXIgbXVtYXAgPSBcIuKKuFwiO1xudmFyIG5hYmxhID0gXCLiiIdcIjtcbnZhciBOYWN1dGUgPSBcIsWDXCI7XG52YXIgbmFjdXRlID0gXCLFhFwiO1xudmFyIG5hbmcgPSBcIuKIoOKDklwiO1xudmFyIG5hcCA9IFwi4omJXCI7XG52YXIgbmFwRSA9IFwi4qmwzLhcIjtcbnZhciBuYXBpZCA9IFwi4omLzLhcIjtcbnZhciBuYXBvcyA9IFwixYlcIjtcbnZhciBuYXBwcm94ID0gXCLiiYlcIjtcbnZhciBuYXR1cmFsID0gXCLima5cIjtcbnZhciBuYXR1cmFscyA9IFwi4oSVXCI7XG52YXIgbmF0dXIgPSBcIuKZrlwiO1xudmFyIG5ic3AkMSA9IFwiwqBcIjtcbnZhciBuYnVtcCA9IFwi4omOzLhcIjtcbnZhciBuYnVtcGUgPSBcIuKJj8y4XCI7XG52YXIgbmNhcCA9IFwi4qmDXCI7XG52YXIgTmNhcm9uID0gXCLFh1wiO1xudmFyIG5jYXJvbiA9IFwixYhcIjtcbnZhciBOY2VkaWwgPSBcIsWFXCI7XG52YXIgbmNlZGlsID0gXCLFhlwiO1xudmFyIG5jb25nID0gXCLiiYdcIjtcbnZhciBuY29uZ2RvdCA9IFwi4qmtzLhcIjtcbnZhciBuY3VwID0gXCLiqYJcIjtcbnZhciBOY3kgPSBcItCdXCI7XG52YXIgbmN5ID0gXCLQvVwiO1xudmFyIG5kYXNoID0gXCLigJNcIjtcbnZhciBuZWFyaGsgPSBcIuKkpFwiO1xudmFyIG5lYXJyID0gXCLihpdcIjtcbnZhciBuZUFyciA9IFwi4oeXXCI7XG52YXIgbmVhcnJvdyA9IFwi4oaXXCI7XG52YXIgbmUgPSBcIuKJoFwiO1xudmFyIG5lZG90ID0gXCLiiZDMuFwiO1xudmFyIE5lZ2F0aXZlTWVkaXVtU3BhY2UgPSBcIuKAi1wiO1xudmFyIE5lZ2F0aXZlVGhpY2tTcGFjZSA9IFwi4oCLXCI7XG52YXIgTmVnYXRpdmVUaGluU3BhY2UgPSBcIuKAi1wiO1xudmFyIE5lZ2F0aXZlVmVyeVRoaW5TcGFjZSA9IFwi4oCLXCI7XG52YXIgbmVxdWl2ID0gXCLiiaJcIjtcbnZhciBuZXNlYXIgPSBcIuKkqFwiO1xudmFyIG5lc2ltID0gXCLiiYLMuFwiO1xudmFyIE5lc3RlZEdyZWF0ZXJHcmVhdGVyID0gXCLiiatcIjtcbnZhciBOZXN0ZWRMZXNzTGVzcyA9IFwi4omqXCI7XG52YXIgTmV3TGluZSA9IFwiXFxuXCI7XG52YXIgbmV4aXN0ID0gXCLiiIRcIjtcbnZhciBuZXhpc3RzID0gXCLiiIRcIjtcbnZhciBOZnIgPSBcIvCdlJFcIjtcbnZhciBuZnIgPSBcIvCdlKtcIjtcbnZhciBuZ0UgPSBcIuKJp8y4XCI7XG52YXIgbmdlID0gXCLiibFcIjtcbnZhciBuZ2VxID0gXCLiibFcIjtcbnZhciBuZ2VxcSA9IFwi4omnzLhcIjtcbnZhciBuZ2Vxc2xhbnQgPSBcIuKpvsy4XCI7XG52YXIgbmdlcyA9IFwi4qm+zLhcIjtcbnZhciBuR2cgPSBcIuKLmcy4XCI7XG52YXIgbmdzaW0gPSBcIuKJtVwiO1xudmFyIG5HdCA9IFwi4omr4oOSXCI7XG52YXIgbmd0ID0gXCLiia9cIjtcbnZhciBuZ3RyID0gXCLiia9cIjtcbnZhciBuR3R2ID0gXCLiiavMuFwiO1xudmFyIG5oYXJyID0gXCLihq5cIjtcbnZhciBuaEFyciA9IFwi4oeOXCI7XG52YXIgbmhwYXIgPSBcIuKrslwiO1xudmFyIG5pID0gXCLiiItcIjtcbnZhciBuaXMgPSBcIuKLvFwiO1xudmFyIG5pc2QgPSBcIuKLulwiO1xudmFyIG5pdiA9IFwi4oiLXCI7XG52YXIgTkpjeSA9IFwi0IpcIjtcbnZhciBuamN5ID0gXCLRmlwiO1xudmFyIG5sYXJyID0gXCLihppcIjtcbnZhciBubEFyciA9IFwi4oeNXCI7XG52YXIgbmxkciA9IFwi4oClXCI7XG52YXIgbmxFID0gXCLiiabMuFwiO1xudmFyIG5sZSA9IFwi4omwXCI7XG52YXIgbmxlZnRhcnJvdyA9IFwi4oaaXCI7XG52YXIgbkxlZnRhcnJvdyA9IFwi4oeNXCI7XG52YXIgbmxlZnRyaWdodGFycm93ID0gXCLihq5cIjtcbnZhciBuTGVmdHJpZ2h0YXJyb3cgPSBcIuKHjlwiO1xudmFyIG5sZXEgPSBcIuKJsFwiO1xudmFyIG5sZXFxID0gXCLiiabMuFwiO1xudmFyIG5sZXFzbGFudCA9IFwi4qm9zLhcIjtcbnZhciBubGVzID0gXCLiqb3MuFwiO1xudmFyIG5sZXNzID0gXCLiia5cIjtcbnZhciBuTGwgPSBcIuKLmMy4XCI7XG52YXIgbmxzaW0gPSBcIuKJtFwiO1xudmFyIG5MdCA9IFwi4omq4oOSXCI7XG52YXIgbmx0ID0gXCLiia5cIjtcbnZhciBubHRyaSA9IFwi4ouqXCI7XG52YXIgbmx0cmllID0gXCLii6xcIjtcbnZhciBuTHR2ID0gXCLiiarMuFwiO1xudmFyIG5taWQgPSBcIuKIpFwiO1xudmFyIE5vQnJlYWsgPSBcIuKBoFwiO1xudmFyIE5vbkJyZWFraW5nU3BhY2UgPSBcIsKgXCI7XG52YXIgbm9wZiA9IFwi8J2Vn1wiO1xudmFyIE5vcGYgPSBcIuKElVwiO1xudmFyIE5vdCA9IFwi4qusXCI7XG52YXIgbm90JDEgPSBcIsKsXCI7XG52YXIgTm90Q29uZ3J1ZW50ID0gXCLiiaJcIjtcbnZhciBOb3RDdXBDYXAgPSBcIuKJrVwiO1xudmFyIE5vdERvdWJsZVZlcnRpY2FsQmFyID0gXCLiiKZcIjtcbnZhciBOb3RFbGVtZW50ID0gXCLiiIlcIjtcbnZhciBOb3RFcXVhbCA9IFwi4omgXCI7XG52YXIgTm90RXF1YWxUaWxkZSA9IFwi4omCzLhcIjtcbnZhciBOb3RFeGlzdHMgPSBcIuKIhFwiO1xudmFyIE5vdEdyZWF0ZXIgPSBcIuKJr1wiO1xudmFyIE5vdEdyZWF0ZXJFcXVhbCA9IFwi4omxXCI7XG52YXIgTm90R3JlYXRlckZ1bGxFcXVhbCA9IFwi4omnzLhcIjtcbnZhciBOb3RHcmVhdGVyR3JlYXRlciA9IFwi4omrzLhcIjtcbnZhciBOb3RHcmVhdGVyTGVzcyA9IFwi4om5XCI7XG52YXIgTm90R3JlYXRlclNsYW50RXF1YWwgPSBcIuKpvsy4XCI7XG52YXIgTm90R3JlYXRlclRpbGRlID0gXCLiibVcIjtcbnZhciBOb3RIdW1wRG93bkh1bXAgPSBcIuKJjsy4XCI7XG52YXIgTm90SHVtcEVxdWFsID0gXCLiiY/MuFwiO1xudmFyIG5vdGluID0gXCLiiIlcIjtcbnZhciBub3RpbmRvdCA9IFwi4ou1zLhcIjtcbnZhciBub3RpbkUgPSBcIuKLucy4XCI7XG52YXIgbm90aW52YSA9IFwi4oiJXCI7XG52YXIgbm90aW52YiA9IFwi4ou3XCI7XG52YXIgbm90aW52YyA9IFwi4ou2XCI7XG52YXIgTm90TGVmdFRyaWFuZ2xlQmFyID0gXCLip4/MuFwiO1xudmFyIE5vdExlZnRUcmlhbmdsZSA9IFwi4ouqXCI7XG52YXIgTm90TGVmdFRyaWFuZ2xlRXF1YWwgPSBcIuKLrFwiO1xudmFyIE5vdExlc3MgPSBcIuKJrlwiO1xudmFyIE5vdExlc3NFcXVhbCA9IFwi4omwXCI7XG52YXIgTm90TGVzc0dyZWF0ZXIgPSBcIuKJuFwiO1xudmFyIE5vdExlc3NMZXNzID0gXCLiiarMuFwiO1xudmFyIE5vdExlc3NTbGFudEVxdWFsID0gXCLiqb3MuFwiO1xudmFyIE5vdExlc3NUaWxkZSA9IFwi4om0XCI7XG52YXIgTm90TmVzdGVkR3JlYXRlckdyZWF0ZXIgPSBcIuKqosy4XCI7XG52YXIgTm90TmVzdGVkTGVzc0xlc3MgPSBcIuKqocy4XCI7XG52YXIgbm90bmkgPSBcIuKIjFwiO1xudmFyIG5vdG5pdmEgPSBcIuKIjFwiO1xudmFyIG5vdG5pdmIgPSBcIuKLvlwiO1xudmFyIG5vdG5pdmMgPSBcIuKLvVwiO1xudmFyIE5vdFByZWNlZGVzID0gXCLiioBcIjtcbnZhciBOb3RQcmVjZWRlc0VxdWFsID0gXCLiqq/MuFwiO1xudmFyIE5vdFByZWNlZGVzU2xhbnRFcXVhbCA9IFwi4ougXCI7XG52YXIgTm90UmV2ZXJzZUVsZW1lbnQgPSBcIuKIjFwiO1xudmFyIE5vdFJpZ2h0VHJpYW5nbGVCYXIgPSBcIuKnkMy4XCI7XG52YXIgTm90UmlnaHRUcmlhbmdsZSA9IFwi4ourXCI7XG52YXIgTm90UmlnaHRUcmlhbmdsZUVxdWFsID0gXCLii61cIjtcbnZhciBOb3RTcXVhcmVTdWJzZXQgPSBcIuKKj8y4XCI7XG52YXIgTm90U3F1YXJlU3Vic2V0RXF1YWwgPSBcIuKLolwiO1xudmFyIE5vdFNxdWFyZVN1cGVyc2V0ID0gXCLiipDMuFwiO1xudmFyIE5vdFNxdWFyZVN1cGVyc2V0RXF1YWwgPSBcIuKLo1wiO1xudmFyIE5vdFN1YnNldCA9IFwi4oqC4oOSXCI7XG52YXIgTm90U3Vic2V0RXF1YWwgPSBcIuKKiFwiO1xudmFyIE5vdFN1Y2NlZWRzID0gXCLiioFcIjtcbnZhciBOb3RTdWNjZWVkc0VxdWFsID0gXCLiqrDMuFwiO1xudmFyIE5vdFN1Y2NlZWRzU2xhbnRFcXVhbCA9IFwi4ouhXCI7XG52YXIgTm90U3VjY2VlZHNUaWxkZSA9IFwi4om/zLhcIjtcbnZhciBOb3RTdXBlcnNldCA9IFwi4oqD4oOSXCI7XG52YXIgTm90U3VwZXJzZXRFcXVhbCA9IFwi4oqJXCI7XG52YXIgTm90VGlsZGUgPSBcIuKJgVwiO1xudmFyIE5vdFRpbGRlRXF1YWwgPSBcIuKJhFwiO1xudmFyIE5vdFRpbGRlRnVsbEVxdWFsID0gXCLiiYdcIjtcbnZhciBOb3RUaWxkZVRpbGRlID0gXCLiiYlcIjtcbnZhciBOb3RWZXJ0aWNhbEJhciA9IFwi4oikXCI7XG52YXIgbnBhcmFsbGVsID0gXCLiiKZcIjtcbnZhciBucGFyID0gXCLiiKZcIjtcbnZhciBucGFyc2wgPSBcIuKrveKDpVwiO1xudmFyIG5wYXJ0ID0gXCLiiILMuFwiO1xudmFyIG5wb2xpbnQgPSBcIuKolFwiO1xudmFyIG5wciA9IFwi4oqAXCI7XG52YXIgbnByY3VlID0gXCLii6BcIjtcbnZhciBucHJlYyA9IFwi4oqAXCI7XG52YXIgbnByZWNlcSA9IFwi4qqvzLhcIjtcbnZhciBucHJlID0gXCLiqq/MuFwiO1xudmFyIG5yYXJyYyA9IFwi4qSzzLhcIjtcbnZhciBucmFyciA9IFwi4oabXCI7XG52YXIgbnJBcnIgPSBcIuKHj1wiO1xudmFyIG5yYXJydyA9IFwi4oadzLhcIjtcbnZhciBucmlnaHRhcnJvdyA9IFwi4oabXCI7XG52YXIgblJpZ2h0YXJyb3cgPSBcIuKHj1wiO1xudmFyIG5ydHJpID0gXCLii6tcIjtcbnZhciBucnRyaWUgPSBcIuKLrVwiO1xudmFyIG5zYyA9IFwi4oqBXCI7XG52YXIgbnNjY3VlID0gXCLii6FcIjtcbnZhciBuc2NlID0gXCLiqrDMuFwiO1xudmFyIE5zY3IgPSBcIvCdkqlcIjtcbnZhciBuc2NyID0gXCLwnZODXCI7XG52YXIgbnNob3J0bWlkID0gXCLiiKRcIjtcbnZhciBuc2hvcnRwYXJhbGxlbCA9IFwi4oimXCI7XG52YXIgbnNpbSA9IFwi4omBXCI7XG52YXIgbnNpbWUgPSBcIuKJhFwiO1xudmFyIG5zaW1lcSA9IFwi4omEXCI7XG52YXIgbnNtaWQgPSBcIuKIpFwiO1xudmFyIG5zcGFyID0gXCLiiKZcIjtcbnZhciBuc3FzdWJlID0gXCLii6JcIjtcbnZhciBuc3FzdXBlID0gXCLii6NcIjtcbnZhciBuc3ViID0gXCLiioRcIjtcbnZhciBuc3ViRSA9IFwi4quFzLhcIjtcbnZhciBuc3ViZSA9IFwi4oqIXCI7XG52YXIgbnN1YnNldCA9IFwi4oqC4oOSXCI7XG52YXIgbnN1YnNldGVxID0gXCLiiohcIjtcbnZhciBuc3Vic2V0ZXFxID0gXCLiq4XMuFwiO1xudmFyIG5zdWNjID0gXCLiioFcIjtcbnZhciBuc3VjY2VxID0gXCLiqrDMuFwiO1xudmFyIG5zdXAgPSBcIuKKhVwiO1xudmFyIG5zdXBFID0gXCLiq4bMuFwiO1xudmFyIG5zdXBlID0gXCLiiolcIjtcbnZhciBuc3Vwc2V0ID0gXCLiioPig5JcIjtcbnZhciBuc3Vwc2V0ZXEgPSBcIuKKiVwiO1xudmFyIG5zdXBzZXRlcXEgPSBcIuKrhsy4XCI7XG52YXIgbnRnbCA9IFwi4om5XCI7XG52YXIgTnRpbGRlJDEgPSBcIsORXCI7XG52YXIgbnRpbGRlJDEgPSBcIsOxXCI7XG52YXIgbnRsZyA9IFwi4om4XCI7XG52YXIgbnRyaWFuZ2xlbGVmdCA9IFwi4ouqXCI7XG52YXIgbnRyaWFuZ2xlbGVmdGVxID0gXCLii6xcIjtcbnZhciBudHJpYW5nbGVyaWdodCA9IFwi4ourXCI7XG52YXIgbnRyaWFuZ2xlcmlnaHRlcSA9IFwi4outXCI7XG52YXIgTnUgPSBcIs6dXCI7XG52YXIgbnUgPSBcIs69XCI7XG52YXIgbnVtID0gXCIjXCI7XG52YXIgbnVtZXJvID0gXCLihJZcIjtcbnZhciBudW1zcCA9IFwi4oCHXCI7XG52YXIgbnZhcCA9IFwi4omN4oOSXCI7XG52YXIgbnZkYXNoID0gXCLiiqxcIjtcbnZhciBudkRhc2ggPSBcIuKKrVwiO1xudmFyIG5WZGFzaCA9IFwi4oquXCI7XG52YXIgblZEYXNoID0gXCLiiq9cIjtcbnZhciBudmdlID0gXCLiiaXig5JcIjtcbnZhciBudmd0ID0gXCI+4oOSXCI7XG52YXIgbnZIYXJyID0gXCLipIRcIjtcbnZhciBudmluZmluID0gXCLip55cIjtcbnZhciBudmxBcnIgPSBcIuKkglwiO1xudmFyIG52bGUgPSBcIuKJpOKDklwiO1xudmFyIG52bHQgPSBcIjzig5JcIjtcbnZhciBudmx0cmllID0gXCLiirTig5JcIjtcbnZhciBudnJBcnIgPSBcIuKkg1wiO1xudmFyIG52cnRyaWUgPSBcIuKKteKDklwiO1xudmFyIG52c2ltID0gXCLiiLzig5JcIjtcbnZhciBud2FyaGsgPSBcIuKko1wiO1xudmFyIG53YXJyID0gXCLihpZcIjtcbnZhciBud0FyciA9IFwi4oeWXCI7XG52YXIgbndhcnJvdyA9IFwi4oaWXCI7XG52YXIgbnduZWFyID0gXCLipKdcIjtcbnZhciBPYWN1dGUkMSA9IFwiw5NcIjtcbnZhciBvYWN1dGUkMSA9IFwiw7NcIjtcbnZhciBvYXN0ID0gXCLiiptcIjtcbnZhciBPY2lyYyQxID0gXCLDlFwiO1xudmFyIG9jaXJjJDEgPSBcIsO0XCI7XG52YXIgb2NpciA9IFwi4oqaXCI7XG52YXIgT2N5ID0gXCLQnlwiO1xudmFyIG9jeSA9IFwi0L5cIjtcbnZhciBvZGFzaCA9IFwi4oqdXCI7XG52YXIgT2RibGFjID0gXCLFkFwiO1xudmFyIG9kYmxhYyA9IFwixZFcIjtcbnZhciBvZGl2ID0gXCLiqLhcIjtcbnZhciBvZG90ID0gXCLiiplcIjtcbnZhciBvZHNvbGQgPSBcIuKmvFwiO1xudmFyIE9FbGlnID0gXCLFklwiO1xudmFyIG9lbGlnID0gXCLFk1wiO1xudmFyIG9mY2lyID0gXCLipr9cIjtcbnZhciBPZnIgPSBcIvCdlJJcIjtcbnZhciBvZnIgPSBcIvCdlKxcIjtcbnZhciBvZ29uID0gXCLLm1wiO1xudmFyIE9ncmF2ZSQxID0gXCLDklwiO1xudmFyIG9ncmF2ZSQxID0gXCLDslwiO1xudmFyIG9ndCA9IFwi4qeBXCI7XG52YXIgb2hiYXIgPSBcIuKmtVwiO1xudmFyIG9obSA9IFwizqlcIjtcbnZhciBvaW50ID0gXCLiiK5cIjtcbnZhciBvbGFyciA9IFwi4oa6XCI7XG52YXIgb2xjaXIgPSBcIuKmvlwiO1xudmFyIG9sY3Jvc3MgPSBcIuKmu1wiO1xudmFyIG9saW5lID0gXCLigL5cIjtcbnZhciBvbHQgPSBcIuKngFwiO1xudmFyIE9tYWNyID0gXCLFjFwiO1xudmFyIG9tYWNyID0gXCLFjVwiO1xudmFyIE9tZWdhID0gXCLOqVwiO1xudmFyIG9tZWdhID0gXCLPiVwiO1xudmFyIE9taWNyb24gPSBcIs6fXCI7XG52YXIgb21pY3JvbiA9IFwizr9cIjtcbnZhciBvbWlkID0gXCLiprZcIjtcbnZhciBvbWludXMgPSBcIuKKllwiO1xudmFyIE9vcGYgPSBcIvCdlYZcIjtcbnZhciBvb3BmID0gXCLwnZWgXCI7XG52YXIgb3BhciA9IFwi4qa3XCI7XG52YXIgT3BlbkN1cmx5RG91YmxlUXVvdGUgPSBcIuKAnFwiO1xudmFyIE9wZW5DdXJseVF1b3RlID0gXCLigJhcIjtcbnZhciBvcGVycCA9IFwi4qa5XCI7XG52YXIgb3BsdXMgPSBcIuKKlVwiO1xudmFyIG9yYXJyID0gXCLihrtcIjtcbnZhciBPciA9IFwi4qmUXCI7XG52YXIgb3IgPSBcIuKIqFwiO1xudmFyIG9yZCA9IFwi4qmdXCI7XG52YXIgb3JkZXIgPSBcIuKEtFwiO1xudmFyIG9yZGVyb2YgPSBcIuKEtFwiO1xudmFyIG9yZGYkMSA9IFwiwqpcIjtcbnZhciBvcmRtJDEgPSBcIsK6XCI7XG52YXIgb3JpZ29mID0gXCLiirZcIjtcbnZhciBvcm9yID0gXCLiqZZcIjtcbnZhciBvcnNsb3BlID0gXCLiqZdcIjtcbnZhciBvcnYgPSBcIuKpm1wiO1xudmFyIG9TID0gXCLik4hcIjtcbnZhciBPc2NyID0gXCLwnZKqXCI7XG52YXIgb3NjciA9IFwi4oS0XCI7XG52YXIgT3NsYXNoJDEgPSBcIsOYXCI7XG52YXIgb3NsYXNoJDEgPSBcIsO4XCI7XG52YXIgb3NvbCA9IFwi4oqYXCI7XG52YXIgT3RpbGRlJDEgPSBcIsOVXCI7XG52YXIgb3RpbGRlJDEgPSBcIsO1XCI7XG52YXIgb3RpbWVzYXMgPSBcIuKotlwiO1xudmFyIE90aW1lcyA9IFwi4qi3XCI7XG52YXIgb3RpbWVzID0gXCLiipdcIjtcbnZhciBPdW1sJDEgPSBcIsOWXCI7XG52YXIgb3VtbCQxID0gXCLDtlwiO1xudmFyIG92YmFyID0gXCLijL1cIjtcbnZhciBPdmVyQmFyID0gXCLigL5cIjtcbnZhciBPdmVyQnJhY2UgPSBcIuKPnlwiO1xudmFyIE92ZXJCcmFja2V0ID0gXCLijrRcIjtcbnZhciBPdmVyUGFyZW50aGVzaXMgPSBcIuKPnFwiO1xudmFyIHBhcmEkMSA9IFwiwrZcIjtcbnZhciBwYXJhbGxlbCA9IFwi4oilXCI7XG52YXIgcGFyID0gXCLiiKVcIjtcbnZhciBwYXJzaW0gPSBcIuKrs1wiO1xudmFyIHBhcnNsID0gXCLiq71cIjtcbnZhciBwYXJ0ID0gXCLiiIJcIjtcbnZhciBQYXJ0aWFsRCA9IFwi4oiCXCI7XG52YXIgUGN5ID0gXCLQn1wiO1xudmFyIHBjeSA9IFwi0L9cIjtcbnZhciBwZXJjbnQgPSBcIiVcIjtcbnZhciBwZXJpb2QgPSBcIi5cIjtcbnZhciBwZXJtaWwgPSBcIuKAsFwiO1xudmFyIHBlcnAgPSBcIuKKpVwiO1xudmFyIHBlcnRlbmsgPSBcIuKAsVwiO1xudmFyIFBmciA9IFwi8J2Uk1wiO1xudmFyIHBmciA9IFwi8J2UrVwiO1xudmFyIFBoaSA9IFwizqZcIjtcbnZhciBwaGkgPSBcIs+GXCI7XG52YXIgcGhpdiA9IFwiz5VcIjtcbnZhciBwaG1tYXQgPSBcIuKEs1wiO1xudmFyIHBob25lID0gXCLimI5cIjtcbnZhciBQaSA9IFwizqBcIjtcbnZhciBwaSA9IFwiz4BcIjtcbnZhciBwaXRjaGZvcmsgPSBcIuKLlFwiO1xudmFyIHBpdiA9IFwiz5ZcIjtcbnZhciBwbGFuY2sgPSBcIuKEj1wiO1xudmFyIHBsYW5ja2ggPSBcIuKEjlwiO1xudmFyIHBsYW5rdiA9IFwi4oSPXCI7XG52YXIgcGx1c2FjaXIgPSBcIuKoo1wiO1xudmFyIHBsdXNiID0gXCLiip5cIjtcbnZhciBwbHVzY2lyID0gXCLiqKJcIjtcbnZhciBwbHVzID0gXCIrXCI7XG52YXIgcGx1c2RvID0gXCLiiJRcIjtcbnZhciBwbHVzZHUgPSBcIuKopVwiO1xudmFyIHBsdXNlID0gXCLiqbJcIjtcbnZhciBQbHVzTWludXMgPSBcIsKxXCI7XG52YXIgcGx1c21uJDEgPSBcIsKxXCI7XG52YXIgcGx1c3NpbSA9IFwi4qimXCI7XG52YXIgcGx1c3R3byA9IFwi4qinXCI7XG52YXIgcG0gPSBcIsKxXCI7XG52YXIgUG9pbmNhcmVwbGFuZSA9IFwi4oSMXCI7XG52YXIgcG9pbnRpbnQgPSBcIuKolVwiO1xudmFyIHBvcGYgPSBcIvCdlaFcIjtcbnZhciBQb3BmID0gXCLihJlcIjtcbnZhciBwb3VuZCQxID0gXCLCo1wiO1xudmFyIHByYXAgPSBcIuKqt1wiO1xudmFyIFByID0gXCLiqrtcIjtcbnZhciBwciA9IFwi4om6XCI7XG52YXIgcHJjdWUgPSBcIuKJvFwiO1xudmFyIHByZWNhcHByb3ggPSBcIuKqt1wiO1xudmFyIHByZWMgPSBcIuKJulwiO1xudmFyIHByZWNjdXJseWVxID0gXCLiibxcIjtcbnZhciBQcmVjZWRlcyA9IFwi4om6XCI7XG52YXIgUHJlY2VkZXNFcXVhbCA9IFwi4qqvXCI7XG52YXIgUHJlY2VkZXNTbGFudEVxdWFsID0gXCLiibxcIjtcbnZhciBQcmVjZWRlc1RpbGRlID0gXCLiib5cIjtcbnZhciBwcmVjZXEgPSBcIuKqr1wiO1xudmFyIHByZWNuYXBwcm94ID0gXCLiqrlcIjtcbnZhciBwcmVjbmVxcSA9IFwi4qq1XCI7XG52YXIgcHJlY25zaW0gPSBcIuKLqFwiO1xudmFyIHByZSA9IFwi4qqvXCI7XG52YXIgcHJFID0gXCLiqrNcIjtcbnZhciBwcmVjc2ltID0gXCLiib5cIjtcbnZhciBwcmltZSA9IFwi4oCyXCI7XG52YXIgUHJpbWUgPSBcIuKAs1wiO1xudmFyIHByaW1lcyA9IFwi4oSZXCI7XG52YXIgcHJuYXAgPSBcIuKquVwiO1xudmFyIHBybkUgPSBcIuKqtVwiO1xudmFyIHBybnNpbSA9IFwi4ouoXCI7XG52YXIgcHJvZCA9IFwi4oiPXCI7XG52YXIgUHJvZHVjdCA9IFwi4oiPXCI7XG52YXIgcHJvZmFsYXIgPSBcIuKMrlwiO1xudmFyIHByb2ZsaW5lID0gXCLijJJcIjtcbnZhciBwcm9mc3VyZiA9IFwi4oyTXCI7XG52YXIgcHJvcCA9IFwi4oidXCI7XG52YXIgUHJvcG9ydGlvbmFsID0gXCLiiJ1cIjtcbnZhciBQcm9wb3J0aW9uID0gXCLiiLdcIjtcbnZhciBwcm9wdG8gPSBcIuKInVwiO1xudmFyIHByc2ltID0gXCLiib5cIjtcbnZhciBwcnVyZWwgPSBcIuKKsFwiO1xudmFyIFBzY3IgPSBcIvCdkqtcIjtcbnZhciBwc2NyID0gXCLwnZOFXCI7XG52YXIgUHNpID0gXCLOqFwiO1xudmFyIHBzaSA9IFwiz4hcIjtcbnZhciBwdW5jc3AgPSBcIuKAiFwiO1xudmFyIFFmciA9IFwi8J2UlFwiO1xudmFyIHFmciA9IFwi8J2UrlwiO1xudmFyIHFpbnQgPSBcIuKojFwiO1xudmFyIHFvcGYgPSBcIvCdlaJcIjtcbnZhciBRb3BmID0gXCLihJpcIjtcbnZhciBxcHJpbWUgPSBcIuKBl1wiO1xudmFyIFFzY3IgPSBcIvCdkqxcIjtcbnZhciBxc2NyID0gXCLwnZOGXCI7XG52YXIgcXVhdGVybmlvbnMgPSBcIuKEjVwiO1xudmFyIHF1YXRpbnQgPSBcIuKollwiO1xudmFyIHF1ZXN0ID0gXCI/XCI7XG52YXIgcXVlc3RlcSA9IFwi4omfXCI7XG52YXIgcXVvdCQyID0gXCJcXFwiXCI7XG52YXIgUVVPVCQxID0gXCJcXFwiXCI7XG52YXIgckFhcnIgPSBcIuKHm1wiO1xudmFyIHJhY2UgPSBcIuKIvcyxXCI7XG52YXIgUmFjdXRlID0gXCLFlFwiO1xudmFyIHJhY3V0ZSA9IFwixZVcIjtcbnZhciByYWRpYyA9IFwi4oiaXCI7XG52YXIgcmFlbXB0eXYgPSBcIuKms1wiO1xudmFyIHJhbmcgPSBcIuKfqVwiO1xudmFyIFJhbmcgPSBcIuKfq1wiO1xudmFyIHJhbmdkID0gXCLippJcIjtcbnZhciByYW5nZSA9IFwi4qalXCI7XG52YXIgcmFuZ2xlID0gXCLin6lcIjtcbnZhciByYXF1byQxID0gXCLCu1wiO1xudmFyIHJhcnJhcCA9IFwi4qW1XCI7XG52YXIgcmFycmIgPSBcIuKHpVwiO1xudmFyIHJhcnJiZnMgPSBcIuKkoFwiO1xudmFyIHJhcnJjID0gXCLipLNcIjtcbnZhciByYXJyID0gXCLihpJcIjtcbnZhciBSYXJyID0gXCLihqBcIjtcbnZhciByQXJyID0gXCLih5JcIjtcbnZhciByYXJyZnMgPSBcIuKknlwiO1xudmFyIHJhcnJoayA9IFwi4oaqXCI7XG52YXIgcmFycmxwID0gXCLihqxcIjtcbnZhciByYXJycGwgPSBcIuKlhVwiO1xudmFyIHJhcnJzaW0gPSBcIuKltFwiO1xudmFyIFJhcnJ0bCA9IFwi4qSWXCI7XG52YXIgcmFycnRsID0gXCLihqNcIjtcbnZhciByYXJydyA9IFwi4oadXCI7XG52YXIgcmF0YWlsID0gXCLipJpcIjtcbnZhciByQXRhaWwgPSBcIuKknFwiO1xudmFyIHJhdGlvID0gXCLiiLZcIjtcbnZhciByYXRpb25hbHMgPSBcIuKEmlwiO1xudmFyIHJiYXJyID0gXCLipI1cIjtcbnZhciByQmFyciA9IFwi4qSPXCI7XG52YXIgUkJhcnIgPSBcIuKkkFwiO1xudmFyIHJiYnJrID0gXCLinbNcIjtcbnZhciByYnJhY2UgPSBcIn1cIjtcbnZhciByYnJhY2sgPSBcIl1cIjtcbnZhciByYnJrZSA9IFwi4qaMXCI7XG52YXIgcmJya3NsZCA9IFwi4qaOXCI7XG52YXIgcmJya3NsdSA9IFwi4qaQXCI7XG52YXIgUmNhcm9uID0gXCLFmFwiO1xudmFyIHJjYXJvbiA9IFwixZlcIjtcbnZhciBSY2VkaWwgPSBcIsWWXCI7XG52YXIgcmNlZGlsID0gXCLFl1wiO1xudmFyIHJjZWlsID0gXCLijIlcIjtcbnZhciByY3ViID0gXCJ9XCI7XG52YXIgUmN5ID0gXCLQoFwiO1xudmFyIHJjeSA9IFwi0YBcIjtcbnZhciByZGNhID0gXCLipLdcIjtcbnZhciByZGxkaGFyID0gXCLipalcIjtcbnZhciByZHF1byA9IFwi4oCdXCI7XG52YXIgcmRxdW9yID0gXCLigJ1cIjtcbnZhciByZHNoID0gXCLihrNcIjtcbnZhciByZWFsID0gXCLihJxcIjtcbnZhciByZWFsaW5lID0gXCLihJtcIjtcbnZhciByZWFscGFydCA9IFwi4oScXCI7XG52YXIgcmVhbHMgPSBcIuKEnVwiO1xudmFyIFJlID0gXCLihJxcIjtcbnZhciByZWN0ID0gXCLilq1cIjtcbnZhciByZWckMSA9IFwiwq5cIjtcbnZhciBSRUckMSA9IFwiwq5cIjtcbnZhciBSZXZlcnNlRWxlbWVudCA9IFwi4oiLXCI7XG52YXIgUmV2ZXJzZUVxdWlsaWJyaXVtID0gXCLih4tcIjtcbnZhciBSZXZlcnNlVXBFcXVpbGlicml1bSA9IFwi4qWvXCI7XG52YXIgcmZpc2h0ID0gXCLipb1cIjtcbnZhciByZmxvb3IgPSBcIuKMi1wiO1xudmFyIHJmciA9IFwi8J2Ur1wiO1xudmFyIFJmciA9IFwi4oScXCI7XG52YXIgckhhciA9IFwi4qWkXCI7XG52YXIgcmhhcmQgPSBcIuKHgVwiO1xudmFyIHJoYXJ1ID0gXCLih4BcIjtcbnZhciByaGFydWwgPSBcIuKlrFwiO1xudmFyIFJobyA9IFwizqFcIjtcbnZhciByaG8gPSBcIs+BXCI7XG52YXIgcmhvdiA9IFwiz7FcIjtcbnZhciBSaWdodEFuZ2xlQnJhY2tldCA9IFwi4p+pXCI7XG52YXIgUmlnaHRBcnJvd0JhciA9IFwi4oelXCI7XG52YXIgcmlnaHRhcnJvdyA9IFwi4oaSXCI7XG52YXIgUmlnaHRBcnJvdyA9IFwi4oaSXCI7XG52YXIgUmlnaHRhcnJvdyA9IFwi4oeSXCI7XG52YXIgUmlnaHRBcnJvd0xlZnRBcnJvdyA9IFwi4oeEXCI7XG52YXIgcmlnaHRhcnJvd3RhaWwgPSBcIuKGo1wiO1xudmFyIFJpZ2h0Q2VpbGluZyA9IFwi4oyJXCI7XG52YXIgUmlnaHREb3VibGVCcmFja2V0ID0gXCLin6dcIjtcbnZhciBSaWdodERvd25UZWVWZWN0b3IgPSBcIuKlnVwiO1xudmFyIFJpZ2h0RG93blZlY3RvckJhciA9IFwi4qWVXCI7XG52YXIgUmlnaHREb3duVmVjdG9yID0gXCLih4JcIjtcbnZhciBSaWdodEZsb29yID0gXCLijItcIjtcbnZhciByaWdodGhhcnBvb25kb3duID0gXCLih4FcIjtcbnZhciByaWdodGhhcnBvb251cCA9IFwi4oeAXCI7XG52YXIgcmlnaHRsZWZ0YXJyb3dzID0gXCLih4RcIjtcbnZhciByaWdodGxlZnRoYXJwb29ucyA9IFwi4oeMXCI7XG52YXIgcmlnaHRyaWdodGFycm93cyA9IFwi4oeJXCI7XG52YXIgcmlnaHRzcXVpZ2Fycm93ID0gXCLihp1cIjtcbnZhciBSaWdodFRlZUFycm93ID0gXCLihqZcIjtcbnZhciBSaWdodFRlZSA9IFwi4oqiXCI7XG52YXIgUmlnaHRUZWVWZWN0b3IgPSBcIuKlm1wiO1xudmFyIHJpZ2h0dGhyZWV0aW1lcyA9IFwi4ouMXCI7XG52YXIgUmlnaHRUcmlhbmdsZUJhciA9IFwi4qeQXCI7XG52YXIgUmlnaHRUcmlhbmdsZSA9IFwi4oqzXCI7XG52YXIgUmlnaHRUcmlhbmdsZUVxdWFsID0gXCLiirVcIjtcbnZhciBSaWdodFVwRG93blZlY3RvciA9IFwi4qWPXCI7XG52YXIgUmlnaHRVcFRlZVZlY3RvciA9IFwi4qWcXCI7XG52YXIgUmlnaHRVcFZlY3RvckJhciA9IFwi4qWUXCI7XG52YXIgUmlnaHRVcFZlY3RvciA9IFwi4oa+XCI7XG52YXIgUmlnaHRWZWN0b3JCYXIgPSBcIuKlk1wiO1xudmFyIFJpZ2h0VmVjdG9yID0gXCLih4BcIjtcbnZhciByaW5nID0gXCLLmlwiO1xudmFyIHJpc2luZ2RvdHNlcSA9IFwi4omTXCI7XG52YXIgcmxhcnIgPSBcIuKHhFwiO1xudmFyIHJsaGFyID0gXCLih4xcIjtcbnZhciBybG0gPSBcIuKAj1wiO1xudmFyIHJtb3VzdGFjaGUgPSBcIuKOsVwiO1xudmFyIHJtb3VzdCA9IFwi4o6xXCI7XG52YXIgcm5taWQgPSBcIuKrrlwiO1xudmFyIHJvYW5nID0gXCLin61cIjtcbnZhciByb2FyciA9IFwi4oe+XCI7XG52YXIgcm9icmsgPSBcIuKfp1wiO1xudmFyIHJvcGFyID0gXCLipoZcIjtcbnZhciByb3BmID0gXCLwnZWjXCI7XG52YXIgUm9wZiA9IFwi4oSdXCI7XG52YXIgcm9wbHVzID0gXCLiqK5cIjtcbnZhciByb3RpbWVzID0gXCLiqLVcIjtcbnZhciBSb3VuZEltcGxpZXMgPSBcIuKlsFwiO1xudmFyIHJwYXIgPSBcIilcIjtcbnZhciBycGFyZ3QgPSBcIuKmlFwiO1xudmFyIHJwcG9saW50ID0gXCLiqJJcIjtcbnZhciBycmFyciA9IFwi4oeJXCI7XG52YXIgUnJpZ2h0YXJyb3cgPSBcIuKHm1wiO1xudmFyIHJzYXF1byA9IFwi4oC6XCI7XG52YXIgcnNjciA9IFwi8J2Th1wiO1xudmFyIFJzY3IgPSBcIuKEm1wiO1xudmFyIHJzaCA9IFwi4oaxXCI7XG52YXIgUnNoID0gXCLihrFcIjtcbnZhciByc3FiID0gXCJdXCI7XG52YXIgcnNxdW8gPSBcIuKAmVwiO1xudmFyIHJzcXVvciA9IFwi4oCZXCI7XG52YXIgcnRocmVlID0gXCLii4xcIjtcbnZhciBydGltZXMgPSBcIuKLilwiO1xudmFyIHJ0cmkgPSBcIuKWuVwiO1xudmFyIHJ0cmllID0gXCLiirVcIjtcbnZhciBydHJpZiA9IFwi4pa4XCI7XG52YXIgcnRyaWx0cmkgPSBcIuKnjlwiO1xudmFyIFJ1bGVEZWxheWVkID0gXCLip7RcIjtcbnZhciBydWx1aGFyID0gXCLipahcIjtcbnZhciByeCA9IFwi4oSeXCI7XG52YXIgU2FjdXRlID0gXCLFmlwiO1xudmFyIHNhY3V0ZSA9IFwixZtcIjtcbnZhciBzYnF1byA9IFwi4oCaXCI7XG52YXIgc2NhcCA9IFwi4qq4XCI7XG52YXIgU2Nhcm9uID0gXCLFoFwiO1xudmFyIHNjYXJvbiA9IFwixaFcIjtcbnZhciBTYyA9IFwi4qq8XCI7XG52YXIgc2MgPSBcIuKJu1wiO1xudmFyIHNjY3VlID0gXCLiib1cIjtcbnZhciBzY2UgPSBcIuKqsFwiO1xudmFyIHNjRSA9IFwi4qq0XCI7XG52YXIgU2NlZGlsID0gXCLFnlwiO1xudmFyIHNjZWRpbCA9IFwixZ9cIjtcbnZhciBTY2lyYyA9IFwixZxcIjtcbnZhciBzY2lyYyA9IFwixZ1cIjtcbnZhciBzY25hcCA9IFwi4qq6XCI7XG52YXIgc2NuRSA9IFwi4qq2XCI7XG52YXIgc2Nuc2ltID0gXCLii6lcIjtcbnZhciBzY3BvbGludCA9IFwi4qiTXCI7XG52YXIgc2NzaW0gPSBcIuKJv1wiO1xudmFyIFNjeSA9IFwi0KFcIjtcbnZhciBzY3kgPSBcItGBXCI7XG52YXIgc2RvdGIgPSBcIuKKoVwiO1xudmFyIHNkb3QgPSBcIuKLhVwiO1xudmFyIHNkb3RlID0gXCLiqaZcIjtcbnZhciBzZWFyaGsgPSBcIuKkpVwiO1xudmFyIHNlYXJyID0gXCLihphcIjtcbnZhciBzZUFyciA9IFwi4oeYXCI7XG52YXIgc2VhcnJvdyA9IFwi4oaYXCI7XG52YXIgc2VjdCQxID0gXCLCp1wiO1xudmFyIHNlbWkgPSBcIjtcIjtcbnZhciBzZXN3YXIgPSBcIuKkqVwiO1xudmFyIHNldG1pbnVzID0gXCLiiJZcIjtcbnZhciBzZXRtbiA9IFwi4oiWXCI7XG52YXIgc2V4dCA9IFwi4py2XCI7XG52YXIgU2ZyID0gXCLwnZSWXCI7XG52YXIgc2ZyID0gXCLwnZSwXCI7XG52YXIgc2Zyb3duID0gXCLijKJcIjtcbnZhciBzaGFycCA9IFwi4pmvXCI7XG52YXIgU0hDSGN5ID0gXCLQqVwiO1xudmFyIHNoY2hjeSA9IFwi0YlcIjtcbnZhciBTSGN5ID0gXCLQqFwiO1xudmFyIHNoY3kgPSBcItGIXCI7XG52YXIgU2hvcnREb3duQXJyb3cgPSBcIuKGk1wiO1xudmFyIFNob3J0TGVmdEFycm93ID0gXCLihpBcIjtcbnZhciBzaG9ydG1pZCA9IFwi4oijXCI7XG52YXIgc2hvcnRwYXJhbGxlbCA9IFwi4oilXCI7XG52YXIgU2hvcnRSaWdodEFycm93ID0gXCLihpJcIjtcbnZhciBTaG9ydFVwQXJyb3cgPSBcIuKGkVwiO1xudmFyIHNoeSQxID0gXCLCrVwiO1xudmFyIFNpZ21hID0gXCLOo1wiO1xudmFyIHNpZ21hID0gXCLPg1wiO1xudmFyIHNpZ21hZiA9IFwiz4JcIjtcbnZhciBzaWdtYXYgPSBcIs+CXCI7XG52YXIgc2ltID0gXCLiiLxcIjtcbnZhciBzaW1kb3QgPSBcIuKpqlwiO1xudmFyIHNpbWUgPSBcIuKJg1wiO1xudmFyIHNpbWVxID0gXCLiiYNcIjtcbnZhciBzaW1nID0gXCLiqp5cIjtcbnZhciBzaW1nRSA9IFwi4qqgXCI7XG52YXIgc2ltbCA9IFwi4qqdXCI7XG52YXIgc2ltbEUgPSBcIuKqn1wiO1xudmFyIHNpbW5lID0gXCLiiYZcIjtcbnZhciBzaW1wbHVzID0gXCLiqKRcIjtcbnZhciBzaW1yYXJyID0gXCLipbJcIjtcbnZhciBzbGFyciA9IFwi4oaQXCI7XG52YXIgU21hbGxDaXJjbGUgPSBcIuKImFwiO1xudmFyIHNtYWxsc2V0bWludXMgPSBcIuKIllwiO1xudmFyIHNtYXNocCA9IFwi4qizXCI7XG52YXIgc21lcGFyc2wgPSBcIuKnpFwiO1xudmFyIHNtaWQgPSBcIuKIo1wiO1xudmFyIHNtaWxlID0gXCLijKNcIjtcbnZhciBzbXQgPSBcIuKqqlwiO1xudmFyIHNtdGUgPSBcIuKqrFwiO1xudmFyIHNtdGVzID0gXCLiqqzvuIBcIjtcbnZhciBTT0ZUY3kgPSBcItCsXCI7XG52YXIgc29mdGN5ID0gXCLRjFwiO1xudmFyIHNvbGJhciA9IFwi4oy/XCI7XG52YXIgc29sYiA9IFwi4qeEXCI7XG52YXIgc29sID0gXCIvXCI7XG52YXIgU29wZiA9IFwi8J2VilwiO1xudmFyIHNvcGYgPSBcIvCdlaRcIjtcbnZhciBzcGFkZXMgPSBcIuKZoFwiO1xudmFyIHNwYWRlc3VpdCA9IFwi4pmgXCI7XG52YXIgc3BhciA9IFwi4oilXCI7XG52YXIgc3FjYXAgPSBcIuKKk1wiO1xudmFyIHNxY2FwcyA9IFwi4oqT77iAXCI7XG52YXIgc3FjdXAgPSBcIuKKlFwiO1xudmFyIHNxY3VwcyA9IFwi4oqU77iAXCI7XG52YXIgU3FydCA9IFwi4oiaXCI7XG52YXIgc3FzdWIgPSBcIuKKj1wiO1xudmFyIHNxc3ViZSA9IFwi4oqRXCI7XG52YXIgc3FzdWJzZXQgPSBcIuKKj1wiO1xudmFyIHNxc3Vic2V0ZXEgPSBcIuKKkVwiO1xudmFyIHNxc3VwID0gXCLiipBcIjtcbnZhciBzcXN1cGUgPSBcIuKKklwiO1xudmFyIHNxc3Vwc2V0ID0gXCLiipBcIjtcbnZhciBzcXN1cHNldGVxID0gXCLiipJcIjtcbnZhciBzcXVhcmUgPSBcIuKWoVwiO1xudmFyIFNxdWFyZSA9IFwi4pahXCI7XG52YXIgU3F1YXJlSW50ZXJzZWN0aW9uID0gXCLiipNcIjtcbnZhciBTcXVhcmVTdWJzZXQgPSBcIuKKj1wiO1xudmFyIFNxdWFyZVN1YnNldEVxdWFsID0gXCLiipFcIjtcbnZhciBTcXVhcmVTdXBlcnNldCA9IFwi4oqQXCI7XG52YXIgU3F1YXJlU3VwZXJzZXRFcXVhbCA9IFwi4oqSXCI7XG52YXIgU3F1YXJlVW5pb24gPSBcIuKKlFwiO1xudmFyIHNxdWFyZiA9IFwi4paqXCI7XG52YXIgc3F1ID0gXCLilqFcIjtcbnZhciBzcXVmID0gXCLilqpcIjtcbnZhciBzcmFyciA9IFwi4oaSXCI7XG52YXIgU3NjciA9IFwi8J2SrlwiO1xudmFyIHNzY3IgPSBcIvCdk4hcIjtcbnZhciBzc2V0bW4gPSBcIuKIllwiO1xudmFyIHNzbWlsZSA9IFwi4oyjXCI7XG52YXIgc3N0YXJmID0gXCLii4ZcIjtcbnZhciBTdGFyID0gXCLii4ZcIjtcbnZhciBzdGFyID0gXCLimIZcIjtcbnZhciBzdGFyZiA9IFwi4piFXCI7XG52YXIgc3RyYWlnaHRlcHNpbG9uID0gXCLPtVwiO1xudmFyIHN0cmFpZ2h0cGhpID0gXCLPlVwiO1xudmFyIHN0cm5zID0gXCLCr1wiO1xudmFyIHN1YiA9IFwi4oqCXCI7XG52YXIgU3ViID0gXCLii5BcIjtcbnZhciBzdWJkb3QgPSBcIuKqvVwiO1xudmFyIHN1YkUgPSBcIuKrhVwiO1xudmFyIHN1YmUgPSBcIuKKhlwiO1xudmFyIHN1YmVkb3QgPSBcIuKrg1wiO1xudmFyIHN1Ym11bHQgPSBcIuKrgVwiO1xudmFyIHN1Ym5FID0gXCLiq4tcIjtcbnZhciBzdWJuZSA9IFwi4oqKXCI7XG52YXIgc3VicGx1cyA9IFwi4qq/XCI7XG52YXIgc3VicmFyciA9IFwi4qW5XCI7XG52YXIgc3Vic2V0ID0gXCLiioJcIjtcbnZhciBTdWJzZXQgPSBcIuKLkFwiO1xudmFyIHN1YnNldGVxID0gXCLiioZcIjtcbnZhciBzdWJzZXRlcXEgPSBcIuKrhVwiO1xudmFyIFN1YnNldEVxdWFsID0gXCLiioZcIjtcbnZhciBzdWJzZXRuZXEgPSBcIuKKilwiO1xudmFyIHN1YnNldG5lcXEgPSBcIuKri1wiO1xudmFyIHN1YnNpbSA9IFwi4quHXCI7XG52YXIgc3Vic3ViID0gXCLiq5VcIjtcbnZhciBzdWJzdXAgPSBcIuKrk1wiO1xudmFyIHN1Y2NhcHByb3ggPSBcIuKquFwiO1xudmFyIHN1Y2MgPSBcIuKJu1wiO1xudmFyIHN1Y2NjdXJseWVxID0gXCLiib1cIjtcbnZhciBTdWNjZWVkcyA9IFwi4om7XCI7XG52YXIgU3VjY2VlZHNFcXVhbCA9IFwi4qqwXCI7XG52YXIgU3VjY2VlZHNTbGFudEVxdWFsID0gXCLiib1cIjtcbnZhciBTdWNjZWVkc1RpbGRlID0gXCLiib9cIjtcbnZhciBzdWNjZXEgPSBcIuKqsFwiO1xudmFyIHN1Y2NuYXBwcm94ID0gXCLiqrpcIjtcbnZhciBzdWNjbmVxcSA9IFwi4qq2XCI7XG52YXIgc3VjY25zaW0gPSBcIuKLqVwiO1xudmFyIHN1Y2NzaW0gPSBcIuKJv1wiO1xudmFyIFN1Y2hUaGF0ID0gXCLiiItcIjtcbnZhciBzdW0gPSBcIuKIkVwiO1xudmFyIFN1bSA9IFwi4oiRXCI7XG52YXIgc3VuZyA9IFwi4pmqXCI7XG52YXIgc3VwMSQxID0gXCLCuVwiO1xudmFyIHN1cDIkMSA9IFwiwrJcIjtcbnZhciBzdXAzJDEgPSBcIsKzXCI7XG52YXIgc3VwID0gXCLiioNcIjtcbnZhciBTdXAgPSBcIuKLkVwiO1xudmFyIHN1cGRvdCA9IFwi4qq+XCI7XG52YXIgc3VwZHN1YiA9IFwi4quYXCI7XG52YXIgc3VwRSA9IFwi4quGXCI7XG52YXIgc3VwZSA9IFwi4oqHXCI7XG52YXIgc3VwZWRvdCA9IFwi4quEXCI7XG52YXIgU3VwZXJzZXQgPSBcIuKKg1wiO1xudmFyIFN1cGVyc2V0RXF1YWwgPSBcIuKKh1wiO1xudmFyIHN1cGhzb2wgPSBcIuKfiVwiO1xudmFyIHN1cGhzdWIgPSBcIuKrl1wiO1xudmFyIHN1cGxhcnIgPSBcIuKlu1wiO1xudmFyIHN1cG11bHQgPSBcIuKrglwiO1xudmFyIHN1cG5FID0gXCLiq4xcIjtcbnZhciBzdXBuZSA9IFwi4oqLXCI7XG52YXIgc3VwcGx1cyA9IFwi4quAXCI7XG52YXIgc3Vwc2V0ID0gXCLiioNcIjtcbnZhciBTdXBzZXQgPSBcIuKLkVwiO1xudmFyIHN1cHNldGVxID0gXCLiiodcIjtcbnZhciBzdXBzZXRlcXEgPSBcIuKrhlwiO1xudmFyIHN1cHNldG5lcSA9IFwi4oqLXCI7XG52YXIgc3Vwc2V0bmVxcSA9IFwi4quMXCI7XG52YXIgc3Vwc2ltID0gXCLiq4hcIjtcbnZhciBzdXBzdWIgPSBcIuKrlFwiO1xudmFyIHN1cHN1cCA9IFwi4quWXCI7XG52YXIgc3dhcmhrID0gXCLipKZcIjtcbnZhciBzd2FyciA9IFwi4oaZXCI7XG52YXIgc3dBcnIgPSBcIuKHmVwiO1xudmFyIHN3YXJyb3cgPSBcIuKGmVwiO1xudmFyIHN3bndhciA9IFwi4qSqXCI7XG52YXIgc3psaWckMSA9IFwiw59cIjtcbnZhciBUYWIgPSBcIlxcdFwiO1xudmFyIHRhcmdldCA9IFwi4oyWXCI7XG52YXIgVGF1ID0gXCLOpFwiO1xudmFyIHRhdSA9IFwiz4RcIjtcbnZhciB0YnJrID0gXCLijrRcIjtcbnZhciBUY2Fyb24gPSBcIsWkXCI7XG52YXIgdGNhcm9uID0gXCLFpVwiO1xudmFyIFRjZWRpbCA9IFwixaJcIjtcbnZhciB0Y2VkaWwgPSBcIsWjXCI7XG52YXIgVGN5ID0gXCLQolwiO1xudmFyIHRjeSA9IFwi0YJcIjtcbnZhciB0ZG90ID0gXCLig5tcIjtcbnZhciB0ZWxyZWMgPSBcIuKMlVwiO1xudmFyIFRmciA9IFwi8J2Ul1wiO1xudmFyIHRmciA9IFwi8J2UsVwiO1xudmFyIHRoZXJlNCA9IFwi4oi0XCI7XG52YXIgdGhlcmVmb3JlID0gXCLiiLRcIjtcbnZhciBUaGVyZWZvcmUgPSBcIuKItFwiO1xudmFyIFRoZXRhID0gXCLOmFwiO1xudmFyIHRoZXRhID0gXCLOuFwiO1xudmFyIHRoZXRhc3ltID0gXCLPkVwiO1xudmFyIHRoZXRhdiA9IFwiz5FcIjtcbnZhciB0aGlja2FwcHJveCA9IFwi4omIXCI7XG52YXIgdGhpY2tzaW0gPSBcIuKIvFwiO1xudmFyIFRoaWNrU3BhY2UgPSBcIuKBn+KAilwiO1xudmFyIFRoaW5TcGFjZSA9IFwi4oCJXCI7XG52YXIgdGhpbnNwID0gXCLigIlcIjtcbnZhciB0aGthcCA9IFwi4omIXCI7XG52YXIgdGhrc2ltID0gXCLiiLxcIjtcbnZhciBUSE9STiQxID0gXCLDnlwiO1xudmFyIHRob3JuJDEgPSBcIsO+XCI7XG52YXIgdGlsZGUgPSBcIsucXCI7XG52YXIgVGlsZGUgPSBcIuKIvFwiO1xudmFyIFRpbGRlRXF1YWwgPSBcIuKJg1wiO1xudmFyIFRpbGRlRnVsbEVxdWFsID0gXCLiiYVcIjtcbnZhciBUaWxkZVRpbGRlID0gXCLiiYhcIjtcbnZhciB0aW1lc2JhciA9IFwi4qixXCI7XG52YXIgdGltZXNiID0gXCLiiqBcIjtcbnZhciB0aW1lcyQxID0gXCLDl1wiO1xudmFyIHRpbWVzZCA9IFwi4qiwXCI7XG52YXIgdGludCA9IFwi4oitXCI7XG52YXIgdG9lYSA9IFwi4qSoXCI7XG52YXIgdG9wYm90ID0gXCLijLZcIjtcbnZhciB0b3BjaXIgPSBcIuKrsVwiO1xudmFyIGVzbV90b3AgPSBcIuKKpFwiO1xudmFyIFRvcGYgPSBcIvCdlYtcIjtcbnZhciB0b3BmID0gXCLwnZWlXCI7XG52YXIgdG9wZm9yayA9IFwi4quaXCI7XG52YXIgdG9zYSA9IFwi4qSpXCI7XG52YXIgdHByaW1lID0gXCLigLRcIjtcbnZhciB0cmFkZSA9IFwi4oSiXCI7XG52YXIgVFJBREUgPSBcIuKEolwiO1xudmFyIHRyaWFuZ2xlID0gXCLilrVcIjtcbnZhciB0cmlhbmdsZWRvd24gPSBcIuKWv1wiO1xudmFyIHRyaWFuZ2xlbGVmdCA9IFwi4peDXCI7XG52YXIgdHJpYW5nbGVsZWZ0ZXEgPSBcIuKKtFwiO1xudmFyIHRyaWFuZ2xlcSA9IFwi4omcXCI7XG52YXIgdHJpYW5nbGVyaWdodCA9IFwi4pa5XCI7XG52YXIgdHJpYW5nbGVyaWdodGVxID0gXCLiirVcIjtcbnZhciB0cmlkb3QgPSBcIuKXrFwiO1xudmFyIHRyaWUgPSBcIuKJnFwiO1xudmFyIHRyaW1pbnVzID0gXCLiqLpcIjtcbnZhciBUcmlwbGVEb3QgPSBcIuKDm1wiO1xudmFyIHRyaXBsdXMgPSBcIuKouVwiO1xudmFyIHRyaXNiID0gXCLip41cIjtcbnZhciB0cml0aW1lID0gXCLiqLtcIjtcbnZhciB0cnBleml1bSA9IFwi4o+iXCI7XG52YXIgVHNjciA9IFwi8J2Sr1wiO1xudmFyIHRzY3IgPSBcIvCdk4lcIjtcbnZhciBUU2N5ID0gXCLQplwiO1xudmFyIHRzY3kgPSBcItGGXCI7XG52YXIgVFNIY3kgPSBcItCLXCI7XG52YXIgdHNoY3kgPSBcItGbXCI7XG52YXIgVHN0cm9rID0gXCLFplwiO1xudmFyIHRzdHJvayA9IFwixadcIjtcbnZhciB0d2l4dCA9IFwi4omsXCI7XG52YXIgdHdvaGVhZGxlZnRhcnJvdyA9IFwi4oaeXCI7XG52YXIgdHdvaGVhZHJpZ2h0YXJyb3cgPSBcIuKGoFwiO1xudmFyIFVhY3V0ZSQxID0gXCLDmlwiO1xudmFyIHVhY3V0ZSQxID0gXCLDulwiO1xudmFyIHVhcnIgPSBcIuKGkVwiO1xudmFyIFVhcnIgPSBcIuKGn1wiO1xudmFyIHVBcnIgPSBcIuKHkVwiO1xudmFyIFVhcnJvY2lyID0gXCLipYlcIjtcbnZhciBVYnJjeSA9IFwi0I5cIjtcbnZhciB1YnJjeSA9IFwi0Z5cIjtcbnZhciBVYnJldmUgPSBcIsWsXCI7XG52YXIgdWJyZXZlID0gXCLFrVwiO1xudmFyIFVjaXJjJDEgPSBcIsObXCI7XG52YXIgdWNpcmMkMSA9IFwiw7tcIjtcbnZhciBVY3kgPSBcItCjXCI7XG52YXIgdWN5ID0gXCLRg1wiO1xudmFyIHVkYXJyID0gXCLih4VcIjtcbnZhciBVZGJsYWMgPSBcIsWwXCI7XG52YXIgdWRibGFjID0gXCLFsVwiO1xudmFyIHVkaGFyID0gXCLipa5cIjtcbnZhciB1ZmlzaHQgPSBcIuKlvlwiO1xudmFyIFVmciA9IFwi8J2UmFwiO1xudmFyIHVmciA9IFwi8J2UslwiO1xudmFyIFVncmF2ZSQxID0gXCLDmVwiO1xudmFyIHVncmF2ZSQxID0gXCLDuVwiO1xudmFyIHVIYXIgPSBcIuKlo1wiO1xudmFyIHVoYXJsID0gXCLihr9cIjtcbnZhciB1aGFyciA9IFwi4oa+XCI7XG52YXIgdWhibGsgPSBcIuKWgFwiO1xudmFyIHVsY29ybiA9IFwi4oycXCI7XG52YXIgdWxjb3JuZXIgPSBcIuKMnFwiO1xudmFyIHVsY3JvcCA9IFwi4oyPXCI7XG52YXIgdWx0cmkgPSBcIuKXuFwiO1xudmFyIFVtYWNyID0gXCLFqlwiO1xudmFyIHVtYWNyID0gXCLFq1wiO1xudmFyIHVtbCQxID0gXCLCqFwiO1xudmFyIFVuZGVyQmFyID0gXCJfXCI7XG52YXIgVW5kZXJCcmFjZSA9IFwi4o+fXCI7XG52YXIgVW5kZXJCcmFja2V0ID0gXCLijrVcIjtcbnZhciBVbmRlclBhcmVudGhlc2lzID0gXCLij51cIjtcbnZhciBVbmlvbiA9IFwi4ouDXCI7XG52YXIgVW5pb25QbHVzID0gXCLiio5cIjtcbnZhciBVb2dvbiA9IFwixbJcIjtcbnZhciB1b2dvbiA9IFwixbNcIjtcbnZhciBVb3BmID0gXCLwnZWMXCI7XG52YXIgdW9wZiA9IFwi8J2VplwiO1xudmFyIFVwQXJyb3dCYXIgPSBcIuKkklwiO1xudmFyIHVwYXJyb3cgPSBcIuKGkVwiO1xudmFyIFVwQXJyb3cgPSBcIuKGkVwiO1xudmFyIFVwYXJyb3cgPSBcIuKHkVwiO1xudmFyIFVwQXJyb3dEb3duQXJyb3cgPSBcIuKHhVwiO1xudmFyIHVwZG93bmFycm93ID0gXCLihpVcIjtcbnZhciBVcERvd25BcnJvdyA9IFwi4oaVXCI7XG52YXIgVXBkb3duYXJyb3cgPSBcIuKHlVwiO1xudmFyIFVwRXF1aWxpYnJpdW0gPSBcIuKlrlwiO1xudmFyIHVwaGFycG9vbmxlZnQgPSBcIuKGv1wiO1xudmFyIHVwaGFycG9vbnJpZ2h0ID0gXCLihr5cIjtcbnZhciB1cGx1cyA9IFwi4oqOXCI7XG52YXIgVXBwZXJMZWZ0QXJyb3cgPSBcIuKGllwiO1xudmFyIFVwcGVyUmlnaHRBcnJvdyA9IFwi4oaXXCI7XG52YXIgdXBzaSA9IFwiz4VcIjtcbnZhciBVcHNpID0gXCLPklwiO1xudmFyIHVwc2loID0gXCLPklwiO1xudmFyIFVwc2lsb24gPSBcIs6lXCI7XG52YXIgdXBzaWxvbiA9IFwiz4VcIjtcbnZhciBVcFRlZUFycm93ID0gXCLihqVcIjtcbnZhciBVcFRlZSA9IFwi4oqlXCI7XG52YXIgdXB1cGFycm93cyA9IFwi4oeIXCI7XG52YXIgdXJjb3JuID0gXCLijJ1cIjtcbnZhciB1cmNvcm5lciA9IFwi4oydXCI7XG52YXIgdXJjcm9wID0gXCLijI5cIjtcbnZhciBVcmluZyA9IFwixa5cIjtcbnZhciB1cmluZyA9IFwixa9cIjtcbnZhciB1cnRyaSA9IFwi4pe5XCI7XG52YXIgVXNjciA9IFwi8J2SsFwiO1xudmFyIHVzY3IgPSBcIvCdk4pcIjtcbnZhciB1dGRvdCA9IFwi4ouwXCI7XG52YXIgVXRpbGRlID0gXCLFqFwiO1xudmFyIHV0aWxkZSA9IFwixalcIjtcbnZhciB1dHJpID0gXCLilrVcIjtcbnZhciB1dHJpZiA9IFwi4pa0XCI7XG52YXIgdXVhcnIgPSBcIuKHiFwiO1xudmFyIFV1bWwkMSA9IFwiw5xcIjtcbnZhciB1dW1sJDEgPSBcIsO8XCI7XG52YXIgdXdhbmdsZSA9IFwi4qanXCI7XG52YXIgdmFuZ3J0ID0gXCLippxcIjtcbnZhciB2YXJlcHNpbG9uID0gXCLPtVwiO1xudmFyIHZhcmthcHBhID0gXCLPsFwiO1xudmFyIHZhcm5vdGhpbmcgPSBcIuKIhVwiO1xudmFyIHZhcnBoaSA9IFwiz5VcIjtcbnZhciB2YXJwaSA9IFwiz5ZcIjtcbnZhciB2YXJwcm9wdG8gPSBcIuKInVwiO1xudmFyIHZhcnIgPSBcIuKGlVwiO1xudmFyIHZBcnIgPSBcIuKHlVwiO1xudmFyIHZhcnJobyA9IFwiz7FcIjtcbnZhciB2YXJzaWdtYSA9IFwiz4JcIjtcbnZhciB2YXJzdWJzZXRuZXEgPSBcIuKKiu+4gFwiO1xudmFyIHZhcnN1YnNldG5lcXEgPSBcIuKri++4gFwiO1xudmFyIHZhcnN1cHNldG5lcSA9IFwi4oqL77iAXCI7XG52YXIgdmFyc3Vwc2V0bmVxcSA9IFwi4quM77iAXCI7XG52YXIgdmFydGhldGEgPSBcIs+RXCI7XG52YXIgdmFydHJpYW5nbGVsZWZ0ID0gXCLiirJcIjtcbnZhciB2YXJ0cmlhbmdsZXJpZ2h0ID0gXCLiirNcIjtcbnZhciB2QmFyID0gXCLiq6hcIjtcbnZhciBWYmFyID0gXCLiq6tcIjtcbnZhciB2QmFydiA9IFwi4qupXCI7XG52YXIgVmN5ID0gXCLQklwiO1xudmFyIHZjeSA9IFwi0LJcIjtcbnZhciB2ZGFzaCA9IFwi4oqiXCI7XG52YXIgdkRhc2ggPSBcIuKKqFwiO1xudmFyIFZkYXNoID0gXCLiiqlcIjtcbnZhciBWRGFzaCA9IFwi4oqrXCI7XG52YXIgVmRhc2hsID0gXCLiq6ZcIjtcbnZhciB2ZWViYXIgPSBcIuKKu1wiO1xudmFyIHZlZSA9IFwi4oioXCI7XG52YXIgVmVlID0gXCLii4FcIjtcbnZhciB2ZWVlcSA9IFwi4omaXCI7XG52YXIgdmVsbGlwID0gXCLii65cIjtcbnZhciB2ZXJiYXIgPSBcInxcIjtcbnZhciBWZXJiYXIgPSBcIuKAllwiO1xudmFyIHZlcnQgPSBcInxcIjtcbnZhciBWZXJ0ID0gXCLigJZcIjtcbnZhciBWZXJ0aWNhbEJhciA9IFwi4oijXCI7XG52YXIgVmVydGljYWxMaW5lID0gXCJ8XCI7XG52YXIgVmVydGljYWxTZXBhcmF0b3IgPSBcIuKdmFwiO1xudmFyIFZlcnRpY2FsVGlsZGUgPSBcIuKJgFwiO1xudmFyIFZlcnlUaGluU3BhY2UgPSBcIuKAilwiO1xudmFyIFZmciA9IFwi8J2UmVwiO1xudmFyIHZmciA9IFwi8J2Us1wiO1xudmFyIHZsdHJpID0gXCLiirJcIjtcbnZhciB2bnN1YiA9IFwi4oqC4oOSXCI7XG52YXIgdm5zdXAgPSBcIuKKg+KDklwiO1xudmFyIFZvcGYgPSBcIvCdlY1cIjtcbnZhciB2b3BmID0gXCLwnZWnXCI7XG52YXIgdnByb3AgPSBcIuKInVwiO1xudmFyIHZydHJpID0gXCLiirNcIjtcbnZhciBWc2NyID0gXCLwnZKxXCI7XG52YXIgdnNjciA9IFwi8J2Ti1wiO1xudmFyIHZzdWJuRSA9IFwi4quL77iAXCI7XG52YXIgdnN1Ym5lID0gXCLiiorvuIBcIjtcbnZhciB2c3VwbkUgPSBcIuKrjO+4gFwiO1xudmFyIHZzdXBuZSA9IFwi4oqL77iAXCI7XG52YXIgVnZkYXNoID0gXCLiiqpcIjtcbnZhciB2emlnemFnID0gXCLipppcIjtcbnZhciBXY2lyYyA9IFwixbRcIjtcbnZhciB3Y2lyYyA9IFwixbVcIjtcbnZhciB3ZWRiYXIgPSBcIuKpn1wiO1xudmFyIHdlZGdlID0gXCLiiKdcIjtcbnZhciBXZWRnZSA9IFwi4ouAXCI7XG52YXIgd2VkZ2VxID0gXCLiiZlcIjtcbnZhciB3ZWllcnAgPSBcIuKEmFwiO1xudmFyIFdmciA9IFwi8J2UmlwiO1xudmFyIHdmciA9IFwi8J2UtFwiO1xudmFyIFdvcGYgPSBcIvCdlY5cIjtcbnZhciB3b3BmID0gXCLwnZWoXCI7XG52YXIgd3AgPSBcIuKEmFwiO1xudmFyIHdyID0gXCLiiYBcIjtcbnZhciB3cmVhdGggPSBcIuKJgFwiO1xudmFyIFdzY3IgPSBcIvCdkrJcIjtcbnZhciB3c2NyID0gXCLwnZOMXCI7XG52YXIgeGNhcCA9IFwi4ouCXCI7XG52YXIgeGNpcmMgPSBcIuKXr1wiO1xudmFyIHhjdXAgPSBcIuKLg1wiO1xudmFyIHhkdHJpID0gXCLilr1cIjtcbnZhciBYZnIgPSBcIvCdlJtcIjtcbnZhciB4ZnIgPSBcIvCdlLVcIjtcbnZhciB4aGFyciA9IFwi4p+3XCI7XG52YXIgeGhBcnIgPSBcIuKfulwiO1xudmFyIFhpID0gXCLOnlwiO1xudmFyIHhpID0gXCLOvlwiO1xudmFyIHhsYXJyID0gXCLin7VcIjtcbnZhciB4bEFyciA9IFwi4p+4XCI7XG52YXIgeG1hcCA9IFwi4p+8XCI7XG52YXIgeG5pcyA9IFwi4ou7XCI7XG52YXIgeG9kb3QgPSBcIuKogFwiO1xudmFyIFhvcGYgPSBcIvCdlY9cIjtcbnZhciB4b3BmID0gXCLwnZWpXCI7XG52YXIgeG9wbHVzID0gXCLiqIFcIjtcbnZhciB4b3RpbWUgPSBcIuKoglwiO1xudmFyIHhyYXJyID0gXCLin7ZcIjtcbnZhciB4ckFyciA9IFwi4p+5XCI7XG52YXIgWHNjciA9IFwi8J2Ss1wiO1xudmFyIHhzY3IgPSBcIvCdk41cIjtcbnZhciB4c3FjdXAgPSBcIuKohlwiO1xudmFyIHh1cGx1cyA9IFwi4qiEXCI7XG52YXIgeHV0cmkgPSBcIuKWs1wiO1xudmFyIHh2ZWUgPSBcIuKLgVwiO1xudmFyIHh3ZWRnZSA9IFwi4ouAXCI7XG52YXIgWWFjdXRlJDEgPSBcIsOdXCI7XG52YXIgeWFjdXRlJDEgPSBcIsO9XCI7XG52YXIgWUFjeSA9IFwi0K9cIjtcbnZhciB5YWN5ID0gXCLRj1wiO1xudmFyIFljaXJjID0gXCLFtlwiO1xudmFyIHljaXJjID0gXCLFt1wiO1xudmFyIFljeSA9IFwi0KtcIjtcbnZhciB5Y3kgPSBcItGLXCI7XG52YXIgeWVuJDEgPSBcIsKlXCI7XG52YXIgWWZyID0gXCLwnZScXCI7XG52YXIgeWZyID0gXCLwnZS2XCI7XG52YXIgWUljeSA9IFwi0IdcIjtcbnZhciB5aWN5ID0gXCLRl1wiO1xudmFyIFlvcGYgPSBcIvCdlZBcIjtcbnZhciB5b3BmID0gXCLwnZWqXCI7XG52YXIgWXNjciA9IFwi8J2StFwiO1xudmFyIHlzY3IgPSBcIvCdk45cIjtcbnZhciBZVWN5ID0gXCLQrlwiO1xudmFyIHl1Y3kgPSBcItGOXCI7XG52YXIgeXVtbCQxID0gXCLDv1wiO1xudmFyIFl1bWwgPSBcIsW4XCI7XG52YXIgWmFjdXRlID0gXCLFuVwiO1xudmFyIHphY3V0ZSA9IFwixbpcIjtcbnZhciBaY2Fyb24gPSBcIsW9XCI7XG52YXIgemNhcm9uID0gXCLFvlwiO1xudmFyIFpjeSA9IFwi0JdcIjtcbnZhciB6Y3kgPSBcItC3XCI7XG52YXIgWmRvdCA9IFwixbtcIjtcbnZhciB6ZG90ID0gXCLFvFwiO1xudmFyIHplZXRyZiA9IFwi4oSoXCI7XG52YXIgWmVyb1dpZHRoU3BhY2UgPSBcIuKAi1wiO1xudmFyIFpldGEgPSBcIs6WXCI7XG52YXIgemV0YSA9IFwizrZcIjtcbnZhciB6ZnIgPSBcIvCdlLdcIjtcbnZhciBaZnIgPSBcIuKEqFwiO1xudmFyIFpIY3kgPSBcItCWXCI7XG52YXIgemhjeSA9IFwi0LZcIjtcbnZhciB6aWdyYXJyID0gXCLih51cIjtcbnZhciB6b3BmID0gXCLwnZWrXCI7XG52YXIgWm9wZiA9IFwi4oSkXCI7XG52YXIgWnNjciA9IFwi8J2StVwiO1xudmFyIHpzY3IgPSBcIvCdk49cIjtcbnZhciB6d2ogPSBcIuKAjVwiO1xudmFyIHp3bmogPSBcIuKAjFwiO1xudmFyIHJlcXVpcmUkJDEkMSA9IHtcbiAgICBBYWN1dGU6IEFhY3V0ZSQxLFxuICAgIGFhY3V0ZTogYWFjdXRlJDEsXG4gICAgQWJyZXZlOiBBYnJldmUsXG4gICAgYWJyZXZlOiBhYnJldmUsXG4gICAgYWM6IGFjLFxuICAgIGFjZDogYWNkLFxuICAgIGFjRTogYWNFLFxuICAgIEFjaXJjOiBBY2lyYyQxLFxuICAgIGFjaXJjOiBhY2lyYyQxLFxuICAgIGFjdXRlOiBhY3V0ZSQxLFxuICAgIEFjeTogQWN5LFxuICAgIGFjeTogYWN5LFxuICAgIEFFbGlnOiBBRWxpZyQxLFxuICAgIGFlbGlnOiBhZWxpZyQxLFxuICAgIGFmOiBhZixcbiAgICBBZnI6IEFmcixcbiAgICBhZnI6IGFmcixcbiAgICBBZ3JhdmU6IEFncmF2ZSQxLFxuICAgIGFncmF2ZTogYWdyYXZlJDEsXG4gICAgYWxlZnN5bTogYWxlZnN5bSxcbiAgICBhbGVwaDogYWxlcGgsXG4gICAgQWxwaGE6IEFscGhhLFxuICAgIGFscGhhOiBhbHBoYSxcbiAgICBBbWFjcjogQW1hY3IsXG4gICAgYW1hY3I6IGFtYWNyLFxuICAgIGFtYWxnOiBhbWFsZyxcbiAgICBhbXA6IGFtcCQyLFxuICAgIEFNUDogQU1QJDEsXG4gICAgYW5kYW5kOiBhbmRhbmQsXG4gICAgQW5kOiBBbmQsXG4gICAgYW5kOiBhbmQsXG4gICAgYW5kZDogYW5kZCxcbiAgICBhbmRzbG9wZTogYW5kc2xvcGUsXG4gICAgYW5kdjogYW5kdixcbiAgICBhbmc6IGFuZyxcbiAgICBhbmdlOiBhbmdlLFxuICAgIGFuZ2xlOiBhbmdsZSxcbiAgICBhbmdtc2RhYTogYW5nbXNkYWEsXG4gICAgYW5nbXNkYWI6IGFuZ21zZGFiLFxuICAgIGFuZ21zZGFjOiBhbmdtc2RhYyxcbiAgICBhbmdtc2RhZDogYW5nbXNkYWQsXG4gICAgYW5nbXNkYWU6IGFuZ21zZGFlLFxuICAgIGFuZ21zZGFmOiBhbmdtc2RhZixcbiAgICBhbmdtc2RhZzogYW5nbXNkYWcsXG4gICAgYW5nbXNkYWg6IGFuZ21zZGFoLFxuICAgIGFuZ21zZDogYW5nbXNkLFxuICAgIGFuZ3J0OiBhbmdydCxcbiAgICBhbmdydHZiOiBhbmdydHZiLFxuICAgIGFuZ3J0dmJkOiBhbmdydHZiZCxcbiAgICBhbmdzcGg6IGFuZ3NwaCxcbiAgICBhbmdzdDogYW5nc3QsXG4gICAgYW5nemFycjogYW5nemFycixcbiAgICBBb2dvbjogQW9nb24sXG4gICAgYW9nb246IGFvZ29uLFxuICAgIEFvcGY6IEFvcGYsXG4gICAgYW9wZjogYW9wZixcbiAgICBhcGFjaXI6IGFwYWNpcixcbiAgICBhcDogYXAsXG4gICAgYXBFOiBhcEUsXG4gICAgYXBlOiBhcGUsXG4gICAgYXBpZDogYXBpZCxcbiAgICBhcG9zOiBhcG9zJDEsXG4gICAgQXBwbHlGdW5jdGlvbjogQXBwbHlGdW5jdGlvbixcbiAgICBhcHByb3g6IGFwcHJveCxcbiAgICBhcHByb3hlcTogYXBwcm94ZXEsXG4gICAgQXJpbmc6IEFyaW5nJDEsXG4gICAgYXJpbmc6IGFyaW5nJDEsXG4gICAgQXNjcjogQXNjcixcbiAgICBhc2NyOiBhc2NyLFxuICAgIEFzc2lnbjogQXNzaWduLFxuICAgIGFzdDogYXN0LFxuICAgIGFzeW1wOiBhc3ltcCxcbiAgICBhc3ltcGVxOiBhc3ltcGVxLFxuICAgIEF0aWxkZTogQXRpbGRlJDEsXG4gICAgYXRpbGRlOiBhdGlsZGUkMSxcbiAgICBBdW1sOiBBdW1sJDEsXG4gICAgYXVtbDogYXVtbCQxLFxuICAgIGF3Y29uaW50OiBhd2NvbmludCxcbiAgICBhd2ludDogYXdpbnQsXG4gICAgYmFja2Nvbmc6IGJhY2tjb25nLFxuICAgIGJhY2tlcHNpbG9uOiBiYWNrZXBzaWxvbixcbiAgICBiYWNrcHJpbWU6IGJhY2twcmltZSxcbiAgICBiYWNrc2ltOiBiYWNrc2ltLFxuICAgIGJhY2tzaW1lcTogYmFja3NpbWVxLFxuICAgIEJhY2tzbGFzaDogQmFja3NsYXNoLFxuICAgIEJhcnY6IEJhcnYsXG4gICAgYmFydmVlOiBiYXJ2ZWUsXG4gICAgYmFyd2VkOiBiYXJ3ZWQsXG4gICAgQmFyd2VkOiBCYXJ3ZWQsXG4gICAgYmFyd2VkZ2U6IGJhcndlZGdlLFxuICAgIGJicms6IGJicmssXG4gICAgYmJya3Ricms6IGJicmt0YnJrLFxuICAgIGJjb25nOiBiY29uZyxcbiAgICBCY3k6IEJjeSxcbiAgICBiY3k6IGJjeSxcbiAgICBiZHF1bzogYmRxdW8sXG4gICAgYmVjYXVzOiBiZWNhdXMsXG4gICAgYmVjYXVzZTogYmVjYXVzZSxcbiAgICBCZWNhdXNlOiBCZWNhdXNlLFxuICAgIGJlbXB0eXY6IGJlbXB0eXYsXG4gICAgYmVwc2k6IGJlcHNpLFxuICAgIGJlcm5vdTogYmVybm91LFxuICAgIEJlcm5vdWxsaXM6IEJlcm5vdWxsaXMsXG4gICAgQmV0YTogQmV0YSxcbiAgICBiZXRhOiBiZXRhLFxuICAgIGJldGg6IGJldGgsXG4gICAgYmV0d2VlbjogYmV0d2VlbixcbiAgICBCZnI6IEJmcixcbiAgICBiZnI6IGJmcixcbiAgICBiaWdjYXA6IGJpZ2NhcCxcbiAgICBiaWdjaXJjOiBiaWdjaXJjLFxuICAgIGJpZ2N1cDogYmlnY3VwLFxuICAgIGJpZ29kb3Q6IGJpZ29kb3QsXG4gICAgYmlnb3BsdXM6IGJpZ29wbHVzLFxuICAgIGJpZ290aW1lczogYmlnb3RpbWVzLFxuICAgIGJpZ3NxY3VwOiBiaWdzcWN1cCxcbiAgICBiaWdzdGFyOiBiaWdzdGFyLFxuICAgIGJpZ3RyaWFuZ2xlZG93bjogYmlndHJpYW5nbGVkb3duLFxuICAgIGJpZ3RyaWFuZ2xldXA6IGJpZ3RyaWFuZ2xldXAsXG4gICAgYmlndXBsdXM6IGJpZ3VwbHVzLFxuICAgIGJpZ3ZlZTogYmlndmVlLFxuICAgIGJpZ3dlZGdlOiBiaWd3ZWRnZSxcbiAgICBia2Fyb3c6IGJrYXJvdyxcbiAgICBibGFja2xvemVuZ2U6IGJsYWNrbG96ZW5nZSxcbiAgICBibGFja3NxdWFyZTogYmxhY2tzcXVhcmUsXG4gICAgYmxhY2t0cmlhbmdsZTogYmxhY2t0cmlhbmdsZSxcbiAgICBibGFja3RyaWFuZ2xlZG93bjogYmxhY2t0cmlhbmdsZWRvd24sXG4gICAgYmxhY2t0cmlhbmdsZWxlZnQ6IGJsYWNrdHJpYW5nbGVsZWZ0LFxuICAgIGJsYWNrdHJpYW5nbGVyaWdodDogYmxhY2t0cmlhbmdsZXJpZ2h0LFxuICAgIGJsYW5rOiBibGFuayxcbiAgICBibGsxMjogYmxrMTIsXG4gICAgYmxrMTQ6IGJsazE0LFxuICAgIGJsazM0OiBibGszNCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgYm5lOiBibmUsXG4gICAgYm5lcXVpdjogYm5lcXVpdixcbiAgICBiTm90OiBiTm90LFxuICAgIGJub3Q6IGJub3QsXG4gICAgQm9wZjogQm9wZixcbiAgICBib3BmOiBib3BmLFxuICAgIGJvdDogYm90LFxuICAgIGJvdHRvbTogYm90dG9tLFxuICAgIGJvd3RpZTogYm93dGllLFxuICAgIGJveGJveDogYm94Ym94LFxuICAgIGJveGRsOiBib3hkbCxcbiAgICBib3hkTDogYm94ZEwsXG4gICAgYm94RGw6IGJveERsLFxuICAgIGJveERMOiBib3hETCxcbiAgICBib3hkcjogYm94ZHIsXG4gICAgYm94ZFI6IGJveGRSLFxuICAgIGJveERyOiBib3hEcixcbiAgICBib3hEUjogYm94RFIsXG4gICAgYm94aDogYm94aCxcbiAgICBib3hIOiBib3hILFxuICAgIGJveGhkOiBib3hoZCxcbiAgICBib3hIZDogYm94SGQsXG4gICAgYm94aEQ6IGJveGhELFxuICAgIGJveEhEOiBib3hIRCxcbiAgICBib3hodTogYm94aHUsXG4gICAgYm94SHU6IGJveEh1LFxuICAgIGJveGhVOiBib3hoVSxcbiAgICBib3hIVTogYm94SFUsXG4gICAgYm94bWludXM6IGJveG1pbnVzLFxuICAgIGJveHBsdXM6IGJveHBsdXMsXG4gICAgYm94dGltZXM6IGJveHRpbWVzLFxuICAgIGJveHVsOiBib3h1bCxcbiAgICBib3h1TDogYm94dUwsXG4gICAgYm94VWw6IGJveFVsLFxuICAgIGJveFVMOiBib3hVTCxcbiAgICBib3h1cjogYm94dXIsXG4gICAgYm94dVI6IGJveHVSLFxuICAgIGJveFVyOiBib3hVcixcbiAgICBib3hVUjogYm94VVIsXG4gICAgYm94djogYm94dixcbiAgICBib3hWOiBib3hWLFxuICAgIGJveHZoOiBib3h2aCxcbiAgICBib3h2SDogYm94dkgsXG4gICAgYm94Vmg6IGJveFZoLFxuICAgIGJveFZIOiBib3hWSCxcbiAgICBib3h2bDogYm94dmwsXG4gICAgYm94dkw6IGJveHZMLFxuICAgIGJveFZsOiBib3hWbCxcbiAgICBib3hWTDogYm94VkwsXG4gICAgYm94dnI6IGJveHZyLFxuICAgIGJveHZSOiBib3h2UixcbiAgICBib3hWcjogYm94VnIsXG4gICAgYm94VlI6IGJveFZSLFxuICAgIGJwcmltZTogYnByaW1lLFxuICAgIGJyZXZlOiBicmV2ZSxcbiAgICBCcmV2ZTogQnJldmUsXG4gICAgYnJ2YmFyOiBicnZiYXIkMSxcbiAgICBic2NyOiBic2NyLFxuICAgIEJzY3I6IEJzY3IsXG4gICAgYnNlbWk6IGJzZW1pLFxuICAgIGJzaW06IGJzaW0sXG4gICAgYnNpbWU6IGJzaW1lLFxuICAgIGJzb2xiOiBic29sYixcbiAgICBic29sOiBic29sLFxuICAgIGJzb2xoc3ViOiBic29saHN1YixcbiAgICBidWxsOiBidWxsLFxuICAgIGJ1bGxldDogYnVsbGV0LFxuICAgIGJ1bXA6IGJ1bXAsXG4gICAgYnVtcEU6IGJ1bXBFLFxuICAgIGJ1bXBlOiBidW1wZSxcbiAgICBCdW1wZXE6IEJ1bXBlcSxcbiAgICBidW1wZXE6IGJ1bXBlcSxcbiAgICBDYWN1dGU6IENhY3V0ZSxcbiAgICBjYWN1dGU6IGNhY3V0ZSxcbiAgICBjYXBhbmQ6IGNhcGFuZCxcbiAgICBjYXBicmN1cDogY2FwYnJjdXAsXG4gICAgY2FwY2FwOiBjYXBjYXAsXG4gICAgY2FwOiBjYXAsXG4gICAgQ2FwOiBDYXAsXG4gICAgY2FwY3VwOiBjYXBjdXAsXG4gICAgY2FwZG90OiBjYXBkb3QsXG4gICAgQ2FwaXRhbERpZmZlcmVudGlhbEQ6IENhcGl0YWxEaWZmZXJlbnRpYWxELFxuICAgIGNhcHM6IGNhcHMsXG4gICAgY2FyZXQ6IGNhcmV0LFxuICAgIGNhcm9uOiBjYXJvbixcbiAgICBDYXlsZXlzOiBDYXlsZXlzLFxuICAgIGNjYXBzOiBjY2FwcyxcbiAgICBDY2Fyb246IENjYXJvbixcbiAgICBjY2Fyb246IGNjYXJvbixcbiAgICBDY2VkaWw6IENjZWRpbCQxLFxuICAgIGNjZWRpbDogY2NlZGlsJDEsXG4gICAgQ2NpcmM6IENjaXJjLFxuICAgIGNjaXJjOiBjY2lyYyxcbiAgICBDY29uaW50OiBDY29uaW50LFxuICAgIGNjdXBzOiBjY3VwcyxcbiAgICBjY3Vwc3NtOiBjY3Vwc3NtLFxuICAgIENkb3Q6IENkb3QsXG4gICAgY2RvdDogY2RvdCxcbiAgICBjZWRpbDogY2VkaWwkMSxcbiAgICBDZWRpbGxhOiBDZWRpbGxhLFxuICAgIGNlbXB0eXY6IGNlbXB0eXYsXG4gICAgY2VudDogY2VudCQxLFxuICAgIGNlbnRlcmRvdDogY2VudGVyZG90LFxuICAgIENlbnRlckRvdDogQ2VudGVyRG90LFxuICAgIGNmcjogY2ZyLFxuICAgIENmcjogQ2ZyLFxuICAgIENIY3k6IENIY3ksXG4gICAgY2hjeTogY2hjeSxcbiAgICBjaGVjazogY2hlY2ssXG4gICAgY2hlY2ttYXJrOiBjaGVja21hcmssXG4gICAgQ2hpOiBDaGksXG4gICAgY2hpOiBjaGksXG4gICAgY2lyYzogY2lyYyxcbiAgICBjaXJjZXE6IGNpcmNlcSxcbiAgICBjaXJjbGVhcnJvd2xlZnQ6IGNpcmNsZWFycm93bGVmdCxcbiAgICBjaXJjbGVhcnJvd3JpZ2h0OiBjaXJjbGVhcnJvd3JpZ2h0LFxuICAgIGNpcmNsZWRhc3Q6IGNpcmNsZWRhc3QsXG4gICAgY2lyY2xlZGNpcmM6IGNpcmNsZWRjaXJjLFxuICAgIGNpcmNsZWRkYXNoOiBjaXJjbGVkZGFzaCxcbiAgICBDaXJjbGVEb3Q6IENpcmNsZURvdCxcbiAgICBjaXJjbGVkUjogY2lyY2xlZFIsXG4gICAgY2lyY2xlZFM6IGNpcmNsZWRTLFxuICAgIENpcmNsZU1pbnVzOiBDaXJjbGVNaW51cyxcbiAgICBDaXJjbGVQbHVzOiBDaXJjbGVQbHVzLFxuICAgIENpcmNsZVRpbWVzOiBDaXJjbGVUaW1lcyxcbiAgICBjaXI6IGNpcixcbiAgICBjaXJFOiBjaXJFLFxuICAgIGNpcmU6IGNpcmUsXG4gICAgY2lyZm5pbnQ6IGNpcmZuaW50LFxuICAgIGNpcm1pZDogY2lybWlkLFxuICAgIGNpcnNjaXI6IGNpcnNjaXIsXG4gICAgQ2xvY2t3aXNlQ29udG91ckludGVncmFsOiBDbG9ja3dpc2VDb250b3VySW50ZWdyYWwsXG4gICAgQ2xvc2VDdXJseURvdWJsZVF1b3RlOiBDbG9zZUN1cmx5RG91YmxlUXVvdGUsXG4gICAgQ2xvc2VDdXJseVF1b3RlOiBDbG9zZUN1cmx5UXVvdGUsXG4gICAgY2x1YnM6IGNsdWJzLFxuICAgIGNsdWJzdWl0OiBjbHVic3VpdCxcbiAgICBjb2xvbjogY29sb24sXG4gICAgQ29sb246IENvbG9uLFxuICAgIENvbG9uZTogQ29sb25lLFxuICAgIGNvbG9uZTogY29sb25lLFxuICAgIGNvbG9uZXE6IGNvbG9uZXEsXG4gICAgY29tbWE6IGNvbW1hLFxuICAgIGNvbW1hdDogY29tbWF0LFxuICAgIGNvbXA6IGNvbXAsXG4gICAgY29tcGZuOiBjb21wZm4sXG4gICAgY29tcGxlbWVudDogY29tcGxlbWVudCxcbiAgICBjb21wbGV4ZXM6IGNvbXBsZXhlcyxcbiAgICBjb25nOiBjb25nLFxuICAgIGNvbmdkb3Q6IGNvbmdkb3QsXG4gICAgQ29uZ3J1ZW50OiBDb25ncnVlbnQsXG4gICAgY29uaW50OiBjb25pbnQsXG4gICAgQ29uaW50OiBDb25pbnQsXG4gICAgQ29udG91ckludGVncmFsOiBDb250b3VySW50ZWdyYWwsXG4gICAgY29wZjogY29wZixcbiAgICBDb3BmOiBDb3BmLFxuICAgIGNvcHJvZDogY29wcm9kLFxuICAgIENvcHJvZHVjdDogQ29wcm9kdWN0LFxuICAgIGNvcHk6IGNvcHkkMSxcbiAgICBDT1BZOiBDT1BZJDEsXG4gICAgY29weXNyOiBjb3B5c3IsXG4gICAgQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDogQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCxcbiAgICBjcmFycjogY3JhcnIsXG4gICAgY3Jvc3M6IGNyb3NzLFxuICAgIENyb3NzOiBDcm9zcyxcbiAgICBDc2NyOiBDc2NyLFxuICAgIGNzY3I6IGNzY3IsXG4gICAgY3N1YjogY3N1YixcbiAgICBjc3ViZTogY3N1YmUsXG4gICAgY3N1cDogY3N1cCxcbiAgICBjc3VwZTogY3N1cGUsXG4gICAgY3Rkb3Q6IGN0ZG90LFxuICAgIGN1ZGFycmw6IGN1ZGFycmwsXG4gICAgY3VkYXJycjogY3VkYXJycixcbiAgICBjdWVwcjogY3VlcHIsXG4gICAgY3Vlc2M6IGN1ZXNjLFxuICAgIGN1bGFycjogY3VsYXJyLFxuICAgIGN1bGFycnA6IGN1bGFycnAsXG4gICAgY3VwYnJjYXA6IGN1cGJyY2FwLFxuICAgIGN1cGNhcDogY3VwY2FwLFxuICAgIEN1cENhcDogQ3VwQ2FwLFxuICAgIGN1cDogY3VwLFxuICAgIEN1cDogQ3VwLFxuICAgIGN1cGN1cDogY3VwY3VwLFxuICAgIGN1cGRvdDogY3VwZG90LFxuICAgIGN1cG9yOiBjdXBvcixcbiAgICBjdXBzOiBjdXBzLFxuICAgIGN1cmFycjogY3VyYXJyLFxuICAgIGN1cmFycm06IGN1cmFycm0sXG4gICAgY3VybHllcXByZWM6IGN1cmx5ZXFwcmVjLFxuICAgIGN1cmx5ZXFzdWNjOiBjdXJseWVxc3VjYyxcbiAgICBjdXJseXZlZTogY3VybHl2ZWUsXG4gICAgY3VybHl3ZWRnZTogY3VybHl3ZWRnZSxcbiAgICBjdXJyZW46IGN1cnJlbiQxLFxuICAgIGN1cnZlYXJyb3dsZWZ0OiBjdXJ2ZWFycm93bGVmdCxcbiAgICBjdXJ2ZWFycm93cmlnaHQ6IGN1cnZlYXJyb3dyaWdodCxcbiAgICBjdXZlZTogY3V2ZWUsXG4gICAgY3V3ZWQ6IGN1d2VkLFxuICAgIGN3Y29uaW50OiBjd2NvbmludCxcbiAgICBjd2ludDogY3dpbnQsXG4gICAgY3lsY3R5OiBjeWxjdHksXG4gICAgZGFnZ2VyOiBkYWdnZXIsXG4gICAgRGFnZ2VyOiBEYWdnZXIsXG4gICAgZGFsZXRoOiBkYWxldGgsXG4gICAgZGFycjogZGFycixcbiAgICBEYXJyOiBEYXJyLFxuICAgIGRBcnI6IGRBcnIsXG4gICAgZGFzaDogZGFzaCxcbiAgICBEYXNodjogRGFzaHYsXG4gICAgZGFzaHY6IGRhc2h2LFxuICAgIGRia2Fyb3c6IGRia2Fyb3csXG4gICAgZGJsYWM6IGRibGFjLFxuICAgIERjYXJvbjogRGNhcm9uLFxuICAgIGRjYXJvbjogZGNhcm9uLFxuICAgIERjeTogRGN5LFxuICAgIGRjeTogZGN5LFxuICAgIGRkYWdnZXI6IGRkYWdnZXIsXG4gICAgZGRhcnI6IGRkYXJyLFxuICAgIEREOiBERCxcbiAgICBkZDogZGQsXG4gICAgRERvdHJhaGQ6IEREb3RyYWhkLFxuICAgIGRkb3RzZXE6IGRkb3RzZXEsXG4gICAgZGVnOiBkZWckMSxcbiAgICBEZWw6IERlbCxcbiAgICBEZWx0YTogRGVsdGEsXG4gICAgZGVsdGE6IGRlbHRhLFxuICAgIGRlbXB0eXY6IGRlbXB0eXYsXG4gICAgZGZpc2h0OiBkZmlzaHQsXG4gICAgRGZyOiBEZnIsXG4gICAgZGZyOiBkZnIsXG4gICAgZEhhcjogZEhhcixcbiAgICBkaGFybDogZGhhcmwsXG4gICAgZGhhcnI6IGRoYXJyLFxuICAgIERpYWNyaXRpY2FsQWN1dGU6IERpYWNyaXRpY2FsQWN1dGUsXG4gICAgRGlhY3JpdGljYWxEb3Q6IERpYWNyaXRpY2FsRG90LFxuICAgIERpYWNyaXRpY2FsRG91YmxlQWN1dGU6IERpYWNyaXRpY2FsRG91YmxlQWN1dGUsXG4gICAgRGlhY3JpdGljYWxHcmF2ZTogRGlhY3JpdGljYWxHcmF2ZSxcbiAgICBEaWFjcml0aWNhbFRpbGRlOiBEaWFjcml0aWNhbFRpbGRlLFxuICAgIGRpYW06IGRpYW0sXG4gICAgZGlhbW9uZDogZGlhbW9uZCxcbiAgICBEaWFtb25kOiBEaWFtb25kLFxuICAgIGRpYW1vbmRzdWl0OiBkaWFtb25kc3VpdCxcbiAgICBkaWFtczogZGlhbXMsXG4gICAgZGllOiBkaWUsXG4gICAgRGlmZmVyZW50aWFsRDogRGlmZmVyZW50aWFsRCxcbiAgICBkaWdhbW1hOiBkaWdhbW1hLFxuICAgIGRpc2luOiBkaXNpbixcbiAgICBkaXY6IGRpdixcbiAgICBkaXZpZGU6IGRpdmlkZSQxLFxuICAgIGRpdmlkZW9udGltZXM6IGRpdmlkZW9udGltZXMsXG4gICAgZGl2b254OiBkaXZvbngsXG4gICAgREpjeTogREpjeSxcbiAgICBkamN5OiBkamN5LFxuICAgIGRsY29ybjogZGxjb3JuLFxuICAgIGRsY3JvcDogZGxjcm9wLFxuICAgIGRvbGxhcjogZG9sbGFyLFxuICAgIERvcGY6IERvcGYsXG4gICAgZG9wZjogZG9wZixcbiAgICBEb3Q6IERvdCxcbiAgICBkb3Q6IGRvdCxcbiAgICBEb3REb3Q6IERvdERvdCxcbiAgICBkb3RlcTogZG90ZXEsXG4gICAgZG90ZXFkb3Q6IGRvdGVxZG90LFxuICAgIERvdEVxdWFsOiBEb3RFcXVhbCxcbiAgICBkb3RtaW51czogZG90bWludXMsXG4gICAgZG90cGx1czogZG90cGx1cyxcbiAgICBkb3RzcXVhcmU6IGRvdHNxdWFyZSxcbiAgICBkb3VibGViYXJ3ZWRnZTogZG91YmxlYmFyd2VkZ2UsXG4gICAgRG91YmxlQ29udG91ckludGVncmFsOiBEb3VibGVDb250b3VySW50ZWdyYWwsXG4gICAgRG91YmxlRG90OiBEb3VibGVEb3QsXG4gICAgRG91YmxlRG93bkFycm93OiBEb3VibGVEb3duQXJyb3csXG4gICAgRG91YmxlTGVmdEFycm93OiBEb3VibGVMZWZ0QXJyb3csXG4gICAgRG91YmxlTGVmdFJpZ2h0QXJyb3c6IERvdWJsZUxlZnRSaWdodEFycm93LFxuICAgIERvdWJsZUxlZnRUZWU6IERvdWJsZUxlZnRUZWUsXG4gICAgRG91YmxlTG9uZ0xlZnRBcnJvdzogRG91YmxlTG9uZ0xlZnRBcnJvdyxcbiAgICBEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3c6IERvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyxcbiAgICBEb3VibGVMb25nUmlnaHRBcnJvdzogRG91YmxlTG9uZ1JpZ2h0QXJyb3csXG4gICAgRG91YmxlUmlnaHRBcnJvdzogRG91YmxlUmlnaHRBcnJvdyxcbiAgICBEb3VibGVSaWdodFRlZTogRG91YmxlUmlnaHRUZWUsXG4gICAgRG91YmxlVXBBcnJvdzogRG91YmxlVXBBcnJvdyxcbiAgICBEb3VibGVVcERvd25BcnJvdzogRG91YmxlVXBEb3duQXJyb3csXG4gICAgRG91YmxlVmVydGljYWxCYXI6IERvdWJsZVZlcnRpY2FsQmFyLFxuICAgIERvd25BcnJvd0JhcjogRG93bkFycm93QmFyLFxuICAgIGRvd25hcnJvdzogZG93bmFycm93LFxuICAgIERvd25BcnJvdzogRG93bkFycm93LFxuICAgIERvd25hcnJvdzogRG93bmFycm93LFxuICAgIERvd25BcnJvd1VwQXJyb3c6IERvd25BcnJvd1VwQXJyb3csXG4gICAgRG93bkJyZXZlOiBEb3duQnJldmUsXG4gICAgZG93bmRvd25hcnJvd3M6IGRvd25kb3duYXJyb3dzLFxuICAgIGRvd25oYXJwb29ubGVmdDogZG93bmhhcnBvb25sZWZ0LFxuICAgIGRvd25oYXJwb29ucmlnaHQ6IGRvd25oYXJwb29ucmlnaHQsXG4gICAgRG93bkxlZnRSaWdodFZlY3RvcjogRG93bkxlZnRSaWdodFZlY3RvcixcbiAgICBEb3duTGVmdFRlZVZlY3RvcjogRG93bkxlZnRUZWVWZWN0b3IsXG4gICAgRG93bkxlZnRWZWN0b3JCYXI6IERvd25MZWZ0VmVjdG9yQmFyLFxuICAgIERvd25MZWZ0VmVjdG9yOiBEb3duTGVmdFZlY3RvcixcbiAgICBEb3duUmlnaHRUZWVWZWN0b3I6IERvd25SaWdodFRlZVZlY3RvcixcbiAgICBEb3duUmlnaHRWZWN0b3JCYXI6IERvd25SaWdodFZlY3RvckJhcixcbiAgICBEb3duUmlnaHRWZWN0b3I6IERvd25SaWdodFZlY3RvcixcbiAgICBEb3duVGVlQXJyb3c6IERvd25UZWVBcnJvdyxcbiAgICBEb3duVGVlOiBEb3duVGVlLFxuICAgIGRyYmthcm93OiBkcmJrYXJvdyxcbiAgICBkcmNvcm46IGRyY29ybixcbiAgICBkcmNyb3A6IGRyY3JvcCxcbiAgICBEc2NyOiBEc2NyLFxuICAgIGRzY3I6IGRzY3IsXG4gICAgRFNjeTogRFNjeSxcbiAgICBkc2N5OiBkc2N5LFxuICAgIGRzb2w6IGRzb2wsXG4gICAgRHN0cm9rOiBEc3Ryb2ssXG4gICAgZHN0cm9rOiBkc3Ryb2ssXG4gICAgZHRkb3Q6IGR0ZG90LFxuICAgIGR0cmk6IGR0cmksXG4gICAgZHRyaWY6IGR0cmlmLFxuICAgIGR1YXJyOiBkdWFycixcbiAgICBkdWhhcjogZHVoYXIsXG4gICAgZHdhbmdsZTogZHdhbmdsZSxcbiAgICBEWmN5OiBEWmN5LFxuICAgIGR6Y3k6IGR6Y3ksXG4gICAgZHppZ3JhcnI6IGR6aWdyYXJyLFxuICAgIEVhY3V0ZTogRWFjdXRlJDEsXG4gICAgZWFjdXRlOiBlYWN1dGUkMSxcbiAgICBlYXN0ZXI6IGVhc3RlcixcbiAgICBFY2Fyb246IEVjYXJvbixcbiAgICBlY2Fyb246IGVjYXJvbixcbiAgICBFY2lyYzogRWNpcmMkMSxcbiAgICBlY2lyYzogZWNpcmMkMSxcbiAgICBlY2lyOiBlY2lyLFxuICAgIGVjb2xvbjogZWNvbG9uLFxuICAgIEVjeTogRWN5LFxuICAgIGVjeTogZWN5LFxuICAgIGVERG90OiBlRERvdCxcbiAgICBFZG90OiBFZG90LFxuICAgIGVkb3Q6IGVkb3QsXG4gICAgZURvdDogZURvdCxcbiAgICBlZTogZWUsXG4gICAgZWZEb3Q6IGVmRG90LFxuICAgIEVmcjogRWZyLFxuICAgIGVmcjogZWZyLFxuICAgIGVnOiBlZyxcbiAgICBFZ3JhdmU6IEVncmF2ZSQxLFxuICAgIGVncmF2ZTogZWdyYXZlJDEsXG4gICAgZWdzOiBlZ3MsXG4gICAgZWdzZG90OiBlZ3Nkb3QsXG4gICAgZWw6IGVsLFxuICAgIEVsZW1lbnQ6IEVsZW1lbnQsXG4gICAgZWxpbnRlcnM6IGVsaW50ZXJzLFxuICAgIGVsbDogZWxsLFxuICAgIGVsczogZWxzLFxuICAgIGVsc2RvdDogZWxzZG90LFxuICAgIEVtYWNyOiBFbWFjcixcbiAgICBlbWFjcjogZW1hY3IsXG4gICAgZW1wdHk6IGVtcHR5LFxuICAgIGVtcHR5c2V0OiBlbXB0eXNldCxcbiAgICBFbXB0eVNtYWxsU3F1YXJlOiBFbXB0eVNtYWxsU3F1YXJlLFxuICAgIGVtcHR5djogZW1wdHl2LFxuICAgIEVtcHR5VmVyeVNtYWxsU3F1YXJlOiBFbXB0eVZlcnlTbWFsbFNxdWFyZSxcbiAgICBlbXNwMTM6IGVtc3AxMyxcbiAgICBlbXNwMTQ6IGVtc3AxNCxcbiAgICBlbXNwOiBlbXNwLFxuICAgIEVORzogRU5HLFxuICAgIGVuZzogZW5nLFxuICAgIGVuc3A6IGVuc3AsXG4gICAgRW9nb246IEVvZ29uLFxuICAgIGVvZ29uOiBlb2dvbixcbiAgICBFb3BmOiBFb3BmLFxuICAgIGVvcGY6IGVvcGYsXG4gICAgZXBhcjogZXBhcixcbiAgICBlcGFyc2w6IGVwYXJzbCxcbiAgICBlcGx1czogZXBsdXMsXG4gICAgZXBzaTogZXBzaSxcbiAgICBFcHNpbG9uOiBFcHNpbG9uLFxuICAgIGVwc2lsb246IGVwc2lsb24sXG4gICAgZXBzaXY6IGVwc2l2LFxuICAgIGVxY2lyYzogZXFjaXJjLFxuICAgIGVxY29sb246IGVxY29sb24sXG4gICAgZXFzaW06IGVxc2ltLFxuICAgIGVxc2xhbnRndHI6IGVxc2xhbnRndHIsXG4gICAgZXFzbGFudGxlc3M6IGVxc2xhbnRsZXNzLFxuICAgIEVxdWFsOiBFcXVhbCxcbiAgICBlcXVhbHM6IGVxdWFscyxcbiAgICBFcXVhbFRpbGRlOiBFcXVhbFRpbGRlLFxuICAgIGVxdWVzdDogZXF1ZXN0LFxuICAgIEVxdWlsaWJyaXVtOiBFcXVpbGlicml1bSxcbiAgICBlcXVpdjogZXF1aXYsXG4gICAgZXF1aXZERDogZXF1aXZERCxcbiAgICBlcXZwYXJzbDogZXF2cGFyc2wsXG4gICAgZXJhcnI6IGVyYXJyLFxuICAgIGVyRG90OiBlckRvdCxcbiAgICBlc2NyOiBlc2NyLFxuICAgIEVzY3I6IEVzY3IsXG4gICAgZXNkb3Q6IGVzZG90LFxuICAgIEVzaW06IEVzaW0sXG4gICAgZXNpbTogZXNpbSxcbiAgICBFdGE6IEV0YSxcbiAgICBldGE6IGV0YSxcbiAgICBFVEg6IEVUSCQxLFxuICAgIGV0aDogZXRoJDEsXG4gICAgRXVtbDogRXVtbCQxLFxuICAgIGV1bWw6IGV1bWwkMSxcbiAgICBldXJvOiBldXJvLFxuICAgIGV4Y2w6IGV4Y2wsXG4gICAgZXhpc3Q6IGV4aXN0LFxuICAgIEV4aXN0czogRXhpc3RzLFxuICAgIGV4cGVjdGF0aW9uOiBleHBlY3RhdGlvbixcbiAgICBleHBvbmVudGlhbGU6IGV4cG9uZW50aWFsZSxcbiAgICBFeHBvbmVudGlhbEU6IEV4cG9uZW50aWFsRSxcbiAgICBmYWxsaW5nZG90c2VxOiBmYWxsaW5nZG90c2VxLFxuICAgIEZjeTogRmN5LFxuICAgIGZjeTogZmN5LFxuICAgIGZlbWFsZTogZmVtYWxlLFxuICAgIGZmaWxpZzogZmZpbGlnLFxuICAgIGZmbGlnOiBmZmxpZyxcbiAgICBmZmxsaWc6IGZmbGxpZyxcbiAgICBGZnI6IEZmcixcbiAgICBmZnI6IGZmcixcbiAgICBmaWxpZzogZmlsaWcsXG4gICAgRmlsbGVkU21hbGxTcXVhcmU6IEZpbGxlZFNtYWxsU3F1YXJlLFxuICAgIEZpbGxlZFZlcnlTbWFsbFNxdWFyZTogRmlsbGVkVmVyeVNtYWxsU3F1YXJlLFxuICAgIGZqbGlnOiBmamxpZyxcbiAgICBmbGF0OiBmbGF0LFxuICAgIGZsbGlnOiBmbGxpZyxcbiAgICBmbHRuczogZmx0bnMsXG4gICAgZm5vZjogZm5vZixcbiAgICBGb3BmOiBGb3BmLFxuICAgIGZvcGY6IGZvcGYsXG4gICAgZm9yYWxsOiBmb3JhbGwsXG4gICAgRm9yQWxsOiBGb3JBbGwsXG4gICAgZm9yazogZm9yayxcbiAgICBmb3JrdjogZm9ya3YsXG4gICAgRm91cmllcnRyZjogRm91cmllcnRyZixcbiAgICBmcGFydGludDogZnBhcnRpbnQsXG4gICAgZnJhYzEyOiBmcmFjMTIkMSxcbiAgICBmcmFjMTM6IGZyYWMxMyxcbiAgICBmcmFjMTQ6IGZyYWMxNCQxLFxuICAgIGZyYWMxNTogZnJhYzE1LFxuICAgIGZyYWMxNjogZnJhYzE2LFxuICAgIGZyYWMxODogZnJhYzE4LFxuICAgIGZyYWMyMzogZnJhYzIzLFxuICAgIGZyYWMyNTogZnJhYzI1LFxuICAgIGZyYWMzNDogZnJhYzM0JDEsXG4gICAgZnJhYzM1OiBmcmFjMzUsXG4gICAgZnJhYzM4OiBmcmFjMzgsXG4gICAgZnJhYzQ1OiBmcmFjNDUsXG4gICAgZnJhYzU2OiBmcmFjNTYsXG4gICAgZnJhYzU4OiBmcmFjNTgsXG4gICAgZnJhYzc4OiBmcmFjNzgsXG4gICAgZnJhc2w6IGZyYXNsLFxuICAgIGZyb3duOiBmcm93bixcbiAgICBmc2NyOiBmc2NyLFxuICAgIEZzY3I6IEZzY3IsXG4gICAgZ2FjdXRlOiBnYWN1dGUsXG4gICAgR2FtbWE6IEdhbW1hLFxuICAgIGdhbW1hOiBnYW1tYSxcbiAgICBHYW1tYWQ6IEdhbW1hZCxcbiAgICBnYW1tYWQ6IGdhbW1hZCxcbiAgICBnYXA6IGdhcCxcbiAgICBHYnJldmU6IEdicmV2ZSxcbiAgICBnYnJldmU6IGdicmV2ZSxcbiAgICBHY2VkaWw6IEdjZWRpbCxcbiAgICBHY2lyYzogR2NpcmMsXG4gICAgZ2NpcmM6IGdjaXJjLFxuICAgIEdjeTogR2N5LFxuICAgIGdjeTogZ2N5LFxuICAgIEdkb3Q6IEdkb3QsXG4gICAgZ2RvdDogZ2RvdCxcbiAgICBnZTogZ2UsXG4gICAgZ0U6IGdFLFxuICAgIGdFbDogZ0VsLFxuICAgIGdlbDogZ2VsLFxuICAgIGdlcTogZ2VxLFxuICAgIGdlcXE6IGdlcXEsXG4gICAgZ2Vxc2xhbnQ6IGdlcXNsYW50LFxuICAgIGdlc2NjOiBnZXNjYyxcbiAgICBnZXM6IGdlcyxcbiAgICBnZXNkb3Q6IGdlc2RvdCxcbiAgICBnZXNkb3RvOiBnZXNkb3RvLFxuICAgIGdlc2RvdG9sOiBnZXNkb3RvbCxcbiAgICBnZXNsOiBnZXNsLFxuICAgIGdlc2xlczogZ2VzbGVzLFxuICAgIEdmcjogR2ZyLFxuICAgIGdmcjogZ2ZyLFxuICAgIGdnOiBnZyxcbiAgICBHZzogR2csXG4gICAgZ2dnOiBnZ2csXG4gICAgZ2ltZWw6IGdpbWVsLFxuICAgIEdKY3k6IEdKY3ksXG4gICAgZ2pjeTogZ2pjeSxcbiAgICBnbGE6IGdsYSxcbiAgICBnbDogZ2wsXG4gICAgZ2xFOiBnbEUsXG4gICAgZ2xqOiBnbGosXG4gICAgZ25hcDogZ25hcCxcbiAgICBnbmFwcHJveDogZ25hcHByb3gsXG4gICAgZ25lOiBnbmUsXG4gICAgZ25FOiBnbkUsXG4gICAgZ25lcTogZ25lcSxcbiAgICBnbmVxcTogZ25lcXEsXG4gICAgZ25zaW06IGduc2ltLFxuICAgIEdvcGY6IEdvcGYsXG4gICAgZ29wZjogZ29wZixcbiAgICBncmF2ZTogZ3JhdmUsXG4gICAgR3JlYXRlckVxdWFsOiBHcmVhdGVyRXF1YWwsXG4gICAgR3JlYXRlckVxdWFsTGVzczogR3JlYXRlckVxdWFsTGVzcyxcbiAgICBHcmVhdGVyRnVsbEVxdWFsOiBHcmVhdGVyRnVsbEVxdWFsLFxuICAgIEdyZWF0ZXJHcmVhdGVyOiBHcmVhdGVyR3JlYXRlcixcbiAgICBHcmVhdGVyTGVzczogR3JlYXRlckxlc3MsXG4gICAgR3JlYXRlclNsYW50RXF1YWw6IEdyZWF0ZXJTbGFudEVxdWFsLFxuICAgIEdyZWF0ZXJUaWxkZTogR3JlYXRlclRpbGRlLFxuICAgIEdzY3I6IEdzY3IsXG4gICAgZ3NjcjogZ3NjcixcbiAgICBnc2ltOiBnc2ltLFxuICAgIGdzaW1lOiBnc2ltZSxcbiAgICBnc2ltbDogZ3NpbWwsXG4gICAgZ3RjYzogZ3RjYyxcbiAgICBndGNpcjogZ3RjaXIsXG4gICAgZ3Q6IGd0JDIsXG4gICAgR1Q6IEdUJDEsXG4gICAgR3Q6IEd0LFxuICAgIGd0ZG90OiBndGRvdCxcbiAgICBndGxQYXI6IGd0bFBhcixcbiAgICBndHF1ZXN0OiBndHF1ZXN0LFxuICAgIGd0cmFwcHJveDogZ3RyYXBwcm94LFxuICAgIGd0cmFycjogZ3RyYXJyLFxuICAgIGd0cmRvdDogZ3RyZG90LFxuICAgIGd0cmVxbGVzczogZ3RyZXFsZXNzLFxuICAgIGd0cmVxcWxlc3M6IGd0cmVxcWxlc3MsXG4gICAgZ3RybGVzczogZ3RybGVzcyxcbiAgICBndHJzaW06IGd0cnNpbSxcbiAgICBndmVydG5lcXE6IGd2ZXJ0bmVxcSxcbiAgICBndm5FOiBndm5FLFxuICAgIEhhY2VrOiBIYWNlayxcbiAgICBoYWlyc3A6IGhhaXJzcCxcbiAgICBoYWxmOiBoYWxmLFxuICAgIGhhbWlsdDogaGFtaWx0LFxuICAgIEhBUkRjeTogSEFSRGN5LFxuICAgIGhhcmRjeTogaGFyZGN5LFxuICAgIGhhcnJjaXI6IGhhcnJjaXIsXG4gICAgaGFycjogaGFycixcbiAgICBoQXJyOiBoQXJyLFxuICAgIGhhcnJ3OiBoYXJydyxcbiAgICBIYXQ6IEhhdCxcbiAgICBoYmFyOiBoYmFyLFxuICAgIEhjaXJjOiBIY2lyYyxcbiAgICBoY2lyYzogaGNpcmMsXG4gICAgaGVhcnRzOiBoZWFydHMsXG4gICAgaGVhcnRzdWl0OiBoZWFydHN1aXQsXG4gICAgaGVsbGlwOiBoZWxsaXAsXG4gICAgaGVyY29uOiBoZXJjb24sXG4gICAgaGZyOiBoZnIsXG4gICAgSGZyOiBIZnIsXG4gICAgSGlsYmVydFNwYWNlOiBIaWxiZXJ0U3BhY2UsXG4gICAgaGtzZWFyb3c6IGhrc2Vhcm93LFxuICAgIGhrc3dhcm93OiBoa3N3YXJvdyxcbiAgICBob2FycjogaG9hcnIsXG4gICAgaG9tdGh0OiBob210aHQsXG4gICAgaG9va2xlZnRhcnJvdzogaG9va2xlZnRhcnJvdyxcbiAgICBob29rcmlnaHRhcnJvdzogaG9va3JpZ2h0YXJyb3csXG4gICAgaG9wZjogaG9wZixcbiAgICBIb3BmOiBIb3BmLFxuICAgIGhvcmJhcjogaG9yYmFyLFxuICAgIEhvcml6b250YWxMaW5lOiBIb3Jpem9udGFsTGluZSxcbiAgICBoc2NyOiBoc2NyLFxuICAgIEhzY3I6IEhzY3IsXG4gICAgaHNsYXNoOiBoc2xhc2gsXG4gICAgSHN0cm9rOiBIc3Ryb2ssXG4gICAgaHN0cm9rOiBoc3Ryb2ssXG4gICAgSHVtcERvd25IdW1wOiBIdW1wRG93bkh1bXAsXG4gICAgSHVtcEVxdWFsOiBIdW1wRXF1YWwsXG4gICAgaHlidWxsOiBoeWJ1bGwsXG4gICAgaHlwaGVuOiBoeXBoZW4sXG4gICAgSWFjdXRlOiBJYWN1dGUkMSxcbiAgICBpYWN1dGU6IGlhY3V0ZSQxLFxuICAgIGljOiBpYyxcbiAgICBJY2lyYzogSWNpcmMkMSxcbiAgICBpY2lyYzogaWNpcmMkMSxcbiAgICBJY3k6IEljeSxcbiAgICBpY3k6IGljeSxcbiAgICBJZG90OiBJZG90LFxuICAgIElFY3k6IElFY3ksXG4gICAgaWVjeTogaWVjeSxcbiAgICBpZXhjbDogaWV4Y2wkMSxcbiAgICBpZmY6IGlmZixcbiAgICBpZnI6IGlmcixcbiAgICBJZnI6IElmcixcbiAgICBJZ3JhdmU6IElncmF2ZSQxLFxuICAgIGlncmF2ZTogaWdyYXZlJDEsXG4gICAgaWk6IGlpLFxuICAgIGlpaWludDogaWlpaW50LFxuICAgIGlpaW50OiBpaWludCxcbiAgICBpaW5maW46IGlpbmZpbixcbiAgICBpaW90YTogaWlvdGEsXG4gICAgSUpsaWc6IElKbGlnLFxuICAgIGlqbGlnOiBpamxpZyxcbiAgICBJbWFjcjogSW1hY3IsXG4gICAgaW1hY3I6IGltYWNyLFxuICAgIGltYWdlOiBlc21faW1hZ2UsXG4gICAgSW1hZ2luYXJ5STogSW1hZ2luYXJ5SSxcbiAgICBpbWFnbGluZTogaW1hZ2xpbmUsXG4gICAgaW1hZ3BhcnQ6IGltYWdwYXJ0LFxuICAgIGltYXRoOiBpbWF0aCxcbiAgICBJbTogSW0sXG4gICAgaW1vZjogaW1vZixcbiAgICBpbXBlZDogaW1wZWQsXG4gICAgSW1wbGllczogSW1wbGllcyxcbiAgICBpbmNhcmU6IGluY2FyZSxcbiAgICBcImluXCI6IFwi4oiIXCIsXG4gICAgaW5maW46IGluZmluLFxuICAgIGluZmludGllOiBpbmZpbnRpZSxcbiAgICBpbm9kb3Q6IGlub2RvdCxcbiAgICBpbnRjYWw6IGludGNhbCxcbiAgICBpbnQ6IGVzbV9pbnQsXG4gICAgSW50OiBJbnQsXG4gICAgaW50ZWdlcnM6IGludGVnZXJzLFxuICAgIEludGVncmFsOiBJbnRlZ3JhbCxcbiAgICBpbnRlcmNhbDogaW50ZXJjYWwsXG4gICAgSW50ZXJzZWN0aW9uOiBJbnRlcnNlY3Rpb24sXG4gICAgaW50bGFyaGs6IGludGxhcmhrLFxuICAgIGludHByb2Q6IGludHByb2QsXG4gICAgSW52aXNpYmxlQ29tbWE6IEludmlzaWJsZUNvbW1hLFxuICAgIEludmlzaWJsZVRpbWVzOiBJbnZpc2libGVUaW1lcyxcbiAgICBJT2N5OiBJT2N5LFxuICAgIGlvY3k6IGlvY3ksXG4gICAgSW9nb246IElvZ29uLFxuICAgIGlvZ29uOiBpb2dvbixcbiAgICBJb3BmOiBJb3BmLFxuICAgIGlvcGY6IGlvcGYsXG4gICAgSW90YTogSW90YSxcbiAgICBpb3RhOiBpb3RhLFxuICAgIGlwcm9kOiBpcHJvZCxcbiAgICBpcXVlc3Q6IGlxdWVzdCQxLFxuICAgIGlzY3I6IGlzY3IsXG4gICAgSXNjcjogSXNjcixcbiAgICBpc2luOiBpc2luLFxuICAgIGlzaW5kb3Q6IGlzaW5kb3QsXG4gICAgaXNpbkU6IGlzaW5FLFxuICAgIGlzaW5zOiBpc2lucyxcbiAgICBpc2luc3Y6IGlzaW5zdixcbiAgICBpc2ludjogaXNpbnYsXG4gICAgaXQ6IGl0LFxuICAgIEl0aWxkZTogSXRpbGRlLFxuICAgIGl0aWxkZTogaXRpbGRlLFxuICAgIEl1a2N5OiBJdWtjeSxcbiAgICBpdWtjeTogaXVrY3ksXG4gICAgSXVtbDogSXVtbCQxLFxuICAgIGl1bWw6IGl1bWwkMSxcbiAgICBKY2lyYzogSmNpcmMsXG4gICAgamNpcmM6IGpjaXJjLFxuICAgIEpjeTogSmN5LFxuICAgIGpjeTogamN5LFxuICAgIEpmcjogSmZyLFxuICAgIGpmcjogamZyLFxuICAgIGptYXRoOiBqbWF0aCxcbiAgICBKb3BmOiBKb3BmLFxuICAgIGpvcGY6IGpvcGYsXG4gICAgSnNjcjogSnNjcixcbiAgICBqc2NyOiBqc2NyLFxuICAgIEpzZXJjeTogSnNlcmN5LFxuICAgIGpzZXJjeToganNlcmN5LFxuICAgIEp1a2N5OiBKdWtjeSxcbiAgICBqdWtjeToganVrY3ksXG4gICAgS2FwcGE6IEthcHBhLFxuICAgIGthcHBhOiBrYXBwYSxcbiAgICBrYXBwYXY6IGthcHBhdixcbiAgICBLY2VkaWw6IEtjZWRpbCxcbiAgICBrY2VkaWw6IGtjZWRpbCxcbiAgICBLY3k6IEtjeSxcbiAgICBrY3k6IGtjeSxcbiAgICBLZnI6IEtmcixcbiAgICBrZnI6IGtmcixcbiAgICBrZ3JlZW46IGtncmVlbixcbiAgICBLSGN5OiBLSGN5LFxuICAgIGtoY3k6IGtoY3ksXG4gICAgS0pjeTogS0pjeSxcbiAgICBramN5OiBramN5LFxuICAgIEtvcGY6IEtvcGYsXG4gICAga29wZjoga29wZixcbiAgICBLc2NyOiBLc2NyLFxuICAgIGtzY3I6IGtzY3IsXG4gICAgbEFhcnI6IGxBYXJyLFxuICAgIExhY3V0ZTogTGFjdXRlLFxuICAgIGxhY3V0ZTogbGFjdXRlLFxuICAgIGxhZW1wdHl2OiBsYWVtcHR5dixcbiAgICBsYWdyYW46IGxhZ3JhbixcbiAgICBMYW1iZGE6IExhbWJkYSxcbiAgICBsYW1iZGE6IGxhbWJkYSxcbiAgICBsYW5nOiBsYW5nLFxuICAgIExhbmc6IExhbmcsXG4gICAgbGFuZ2Q6IGxhbmdkLFxuICAgIGxhbmdsZTogbGFuZ2xlLFxuICAgIGxhcDogbGFwLFxuICAgIExhcGxhY2V0cmY6IExhcGxhY2V0cmYsXG4gICAgbGFxdW86IGxhcXVvJDEsXG4gICAgbGFycmI6IGxhcnJiLFxuICAgIGxhcnJiZnM6IGxhcnJiZnMsXG4gICAgbGFycjogbGFycixcbiAgICBMYXJyOiBMYXJyLFxuICAgIGxBcnI6IGxBcnIsXG4gICAgbGFycmZzOiBsYXJyZnMsXG4gICAgbGFycmhrOiBsYXJyaGssXG4gICAgbGFycmxwOiBsYXJybHAsXG4gICAgbGFycnBsOiBsYXJycGwsXG4gICAgbGFycnNpbTogbGFycnNpbSxcbiAgICBsYXJydGw6IGxhcnJ0bCxcbiAgICBsYXRhaWw6IGxhdGFpbCxcbiAgICBsQXRhaWw6IGxBdGFpbCxcbiAgICBsYXQ6IGxhdCxcbiAgICBsYXRlOiBsYXRlLFxuICAgIGxhdGVzOiBsYXRlcyxcbiAgICBsYmFycjogbGJhcnIsXG4gICAgbEJhcnI6IGxCYXJyLFxuICAgIGxiYnJrOiBsYmJyayxcbiAgICBsYnJhY2U6IGxicmFjZSxcbiAgICBsYnJhY2s6IGxicmFjayxcbiAgICBsYnJrZTogbGJya2UsXG4gICAgbGJya3NsZDogbGJya3NsZCxcbiAgICBsYnJrc2x1OiBsYnJrc2x1LFxuICAgIExjYXJvbjogTGNhcm9uLFxuICAgIGxjYXJvbjogbGNhcm9uLFxuICAgIExjZWRpbDogTGNlZGlsLFxuICAgIGxjZWRpbDogbGNlZGlsLFxuICAgIGxjZWlsOiBsY2VpbCxcbiAgICBsY3ViOiBsY3ViLFxuICAgIExjeTogTGN5LFxuICAgIGxjeTogbGN5LFxuICAgIGxkY2E6IGxkY2EsXG4gICAgbGRxdW86IGxkcXVvLFxuICAgIGxkcXVvcjogbGRxdW9yLFxuICAgIGxkcmRoYXI6IGxkcmRoYXIsXG4gICAgbGRydXNoYXI6IGxkcnVzaGFyLFxuICAgIGxkc2g6IGxkc2gsXG4gICAgbGU6IGxlLFxuICAgIGxFOiBsRSxcbiAgICBMZWZ0QW5nbGVCcmFja2V0OiBMZWZ0QW5nbGVCcmFja2V0LFxuICAgIExlZnRBcnJvd0JhcjogTGVmdEFycm93QmFyLFxuICAgIGxlZnRhcnJvdzogbGVmdGFycm93LFxuICAgIExlZnRBcnJvdzogTGVmdEFycm93LFxuICAgIExlZnRhcnJvdzogTGVmdGFycm93LFxuICAgIExlZnRBcnJvd1JpZ2h0QXJyb3c6IExlZnRBcnJvd1JpZ2h0QXJyb3csXG4gICAgbGVmdGFycm93dGFpbDogbGVmdGFycm93dGFpbCxcbiAgICBMZWZ0Q2VpbGluZzogTGVmdENlaWxpbmcsXG4gICAgTGVmdERvdWJsZUJyYWNrZXQ6IExlZnREb3VibGVCcmFja2V0LFxuICAgIExlZnREb3duVGVlVmVjdG9yOiBMZWZ0RG93blRlZVZlY3RvcixcbiAgICBMZWZ0RG93blZlY3RvckJhcjogTGVmdERvd25WZWN0b3JCYXIsXG4gICAgTGVmdERvd25WZWN0b3I6IExlZnREb3duVmVjdG9yLFxuICAgIExlZnRGbG9vcjogTGVmdEZsb29yLFxuICAgIGxlZnRoYXJwb29uZG93bjogbGVmdGhhcnBvb25kb3duLFxuICAgIGxlZnRoYXJwb29udXA6IGxlZnRoYXJwb29udXAsXG4gICAgbGVmdGxlZnRhcnJvd3M6IGxlZnRsZWZ0YXJyb3dzLFxuICAgIGxlZnRyaWdodGFycm93OiBsZWZ0cmlnaHRhcnJvdyxcbiAgICBMZWZ0UmlnaHRBcnJvdzogTGVmdFJpZ2h0QXJyb3csXG4gICAgTGVmdHJpZ2h0YXJyb3c6IExlZnRyaWdodGFycm93LFxuICAgIGxlZnRyaWdodGFycm93czogbGVmdHJpZ2h0YXJyb3dzLFxuICAgIGxlZnRyaWdodGhhcnBvb25zOiBsZWZ0cmlnaHRoYXJwb29ucyxcbiAgICBsZWZ0cmlnaHRzcXVpZ2Fycm93OiBsZWZ0cmlnaHRzcXVpZ2Fycm93LFxuICAgIExlZnRSaWdodFZlY3RvcjogTGVmdFJpZ2h0VmVjdG9yLFxuICAgIExlZnRUZWVBcnJvdzogTGVmdFRlZUFycm93LFxuICAgIExlZnRUZWU6IExlZnRUZWUsXG4gICAgTGVmdFRlZVZlY3RvcjogTGVmdFRlZVZlY3RvcixcbiAgICBsZWZ0dGhyZWV0aW1lczogbGVmdHRocmVldGltZXMsXG4gICAgTGVmdFRyaWFuZ2xlQmFyOiBMZWZ0VHJpYW5nbGVCYXIsXG4gICAgTGVmdFRyaWFuZ2xlOiBMZWZ0VHJpYW5nbGUsXG4gICAgTGVmdFRyaWFuZ2xlRXF1YWw6IExlZnRUcmlhbmdsZUVxdWFsLFxuICAgIExlZnRVcERvd25WZWN0b3I6IExlZnRVcERvd25WZWN0b3IsXG4gICAgTGVmdFVwVGVlVmVjdG9yOiBMZWZ0VXBUZWVWZWN0b3IsXG4gICAgTGVmdFVwVmVjdG9yQmFyOiBMZWZ0VXBWZWN0b3JCYXIsXG4gICAgTGVmdFVwVmVjdG9yOiBMZWZ0VXBWZWN0b3IsXG4gICAgTGVmdFZlY3RvckJhcjogTGVmdFZlY3RvckJhcixcbiAgICBMZWZ0VmVjdG9yOiBMZWZ0VmVjdG9yLFxuICAgIGxFZzogbEVnLFxuICAgIGxlZzogbGVnLFxuICAgIGxlcTogbGVxLFxuICAgIGxlcXE6IGxlcXEsXG4gICAgbGVxc2xhbnQ6IGxlcXNsYW50LFxuICAgIGxlc2NjOiBsZXNjYyxcbiAgICBsZXM6IGxlcyxcbiAgICBsZXNkb3Q6IGxlc2RvdCxcbiAgICBsZXNkb3RvOiBsZXNkb3RvLFxuICAgIGxlc2RvdG9yOiBsZXNkb3RvcixcbiAgICBsZXNnOiBsZXNnLFxuICAgIGxlc2dlczogbGVzZ2VzLFxuICAgIGxlc3NhcHByb3g6IGxlc3NhcHByb3gsXG4gICAgbGVzc2RvdDogbGVzc2RvdCxcbiAgICBsZXNzZXFndHI6IGxlc3NlcWd0cixcbiAgICBsZXNzZXFxZ3RyOiBsZXNzZXFxZ3RyLFxuICAgIExlc3NFcXVhbEdyZWF0ZXI6IExlc3NFcXVhbEdyZWF0ZXIsXG4gICAgTGVzc0Z1bGxFcXVhbDogTGVzc0Z1bGxFcXVhbCxcbiAgICBMZXNzR3JlYXRlcjogTGVzc0dyZWF0ZXIsXG4gICAgbGVzc2d0cjogbGVzc2d0cixcbiAgICBMZXNzTGVzczogTGVzc0xlc3MsXG4gICAgbGVzc3NpbTogbGVzc3NpbSxcbiAgICBMZXNzU2xhbnRFcXVhbDogTGVzc1NsYW50RXF1YWwsXG4gICAgTGVzc1RpbGRlOiBMZXNzVGlsZGUsXG4gICAgbGZpc2h0OiBsZmlzaHQsXG4gICAgbGZsb29yOiBsZmxvb3IsXG4gICAgTGZyOiBMZnIsXG4gICAgbGZyOiBsZnIsXG4gICAgbGc6IGxnLFxuICAgIGxnRTogbGdFLFxuICAgIGxIYXI6IGxIYXIsXG4gICAgbGhhcmQ6IGxoYXJkLFxuICAgIGxoYXJ1OiBsaGFydSxcbiAgICBsaGFydWw6IGxoYXJ1bCxcbiAgICBsaGJsazogbGhibGssXG4gICAgTEpjeTogTEpjeSxcbiAgICBsamN5OiBsamN5LFxuICAgIGxsYXJyOiBsbGFycixcbiAgICBsbDogbGwsXG4gICAgTGw6IExsLFxuICAgIGxsY29ybmVyOiBsbGNvcm5lcixcbiAgICBMbGVmdGFycm93OiBMbGVmdGFycm93LFxuICAgIGxsaGFyZDogbGxoYXJkLFxuICAgIGxsdHJpOiBsbHRyaSxcbiAgICBMbWlkb3Q6IExtaWRvdCxcbiAgICBsbWlkb3Q6IGxtaWRvdCxcbiAgICBsbW91c3RhY2hlOiBsbW91c3RhY2hlLFxuICAgIGxtb3VzdDogbG1vdXN0LFxuICAgIGxuYXA6IGxuYXAsXG4gICAgbG5hcHByb3g6IGxuYXBwcm94LFxuICAgIGxuZTogbG5lLFxuICAgIGxuRTogbG5FLFxuICAgIGxuZXE6IGxuZXEsXG4gICAgbG5lcXE6IGxuZXFxLFxuICAgIGxuc2ltOiBsbnNpbSxcbiAgICBsb2FuZzogbG9hbmcsXG4gICAgbG9hcnI6IGxvYXJyLFxuICAgIGxvYnJrOiBsb2JyayxcbiAgICBsb25nbGVmdGFycm93OiBsb25nbGVmdGFycm93LFxuICAgIExvbmdMZWZ0QXJyb3c6IExvbmdMZWZ0QXJyb3csXG4gICAgTG9uZ2xlZnRhcnJvdzogTG9uZ2xlZnRhcnJvdyxcbiAgICBsb25nbGVmdHJpZ2h0YXJyb3c6IGxvbmdsZWZ0cmlnaHRhcnJvdyxcbiAgICBMb25nTGVmdFJpZ2h0QXJyb3c6IExvbmdMZWZ0UmlnaHRBcnJvdyxcbiAgICBMb25nbGVmdHJpZ2h0YXJyb3c6IExvbmdsZWZ0cmlnaHRhcnJvdyxcbiAgICBsb25nbWFwc3RvOiBsb25nbWFwc3RvLFxuICAgIGxvbmdyaWdodGFycm93OiBsb25ncmlnaHRhcnJvdyxcbiAgICBMb25nUmlnaHRBcnJvdzogTG9uZ1JpZ2h0QXJyb3csXG4gICAgTG9uZ3JpZ2h0YXJyb3c6IExvbmdyaWdodGFycm93LFxuICAgIGxvb3BhcnJvd2xlZnQ6IGxvb3BhcnJvd2xlZnQsXG4gICAgbG9vcGFycm93cmlnaHQ6IGxvb3BhcnJvd3JpZ2h0LFxuICAgIGxvcGFyOiBsb3BhcixcbiAgICBMb3BmOiBMb3BmLFxuICAgIGxvcGY6IGxvcGYsXG4gICAgbG9wbHVzOiBsb3BsdXMsXG4gICAgbG90aW1lczogbG90aW1lcyxcbiAgICBsb3dhc3Q6IGxvd2FzdCxcbiAgICBsb3diYXI6IGxvd2JhcixcbiAgICBMb3dlckxlZnRBcnJvdzogTG93ZXJMZWZ0QXJyb3csXG4gICAgTG93ZXJSaWdodEFycm93OiBMb3dlclJpZ2h0QXJyb3csXG4gICAgbG96OiBsb3osXG4gICAgbG96ZW5nZTogbG96ZW5nZSxcbiAgICBsb3pmOiBsb3pmLFxuICAgIGxwYXI6IGxwYXIsXG4gICAgbHBhcmx0OiBscGFybHQsXG4gICAgbHJhcnI6IGxyYXJyLFxuICAgIGxyY29ybmVyOiBscmNvcm5lcixcbiAgICBscmhhcjogbHJoYXIsXG4gICAgbHJoYXJkOiBscmhhcmQsXG4gICAgbHJtOiBscm0sXG4gICAgbHJ0cmk6IGxydHJpLFxuICAgIGxzYXF1bzogbHNhcXVvLFxuICAgIGxzY3I6IGxzY3IsXG4gICAgTHNjcjogTHNjcixcbiAgICBsc2g6IGxzaCxcbiAgICBMc2g6IExzaCxcbiAgICBsc2ltOiBsc2ltLFxuICAgIGxzaW1lOiBsc2ltZSxcbiAgICBsc2ltZzogbHNpbWcsXG4gICAgbHNxYjogbHNxYixcbiAgICBsc3F1bzogbHNxdW8sXG4gICAgbHNxdW9yOiBsc3F1b3IsXG4gICAgTHN0cm9rOiBMc3Ryb2ssXG4gICAgbHN0cm9rOiBsc3Ryb2ssXG4gICAgbHRjYzogbHRjYyxcbiAgICBsdGNpcjogbHRjaXIsXG4gICAgbHQ6IGx0JDIsXG4gICAgTFQ6IExUJDEsXG4gICAgTHQ6IEx0LFxuICAgIGx0ZG90OiBsdGRvdCxcbiAgICBsdGhyZWU6IGx0aHJlZSxcbiAgICBsdGltZXM6IGx0aW1lcyxcbiAgICBsdGxhcnI6IGx0bGFycixcbiAgICBsdHF1ZXN0OiBsdHF1ZXN0LFxuICAgIGx0cmk6IGx0cmksXG4gICAgbHRyaWU6IGx0cmllLFxuICAgIGx0cmlmOiBsdHJpZixcbiAgICBsdHJQYXI6IGx0clBhcixcbiAgICBsdXJkc2hhcjogbHVyZHNoYXIsXG4gICAgbHVydWhhcjogbHVydWhhcixcbiAgICBsdmVydG5lcXE6IGx2ZXJ0bmVxcSxcbiAgICBsdm5FOiBsdm5FLFxuICAgIG1hY3I6IG1hY3IkMSxcbiAgICBtYWxlOiBtYWxlLFxuICAgIG1hbHQ6IG1hbHQsXG4gICAgbWFsdGVzZTogbWFsdGVzZSxcbiAgICBcIk1hcFwiOiBcIuKkhVwiLFxuICAgIG1hcDogbWFwLFxuICAgIG1hcHN0bzogbWFwc3RvLFxuICAgIG1hcHN0b2Rvd246IG1hcHN0b2Rvd24sXG4gICAgbWFwc3RvbGVmdDogbWFwc3RvbGVmdCxcbiAgICBtYXBzdG91cDogbWFwc3RvdXAsXG4gICAgbWFya2VyOiBtYXJrZXIsXG4gICAgbWNvbW1hOiBtY29tbWEsXG4gICAgTWN5OiBNY3ksXG4gICAgbWN5OiBtY3ksXG4gICAgbWRhc2g6IG1kYXNoLFxuICAgIG1ERG90OiBtRERvdCxcbiAgICBtZWFzdXJlZGFuZ2xlOiBtZWFzdXJlZGFuZ2xlLFxuICAgIE1lZGl1bVNwYWNlOiBNZWRpdW1TcGFjZSxcbiAgICBNZWxsaW50cmY6IE1lbGxpbnRyZixcbiAgICBNZnI6IE1mcixcbiAgICBtZnI6IG1mcixcbiAgICBtaG86IG1obyxcbiAgICBtaWNybzogbWljcm8kMSxcbiAgICBtaWRhc3Q6IG1pZGFzdCxcbiAgICBtaWRjaXI6IG1pZGNpcixcbiAgICBtaWQ6IG1pZCxcbiAgICBtaWRkb3Q6IG1pZGRvdCQxLFxuICAgIG1pbnVzYjogbWludXNiLFxuICAgIG1pbnVzOiBtaW51cyxcbiAgICBtaW51c2Q6IG1pbnVzZCxcbiAgICBtaW51c2R1OiBtaW51c2R1LFxuICAgIE1pbnVzUGx1czogTWludXNQbHVzLFxuICAgIG1sY3A6IG1sY3AsXG4gICAgbWxkcjogbWxkcixcbiAgICBtbnBsdXM6IG1ucGx1cyxcbiAgICBtb2RlbHM6IG1vZGVscyxcbiAgICBNb3BmOiBNb3BmLFxuICAgIG1vcGY6IG1vcGYsXG4gICAgbXA6IG1wLFxuICAgIG1zY3I6IG1zY3IsXG4gICAgTXNjcjogTXNjcixcbiAgICBtc3Rwb3M6IG1zdHBvcyxcbiAgICBNdTogTXUsXG4gICAgbXU6IG11LFxuICAgIG11bHRpbWFwOiBtdWx0aW1hcCxcbiAgICBtdW1hcDogbXVtYXAsXG4gICAgbmFibGE6IG5hYmxhLFxuICAgIE5hY3V0ZTogTmFjdXRlLFxuICAgIG5hY3V0ZTogbmFjdXRlLFxuICAgIG5hbmc6IG5hbmcsXG4gICAgbmFwOiBuYXAsXG4gICAgbmFwRTogbmFwRSxcbiAgICBuYXBpZDogbmFwaWQsXG4gICAgbmFwb3M6IG5hcG9zLFxuICAgIG5hcHByb3g6IG5hcHByb3gsXG4gICAgbmF0dXJhbDogbmF0dXJhbCxcbiAgICBuYXR1cmFsczogbmF0dXJhbHMsXG4gICAgbmF0dXI6IG5hdHVyLFxuICAgIG5ic3A6IG5ic3AkMSxcbiAgICBuYnVtcDogbmJ1bXAsXG4gICAgbmJ1bXBlOiBuYnVtcGUsXG4gICAgbmNhcDogbmNhcCxcbiAgICBOY2Fyb246IE5jYXJvbixcbiAgICBuY2Fyb246IG5jYXJvbixcbiAgICBOY2VkaWw6IE5jZWRpbCxcbiAgICBuY2VkaWw6IG5jZWRpbCxcbiAgICBuY29uZzogbmNvbmcsXG4gICAgbmNvbmdkb3Q6IG5jb25nZG90LFxuICAgIG5jdXA6IG5jdXAsXG4gICAgTmN5OiBOY3ksXG4gICAgbmN5OiBuY3ksXG4gICAgbmRhc2g6IG5kYXNoLFxuICAgIG5lYXJoazogbmVhcmhrLFxuICAgIG5lYXJyOiBuZWFycixcbiAgICBuZUFycjogbmVBcnIsXG4gICAgbmVhcnJvdzogbmVhcnJvdyxcbiAgICBuZTogbmUsXG4gICAgbmVkb3Q6IG5lZG90LFxuICAgIE5lZ2F0aXZlTWVkaXVtU3BhY2U6IE5lZ2F0aXZlTWVkaXVtU3BhY2UsXG4gICAgTmVnYXRpdmVUaGlja1NwYWNlOiBOZWdhdGl2ZVRoaWNrU3BhY2UsXG4gICAgTmVnYXRpdmVUaGluU3BhY2U6IE5lZ2F0aXZlVGhpblNwYWNlLFxuICAgIE5lZ2F0aXZlVmVyeVRoaW5TcGFjZTogTmVnYXRpdmVWZXJ5VGhpblNwYWNlLFxuICAgIG5lcXVpdjogbmVxdWl2LFxuICAgIG5lc2VhcjogbmVzZWFyLFxuICAgIG5lc2ltOiBuZXNpbSxcbiAgICBOZXN0ZWRHcmVhdGVyR3JlYXRlcjogTmVzdGVkR3JlYXRlckdyZWF0ZXIsXG4gICAgTmVzdGVkTGVzc0xlc3M6IE5lc3RlZExlc3NMZXNzLFxuICAgIE5ld0xpbmU6IE5ld0xpbmUsXG4gICAgbmV4aXN0OiBuZXhpc3QsXG4gICAgbmV4aXN0czogbmV4aXN0cyxcbiAgICBOZnI6IE5mcixcbiAgICBuZnI6IG5mcixcbiAgICBuZ0U6IG5nRSxcbiAgICBuZ2U6IG5nZSxcbiAgICBuZ2VxOiBuZ2VxLFxuICAgIG5nZXFxOiBuZ2VxcSxcbiAgICBuZ2Vxc2xhbnQ6IG5nZXFzbGFudCxcbiAgICBuZ2VzOiBuZ2VzLFxuICAgIG5HZzogbkdnLFxuICAgIG5nc2ltOiBuZ3NpbSxcbiAgICBuR3Q6IG5HdCxcbiAgICBuZ3Q6IG5ndCxcbiAgICBuZ3RyOiBuZ3RyLFxuICAgIG5HdHY6IG5HdHYsXG4gICAgbmhhcnI6IG5oYXJyLFxuICAgIG5oQXJyOiBuaEFycixcbiAgICBuaHBhcjogbmhwYXIsXG4gICAgbmk6IG5pLFxuICAgIG5pczogbmlzLFxuICAgIG5pc2Q6IG5pc2QsXG4gICAgbml2OiBuaXYsXG4gICAgTkpjeTogTkpjeSxcbiAgICBuamN5OiBuamN5LFxuICAgIG5sYXJyOiBubGFycixcbiAgICBubEFycjogbmxBcnIsXG4gICAgbmxkcjogbmxkcixcbiAgICBubEU6IG5sRSxcbiAgICBubGU6IG5sZSxcbiAgICBubGVmdGFycm93OiBubGVmdGFycm93LFxuICAgIG5MZWZ0YXJyb3c6IG5MZWZ0YXJyb3csXG4gICAgbmxlZnRyaWdodGFycm93OiBubGVmdHJpZ2h0YXJyb3csXG4gICAgbkxlZnRyaWdodGFycm93OiBuTGVmdHJpZ2h0YXJyb3csXG4gICAgbmxlcTogbmxlcSxcbiAgICBubGVxcTogbmxlcXEsXG4gICAgbmxlcXNsYW50OiBubGVxc2xhbnQsXG4gICAgbmxlczogbmxlcyxcbiAgICBubGVzczogbmxlc3MsXG4gICAgbkxsOiBuTGwsXG4gICAgbmxzaW06IG5sc2ltLFxuICAgIG5MdDogbkx0LFxuICAgIG5sdDogbmx0LFxuICAgIG5sdHJpOiBubHRyaSxcbiAgICBubHRyaWU6IG5sdHJpZSxcbiAgICBuTHR2OiBuTHR2LFxuICAgIG5taWQ6IG5taWQsXG4gICAgTm9CcmVhazogTm9CcmVhayxcbiAgICBOb25CcmVha2luZ1NwYWNlOiBOb25CcmVha2luZ1NwYWNlLFxuICAgIG5vcGY6IG5vcGYsXG4gICAgTm9wZjogTm9wZixcbiAgICBOb3Q6IE5vdCxcbiAgICBub3Q6IG5vdCQxLFxuICAgIE5vdENvbmdydWVudDogTm90Q29uZ3J1ZW50LFxuICAgIE5vdEN1cENhcDogTm90Q3VwQ2FwLFxuICAgIE5vdERvdWJsZVZlcnRpY2FsQmFyOiBOb3REb3VibGVWZXJ0aWNhbEJhcixcbiAgICBOb3RFbGVtZW50OiBOb3RFbGVtZW50LFxuICAgIE5vdEVxdWFsOiBOb3RFcXVhbCxcbiAgICBOb3RFcXVhbFRpbGRlOiBOb3RFcXVhbFRpbGRlLFxuICAgIE5vdEV4aXN0czogTm90RXhpc3RzLFxuICAgIE5vdEdyZWF0ZXI6IE5vdEdyZWF0ZXIsXG4gICAgTm90R3JlYXRlckVxdWFsOiBOb3RHcmVhdGVyRXF1YWwsXG4gICAgTm90R3JlYXRlckZ1bGxFcXVhbDogTm90R3JlYXRlckZ1bGxFcXVhbCxcbiAgICBOb3RHcmVhdGVyR3JlYXRlcjogTm90R3JlYXRlckdyZWF0ZXIsXG4gICAgTm90R3JlYXRlckxlc3M6IE5vdEdyZWF0ZXJMZXNzLFxuICAgIE5vdEdyZWF0ZXJTbGFudEVxdWFsOiBOb3RHcmVhdGVyU2xhbnRFcXVhbCxcbiAgICBOb3RHcmVhdGVyVGlsZGU6IE5vdEdyZWF0ZXJUaWxkZSxcbiAgICBOb3RIdW1wRG93bkh1bXA6IE5vdEh1bXBEb3duSHVtcCxcbiAgICBOb3RIdW1wRXF1YWw6IE5vdEh1bXBFcXVhbCxcbiAgICBub3Rpbjogbm90aW4sXG4gICAgbm90aW5kb3Q6IG5vdGluZG90LFxuICAgIG5vdGluRTogbm90aW5FLFxuICAgIG5vdGludmE6IG5vdGludmEsXG4gICAgbm90aW52Yjogbm90aW52YixcbiAgICBub3RpbnZjOiBub3RpbnZjLFxuICAgIE5vdExlZnRUcmlhbmdsZUJhcjogTm90TGVmdFRyaWFuZ2xlQmFyLFxuICAgIE5vdExlZnRUcmlhbmdsZTogTm90TGVmdFRyaWFuZ2xlLFxuICAgIE5vdExlZnRUcmlhbmdsZUVxdWFsOiBOb3RMZWZ0VHJpYW5nbGVFcXVhbCxcbiAgICBOb3RMZXNzOiBOb3RMZXNzLFxuICAgIE5vdExlc3NFcXVhbDogTm90TGVzc0VxdWFsLFxuICAgIE5vdExlc3NHcmVhdGVyOiBOb3RMZXNzR3JlYXRlcixcbiAgICBOb3RMZXNzTGVzczogTm90TGVzc0xlc3MsXG4gICAgTm90TGVzc1NsYW50RXF1YWw6IE5vdExlc3NTbGFudEVxdWFsLFxuICAgIE5vdExlc3NUaWxkZTogTm90TGVzc1RpbGRlLFxuICAgIE5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyOiBOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcixcbiAgICBOb3ROZXN0ZWRMZXNzTGVzczogTm90TmVzdGVkTGVzc0xlc3MsXG4gICAgbm90bmk6IG5vdG5pLFxuICAgIG5vdG5pdmE6IG5vdG5pdmEsXG4gICAgbm90bml2Yjogbm90bml2YixcbiAgICBub3RuaXZjOiBub3RuaXZjLFxuICAgIE5vdFByZWNlZGVzOiBOb3RQcmVjZWRlcyxcbiAgICBOb3RQcmVjZWRlc0VxdWFsOiBOb3RQcmVjZWRlc0VxdWFsLFxuICAgIE5vdFByZWNlZGVzU2xhbnRFcXVhbDogTm90UHJlY2VkZXNTbGFudEVxdWFsLFxuICAgIE5vdFJldmVyc2VFbGVtZW50OiBOb3RSZXZlcnNlRWxlbWVudCxcbiAgICBOb3RSaWdodFRyaWFuZ2xlQmFyOiBOb3RSaWdodFRyaWFuZ2xlQmFyLFxuICAgIE5vdFJpZ2h0VHJpYW5nbGU6IE5vdFJpZ2h0VHJpYW5nbGUsXG4gICAgTm90UmlnaHRUcmlhbmdsZUVxdWFsOiBOb3RSaWdodFRyaWFuZ2xlRXF1YWwsXG4gICAgTm90U3F1YXJlU3Vic2V0OiBOb3RTcXVhcmVTdWJzZXQsXG4gICAgTm90U3F1YXJlU3Vic2V0RXF1YWw6IE5vdFNxdWFyZVN1YnNldEVxdWFsLFxuICAgIE5vdFNxdWFyZVN1cGVyc2V0OiBOb3RTcXVhcmVTdXBlcnNldCxcbiAgICBOb3RTcXVhcmVTdXBlcnNldEVxdWFsOiBOb3RTcXVhcmVTdXBlcnNldEVxdWFsLFxuICAgIE5vdFN1YnNldDogTm90U3Vic2V0LFxuICAgIE5vdFN1YnNldEVxdWFsOiBOb3RTdWJzZXRFcXVhbCxcbiAgICBOb3RTdWNjZWVkczogTm90U3VjY2VlZHMsXG4gICAgTm90U3VjY2VlZHNFcXVhbDogTm90U3VjY2VlZHNFcXVhbCxcbiAgICBOb3RTdWNjZWVkc1NsYW50RXF1YWw6IE5vdFN1Y2NlZWRzU2xhbnRFcXVhbCxcbiAgICBOb3RTdWNjZWVkc1RpbGRlOiBOb3RTdWNjZWVkc1RpbGRlLFxuICAgIE5vdFN1cGVyc2V0OiBOb3RTdXBlcnNldCxcbiAgICBOb3RTdXBlcnNldEVxdWFsOiBOb3RTdXBlcnNldEVxdWFsLFxuICAgIE5vdFRpbGRlOiBOb3RUaWxkZSxcbiAgICBOb3RUaWxkZUVxdWFsOiBOb3RUaWxkZUVxdWFsLFxuICAgIE5vdFRpbGRlRnVsbEVxdWFsOiBOb3RUaWxkZUZ1bGxFcXVhbCxcbiAgICBOb3RUaWxkZVRpbGRlOiBOb3RUaWxkZVRpbGRlLFxuICAgIE5vdFZlcnRpY2FsQmFyOiBOb3RWZXJ0aWNhbEJhcixcbiAgICBucGFyYWxsZWw6IG5wYXJhbGxlbCxcbiAgICBucGFyOiBucGFyLFxuICAgIG5wYXJzbDogbnBhcnNsLFxuICAgIG5wYXJ0OiBucGFydCxcbiAgICBucG9saW50OiBucG9saW50LFxuICAgIG5wcjogbnByLFxuICAgIG5wcmN1ZTogbnByY3VlLFxuICAgIG5wcmVjOiBucHJlYyxcbiAgICBucHJlY2VxOiBucHJlY2VxLFxuICAgIG5wcmU6IG5wcmUsXG4gICAgbnJhcnJjOiBucmFycmMsXG4gICAgbnJhcnI6IG5yYXJyLFxuICAgIG5yQXJyOiBuckFycixcbiAgICBucmFycnc6IG5yYXJydyxcbiAgICBucmlnaHRhcnJvdzogbnJpZ2h0YXJyb3csXG4gICAgblJpZ2h0YXJyb3c6IG5SaWdodGFycm93LFxuICAgIG5ydHJpOiBucnRyaSxcbiAgICBucnRyaWU6IG5ydHJpZSxcbiAgICBuc2M6IG5zYyxcbiAgICBuc2NjdWU6IG5zY2N1ZSxcbiAgICBuc2NlOiBuc2NlLFxuICAgIE5zY3I6IE5zY3IsXG4gICAgbnNjcjogbnNjcixcbiAgICBuc2hvcnRtaWQ6IG5zaG9ydG1pZCxcbiAgICBuc2hvcnRwYXJhbGxlbDogbnNob3J0cGFyYWxsZWwsXG4gICAgbnNpbTogbnNpbSxcbiAgICBuc2ltZTogbnNpbWUsXG4gICAgbnNpbWVxOiBuc2ltZXEsXG4gICAgbnNtaWQ6IG5zbWlkLFxuICAgIG5zcGFyOiBuc3BhcixcbiAgICBuc3FzdWJlOiBuc3FzdWJlLFxuICAgIG5zcXN1cGU6IG5zcXN1cGUsXG4gICAgbnN1YjogbnN1YixcbiAgICBuc3ViRTogbnN1YkUsXG4gICAgbnN1YmU6IG5zdWJlLFxuICAgIG5zdWJzZXQ6IG5zdWJzZXQsXG4gICAgbnN1YnNldGVxOiBuc3Vic2V0ZXEsXG4gICAgbnN1YnNldGVxcTogbnN1YnNldGVxcSxcbiAgICBuc3VjYzogbnN1Y2MsXG4gICAgbnN1Y2NlcTogbnN1Y2NlcSxcbiAgICBuc3VwOiBuc3VwLFxuICAgIG5zdXBFOiBuc3VwRSxcbiAgICBuc3VwZTogbnN1cGUsXG4gICAgbnN1cHNldDogbnN1cHNldCxcbiAgICBuc3Vwc2V0ZXE6IG5zdXBzZXRlcSxcbiAgICBuc3Vwc2V0ZXFxOiBuc3Vwc2V0ZXFxLFxuICAgIG50Z2w6IG50Z2wsXG4gICAgTnRpbGRlOiBOdGlsZGUkMSxcbiAgICBudGlsZGU6IG50aWxkZSQxLFxuICAgIG50bGc6IG50bGcsXG4gICAgbnRyaWFuZ2xlbGVmdDogbnRyaWFuZ2xlbGVmdCxcbiAgICBudHJpYW5nbGVsZWZ0ZXE6IG50cmlhbmdsZWxlZnRlcSxcbiAgICBudHJpYW5nbGVyaWdodDogbnRyaWFuZ2xlcmlnaHQsXG4gICAgbnRyaWFuZ2xlcmlnaHRlcTogbnRyaWFuZ2xlcmlnaHRlcSxcbiAgICBOdTogTnUsXG4gICAgbnU6IG51LFxuICAgIG51bTogbnVtLFxuICAgIG51bWVybzogbnVtZXJvLFxuICAgIG51bXNwOiBudW1zcCxcbiAgICBudmFwOiBudmFwLFxuICAgIG52ZGFzaDogbnZkYXNoLFxuICAgIG52RGFzaDogbnZEYXNoLFxuICAgIG5WZGFzaDogblZkYXNoLFxuICAgIG5WRGFzaDogblZEYXNoLFxuICAgIG52Z2U6IG52Z2UsXG4gICAgbnZndDogbnZndCxcbiAgICBudkhhcnI6IG52SGFycixcbiAgICBudmluZmluOiBudmluZmluLFxuICAgIG52bEFycjogbnZsQXJyLFxuICAgIG52bGU6IG52bGUsXG4gICAgbnZsdDogbnZsdCxcbiAgICBudmx0cmllOiBudmx0cmllLFxuICAgIG52ckFycjogbnZyQXJyLFxuICAgIG52cnRyaWU6IG52cnRyaWUsXG4gICAgbnZzaW06IG52c2ltLFxuICAgIG53YXJoazogbndhcmhrLFxuICAgIG53YXJyOiBud2FycixcbiAgICBud0FycjogbndBcnIsXG4gICAgbndhcnJvdzogbndhcnJvdyxcbiAgICBud25lYXI6IG53bmVhcixcbiAgICBPYWN1dGU6IE9hY3V0ZSQxLFxuICAgIG9hY3V0ZTogb2FjdXRlJDEsXG4gICAgb2FzdDogb2FzdCxcbiAgICBPY2lyYzogT2NpcmMkMSxcbiAgICBvY2lyYzogb2NpcmMkMSxcbiAgICBvY2lyOiBvY2lyLFxuICAgIE9jeTogT2N5LFxuICAgIG9jeTogb2N5LFxuICAgIG9kYXNoOiBvZGFzaCxcbiAgICBPZGJsYWM6IE9kYmxhYyxcbiAgICBvZGJsYWM6IG9kYmxhYyxcbiAgICBvZGl2OiBvZGl2LFxuICAgIG9kb3Q6IG9kb3QsXG4gICAgb2Rzb2xkOiBvZHNvbGQsXG4gICAgT0VsaWc6IE9FbGlnLFxuICAgIG9lbGlnOiBvZWxpZyxcbiAgICBvZmNpcjogb2ZjaXIsXG4gICAgT2ZyOiBPZnIsXG4gICAgb2ZyOiBvZnIsXG4gICAgb2dvbjogb2dvbixcbiAgICBPZ3JhdmU6IE9ncmF2ZSQxLFxuICAgIG9ncmF2ZTogb2dyYXZlJDEsXG4gICAgb2d0OiBvZ3QsXG4gICAgb2hiYXI6IG9oYmFyLFxuICAgIG9obTogb2htLFxuICAgIG9pbnQ6IG9pbnQsXG4gICAgb2xhcnI6IG9sYXJyLFxuICAgIG9sY2lyOiBvbGNpcixcbiAgICBvbGNyb3NzOiBvbGNyb3NzLFxuICAgIG9saW5lOiBvbGluZSxcbiAgICBvbHQ6IG9sdCxcbiAgICBPbWFjcjogT21hY3IsXG4gICAgb21hY3I6IG9tYWNyLFxuICAgIE9tZWdhOiBPbWVnYSxcbiAgICBvbWVnYTogb21lZ2EsXG4gICAgT21pY3JvbjogT21pY3JvbixcbiAgICBvbWljcm9uOiBvbWljcm9uLFxuICAgIG9taWQ6IG9taWQsXG4gICAgb21pbnVzOiBvbWludXMsXG4gICAgT29wZjogT29wZixcbiAgICBvb3BmOiBvb3BmLFxuICAgIG9wYXI6IG9wYXIsXG4gICAgT3BlbkN1cmx5RG91YmxlUXVvdGU6IE9wZW5DdXJseURvdWJsZVF1b3RlLFxuICAgIE9wZW5DdXJseVF1b3RlOiBPcGVuQ3VybHlRdW90ZSxcbiAgICBvcGVycDogb3BlcnAsXG4gICAgb3BsdXM6IG9wbHVzLFxuICAgIG9yYXJyOiBvcmFycixcbiAgICBPcjogT3IsXG4gICAgb3I6IG9yLFxuICAgIG9yZDogb3JkLFxuICAgIG9yZGVyOiBvcmRlcixcbiAgICBvcmRlcm9mOiBvcmRlcm9mLFxuICAgIG9yZGY6IG9yZGYkMSxcbiAgICBvcmRtOiBvcmRtJDEsXG4gICAgb3JpZ29mOiBvcmlnb2YsXG4gICAgb3Jvcjogb3JvcixcbiAgICBvcnNsb3BlOiBvcnNsb3BlLFxuICAgIG9ydjogb3J2LFxuICAgIG9TOiBvUyxcbiAgICBPc2NyOiBPc2NyLFxuICAgIG9zY3I6IG9zY3IsXG4gICAgT3NsYXNoOiBPc2xhc2gkMSxcbiAgICBvc2xhc2g6IG9zbGFzaCQxLFxuICAgIG9zb2w6IG9zb2wsXG4gICAgT3RpbGRlOiBPdGlsZGUkMSxcbiAgICBvdGlsZGU6IG90aWxkZSQxLFxuICAgIG90aW1lc2FzOiBvdGltZXNhcyxcbiAgICBPdGltZXM6IE90aW1lcyxcbiAgICBvdGltZXM6IG90aW1lcyxcbiAgICBPdW1sOiBPdW1sJDEsXG4gICAgb3VtbDogb3VtbCQxLFxuICAgIG92YmFyOiBvdmJhcixcbiAgICBPdmVyQmFyOiBPdmVyQmFyLFxuICAgIE92ZXJCcmFjZTogT3ZlckJyYWNlLFxuICAgIE92ZXJCcmFja2V0OiBPdmVyQnJhY2tldCxcbiAgICBPdmVyUGFyZW50aGVzaXM6IE92ZXJQYXJlbnRoZXNpcyxcbiAgICBwYXJhOiBwYXJhJDEsXG4gICAgcGFyYWxsZWw6IHBhcmFsbGVsLFxuICAgIHBhcjogcGFyLFxuICAgIHBhcnNpbTogcGFyc2ltLFxuICAgIHBhcnNsOiBwYXJzbCxcbiAgICBwYXJ0OiBwYXJ0LFxuICAgIFBhcnRpYWxEOiBQYXJ0aWFsRCxcbiAgICBQY3k6IFBjeSxcbiAgICBwY3k6IHBjeSxcbiAgICBwZXJjbnQ6IHBlcmNudCxcbiAgICBwZXJpb2Q6IHBlcmlvZCxcbiAgICBwZXJtaWw6IHBlcm1pbCxcbiAgICBwZXJwOiBwZXJwLFxuICAgIHBlcnRlbms6IHBlcnRlbmssXG4gICAgUGZyOiBQZnIsXG4gICAgcGZyOiBwZnIsXG4gICAgUGhpOiBQaGksXG4gICAgcGhpOiBwaGksXG4gICAgcGhpdjogcGhpdixcbiAgICBwaG1tYXQ6IHBobW1hdCxcbiAgICBwaG9uZTogcGhvbmUsXG4gICAgUGk6IFBpLFxuICAgIHBpOiBwaSxcbiAgICBwaXRjaGZvcms6IHBpdGNoZm9yayxcbiAgICBwaXY6IHBpdixcbiAgICBwbGFuY2s6IHBsYW5jayxcbiAgICBwbGFuY2toOiBwbGFuY2toLFxuICAgIHBsYW5rdjogcGxhbmt2LFxuICAgIHBsdXNhY2lyOiBwbHVzYWNpcixcbiAgICBwbHVzYjogcGx1c2IsXG4gICAgcGx1c2NpcjogcGx1c2NpcixcbiAgICBwbHVzOiBwbHVzLFxuICAgIHBsdXNkbzogcGx1c2RvLFxuICAgIHBsdXNkdTogcGx1c2R1LFxuICAgIHBsdXNlOiBwbHVzZSxcbiAgICBQbHVzTWludXM6IFBsdXNNaW51cyxcbiAgICBwbHVzbW46IHBsdXNtbiQxLFxuICAgIHBsdXNzaW06IHBsdXNzaW0sXG4gICAgcGx1c3R3bzogcGx1c3R3byxcbiAgICBwbTogcG0sXG4gICAgUG9pbmNhcmVwbGFuZTogUG9pbmNhcmVwbGFuZSxcbiAgICBwb2ludGludDogcG9pbnRpbnQsXG4gICAgcG9wZjogcG9wZixcbiAgICBQb3BmOiBQb3BmLFxuICAgIHBvdW5kOiBwb3VuZCQxLFxuICAgIHByYXA6IHByYXAsXG4gICAgUHI6IFByLFxuICAgIHByOiBwcixcbiAgICBwcmN1ZTogcHJjdWUsXG4gICAgcHJlY2FwcHJveDogcHJlY2FwcHJveCxcbiAgICBwcmVjOiBwcmVjLFxuICAgIHByZWNjdXJseWVxOiBwcmVjY3VybHllcSxcbiAgICBQcmVjZWRlczogUHJlY2VkZXMsXG4gICAgUHJlY2VkZXNFcXVhbDogUHJlY2VkZXNFcXVhbCxcbiAgICBQcmVjZWRlc1NsYW50RXF1YWw6IFByZWNlZGVzU2xhbnRFcXVhbCxcbiAgICBQcmVjZWRlc1RpbGRlOiBQcmVjZWRlc1RpbGRlLFxuICAgIHByZWNlcTogcHJlY2VxLFxuICAgIHByZWNuYXBwcm94OiBwcmVjbmFwcHJveCxcbiAgICBwcmVjbmVxcTogcHJlY25lcXEsXG4gICAgcHJlY25zaW06IHByZWNuc2ltLFxuICAgIHByZTogcHJlLFxuICAgIHByRTogcHJFLFxuICAgIHByZWNzaW06IHByZWNzaW0sXG4gICAgcHJpbWU6IHByaW1lLFxuICAgIFByaW1lOiBQcmltZSxcbiAgICBwcmltZXM6IHByaW1lcyxcbiAgICBwcm5hcDogcHJuYXAsXG4gICAgcHJuRTogcHJuRSxcbiAgICBwcm5zaW06IHBybnNpbSxcbiAgICBwcm9kOiBwcm9kLFxuICAgIFByb2R1Y3Q6IFByb2R1Y3QsXG4gICAgcHJvZmFsYXI6IHByb2ZhbGFyLFxuICAgIHByb2ZsaW5lOiBwcm9mbGluZSxcbiAgICBwcm9mc3VyZjogcHJvZnN1cmYsXG4gICAgcHJvcDogcHJvcCxcbiAgICBQcm9wb3J0aW9uYWw6IFByb3BvcnRpb25hbCxcbiAgICBQcm9wb3J0aW9uOiBQcm9wb3J0aW9uLFxuICAgIHByb3B0bzogcHJvcHRvLFxuICAgIHByc2ltOiBwcnNpbSxcbiAgICBwcnVyZWw6IHBydXJlbCxcbiAgICBQc2NyOiBQc2NyLFxuICAgIHBzY3I6IHBzY3IsXG4gICAgUHNpOiBQc2ksXG4gICAgcHNpOiBwc2ksXG4gICAgcHVuY3NwOiBwdW5jc3AsXG4gICAgUWZyOiBRZnIsXG4gICAgcWZyOiBxZnIsXG4gICAgcWludDogcWludCxcbiAgICBxb3BmOiBxb3BmLFxuICAgIFFvcGY6IFFvcGYsXG4gICAgcXByaW1lOiBxcHJpbWUsXG4gICAgUXNjcjogUXNjcixcbiAgICBxc2NyOiBxc2NyLFxuICAgIHF1YXRlcm5pb25zOiBxdWF0ZXJuaW9ucyxcbiAgICBxdWF0aW50OiBxdWF0aW50LFxuICAgIHF1ZXN0OiBxdWVzdCxcbiAgICBxdWVzdGVxOiBxdWVzdGVxLFxuICAgIHF1b3Q6IHF1b3QkMixcbiAgICBRVU9UOiBRVU9UJDEsXG4gICAgckFhcnI6IHJBYXJyLFxuICAgIHJhY2U6IHJhY2UsXG4gICAgUmFjdXRlOiBSYWN1dGUsXG4gICAgcmFjdXRlOiByYWN1dGUsXG4gICAgcmFkaWM6IHJhZGljLFxuICAgIHJhZW1wdHl2OiByYWVtcHR5dixcbiAgICByYW5nOiByYW5nLFxuICAgIFJhbmc6IFJhbmcsXG4gICAgcmFuZ2Q6IHJhbmdkLFxuICAgIHJhbmdlOiByYW5nZSxcbiAgICByYW5nbGU6IHJhbmdsZSxcbiAgICByYXF1bzogcmFxdW8kMSxcbiAgICByYXJyYXA6IHJhcnJhcCxcbiAgICByYXJyYjogcmFycmIsXG4gICAgcmFycmJmczogcmFycmJmcyxcbiAgICByYXJyYzogcmFycmMsXG4gICAgcmFycjogcmFycixcbiAgICBSYXJyOiBSYXJyLFxuICAgIHJBcnI6IHJBcnIsXG4gICAgcmFycmZzOiByYXJyZnMsXG4gICAgcmFycmhrOiByYXJyaGssXG4gICAgcmFycmxwOiByYXJybHAsXG4gICAgcmFycnBsOiByYXJycGwsXG4gICAgcmFycnNpbTogcmFycnNpbSxcbiAgICBSYXJydGw6IFJhcnJ0bCxcbiAgICByYXJydGw6IHJhcnJ0bCxcbiAgICByYXJydzogcmFycncsXG4gICAgcmF0YWlsOiByYXRhaWwsXG4gICAgckF0YWlsOiByQXRhaWwsXG4gICAgcmF0aW86IHJhdGlvLFxuICAgIHJhdGlvbmFsczogcmF0aW9uYWxzLFxuICAgIHJiYXJyOiByYmFycixcbiAgICByQmFycjogckJhcnIsXG4gICAgUkJhcnI6IFJCYXJyLFxuICAgIHJiYnJrOiByYmJyayxcbiAgICByYnJhY2U6IHJicmFjZSxcbiAgICByYnJhY2s6IHJicmFjayxcbiAgICByYnJrZTogcmJya2UsXG4gICAgcmJya3NsZDogcmJya3NsZCxcbiAgICByYnJrc2x1OiByYnJrc2x1LFxuICAgIFJjYXJvbjogUmNhcm9uLFxuICAgIHJjYXJvbjogcmNhcm9uLFxuICAgIFJjZWRpbDogUmNlZGlsLFxuICAgIHJjZWRpbDogcmNlZGlsLFxuICAgIHJjZWlsOiByY2VpbCxcbiAgICByY3ViOiByY3ViLFxuICAgIFJjeTogUmN5LFxuICAgIHJjeTogcmN5LFxuICAgIHJkY2E6IHJkY2EsXG4gICAgcmRsZGhhcjogcmRsZGhhcixcbiAgICByZHF1bzogcmRxdW8sXG4gICAgcmRxdW9yOiByZHF1b3IsXG4gICAgcmRzaDogcmRzaCxcbiAgICByZWFsOiByZWFsLFxuICAgIHJlYWxpbmU6IHJlYWxpbmUsXG4gICAgcmVhbHBhcnQ6IHJlYWxwYXJ0LFxuICAgIHJlYWxzOiByZWFscyxcbiAgICBSZTogUmUsXG4gICAgcmVjdDogcmVjdCxcbiAgICByZWc6IHJlZyQxLFxuICAgIFJFRzogUkVHJDEsXG4gICAgUmV2ZXJzZUVsZW1lbnQ6IFJldmVyc2VFbGVtZW50LFxuICAgIFJldmVyc2VFcXVpbGlicml1bTogUmV2ZXJzZUVxdWlsaWJyaXVtLFxuICAgIFJldmVyc2VVcEVxdWlsaWJyaXVtOiBSZXZlcnNlVXBFcXVpbGlicml1bSxcbiAgICByZmlzaHQ6IHJmaXNodCxcbiAgICByZmxvb3I6IHJmbG9vcixcbiAgICByZnI6IHJmcixcbiAgICBSZnI6IFJmcixcbiAgICBySGFyOiBySGFyLFxuICAgIHJoYXJkOiByaGFyZCxcbiAgICByaGFydTogcmhhcnUsXG4gICAgcmhhcnVsOiByaGFydWwsXG4gICAgUmhvOiBSaG8sXG4gICAgcmhvOiByaG8sXG4gICAgcmhvdjogcmhvdixcbiAgICBSaWdodEFuZ2xlQnJhY2tldDogUmlnaHRBbmdsZUJyYWNrZXQsXG4gICAgUmlnaHRBcnJvd0JhcjogUmlnaHRBcnJvd0JhcixcbiAgICByaWdodGFycm93OiByaWdodGFycm93LFxuICAgIFJpZ2h0QXJyb3c6IFJpZ2h0QXJyb3csXG4gICAgUmlnaHRhcnJvdzogUmlnaHRhcnJvdyxcbiAgICBSaWdodEFycm93TGVmdEFycm93OiBSaWdodEFycm93TGVmdEFycm93LFxuICAgIHJpZ2h0YXJyb3d0YWlsOiByaWdodGFycm93dGFpbCxcbiAgICBSaWdodENlaWxpbmc6IFJpZ2h0Q2VpbGluZyxcbiAgICBSaWdodERvdWJsZUJyYWNrZXQ6IFJpZ2h0RG91YmxlQnJhY2tldCxcbiAgICBSaWdodERvd25UZWVWZWN0b3I6IFJpZ2h0RG93blRlZVZlY3RvcixcbiAgICBSaWdodERvd25WZWN0b3JCYXI6IFJpZ2h0RG93blZlY3RvckJhcixcbiAgICBSaWdodERvd25WZWN0b3I6IFJpZ2h0RG93blZlY3RvcixcbiAgICBSaWdodEZsb29yOiBSaWdodEZsb29yLFxuICAgIHJpZ2h0aGFycG9vbmRvd246IHJpZ2h0aGFycG9vbmRvd24sXG4gICAgcmlnaHRoYXJwb29udXA6IHJpZ2h0aGFycG9vbnVwLFxuICAgIHJpZ2h0bGVmdGFycm93czogcmlnaHRsZWZ0YXJyb3dzLFxuICAgIHJpZ2h0bGVmdGhhcnBvb25zOiByaWdodGxlZnRoYXJwb29ucyxcbiAgICByaWdodHJpZ2h0YXJyb3dzOiByaWdodHJpZ2h0YXJyb3dzLFxuICAgIHJpZ2h0c3F1aWdhcnJvdzogcmlnaHRzcXVpZ2Fycm93LFxuICAgIFJpZ2h0VGVlQXJyb3c6IFJpZ2h0VGVlQXJyb3csXG4gICAgUmlnaHRUZWU6IFJpZ2h0VGVlLFxuICAgIFJpZ2h0VGVlVmVjdG9yOiBSaWdodFRlZVZlY3RvcixcbiAgICByaWdodHRocmVldGltZXM6IHJpZ2h0dGhyZWV0aW1lcyxcbiAgICBSaWdodFRyaWFuZ2xlQmFyOiBSaWdodFRyaWFuZ2xlQmFyLFxuICAgIFJpZ2h0VHJpYW5nbGU6IFJpZ2h0VHJpYW5nbGUsXG4gICAgUmlnaHRUcmlhbmdsZUVxdWFsOiBSaWdodFRyaWFuZ2xlRXF1YWwsXG4gICAgUmlnaHRVcERvd25WZWN0b3I6IFJpZ2h0VXBEb3duVmVjdG9yLFxuICAgIFJpZ2h0VXBUZWVWZWN0b3I6IFJpZ2h0VXBUZWVWZWN0b3IsXG4gICAgUmlnaHRVcFZlY3RvckJhcjogUmlnaHRVcFZlY3RvckJhcixcbiAgICBSaWdodFVwVmVjdG9yOiBSaWdodFVwVmVjdG9yLFxuICAgIFJpZ2h0VmVjdG9yQmFyOiBSaWdodFZlY3RvckJhcixcbiAgICBSaWdodFZlY3RvcjogUmlnaHRWZWN0b3IsXG4gICAgcmluZzogcmluZyxcbiAgICByaXNpbmdkb3RzZXE6IHJpc2luZ2RvdHNlcSxcbiAgICBybGFycjogcmxhcnIsXG4gICAgcmxoYXI6IHJsaGFyLFxuICAgIHJsbTogcmxtLFxuICAgIHJtb3VzdGFjaGU6IHJtb3VzdGFjaGUsXG4gICAgcm1vdXN0OiBybW91c3QsXG4gICAgcm5taWQ6IHJubWlkLFxuICAgIHJvYW5nOiByb2FuZyxcbiAgICByb2Fycjogcm9hcnIsXG4gICAgcm9icms6IHJvYnJrLFxuICAgIHJvcGFyOiByb3BhcixcbiAgICByb3BmOiByb3BmLFxuICAgIFJvcGY6IFJvcGYsXG4gICAgcm9wbHVzOiByb3BsdXMsXG4gICAgcm90aW1lczogcm90aW1lcyxcbiAgICBSb3VuZEltcGxpZXM6IFJvdW5kSW1wbGllcyxcbiAgICBycGFyOiBycGFyLFxuICAgIHJwYXJndDogcnBhcmd0LFxuICAgIHJwcG9saW50OiBycHBvbGludCxcbiAgICBycmFycjogcnJhcnIsXG4gICAgUnJpZ2h0YXJyb3c6IFJyaWdodGFycm93LFxuICAgIHJzYXF1bzogcnNhcXVvLFxuICAgIHJzY3I6IHJzY3IsXG4gICAgUnNjcjogUnNjcixcbiAgICByc2g6IHJzaCxcbiAgICBSc2g6IFJzaCxcbiAgICByc3FiOiByc3FiLFxuICAgIHJzcXVvOiByc3F1byxcbiAgICByc3F1b3I6IHJzcXVvcixcbiAgICBydGhyZWU6IHJ0aHJlZSxcbiAgICBydGltZXM6IHJ0aW1lcyxcbiAgICBydHJpOiBydHJpLFxuICAgIHJ0cmllOiBydHJpZSxcbiAgICBydHJpZjogcnRyaWYsXG4gICAgcnRyaWx0cmk6IHJ0cmlsdHJpLFxuICAgIFJ1bGVEZWxheWVkOiBSdWxlRGVsYXllZCxcbiAgICBydWx1aGFyOiBydWx1aGFyLFxuICAgIHJ4OiByeCxcbiAgICBTYWN1dGU6IFNhY3V0ZSxcbiAgICBzYWN1dGU6IHNhY3V0ZSxcbiAgICBzYnF1bzogc2JxdW8sXG4gICAgc2NhcDogc2NhcCxcbiAgICBTY2Fyb246IFNjYXJvbixcbiAgICBzY2Fyb246IHNjYXJvbixcbiAgICBTYzogU2MsXG4gICAgc2M6IHNjLFxuICAgIHNjY3VlOiBzY2N1ZSxcbiAgICBzY2U6IHNjZSxcbiAgICBzY0U6IHNjRSxcbiAgICBTY2VkaWw6IFNjZWRpbCxcbiAgICBzY2VkaWw6IHNjZWRpbCxcbiAgICBTY2lyYzogU2NpcmMsXG4gICAgc2NpcmM6IHNjaXJjLFxuICAgIHNjbmFwOiBzY25hcCxcbiAgICBzY25FOiBzY25FLFxuICAgIHNjbnNpbTogc2Nuc2ltLFxuICAgIHNjcG9saW50OiBzY3BvbGludCxcbiAgICBzY3NpbTogc2NzaW0sXG4gICAgU2N5OiBTY3ksXG4gICAgc2N5OiBzY3ksXG4gICAgc2RvdGI6IHNkb3RiLFxuICAgIHNkb3Q6IHNkb3QsXG4gICAgc2RvdGU6IHNkb3RlLFxuICAgIHNlYXJoazogc2VhcmhrLFxuICAgIHNlYXJyOiBzZWFycixcbiAgICBzZUFycjogc2VBcnIsXG4gICAgc2VhcnJvdzogc2VhcnJvdyxcbiAgICBzZWN0OiBzZWN0JDEsXG4gICAgc2VtaTogc2VtaSxcbiAgICBzZXN3YXI6IHNlc3dhcixcbiAgICBzZXRtaW51czogc2V0bWludXMsXG4gICAgc2V0bW46IHNldG1uLFxuICAgIHNleHQ6IHNleHQsXG4gICAgU2ZyOiBTZnIsXG4gICAgc2ZyOiBzZnIsXG4gICAgc2Zyb3duOiBzZnJvd24sXG4gICAgc2hhcnA6IHNoYXJwLFxuICAgIFNIQ0hjeTogU0hDSGN5LFxuICAgIHNoY2hjeTogc2hjaGN5LFxuICAgIFNIY3k6IFNIY3ksXG4gICAgc2hjeTogc2hjeSxcbiAgICBTaG9ydERvd25BcnJvdzogU2hvcnREb3duQXJyb3csXG4gICAgU2hvcnRMZWZ0QXJyb3c6IFNob3J0TGVmdEFycm93LFxuICAgIHNob3J0bWlkOiBzaG9ydG1pZCxcbiAgICBzaG9ydHBhcmFsbGVsOiBzaG9ydHBhcmFsbGVsLFxuICAgIFNob3J0UmlnaHRBcnJvdzogU2hvcnRSaWdodEFycm93LFxuICAgIFNob3J0VXBBcnJvdzogU2hvcnRVcEFycm93LFxuICAgIHNoeTogc2h5JDEsXG4gICAgU2lnbWE6IFNpZ21hLFxuICAgIHNpZ21hOiBzaWdtYSxcbiAgICBzaWdtYWY6IHNpZ21hZixcbiAgICBzaWdtYXY6IHNpZ21hdixcbiAgICBzaW06IHNpbSxcbiAgICBzaW1kb3Q6IHNpbWRvdCxcbiAgICBzaW1lOiBzaW1lLFxuICAgIHNpbWVxOiBzaW1lcSxcbiAgICBzaW1nOiBzaW1nLFxuICAgIHNpbWdFOiBzaW1nRSxcbiAgICBzaW1sOiBzaW1sLFxuICAgIHNpbWxFOiBzaW1sRSxcbiAgICBzaW1uZTogc2ltbmUsXG4gICAgc2ltcGx1czogc2ltcGx1cyxcbiAgICBzaW1yYXJyOiBzaW1yYXJyLFxuICAgIHNsYXJyOiBzbGFycixcbiAgICBTbWFsbENpcmNsZTogU21hbGxDaXJjbGUsXG4gICAgc21hbGxzZXRtaW51czogc21hbGxzZXRtaW51cyxcbiAgICBzbWFzaHA6IHNtYXNocCxcbiAgICBzbWVwYXJzbDogc21lcGFyc2wsXG4gICAgc21pZDogc21pZCxcbiAgICBzbWlsZTogc21pbGUsXG4gICAgc210OiBzbXQsXG4gICAgc210ZTogc210ZSxcbiAgICBzbXRlczogc210ZXMsXG4gICAgU09GVGN5OiBTT0ZUY3ksXG4gICAgc29mdGN5OiBzb2Z0Y3ksXG4gICAgc29sYmFyOiBzb2xiYXIsXG4gICAgc29sYjogc29sYixcbiAgICBzb2w6IHNvbCxcbiAgICBTb3BmOiBTb3BmLFxuICAgIHNvcGY6IHNvcGYsXG4gICAgc3BhZGVzOiBzcGFkZXMsXG4gICAgc3BhZGVzdWl0OiBzcGFkZXN1aXQsXG4gICAgc3Bhcjogc3BhcixcbiAgICBzcWNhcDogc3FjYXAsXG4gICAgc3FjYXBzOiBzcWNhcHMsXG4gICAgc3FjdXA6IHNxY3VwLFxuICAgIHNxY3Vwczogc3FjdXBzLFxuICAgIFNxcnQ6IFNxcnQsXG4gICAgc3FzdWI6IHNxc3ViLFxuICAgIHNxc3ViZTogc3FzdWJlLFxuICAgIHNxc3Vic2V0OiBzcXN1YnNldCxcbiAgICBzcXN1YnNldGVxOiBzcXN1YnNldGVxLFxuICAgIHNxc3VwOiBzcXN1cCxcbiAgICBzcXN1cGU6IHNxc3VwZSxcbiAgICBzcXN1cHNldDogc3FzdXBzZXQsXG4gICAgc3FzdXBzZXRlcTogc3FzdXBzZXRlcSxcbiAgICBzcXVhcmU6IHNxdWFyZSxcbiAgICBTcXVhcmU6IFNxdWFyZSxcbiAgICBTcXVhcmVJbnRlcnNlY3Rpb246IFNxdWFyZUludGVyc2VjdGlvbixcbiAgICBTcXVhcmVTdWJzZXQ6IFNxdWFyZVN1YnNldCxcbiAgICBTcXVhcmVTdWJzZXRFcXVhbDogU3F1YXJlU3Vic2V0RXF1YWwsXG4gICAgU3F1YXJlU3VwZXJzZXQ6IFNxdWFyZVN1cGVyc2V0LFxuICAgIFNxdWFyZVN1cGVyc2V0RXF1YWw6IFNxdWFyZVN1cGVyc2V0RXF1YWwsXG4gICAgU3F1YXJlVW5pb246IFNxdWFyZVVuaW9uLFxuICAgIHNxdWFyZjogc3F1YXJmLFxuICAgIHNxdTogc3F1LFxuICAgIHNxdWY6IHNxdWYsXG4gICAgc3JhcnI6IHNyYXJyLFxuICAgIFNzY3I6IFNzY3IsXG4gICAgc3Njcjogc3NjcixcbiAgICBzc2V0bW46IHNzZXRtbixcbiAgICBzc21pbGU6IHNzbWlsZSxcbiAgICBzc3RhcmY6IHNzdGFyZixcbiAgICBTdGFyOiBTdGFyLFxuICAgIHN0YXI6IHN0YXIsXG4gICAgc3RhcmY6IHN0YXJmLFxuICAgIHN0cmFpZ2h0ZXBzaWxvbjogc3RyYWlnaHRlcHNpbG9uLFxuICAgIHN0cmFpZ2h0cGhpOiBzdHJhaWdodHBoaSxcbiAgICBzdHJuczogc3RybnMsXG4gICAgc3ViOiBzdWIsXG4gICAgU3ViOiBTdWIsXG4gICAgc3ViZG90OiBzdWJkb3QsXG4gICAgc3ViRTogc3ViRSxcbiAgICBzdWJlOiBzdWJlLFxuICAgIHN1YmVkb3Q6IHN1YmVkb3QsXG4gICAgc3VibXVsdDogc3VibXVsdCxcbiAgICBzdWJuRTogc3VibkUsXG4gICAgc3VibmU6IHN1Ym5lLFxuICAgIHN1YnBsdXM6IHN1YnBsdXMsXG4gICAgc3VicmFycjogc3VicmFycixcbiAgICBzdWJzZXQ6IHN1YnNldCxcbiAgICBTdWJzZXQ6IFN1YnNldCxcbiAgICBzdWJzZXRlcTogc3Vic2V0ZXEsXG4gICAgc3Vic2V0ZXFxOiBzdWJzZXRlcXEsXG4gICAgU3Vic2V0RXF1YWw6IFN1YnNldEVxdWFsLFxuICAgIHN1YnNldG5lcTogc3Vic2V0bmVxLFxuICAgIHN1YnNldG5lcXE6IHN1YnNldG5lcXEsXG4gICAgc3Vic2ltOiBzdWJzaW0sXG4gICAgc3Vic3ViOiBzdWJzdWIsXG4gICAgc3Vic3VwOiBzdWJzdXAsXG4gICAgc3VjY2FwcHJveDogc3VjY2FwcHJveCxcbiAgICBzdWNjOiBzdWNjLFxuICAgIHN1Y2NjdXJseWVxOiBzdWNjY3VybHllcSxcbiAgICBTdWNjZWVkczogU3VjY2VlZHMsXG4gICAgU3VjY2VlZHNFcXVhbDogU3VjY2VlZHNFcXVhbCxcbiAgICBTdWNjZWVkc1NsYW50RXF1YWw6IFN1Y2NlZWRzU2xhbnRFcXVhbCxcbiAgICBTdWNjZWVkc1RpbGRlOiBTdWNjZWVkc1RpbGRlLFxuICAgIHN1Y2NlcTogc3VjY2VxLFxuICAgIHN1Y2NuYXBwcm94OiBzdWNjbmFwcHJveCxcbiAgICBzdWNjbmVxcTogc3VjY25lcXEsXG4gICAgc3VjY25zaW06IHN1Y2Nuc2ltLFxuICAgIHN1Y2NzaW06IHN1Y2NzaW0sXG4gICAgU3VjaFRoYXQ6IFN1Y2hUaGF0LFxuICAgIHN1bTogc3VtLFxuICAgIFN1bTogU3VtLFxuICAgIHN1bmc6IHN1bmcsXG4gICAgc3VwMTogc3VwMSQxLFxuICAgIHN1cDI6IHN1cDIkMSxcbiAgICBzdXAzOiBzdXAzJDEsXG4gICAgc3VwOiBzdXAsXG4gICAgU3VwOiBTdXAsXG4gICAgc3VwZG90OiBzdXBkb3QsXG4gICAgc3VwZHN1Yjogc3VwZHN1YixcbiAgICBzdXBFOiBzdXBFLFxuICAgIHN1cGU6IHN1cGUsXG4gICAgc3VwZWRvdDogc3VwZWRvdCxcbiAgICBTdXBlcnNldDogU3VwZXJzZXQsXG4gICAgU3VwZXJzZXRFcXVhbDogU3VwZXJzZXRFcXVhbCxcbiAgICBzdXBoc29sOiBzdXBoc29sLFxuICAgIHN1cGhzdWI6IHN1cGhzdWIsXG4gICAgc3VwbGFycjogc3VwbGFycixcbiAgICBzdXBtdWx0OiBzdXBtdWx0LFxuICAgIHN1cG5FOiBzdXBuRSxcbiAgICBzdXBuZTogc3VwbmUsXG4gICAgc3VwcGx1czogc3VwcGx1cyxcbiAgICBzdXBzZXQ6IHN1cHNldCxcbiAgICBTdXBzZXQ6IFN1cHNldCxcbiAgICBzdXBzZXRlcTogc3Vwc2V0ZXEsXG4gICAgc3Vwc2V0ZXFxOiBzdXBzZXRlcXEsXG4gICAgc3Vwc2V0bmVxOiBzdXBzZXRuZXEsXG4gICAgc3Vwc2V0bmVxcTogc3Vwc2V0bmVxcSxcbiAgICBzdXBzaW06IHN1cHNpbSxcbiAgICBzdXBzdWI6IHN1cHN1YixcbiAgICBzdXBzdXA6IHN1cHN1cCxcbiAgICBzd2FyaGs6IHN3YXJoayxcbiAgICBzd2Fycjogc3dhcnIsXG4gICAgc3dBcnI6IHN3QXJyLFxuICAgIHN3YXJyb3c6IHN3YXJyb3csXG4gICAgc3dud2FyOiBzd253YXIsXG4gICAgc3psaWc6IHN6bGlnJDEsXG4gICAgVGFiOiBUYWIsXG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgVGF1OiBUYXUsXG4gICAgdGF1OiB0YXUsXG4gICAgdGJyazogdGJyayxcbiAgICBUY2Fyb246IFRjYXJvbixcbiAgICB0Y2Fyb246IHRjYXJvbixcbiAgICBUY2VkaWw6IFRjZWRpbCxcbiAgICB0Y2VkaWw6IHRjZWRpbCxcbiAgICBUY3k6IFRjeSxcbiAgICB0Y3k6IHRjeSxcbiAgICB0ZG90OiB0ZG90LFxuICAgIHRlbHJlYzogdGVscmVjLFxuICAgIFRmcjogVGZyLFxuICAgIHRmcjogdGZyLFxuICAgIHRoZXJlNDogdGhlcmU0LFxuICAgIHRoZXJlZm9yZTogdGhlcmVmb3JlLFxuICAgIFRoZXJlZm9yZTogVGhlcmVmb3JlLFxuICAgIFRoZXRhOiBUaGV0YSxcbiAgICB0aGV0YTogdGhldGEsXG4gICAgdGhldGFzeW06IHRoZXRhc3ltLFxuICAgIHRoZXRhdjogdGhldGF2LFxuICAgIHRoaWNrYXBwcm94OiB0aGlja2FwcHJveCxcbiAgICB0aGlja3NpbTogdGhpY2tzaW0sXG4gICAgVGhpY2tTcGFjZTogVGhpY2tTcGFjZSxcbiAgICBUaGluU3BhY2U6IFRoaW5TcGFjZSxcbiAgICB0aGluc3A6IHRoaW5zcCxcbiAgICB0aGthcDogdGhrYXAsXG4gICAgdGhrc2ltOiB0aGtzaW0sXG4gICAgVEhPUk46IFRIT1JOJDEsXG4gICAgdGhvcm46IHRob3JuJDEsXG4gICAgdGlsZGU6IHRpbGRlLFxuICAgIFRpbGRlOiBUaWxkZSxcbiAgICBUaWxkZUVxdWFsOiBUaWxkZUVxdWFsLFxuICAgIFRpbGRlRnVsbEVxdWFsOiBUaWxkZUZ1bGxFcXVhbCxcbiAgICBUaWxkZVRpbGRlOiBUaWxkZVRpbGRlLFxuICAgIHRpbWVzYmFyOiB0aW1lc2JhcixcbiAgICB0aW1lc2I6IHRpbWVzYixcbiAgICB0aW1lczogdGltZXMkMSxcbiAgICB0aW1lc2Q6IHRpbWVzZCxcbiAgICB0aW50OiB0aW50LFxuICAgIHRvZWE6IHRvZWEsXG4gICAgdG9wYm90OiB0b3Bib3QsXG4gICAgdG9wY2lyOiB0b3BjaXIsXG4gICAgdG9wOiBlc21fdG9wLFxuICAgIFRvcGY6IFRvcGYsXG4gICAgdG9wZjogdG9wZixcbiAgICB0b3Bmb3JrOiB0b3Bmb3JrLFxuICAgIHRvc2E6IHRvc2EsXG4gICAgdHByaW1lOiB0cHJpbWUsXG4gICAgdHJhZGU6IHRyYWRlLFxuICAgIFRSQURFOiBUUkFERSxcbiAgICB0cmlhbmdsZTogdHJpYW5nbGUsXG4gICAgdHJpYW5nbGVkb3duOiB0cmlhbmdsZWRvd24sXG4gICAgdHJpYW5nbGVsZWZ0OiB0cmlhbmdsZWxlZnQsXG4gICAgdHJpYW5nbGVsZWZ0ZXE6IHRyaWFuZ2xlbGVmdGVxLFxuICAgIHRyaWFuZ2xlcTogdHJpYW5nbGVxLFxuICAgIHRyaWFuZ2xlcmlnaHQ6IHRyaWFuZ2xlcmlnaHQsXG4gICAgdHJpYW5nbGVyaWdodGVxOiB0cmlhbmdsZXJpZ2h0ZXEsXG4gICAgdHJpZG90OiB0cmlkb3QsXG4gICAgdHJpZTogdHJpZSxcbiAgICB0cmltaW51czogdHJpbWludXMsXG4gICAgVHJpcGxlRG90OiBUcmlwbGVEb3QsXG4gICAgdHJpcGx1czogdHJpcGx1cyxcbiAgICB0cmlzYjogdHJpc2IsXG4gICAgdHJpdGltZTogdHJpdGltZSxcbiAgICB0cnBleml1bTogdHJwZXppdW0sXG4gICAgVHNjcjogVHNjcixcbiAgICB0c2NyOiB0c2NyLFxuICAgIFRTY3k6IFRTY3ksXG4gICAgdHNjeTogdHNjeSxcbiAgICBUU0hjeTogVFNIY3ksXG4gICAgdHNoY3k6IHRzaGN5LFxuICAgIFRzdHJvazogVHN0cm9rLFxuICAgIHRzdHJvazogdHN0cm9rLFxuICAgIHR3aXh0OiB0d2l4dCxcbiAgICB0d29oZWFkbGVmdGFycm93OiB0d29oZWFkbGVmdGFycm93LFxuICAgIHR3b2hlYWRyaWdodGFycm93OiB0d29oZWFkcmlnaHRhcnJvdyxcbiAgICBVYWN1dGU6IFVhY3V0ZSQxLFxuICAgIHVhY3V0ZTogdWFjdXRlJDEsXG4gICAgdWFycjogdWFycixcbiAgICBVYXJyOiBVYXJyLFxuICAgIHVBcnI6IHVBcnIsXG4gICAgVWFycm9jaXI6IFVhcnJvY2lyLFxuICAgIFVicmN5OiBVYnJjeSxcbiAgICB1YnJjeTogdWJyY3ksXG4gICAgVWJyZXZlOiBVYnJldmUsXG4gICAgdWJyZXZlOiB1YnJldmUsXG4gICAgVWNpcmM6IFVjaXJjJDEsXG4gICAgdWNpcmM6IHVjaXJjJDEsXG4gICAgVWN5OiBVY3ksXG4gICAgdWN5OiB1Y3ksXG4gICAgdWRhcnI6IHVkYXJyLFxuICAgIFVkYmxhYzogVWRibGFjLFxuICAgIHVkYmxhYzogdWRibGFjLFxuICAgIHVkaGFyOiB1ZGhhcixcbiAgICB1ZmlzaHQ6IHVmaXNodCxcbiAgICBVZnI6IFVmcixcbiAgICB1ZnI6IHVmcixcbiAgICBVZ3JhdmU6IFVncmF2ZSQxLFxuICAgIHVncmF2ZTogdWdyYXZlJDEsXG4gICAgdUhhcjogdUhhcixcbiAgICB1aGFybDogdWhhcmwsXG4gICAgdWhhcnI6IHVoYXJyLFxuICAgIHVoYmxrOiB1aGJsayxcbiAgICB1bGNvcm46IHVsY29ybixcbiAgICB1bGNvcm5lcjogdWxjb3JuZXIsXG4gICAgdWxjcm9wOiB1bGNyb3AsXG4gICAgdWx0cmk6IHVsdHJpLFxuICAgIFVtYWNyOiBVbWFjcixcbiAgICB1bWFjcjogdW1hY3IsXG4gICAgdW1sOiB1bWwkMSxcbiAgICBVbmRlckJhcjogVW5kZXJCYXIsXG4gICAgVW5kZXJCcmFjZTogVW5kZXJCcmFjZSxcbiAgICBVbmRlckJyYWNrZXQ6IFVuZGVyQnJhY2tldCxcbiAgICBVbmRlclBhcmVudGhlc2lzOiBVbmRlclBhcmVudGhlc2lzLFxuICAgIFVuaW9uOiBVbmlvbixcbiAgICBVbmlvblBsdXM6IFVuaW9uUGx1cyxcbiAgICBVb2dvbjogVW9nb24sXG4gICAgdW9nb246IHVvZ29uLFxuICAgIFVvcGY6IFVvcGYsXG4gICAgdW9wZjogdW9wZixcbiAgICBVcEFycm93QmFyOiBVcEFycm93QmFyLFxuICAgIHVwYXJyb3c6IHVwYXJyb3csXG4gICAgVXBBcnJvdzogVXBBcnJvdyxcbiAgICBVcGFycm93OiBVcGFycm93LFxuICAgIFVwQXJyb3dEb3duQXJyb3c6IFVwQXJyb3dEb3duQXJyb3csXG4gICAgdXBkb3duYXJyb3c6IHVwZG93bmFycm93LFxuICAgIFVwRG93bkFycm93OiBVcERvd25BcnJvdyxcbiAgICBVcGRvd25hcnJvdzogVXBkb3duYXJyb3csXG4gICAgVXBFcXVpbGlicml1bTogVXBFcXVpbGlicml1bSxcbiAgICB1cGhhcnBvb25sZWZ0OiB1cGhhcnBvb25sZWZ0LFxuICAgIHVwaGFycG9vbnJpZ2h0OiB1cGhhcnBvb25yaWdodCxcbiAgICB1cGx1czogdXBsdXMsXG4gICAgVXBwZXJMZWZ0QXJyb3c6IFVwcGVyTGVmdEFycm93LFxuICAgIFVwcGVyUmlnaHRBcnJvdzogVXBwZXJSaWdodEFycm93LFxuICAgIHVwc2k6IHVwc2ksXG4gICAgVXBzaTogVXBzaSxcbiAgICB1cHNpaDogdXBzaWgsXG4gICAgVXBzaWxvbjogVXBzaWxvbixcbiAgICB1cHNpbG9uOiB1cHNpbG9uLFxuICAgIFVwVGVlQXJyb3c6IFVwVGVlQXJyb3csXG4gICAgVXBUZWU6IFVwVGVlLFxuICAgIHVwdXBhcnJvd3M6IHVwdXBhcnJvd3MsXG4gICAgdXJjb3JuOiB1cmNvcm4sXG4gICAgdXJjb3JuZXI6IHVyY29ybmVyLFxuICAgIHVyY3JvcDogdXJjcm9wLFxuICAgIFVyaW5nOiBVcmluZyxcbiAgICB1cmluZzogdXJpbmcsXG4gICAgdXJ0cmk6IHVydHJpLFxuICAgIFVzY3I6IFVzY3IsXG4gICAgdXNjcjogdXNjcixcbiAgICB1dGRvdDogdXRkb3QsXG4gICAgVXRpbGRlOiBVdGlsZGUsXG4gICAgdXRpbGRlOiB1dGlsZGUsXG4gICAgdXRyaTogdXRyaSxcbiAgICB1dHJpZjogdXRyaWYsXG4gICAgdXVhcnI6IHV1YXJyLFxuICAgIFV1bWw6IFV1bWwkMSxcbiAgICB1dW1sOiB1dW1sJDEsXG4gICAgdXdhbmdsZTogdXdhbmdsZSxcbiAgICB2YW5ncnQ6IHZhbmdydCxcbiAgICB2YXJlcHNpbG9uOiB2YXJlcHNpbG9uLFxuICAgIHZhcmthcHBhOiB2YXJrYXBwYSxcbiAgICB2YXJub3RoaW5nOiB2YXJub3RoaW5nLFxuICAgIHZhcnBoaTogdmFycGhpLFxuICAgIHZhcnBpOiB2YXJwaSxcbiAgICB2YXJwcm9wdG86IHZhcnByb3B0byxcbiAgICB2YXJyOiB2YXJyLFxuICAgIHZBcnI6IHZBcnIsXG4gICAgdmFycmhvOiB2YXJyaG8sXG4gICAgdmFyc2lnbWE6IHZhcnNpZ21hLFxuICAgIHZhcnN1YnNldG5lcTogdmFyc3Vic2V0bmVxLFxuICAgIHZhcnN1YnNldG5lcXE6IHZhcnN1YnNldG5lcXEsXG4gICAgdmFyc3Vwc2V0bmVxOiB2YXJzdXBzZXRuZXEsXG4gICAgdmFyc3Vwc2V0bmVxcTogdmFyc3Vwc2V0bmVxcSxcbiAgICB2YXJ0aGV0YTogdmFydGhldGEsXG4gICAgdmFydHJpYW5nbGVsZWZ0OiB2YXJ0cmlhbmdsZWxlZnQsXG4gICAgdmFydHJpYW5nbGVyaWdodDogdmFydHJpYW5nbGVyaWdodCxcbiAgICB2QmFyOiB2QmFyLFxuICAgIFZiYXI6IFZiYXIsXG4gICAgdkJhcnY6IHZCYXJ2LFxuICAgIFZjeTogVmN5LFxuICAgIHZjeTogdmN5LFxuICAgIHZkYXNoOiB2ZGFzaCxcbiAgICB2RGFzaDogdkRhc2gsXG4gICAgVmRhc2g6IFZkYXNoLFxuICAgIFZEYXNoOiBWRGFzaCxcbiAgICBWZGFzaGw6IFZkYXNobCxcbiAgICB2ZWViYXI6IHZlZWJhcixcbiAgICB2ZWU6IHZlZSxcbiAgICBWZWU6IFZlZSxcbiAgICB2ZWVlcTogdmVlZXEsXG4gICAgdmVsbGlwOiB2ZWxsaXAsXG4gICAgdmVyYmFyOiB2ZXJiYXIsXG4gICAgVmVyYmFyOiBWZXJiYXIsXG4gICAgdmVydDogdmVydCxcbiAgICBWZXJ0OiBWZXJ0LFxuICAgIFZlcnRpY2FsQmFyOiBWZXJ0aWNhbEJhcixcbiAgICBWZXJ0aWNhbExpbmU6IFZlcnRpY2FsTGluZSxcbiAgICBWZXJ0aWNhbFNlcGFyYXRvcjogVmVydGljYWxTZXBhcmF0b3IsXG4gICAgVmVydGljYWxUaWxkZTogVmVydGljYWxUaWxkZSxcbiAgICBWZXJ5VGhpblNwYWNlOiBWZXJ5VGhpblNwYWNlLFxuICAgIFZmcjogVmZyLFxuICAgIHZmcjogdmZyLFxuICAgIHZsdHJpOiB2bHRyaSxcbiAgICB2bnN1Yjogdm5zdWIsXG4gICAgdm5zdXA6IHZuc3VwLFxuICAgIFZvcGY6IFZvcGYsXG4gICAgdm9wZjogdm9wZixcbiAgICB2cHJvcDogdnByb3AsXG4gICAgdnJ0cmk6IHZydHJpLFxuICAgIFZzY3I6IFZzY3IsXG4gICAgdnNjcjogdnNjcixcbiAgICB2c3VibkU6IHZzdWJuRSxcbiAgICB2c3VibmU6IHZzdWJuZSxcbiAgICB2c3VwbkU6IHZzdXBuRSxcbiAgICB2c3VwbmU6IHZzdXBuZSxcbiAgICBWdmRhc2g6IFZ2ZGFzaCxcbiAgICB2emlnemFnOiB2emlnemFnLFxuICAgIFdjaXJjOiBXY2lyYyxcbiAgICB3Y2lyYzogd2NpcmMsXG4gICAgd2VkYmFyOiB3ZWRiYXIsXG4gICAgd2VkZ2U6IHdlZGdlLFxuICAgIFdlZGdlOiBXZWRnZSxcbiAgICB3ZWRnZXE6IHdlZGdlcSxcbiAgICB3ZWllcnA6IHdlaWVycCxcbiAgICBXZnI6IFdmcixcbiAgICB3ZnI6IHdmcixcbiAgICBXb3BmOiBXb3BmLFxuICAgIHdvcGY6IHdvcGYsXG4gICAgd3A6IHdwLFxuICAgIHdyOiB3cixcbiAgICB3cmVhdGg6IHdyZWF0aCxcbiAgICBXc2NyOiBXc2NyLFxuICAgIHdzY3I6IHdzY3IsXG4gICAgeGNhcDogeGNhcCxcbiAgICB4Y2lyYzogeGNpcmMsXG4gICAgeGN1cDogeGN1cCxcbiAgICB4ZHRyaTogeGR0cmksXG4gICAgWGZyOiBYZnIsXG4gICAgeGZyOiB4ZnIsXG4gICAgeGhhcnI6IHhoYXJyLFxuICAgIHhoQXJyOiB4aEFycixcbiAgICBYaTogWGksXG4gICAgeGk6IHhpLFxuICAgIHhsYXJyOiB4bGFycixcbiAgICB4bEFycjogeGxBcnIsXG4gICAgeG1hcDogeG1hcCxcbiAgICB4bmlzOiB4bmlzLFxuICAgIHhvZG90OiB4b2RvdCxcbiAgICBYb3BmOiBYb3BmLFxuICAgIHhvcGY6IHhvcGYsXG4gICAgeG9wbHVzOiB4b3BsdXMsXG4gICAgeG90aW1lOiB4b3RpbWUsXG4gICAgeHJhcnI6IHhyYXJyLFxuICAgIHhyQXJyOiB4ckFycixcbiAgICBYc2NyOiBYc2NyLFxuICAgIHhzY3I6IHhzY3IsXG4gICAgeHNxY3VwOiB4c3FjdXAsXG4gICAgeHVwbHVzOiB4dXBsdXMsXG4gICAgeHV0cmk6IHh1dHJpLFxuICAgIHh2ZWU6IHh2ZWUsXG4gICAgeHdlZGdlOiB4d2VkZ2UsXG4gICAgWWFjdXRlOiBZYWN1dGUkMSxcbiAgICB5YWN1dGU6IHlhY3V0ZSQxLFxuICAgIFlBY3k6IFlBY3ksXG4gICAgeWFjeTogeWFjeSxcbiAgICBZY2lyYzogWWNpcmMsXG4gICAgeWNpcmM6IHljaXJjLFxuICAgIFljeTogWWN5LFxuICAgIHljeTogeWN5LFxuICAgIHllbjogeWVuJDEsXG4gICAgWWZyOiBZZnIsXG4gICAgeWZyOiB5ZnIsXG4gICAgWUljeTogWUljeSxcbiAgICB5aWN5OiB5aWN5LFxuICAgIFlvcGY6IFlvcGYsXG4gICAgeW9wZjogeW9wZixcbiAgICBZc2NyOiBZc2NyLFxuICAgIHlzY3I6IHlzY3IsXG4gICAgWVVjeTogWVVjeSxcbiAgICB5dWN5OiB5dWN5LFxuICAgIHl1bWw6IHl1bWwkMSxcbiAgICBZdW1sOiBZdW1sLFxuICAgIFphY3V0ZTogWmFjdXRlLFxuICAgIHphY3V0ZTogemFjdXRlLFxuICAgIFpjYXJvbjogWmNhcm9uLFxuICAgIHpjYXJvbjogemNhcm9uLFxuICAgIFpjeTogWmN5LFxuICAgIHpjeTogemN5LFxuICAgIFpkb3Q6IFpkb3QsXG4gICAgemRvdDogemRvdCxcbiAgICB6ZWV0cmY6IHplZXRyZixcbiAgICBaZXJvV2lkdGhTcGFjZTogWmVyb1dpZHRoU3BhY2UsXG4gICAgWmV0YTogWmV0YSxcbiAgICB6ZXRhOiB6ZXRhLFxuICAgIHpmcjogemZyLFxuICAgIFpmcjogWmZyLFxuICAgIFpIY3k6IFpIY3ksXG4gICAgemhjeTogemhjeSxcbiAgICB6aWdyYXJyOiB6aWdyYXJyLFxuICAgIHpvcGY6IHpvcGYsXG4gICAgWm9wZjogWm9wZixcbiAgICBac2NyOiBac2NyLFxuICAgIHpzY3I6IHpzY3IsXG4gICAgendqOiB6d2osXG4gICAgenduajogendualxufTtcbnZhciBBYWN1dGUgPSBcIsOBXCI7XG52YXIgYWFjdXRlID0gXCLDoVwiO1xudmFyIEFjaXJjID0gXCLDglwiO1xudmFyIGFjaXJjID0gXCLDolwiO1xudmFyIGFjdXRlID0gXCLCtFwiO1xudmFyIEFFbGlnID0gXCLDhlwiO1xudmFyIGFlbGlnID0gXCLDplwiO1xudmFyIEFncmF2ZSA9IFwiw4BcIjtcbnZhciBhZ3JhdmUgPSBcIsOgXCI7XG52YXIgYW1wJDEgPSBcIiZcIjtcbnZhciBBTVAgPSBcIiZcIjtcbnZhciBBcmluZyA9IFwiw4VcIjtcbnZhciBhcmluZyA9IFwiw6VcIjtcbnZhciBBdGlsZGUgPSBcIsODXCI7XG52YXIgYXRpbGRlID0gXCLDo1wiO1xudmFyIEF1bWwgPSBcIsOEXCI7XG52YXIgYXVtbCA9IFwiw6RcIjtcbnZhciBicnZiYXIgPSBcIsKmXCI7XG52YXIgQ2NlZGlsID0gXCLDh1wiO1xudmFyIGNjZWRpbCA9IFwiw6dcIjtcbnZhciBjZWRpbCA9IFwiwrhcIjtcbnZhciBjZW50ID0gXCLColwiO1xudmFyIGNvcHkgPSBcIsKpXCI7XG52YXIgQ09QWSA9IFwiwqlcIjtcbnZhciBjdXJyZW4gPSBcIsKkXCI7XG52YXIgZGVnID0gXCLCsFwiO1xudmFyIGRpdmlkZSA9IFwiw7dcIjtcbnZhciBFYWN1dGUgPSBcIsOJXCI7XG52YXIgZWFjdXRlID0gXCLDqVwiO1xudmFyIEVjaXJjID0gXCLDilwiO1xudmFyIGVjaXJjID0gXCLDqlwiO1xudmFyIEVncmF2ZSA9IFwiw4hcIjtcbnZhciBlZ3JhdmUgPSBcIsOoXCI7XG52YXIgRVRIID0gXCLDkFwiO1xudmFyIGV0aCA9IFwiw7BcIjtcbnZhciBFdW1sID0gXCLDi1wiO1xudmFyIGV1bWwgPSBcIsOrXCI7XG52YXIgZnJhYzEyID0gXCLCvVwiO1xudmFyIGZyYWMxNCA9IFwiwrxcIjtcbnZhciBmcmFjMzQgPSBcIsK+XCI7XG52YXIgZ3QkMSA9IFwiPlwiO1xudmFyIEdUID0gXCI+XCI7XG52YXIgSWFjdXRlID0gXCLDjVwiO1xudmFyIGlhY3V0ZSA9IFwiw61cIjtcbnZhciBJY2lyYyA9IFwiw45cIjtcbnZhciBpY2lyYyA9IFwiw65cIjtcbnZhciBpZXhjbCA9IFwiwqFcIjtcbnZhciBJZ3JhdmUgPSBcIsOMXCI7XG52YXIgaWdyYXZlID0gXCLDrFwiO1xudmFyIGlxdWVzdCA9IFwiwr9cIjtcbnZhciBJdW1sID0gXCLDj1wiO1xudmFyIGl1bWwgPSBcIsOvXCI7XG52YXIgbGFxdW8gPSBcIsKrXCI7XG52YXIgbHQkMSA9IFwiPFwiO1xudmFyIExUID0gXCI8XCI7XG52YXIgbWFjciA9IFwiwq9cIjtcbnZhciBtaWNybyA9IFwiwrVcIjtcbnZhciBtaWRkb3QgPSBcIsK3XCI7XG52YXIgbmJzcCA9IFwiwqBcIjtcbnZhciBub3QgPSBcIsKsXCI7XG52YXIgTnRpbGRlID0gXCLDkVwiO1xudmFyIG50aWxkZSA9IFwiw7FcIjtcbnZhciBPYWN1dGUgPSBcIsOTXCI7XG52YXIgb2FjdXRlID0gXCLDs1wiO1xudmFyIE9jaXJjID0gXCLDlFwiO1xudmFyIG9jaXJjID0gXCLDtFwiO1xudmFyIE9ncmF2ZSA9IFwiw5JcIjtcbnZhciBvZ3JhdmUgPSBcIsOyXCI7XG52YXIgb3JkZiA9IFwiwqpcIjtcbnZhciBvcmRtID0gXCLCulwiO1xudmFyIE9zbGFzaCA9IFwiw5hcIjtcbnZhciBvc2xhc2ggPSBcIsO4XCI7XG52YXIgT3RpbGRlID0gXCLDlVwiO1xudmFyIG90aWxkZSA9IFwiw7VcIjtcbnZhciBPdW1sID0gXCLDllwiO1xudmFyIG91bWwgPSBcIsO2XCI7XG52YXIgcGFyYSA9IFwiwrZcIjtcbnZhciBwbHVzbW4gPSBcIsKxXCI7XG52YXIgcG91bmQgPSBcIsKjXCI7XG52YXIgcXVvdCQxID0gXCJcXFwiXCI7XG52YXIgUVVPVCA9IFwiXFxcIlwiO1xudmFyIHJhcXVvID0gXCLCu1wiO1xudmFyIHJlZyA9IFwiwq5cIjtcbnZhciBSRUcgPSBcIsKuXCI7XG52YXIgc2VjdCA9IFwiwqdcIjtcbnZhciBzaHkgPSBcIsKtXCI7XG52YXIgc3VwMSA9IFwiwrlcIjtcbnZhciBzdXAyID0gXCLCslwiO1xudmFyIHN1cDMgPSBcIsKzXCI7XG52YXIgc3psaWcgPSBcIsOfXCI7XG52YXIgVEhPUk4gPSBcIsOeXCI7XG52YXIgdGhvcm4gPSBcIsO+XCI7XG52YXIgdGltZXMgPSBcIsOXXCI7XG52YXIgVWFjdXRlID0gXCLDmlwiO1xudmFyIHVhY3V0ZSA9IFwiw7pcIjtcbnZhciBVY2lyYyA9IFwiw5tcIjtcbnZhciB1Y2lyYyA9IFwiw7tcIjtcbnZhciBVZ3JhdmUgPSBcIsOZXCI7XG52YXIgdWdyYXZlID0gXCLDuVwiO1xudmFyIHVtbCA9IFwiwqhcIjtcbnZhciBVdW1sID0gXCLDnFwiO1xudmFyIHV1bWwgPSBcIsO8XCI7XG52YXIgWWFjdXRlID0gXCLDnVwiO1xudmFyIHlhY3V0ZSA9IFwiw71cIjtcbnZhciB5ZW4gPSBcIsKlXCI7XG52YXIgeXVtbCA9IFwiw79cIjtcbnZhciByZXF1aXJlJCQxID0ge1xuICAgIEFhY3V0ZTogQWFjdXRlLFxuICAgIGFhY3V0ZTogYWFjdXRlLFxuICAgIEFjaXJjOiBBY2lyYyxcbiAgICBhY2lyYzogYWNpcmMsXG4gICAgYWN1dGU6IGFjdXRlLFxuICAgIEFFbGlnOiBBRWxpZyxcbiAgICBhZWxpZzogYWVsaWcsXG4gICAgQWdyYXZlOiBBZ3JhdmUsXG4gICAgYWdyYXZlOiBhZ3JhdmUsXG4gICAgYW1wOiBhbXAkMSxcbiAgICBBTVA6IEFNUCxcbiAgICBBcmluZzogQXJpbmcsXG4gICAgYXJpbmc6IGFyaW5nLFxuICAgIEF0aWxkZTogQXRpbGRlLFxuICAgIGF0aWxkZTogYXRpbGRlLFxuICAgIEF1bWw6IEF1bWwsXG4gICAgYXVtbDogYXVtbCxcbiAgICBicnZiYXI6IGJydmJhcixcbiAgICBDY2VkaWw6IENjZWRpbCxcbiAgICBjY2VkaWw6IGNjZWRpbCxcbiAgICBjZWRpbDogY2VkaWwsXG4gICAgY2VudDogY2VudCxcbiAgICBjb3B5OiBjb3B5LFxuICAgIENPUFk6IENPUFksXG4gICAgY3VycmVuOiBjdXJyZW4sXG4gICAgZGVnOiBkZWcsXG4gICAgZGl2aWRlOiBkaXZpZGUsXG4gICAgRWFjdXRlOiBFYWN1dGUsXG4gICAgZWFjdXRlOiBlYWN1dGUsXG4gICAgRWNpcmM6IEVjaXJjLFxuICAgIGVjaXJjOiBlY2lyYyxcbiAgICBFZ3JhdmU6IEVncmF2ZSxcbiAgICBlZ3JhdmU6IGVncmF2ZSxcbiAgICBFVEg6IEVUSCxcbiAgICBldGg6IGV0aCxcbiAgICBFdW1sOiBFdW1sLFxuICAgIGV1bWw6IGV1bWwsXG4gICAgZnJhYzEyOiBmcmFjMTIsXG4gICAgZnJhYzE0OiBmcmFjMTQsXG4gICAgZnJhYzM0OiBmcmFjMzQsXG4gICAgZ3Q6IGd0JDEsXG4gICAgR1Q6IEdULFxuICAgIElhY3V0ZTogSWFjdXRlLFxuICAgIGlhY3V0ZTogaWFjdXRlLFxuICAgIEljaXJjOiBJY2lyYyxcbiAgICBpY2lyYzogaWNpcmMsXG4gICAgaWV4Y2w6IGlleGNsLFxuICAgIElncmF2ZTogSWdyYXZlLFxuICAgIGlncmF2ZTogaWdyYXZlLFxuICAgIGlxdWVzdDogaXF1ZXN0LFxuICAgIEl1bWw6IEl1bWwsXG4gICAgaXVtbDogaXVtbCxcbiAgICBsYXF1bzogbGFxdW8sXG4gICAgbHQ6IGx0JDEsXG4gICAgTFQ6IExULFxuICAgIG1hY3I6IG1hY3IsXG4gICAgbWljcm86IG1pY3JvLFxuICAgIG1pZGRvdDogbWlkZG90LFxuICAgIG5ic3A6IG5ic3AsXG4gICAgbm90OiBub3QsXG4gICAgTnRpbGRlOiBOdGlsZGUsXG4gICAgbnRpbGRlOiBudGlsZGUsXG4gICAgT2FjdXRlOiBPYWN1dGUsXG4gICAgb2FjdXRlOiBvYWN1dGUsXG4gICAgT2NpcmM6IE9jaXJjLFxuICAgIG9jaXJjOiBvY2lyYyxcbiAgICBPZ3JhdmU6IE9ncmF2ZSxcbiAgICBvZ3JhdmU6IG9ncmF2ZSxcbiAgICBvcmRmOiBvcmRmLFxuICAgIG9yZG06IG9yZG0sXG4gICAgT3NsYXNoOiBPc2xhc2gsXG4gICAgb3NsYXNoOiBvc2xhc2gsXG4gICAgT3RpbGRlOiBPdGlsZGUsXG4gICAgb3RpbGRlOiBvdGlsZGUsXG4gICAgT3VtbDogT3VtbCxcbiAgICBvdW1sOiBvdW1sLFxuICAgIHBhcmE6IHBhcmEsXG4gICAgcGx1c21uOiBwbHVzbW4sXG4gICAgcG91bmQ6IHBvdW5kLFxuICAgIHF1b3Q6IHF1b3QkMSxcbiAgICBRVU9UOiBRVU9ULFxuICAgIHJhcXVvOiByYXF1byxcbiAgICByZWc6IHJlZyxcbiAgICBSRUc6IFJFRyxcbiAgICBzZWN0OiBzZWN0LFxuICAgIHNoeTogc2h5LFxuICAgIHN1cDE6IHN1cDEsXG4gICAgc3VwMjogc3VwMixcbiAgICBzdXAzOiBzdXAzLFxuICAgIHN6bGlnOiBzemxpZyxcbiAgICBUSE9STjogVEhPUk4sXG4gICAgdGhvcm46IHRob3JuLFxuICAgIHRpbWVzOiB0aW1lcyxcbiAgICBVYWN1dGU6IFVhY3V0ZSxcbiAgICB1YWN1dGU6IHVhY3V0ZSxcbiAgICBVY2lyYzogVWNpcmMsXG4gICAgdWNpcmM6IHVjaXJjLFxuICAgIFVncmF2ZTogVWdyYXZlLFxuICAgIHVncmF2ZTogdWdyYXZlLFxuICAgIHVtbDogdW1sLFxuICAgIFV1bWw6IFV1bWwsXG4gICAgdXVtbDogdXVtbCxcbiAgICBZYWN1dGU6IFlhY3V0ZSxcbiAgICB5YWN1dGU6IHlhY3V0ZSxcbiAgICB5ZW46IHllbixcbiAgICB5dW1sOiB5dW1sXG59O1xudmFyIGFtcCA9IFwiJlwiO1xudmFyIGFwb3MgPSBcIidcIjtcbnZhciBndCA9IFwiPlwiO1xudmFyIGx0ID0gXCI8XCI7XG52YXIgcXVvdCA9IFwiXFxcIlwiO1xudmFyIHJlcXVpcmUkJDAkMSA9IHtcbiAgICBhbXA6IGFtcCxcbiAgICBhcG9zOiBhcG9zLFxuICAgIGd0OiBndCxcbiAgICBsdDogbHQsXG4gICAgcXVvdDogcXVvdFxufTtcbnZhciBkZWNvZGVfY29kZXBvaW50ID0ge307XG52YXIgcmVxdWlyZSQkMCA9IHtcbiAgICBcIjBcIjogNjU1MzMsXG4gICAgXCIxMjhcIjogODM2NCxcbiAgICBcIjEzMFwiOiA4MjE4LFxuICAgIFwiMTMxXCI6IDQwMixcbiAgICBcIjEzMlwiOiA4MjIyLFxuICAgIFwiMTMzXCI6IDgyMzAsXG4gICAgXCIxMzRcIjogODIyNCxcbiAgICBcIjEzNVwiOiA4MjI1LFxuICAgIFwiMTM2XCI6IDcxMCxcbiAgICBcIjEzN1wiOiA4MjQwLFxuICAgIFwiMTM4XCI6IDM1MixcbiAgICBcIjEzOVwiOiA4MjQ5LFxuICAgIFwiMTQwXCI6IDMzOCxcbiAgICBcIjE0MlwiOiAzODEsXG4gICAgXCIxNDVcIjogODIxNixcbiAgICBcIjE0NlwiOiA4MjE3LFxuICAgIFwiMTQ3XCI6IDgyMjAsXG4gICAgXCIxNDhcIjogODIyMSxcbiAgICBcIjE0OVwiOiA4MjI2LFxuICAgIFwiMTUwXCI6IDgyMTEsXG4gICAgXCIxNTFcIjogODIxMixcbiAgICBcIjE1MlwiOiA3MzIsXG4gICAgXCIxNTNcIjogODQ4MixcbiAgICBcIjE1NFwiOiAzNTMsXG4gICAgXCIxNTVcIjogODI1MCxcbiAgICBcIjE1NlwiOiAzMzksXG4gICAgXCIxNThcIjogMzgyLFxuICAgIFwiMTU5XCI6IDM3NlxufTtcbnZhciBfX2ltcG9ydERlZmF1bHQkMiA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZGVjb2RlX2NvZGVwb2ludCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVjb2RlX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdCQyKHJlcXVpcmUkJDApO1xuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL2hlL2Jsb2IvbWFzdGVyL3NyYy9oZS5qcyNMOTQtTDExOVxudmFyIGZyb21Db2RlUG9pbnQkMiA9IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cblN0cmluZy5mcm9tQ29kZVBvaW50IHx8XG4gICAgZnVuY3Rpb24gKGNvZGVQb2ludCkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4ZmZmZikge1xuICAgICAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+Pj4gMTApICYgMHgzZmYpIHwgMHhkODAwKTtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IDB4ZGMwMCB8IChjb2RlUG9pbnQgJiAweDNmZik7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuICAgIGlmICgoY29kZVBvaW50ID49IDB4ZDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhkZmZmKSB8fCBjb2RlUG9pbnQgPiAweDEwZmZmZikge1xuICAgICAgICByZXR1cm4gXCJcXHVGRkZEXCI7XG4gICAgfVxuICAgIGlmIChjb2RlUG9pbnQgaW4gZGVjb2RlX2pzb25fMS5kZWZhdWx0KSB7XG4gICAgICAgIGNvZGVQb2ludCA9IGRlY29kZV9qc29uXzEuZGVmYXVsdFtjb2RlUG9pbnRdO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUNvZGVQb2ludCQyKGNvZGVQb2ludCk7XG59XG5kZWNvZGVfY29kZXBvaW50LmRlZmF1bHQgPSBkZWNvZGVDb2RlUG9pbnQ7XG52YXIgX19pbXBvcnREZWZhdWx0JDEgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlY29kZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5kZWNvZGUuZGVjb2RlSFRNTCA9IGRlY29kZS5kZWNvZGVIVE1MU3RyaWN0ID0gZGVjb2RlLmRlY29kZVhNTCA9IHZvaWQgMDtcbnZhciBlbnRpdGllc19qc29uXzEkMSA9IF9faW1wb3J0RGVmYXVsdCQxKHJlcXVpcmUkJDEkMSk7XG52YXIgbGVnYWN5X2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdCQxKHJlcXVpcmUkJDEpO1xudmFyIHhtbF9qc29uXzEkMSA9IF9faW1wb3J0RGVmYXVsdCQxKHJlcXVpcmUkJDAkMSk7XG52YXIgZGVjb2RlX2NvZGVwb2ludF8xID0gX19pbXBvcnREZWZhdWx0JDEoZGVjb2RlX2NvZGVwb2ludCk7XG52YXIgc3RyaWN0RW50aXR5UmUgPSAvJig/OlthLXpBLVowLTldK3wjW3hYXVtcXGRhLWZBLUZdK3wjXFxkKyk7L2c7XG5kZWNvZGUuZGVjb2RlWE1MID0gZ2V0U3RyaWN0RGVjb2Rlcih4bWxfanNvbl8xJDEuZGVmYXVsdCk7XG5kZWNvZGUuZGVjb2RlSFRNTFN0cmljdCA9IGdldFN0cmljdERlY29kZXIoZW50aXRpZXNfanNvbl8xJDEuZGVmYXVsdCk7XG5mdW5jdGlvbiBnZXRTdHJpY3REZWNvZGVyKG1hcCkge1xuICAgIHZhciByZXBsYWNlID0gZ2V0UmVwbGFjZXIobWFwKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZShzdHJpY3RFbnRpdHlSZSwgcmVwbGFjZSk7IH07XG59XG52YXIgc29ydGVyID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChhIDwgYiA/IDEgOiAtMSk7IH07XG5kZWNvZGUuZGVjb2RlSFRNTCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlZ2FjeSA9IE9iamVjdC5rZXlzKGxlZ2FjeV9qc29uXzEuZGVmYXVsdCkuc29ydChzb3J0ZXIpO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZW50aXRpZXNfanNvbl8xJDEuZGVmYXVsdCkuc29ydChzb3J0ZXIpO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxlZ2FjeVtqXSA9PT0ga2V5c1tpXSkge1xuICAgICAgICAgICAga2V5c1tpXSArPSBcIjs/XCI7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrZXlzW2ldICs9IFwiO1wiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoXCImKD86XCIgKyBrZXlzLmpvaW4oXCJ8XCIpICsgXCJ8I1t4WF1bXFxcXGRhLWZBLUZdKzs/fCNcXFxcZCs7PylcIiwgXCJnXCIpO1xuICAgIHZhciByZXBsYWNlID0gZ2V0UmVwbGFjZXIoZW50aXRpZXNfanNvbl8xJDEuZGVmYXVsdCk7XG4gICAgZnVuY3Rpb24gcmVwbGFjZXIoc3RyKSB7XG4gICAgICAgIGlmIChzdHIuc3Vic3RyKC0xKSAhPT0gXCI7XCIpXG4gICAgICAgICAgICBzdHIgKz0gXCI7XCI7XG4gICAgICAgIHJldHVybiByZXBsYWNlKHN0cik7XG4gICAgfVxuICAgIC8vIFRPRE8gY29uc2lkZXIgY3JlYXRpbmcgYSBtZXJnZWQgbWFwXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UocmUsIHJlcGxhY2VyKTsgfTtcbn0pKCk7XG5mdW5jdGlvbiBnZXRSZXBsYWNlcihtYXApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShzdHIpIHtcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoMSkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICB2YXIgc2Vjb25kQ2hhciA9IHN0ci5jaGFyQXQoMik7XG4gICAgICAgICAgICBpZiAoc2Vjb25kQ2hhciA9PT0gXCJYXCIgfHwgc2Vjb25kQ2hhciA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlX2NvZGVwb2ludF8xLmRlZmF1bHQocGFyc2VJbnQoc3RyLnN1YnN0cigzKSwgMTYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVfY29kZXBvaW50XzEuZGVmYXVsdChwYXJzZUludChzdHIuc3Vic3RyKDIpLCAxMCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW51bGxpc2gtY29hbGVzY2luZ1xuICAgICAgICByZXR1cm4gbWFwW3N0ci5zbGljZSgxLCAtMSldIHx8IHN0cjtcbiAgICB9O1xufVxudmFyIGVuY29kZSA9IHt9O1xudmFyIGVzbV9pbXBvcnREZWZhdWx0ID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbmNvZGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZW5jb2RlLmVzY2FwZVVURjggPSBlbmNvZGUuZXNjYXBlID0gZW5jb2RlLmVuY29kZU5vbkFzY2lpSFRNTCA9IGVuY29kZS5lbmNvZGVIVE1MID0gZW5jb2RlLmVuY29kZVhNTCA9IHZvaWQgMDtcbnZhciB4bWxfanNvbl8xID0gZXNtX2ltcG9ydERlZmF1bHQocmVxdWlyZSQkMCQxKTtcbnZhciBpbnZlcnNlWE1MID0gZ2V0SW52ZXJzZU9iaih4bWxfanNvbl8xLmRlZmF1bHQpO1xudmFyIHhtbFJlcGxhY2VyID0gZ2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2VYTUwpO1xuLyoqXG4gKiBFbmNvZGVzIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycywgYXMgd2VsbCBhcyBjaGFyYWN0ZXJzIG5vdCB2YWxpZCBpbiBYTUxcbiAqIGRvY3VtZW50cyB1c2luZyBYTUwgZW50aXRpZXMuXG4gKlxuICogSWYgYSBjaGFyYWN0ZXIgaGFzIG5vIGVxdWl2YWxlbnQgZW50aXR5LCBhXG4gKiBudW1lcmljIGhleGFkZWNpbWFsIHJlZmVyZW5jZSAoZWcuIGAmI3hmYztgKSB3aWxsIGJlIHVzZWQuXG4gKi9cbmVuY29kZS5lbmNvZGVYTUwgPSBnZXRBU0NJSUVuY29kZXIoaW52ZXJzZVhNTCk7XG52YXIgZW50aXRpZXNfanNvbl8xID0gZXNtX2ltcG9ydERlZmF1bHQocmVxdWlyZSQkMSQxKTtcbnZhciBpbnZlcnNlSFRNTCA9IGdldEludmVyc2VPYmooZW50aXRpZXNfanNvbl8xLmRlZmF1bHQpO1xudmFyIGh0bWxSZXBsYWNlciA9IGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlSFRNTCk7XG4vKipcbiAqIEVuY29kZXMgYWxsIGVudGl0aWVzIGFuZCBub24tQVNDSUkgY2hhcmFjdGVycyBpbiB0aGUgaW5wdXQuXG4gKlxuICogVGhpcyBpbmNsdWRlcyBjaGFyYWN0ZXJzIHRoYXQgYXJlIHZhbGlkIEFTQ0lJIGNoYXJhY3RlcnMgaW4gSFRNTCBkb2N1bWVudHMuXG4gKiBGb3IgZXhhbXBsZSBgI2Agd2lsbCBiZSBlbmNvZGVkIGFzIGAmbnVtO2AuIFRvIGdldCBhIG1vcmUgY29tcGFjdCBvdXRwdXQsXG4gKiBjb25zaWRlciB1c2luZyB0aGUgYGVuY29kZU5vbkFzY2lpSFRNTGAgZnVuY3Rpb24uXG4gKlxuICogSWYgYSBjaGFyYWN0ZXIgaGFzIG5vIGVxdWl2YWxlbnQgZW50aXR5LCBhXG4gKiBudW1lcmljIGhleGFkZWNpbWFsIHJlZmVyZW5jZSAoZWcuIGAmI3hmYztgKSB3aWxsIGJlIHVzZWQuXG4gKi9cbmVuY29kZS5lbmNvZGVIVE1MID0gZ2V0SW52ZXJzZShpbnZlcnNlSFRNTCwgaHRtbFJlcGxhY2VyKTtcbi8qKlxuICogRW5jb2RlcyBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGFzIHdlbGwgYXMgY2hhcmFjdGVycyBub3QgdmFsaWQgaW4gSFRNTFxuICogZG9jdW1lbnRzIHVzaW5nIEhUTUwgZW50aXRpZXMuXG4gKlxuICogSWYgYSBjaGFyYWN0ZXIgaGFzIG5vIGVxdWl2YWxlbnQgZW50aXR5LCBhXG4gKiBudW1lcmljIGhleGFkZWNpbWFsIHJlZmVyZW5jZSAoZWcuIGAmI3hmYztgKSB3aWxsIGJlIHVzZWQuXG4gKi9cbmVuY29kZS5lbmNvZGVOb25Bc2NpaUhUTUwgPSBnZXRBU0NJSUVuY29kZXIoaW52ZXJzZUhUTUwpO1xuZnVuY3Rpb24gZ2V0SW52ZXJzZU9iaihvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGludmVyc2UsIG5hbWUpIHtcbiAgICAgICAgaW52ZXJzZVtvYmpbbmFtZV1dID0gXCImXCIgKyBuYW1lICsgXCI7XCI7XG4gICAgICAgIHJldHVybiBpbnZlcnNlO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlKSB7XG4gICAgdmFyIHNpbmdsZSA9IFtdO1xuICAgIHZhciBtdWx0aXBsZSA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhpbnZlcnNlKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGsgPSBfYVtfaV07XG4gICAgICAgIGlmIChrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gQWRkIHZhbHVlIHRvIHNpbmdsZSBhcnJheVxuICAgICAgICAgICAgc2luZ2xlLnB1c2goXCJcXFxcXCIgKyBrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCB2YWx1ZSB0byBtdWx0aXBsZSBhcnJheVxuICAgICAgICAgICAgbXVsdGlwbGUucHVzaChrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGQgcmFuZ2VzIHRvIHNpbmdsZSBjaGFyYWN0ZXJzLlxuICAgIHNpbmdsZS5zb3J0KCk7XG4gICAgZm9yICh2YXIgc3RhcnQgPSAwOyBzdGFydCA8IHNpbmdsZS5sZW5ndGggLSAxOyBzdGFydCsrKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGVuZCBvZiBhIHJ1biBvZiBjaGFyYWN0ZXJzXG4gICAgICAgIHZhciBlbmQgPSBzdGFydDtcbiAgICAgICAgd2hpbGUgKGVuZCA8IHNpbmdsZS5sZW5ndGggLSAxICYmXG4gICAgICAgICAgICBzaW5nbGVbZW5kXS5jaGFyQ29kZUF0KDEpICsgMSA9PT0gc2luZ2xlW2VuZCArIDFdLmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgICAgICAgIGVuZCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3VudCA9IDEgKyBlbmQgLSBzdGFydDtcbiAgICAgICAgLy8gV2Ugd2FudCB0byByZXBsYWNlIGF0IGxlYXN0IHRocmVlIGNoYXJhY3RlcnNcbiAgICAgICAgaWYgKGNvdW50IDwgMylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBzaW5nbGUuc3BsaWNlKHN0YXJ0LCBjb3VudCwgc2luZ2xlW3N0YXJ0XSArIFwiLVwiICsgc2luZ2xlW2VuZF0pO1xuICAgIH1cbiAgICBtdWx0aXBsZS51bnNoaWZ0KFwiW1wiICsgc2luZ2xlLmpvaW4oXCJcIikgKyBcIl1cIik7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAobXVsdGlwbGUuam9pbihcInxcIiksIFwiZ1wiKTtcbn1cbi8vIC9bXlxcMC1cXHg3Rl0vZ3VcbnZhciByZU5vbkFTQ0lJID0gLyg/OltcXHg4MC1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKS9nO1xudmFyIGdldENvZGVQb2ludCA9IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cblN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQgIT0gbnVsbFxuICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyLmNvZGVQb2ludEF0KDApOyB9XG4gICAgOiAvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIChjLmNoYXJDb2RlQXQoMCkgLSAweGQ4MDApICogMHg0MDAgK1xuICAgICAgICAgICAgICAgIGMuY2hhckNvZGVBdCgxKSAtXG4gICAgICAgICAgICAgICAgMHhkYzAwICtcbiAgICAgICAgICAgICAgICAweDEwMDAwO1xuICAgICAgICB9O1xuZnVuY3Rpb24gc2luZ2xlQ2hhclJlcGxhY2VyKGMpIHtcbiAgICByZXR1cm4gXCImI3hcIiArIChjLmxlbmd0aCA+IDEgPyBnZXRDb2RlUG9pbnQoYykgOiBjLmNoYXJDb2RlQXQoMCkpXG4gICAgICAgIC50b1N0cmluZygxNilcbiAgICAgICAgLnRvVXBwZXJDYXNlKCkgKyBcIjtcIjtcbn1cbmZ1bmN0aW9uIGdldEludmVyc2UoaW52ZXJzZSwgcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgICAgIC5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gaW52ZXJzZVtuYW1lXTsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKHJlTm9uQVNDSUksIHNpbmdsZUNoYXJSZXBsYWNlcik7XG4gICAgfTtcbn1cbnZhciByZUVzY2FwZUNoYXJzID0gbmV3IFJlZ0V4cCh4bWxSZXBsYWNlci5zb3VyY2UgKyBcInxcIiArIHJlTm9uQVNDSUkuc291cmNlLCBcImdcIik7XG4vKipcbiAqIEVuY29kZXMgYWxsIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBhcyB3ZWxsIGFzIGNoYXJhY3RlcnMgbm90IHZhbGlkIGluIFhNTFxuICogZG9jdW1lbnRzIHVzaW5nIG51bWVyaWMgaGV4YWRlY2ltYWwgcmVmZXJlbmNlIChlZy4gYCYjeGZjO2ApLlxuICpcbiAqIEhhdmUgYSBsb29rIGF0IGBlc2NhcGVVVEY4YCBpZiB5b3Ugd2FudCBhIG1vcmUgY29uY2lzZSBvdXRwdXQgYXQgdGhlIGV4cGVuc2VcbiAqIG9mIHJlZHVjZWQgdHJhbnNwb3J0YWJpbGl0eS5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZXNjYXBlLlxuICovXG5mdW5jdGlvbiBlc21fZXNjYXBlKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5yZXBsYWNlKHJlRXNjYXBlQ2hhcnMsIHNpbmdsZUNoYXJSZXBsYWNlcik7XG59XG5lbmNvZGUuZXNjYXBlID0gZXNtX2VzY2FwZTtcbi8qKlxuICogRW5jb2RlcyBhbGwgY2hhcmFjdGVycyBub3QgdmFsaWQgaW4gWE1MIGRvY3VtZW50cyB1c2luZyBudW1lcmljIGhleGFkZWNpbWFsXG4gKiByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBvdXRwdXQgd2lsbCBiZSBjaGFyYWN0ZXItc2V0IGRlcGVuZGVudC5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZXNjYXBlLlxuICovXG5mdW5jdGlvbiBlc2NhcGVVVEY4KGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5yZXBsYWNlKHhtbFJlcGxhY2VyLCBzaW5nbGVDaGFyUmVwbGFjZXIpO1xufVxuZW5jb2RlLmVzY2FwZVVURjggPSBlc2NhcGVVVEY4O1xuZnVuY3Rpb24gZ2V0QVNDSUlFbmNvZGVyKG9iaikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YS5yZXBsYWNlKHJlRXNjYXBlQ2hhcnMsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBvYmpbY10gfHwgc2luZ2xlQ2hhclJlcGxhY2VyKGMpOyB9KTtcbiAgICB9O1xufVxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGV4cG9ydHMuZGVjb2RlWE1MU3RyaWN0ID0gZXhwb3J0cy5kZWNvZGVIVE1MNVN0cmljdCA9IGV4cG9ydHMuZGVjb2RlSFRNTDRTdHJpY3QgPSBleHBvcnRzLmRlY29kZUhUTUw1ID0gZXhwb3J0cy5kZWNvZGVIVE1MNCA9IGV4cG9ydHMuZGVjb2RlSFRNTFN0cmljdCA9IGV4cG9ydHMuZGVjb2RlSFRNTCA9IGV4cG9ydHMuZGVjb2RlWE1MID0gZXhwb3J0cy5lbmNvZGVIVE1MNSA9IGV4cG9ydHMuZW5jb2RlSFRNTDQgPSBleHBvcnRzLmVzY2FwZVVURjggPSBleHBvcnRzLmVzY2FwZSA9IGV4cG9ydHMuZW5jb2RlTm9uQXNjaWlIVE1MID0gZXhwb3J0cy5lbmNvZGVIVE1MID0gZXhwb3J0cy5lbmNvZGVYTUwgPSBleHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlU3RyaWN0ID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG4gICAgdmFyIGRlY29kZV8xID0gZGVjb2RlO1xuICAgIHZhciBlbmNvZGVfMSA9IGVuY29kZTtcbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgc3RyaW5nIHdpdGggZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSBsZXZlbCBPcHRpb25hbCBsZXZlbCB0byBkZWNvZGUgYXQuIDAgPSBYTUwsIDEgPSBIVE1MLiBEZWZhdWx0IGlzIDAuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGBkZWNvZGVYTUxgIG9yIGBkZWNvZGVIVE1MYCBkaXJlY3RseS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWNvZGUkMShkYXRhLCBsZXZlbCkge1xuICAgICAgICByZXR1cm4gKCFsZXZlbCB8fCBsZXZlbCA8PSAwID8gZGVjb2RlXzEuZGVjb2RlWE1MIDogZGVjb2RlXzEuZGVjb2RlSFRNTCkoZGF0YSk7XG4gICAgfVxuICAgIGV4cG9ydHMuZGVjb2RlID0gZGVjb2RlJDE7XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLiBEb2VzIG5vdCBhbGxvdyBtaXNzaW5nIHRyYWlsaW5nIHNlbWljb2xvbnMgZm9yIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0gbGV2ZWwgT3B0aW9uYWwgbGV2ZWwgdG8gZGVjb2RlIGF0LiAwID0gWE1MLCAxID0gSFRNTC4gRGVmYXVsdCBpcyAwLlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZGVjb2RlSFRNTFN0cmljdGAgb3IgYGRlY29kZVhNTGAgZGlyZWN0bHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjb2RlU3RyaWN0KGRhdGEsIGxldmVsKSB7XG4gICAgICAgIHJldHVybiAoIWxldmVsIHx8IGxldmVsIDw9IDAgPyBkZWNvZGVfMS5kZWNvZGVYTUwgOiBkZWNvZGVfMS5kZWNvZGVIVE1MU3RyaWN0KShkYXRhKTtcbiAgICB9XG4gICAgZXhwb3J0cy5kZWNvZGVTdHJpY3QgPSBkZWNvZGVTdHJpY3Q7XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gbGV2ZWwgT3B0aW9uYWwgbGV2ZWwgdG8gZW5jb2RlIGF0LiAwID0gWE1MLCAxID0gSFRNTC4gRGVmYXVsdCBpcyAwLlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZW5jb2RlSFRNTGAsIGBlbmNvZGVYTUxgIG9yIGBlbmNvZGVOb25Bc2NpaUhUTUxgIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuY29kZSQxKGRhdGEsIGxldmVsKSB7XG4gICAgICAgIHJldHVybiAoIWxldmVsIHx8IGxldmVsIDw9IDAgPyBlbmNvZGVfMS5lbmNvZGVYTUwgOiBlbmNvZGVfMS5lbmNvZGVIVE1MKShkYXRhKTtcbiAgICB9XG4gICAgZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGUkMTtcbiAgICB2YXIgZW5jb2RlXzIgPSBlbmNvZGU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlWE1MXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lbmNvZGVYTUw7IH0gfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlSFRNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlSFRNTDsgfSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVOb25Bc2NpaUhUTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVuY29kZU5vbkFzY2lpSFRNTDsgfSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlc2NhcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVzY2FwZTsgfSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlc2NhcGVVVEY4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lc2NhcGVVVEY4OyB9IH0pO1xuICAgIC8vIExlZ2FjeSBhbGlhc2VzIChkZXByZWNhdGVkKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUhUTUw0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lbmNvZGVIVE1MOyB9IH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUhUTUw1XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lbmNvZGVIVE1MOyB9IH0pO1xuICAgIHZhciBkZWNvZGVfMiA9IGRlY29kZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVYTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZVhNTDsgfSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MOyB9IH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUxTdHJpY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUxTdHJpY3Q7IH0gfSk7XG4gICAgLy8gTGVnYWN5IGFsaWFzZXMgKGRlcHJlY2F0ZWQpXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTDRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUw7IH0gfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTDVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUw7IH0gfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTDRTdHJpY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUxTdHJpY3Q7IH0gfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTDVTdHJpY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUxTdHJpY3Q7IH0gfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlWE1MU3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVYTUw7IH0gfSk7XG59KGxpYikpO1xudmFyIEVOVElUWSA9ICcmKD86I3hbYS1mMC05XXsxLDZ9fCNbMC05XXsxLDd9fFthLXpdW2EtejAtOV17MSwzMX0pOyc7XG52YXIgQ19CQUNLU0xBU0gkMSA9IDkyO1xudmFyIHJlQmFja3NsYXNoT3JBbXAgPSAvW1xcXFwmXS87XG52YXIgRVNDQVBBQkxFID0gJ1shXCIjJCUmXFwnKCkqKywuLzo7PD0+P0BbXFxcXFxcXFxcXFxcXV5fYHt8fX4tXSc7XG52YXIgcmVFbnRpdHlPckVzY2FwZWRDaGFyID0gbmV3IFJlZ0V4cChcIlxcXFxcXFxcXCIgKyBFU0NBUEFCTEUgKyBcInxcIiArIEVOVElUWSwgJ2dpJyk7XG52YXIgWE1MU1BFQ0lBTCA9ICdbJjw+XCJdJztcbnZhciByZVhtbFNwZWNpYWwgPSBuZXcgUmVnRXhwKFhNTFNQRUNJQUwsICdnJyk7XG52YXIgdW5lc2NhcGVDaGFyID0gZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocy5jaGFyQ29kZUF0KDApID09PSBDX0JBQ0tTTEFTSCQxKSB7XG4gICAgICAgIHJldHVybiBzLmNoYXJBdCgxKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpYi5kZWNvZGVIVE1MKHMpO1xufTtcbi8vIFJlcGxhY2UgZW50aXRpZXMgYW5kIGJhY2tzbGFzaCBlc2NhcGVzIHdpdGggbGl0ZXJhbCBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdW5lc2NhcGVTdHJpbmcocykge1xuICAgIGlmIChyZUJhY2tzbGFzaE9yQW1wLnRlc3QocykpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZShyZUVudGl0eU9yRXNjYXBlZENoYXIsIHVuZXNjYXBlQ2hhcik7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVVJJKHVyaSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVfMSh1cmkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB1cmk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZVVuc2FmZUNoYXIocykge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgIHJldHVybiAnJmFtcDsnO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgIHJldHVybiAnJmx0Oyc7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICcmZ3Q7JztcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgcmV0dXJuICcmcXVvdDsnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxufVxuZnVuY3Rpb24gZXNjYXBlWG1sKHMpIHtcbiAgICBpZiAocmVYbWxTcGVjaWFsLnRlc3QocykpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZShyZVhtbFNwZWNpYWwsIHJlcGxhY2VVbnNhZmVDaGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiByZXBlYXQoc3RyLCBjb3VudCkge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgYXJyLnB1c2goc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyci5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHkoc3RyKSB7XG4gICAgaWYgKCFzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhL1teIFxcdF0rLy50ZXN0KHN0cik7XG59XG52YXIgTm9kZVdhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlV2Fsa2VyKHJvb3QpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gcm9vdDtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5lbnRlcmluZyA9IHRydWU7XG4gICAgfVxuICAgIE5vZGVXYWxrZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXIgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IHRoaXMuZW50ZXJpbmc7XG4gICAgICAgIGlmIChjdXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250YWluZXIgPSBpc0NvbnRhaW5lcihjdXIpO1xuICAgICAgICBpZiAoZW50ZXJpbmcgJiYgY29udGFpbmVyKSB7XG4gICAgICAgICAgICBpZiAoY3VyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN0YXkgb24gbm9kZSBidXQgZXhpdFxuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIgPT09IHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGN1ci5uZXh0O1xuICAgICAgICAgICAgdGhpcy5lbnRlcmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZW50ZXJpbmc6IGVudGVyaW5nLCBub2RlOiBjdXIgfTtcbiAgICB9O1xuICAgIE5vZGVXYWxrZXIucHJvdG90eXBlLnJlc3VtZUF0ID0gZnVuY3Rpb24gKG5vZGUsIGVudGVyaW5nKSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG5vZGU7XG4gICAgICAgIHRoaXMuZW50ZXJpbmcgPSBlbnRlcmluZyA9PT0gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBOb2RlV2Fsa2VyO1xufSgpKTtcbmZ1bmN0aW9uIGlzQ29udGFpbmVyKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgIGNhc2UgJ2Jsb2NrUXVvdGUnOlxuICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgY2FzZSAnaXRlbSc6XG4gICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6XG4gICAgICAgIGNhc2UgJ2hlYWRpbmcnOlxuICAgICAgICBjYXNlICdlbXBoJzpcbiAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgY2FzZSAnc3RyaWtlJzpcbiAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICBjYXNlICd0YWJsZUhlYWQnOlxuICAgICAgICBjYXNlICd0YWJsZUJvZHknOlxuICAgICAgICBjYXNlICd0YWJsZVJvdyc6XG4gICAgICAgIGNhc2UgJ3RhYmxlQ2VsbCc6XG4gICAgICAgIGNhc2UgJ3RhYmxlRGVsaW1Sb3cnOlxuICAgICAgICBjYXNlICdjdXN0b21JbmxpbmUnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxudmFyIGxhc3ROb2RlSWQgPSAxO1xudmFyIG5vZGVNYXAgPSB7fTtcbmZ1bmN0aW9uIGdldE5vZGVCeUlkKGlkKSB7XG4gICAgcmV0dXJuIG5vZGVNYXBbaWRdO1xufVxuZnVuY3Rpb24gcmVtb3ZlTm9kZUJ5SWQoaWQpIHtcbiAgICBkZWxldGUgbm9kZU1hcFtpZF07XG59XG5mdW5jdGlvbiByZW1vdmVBbGxOb2RlKCkge1xuICAgIG5vZGVNYXAgPSB7fTtcbn1cbnZhciBlc21fTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlKG5vZGVUeXBlLCBzb3VyY2Vwb3MpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICAvLyBvbmx5IGZvciBjb250YWluZXIgbm9kZVxuICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDaGlsZCA9IG51bGw7XG4gICAgICAgIC8vIG9ubHkgZm9yIGxlYWYgbm9kZVxuICAgICAgICB0aGlzLmxpdGVyYWwgPSBudWxsO1xuICAgICAgICBpZiAobm9kZVR5cGUgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBsYXN0Tm9kZUlkKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50eXBlID0gbm9kZVR5cGU7XG4gICAgICAgIHRoaXMuc291cmNlcG9zID0gc291cmNlcG9zO1xuICAgICAgICBub2RlTWFwW3RoaXMuaWRdID0gdGhpcztcbiAgICB9XG4gICAgTm9kZS5wcm90b3R5cGUuaXNDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpc0NvbnRhaW5lcih0aGlzKTtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJldikge1xuICAgICAgICAgICAgdGhpcy5wcmV2Lm5leHQgPSB0aGlzLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmZpcnN0Q2hpbGQgPSB0aGlzLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LnByZXYgPSB0aGlzLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Lmxhc3RDaGlsZCA9IHRoaXMucHJldjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5yZXBsYWNlV2l0aCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICB0aGlzLnVubGluaygpO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoc2libGluZykge1xuICAgICAgICBzaWJsaW5nLnVubGluaygpO1xuICAgICAgICBzaWJsaW5nLm5leHQgPSB0aGlzLm5leHQ7XG4gICAgICAgIGlmIChzaWJsaW5nLm5leHQpIHtcbiAgICAgICAgICAgIHNpYmxpbmcubmV4dC5wcmV2ID0gc2libGluZztcbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nLnByZXYgPSB0aGlzO1xuICAgICAgICB0aGlzLm5leHQgPSBzaWJsaW5nO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXNpYmxpbmcubmV4dCkge1xuICAgICAgICAgICAgICAgIHNpYmxpbmcucGFyZW50Lmxhc3RDaGlsZCA9IHNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChzaWJsaW5nKSB7XG4gICAgICAgIHNpYmxpbmcudW5saW5rKCk7XG4gICAgICAgIHNpYmxpbmcucHJldiA9IHRoaXMucHJldjtcbiAgICAgICAgaWYgKHNpYmxpbmcucHJldikge1xuICAgICAgICAgICAgc2libGluZy5wcmV2Lm5leHQgPSBzaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIHNpYmxpbmcubmV4dCA9IHRoaXM7XG4gICAgICAgIHRoaXMucHJldiA9IHNpYmxpbmc7XG4gICAgICAgIHNpYmxpbmcucGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGlmICghc2libGluZy5wcmV2KSB7XG4gICAgICAgICAgICBzaWJsaW5nLnBhcmVudC5maXJzdENoaWxkID0gc2libGluZztcbiAgICAgICAgfVxuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQudW5saW5rKCk7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q2hpbGQubmV4dCA9IGNoaWxkO1xuICAgICAgICAgICAgY2hpbGQucHJldiA9IHRoaXMubGFzdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUucHJlcGVuZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnVubGluaygpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0Q2hpbGQucHJldiA9IGNoaWxkO1xuICAgICAgICAgICAgY2hpbGQubmV4dCA9IHRoaXMuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maXJzdENoaWxkID0gY2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmxhc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS53YWxrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVdhbGtlcih0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBOb2RlO1xufSgpKTtcbnZhciBCbG9ja05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgZXNtX2V4dGVuZHMoQmxvY2tOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrTm9kZShub2RlVHlwZSwgc291cmNlcG9zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5vZGVUeXBlLCBzb3VyY2Vwb3MpIHx8IHRoaXM7XG4gICAgICAgIC8vIHRlbXBvcmFsIGRhdGEgKGZvciBwYXJzaW5nKVxuICAgICAgICBfdGhpcy5vcGVuID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMubGluZU9mZnNldHMgPSBudWxsO1xuICAgICAgICBfdGhpcy5zdHJpbmdDb250ZW50ID0gbnVsbDtcbiAgICAgICAgX3RoaXMubGFzdExpbmVCbGFuayA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5sYXN0TGluZUNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMudHlwZSA9IG5vZGVUeXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCbG9ja05vZGU7XG59KGVzbV9Ob2RlKSk7XG52YXIgTGlzdE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgZXNtX2V4dGVuZHMoTGlzdE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGlzdE5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5saXN0RGF0YSA9IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExpc3ROb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBIZWFkaW5nTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBlc21fZXh0ZW5kcyhIZWFkaW5nTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWFkaW5nTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxldmVsID0gMDtcbiAgICAgICAgX3RoaXMuaGVhZGluZ1R5cGUgPSAnYXR4JztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSGVhZGluZ05vZGU7XG59KEJsb2NrTm9kZSkpO1xudmFyIENvZGVCbG9ja05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgZXNtX2V4dGVuZHMoQ29kZUJsb2NrTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb2RlQmxvY2tOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaXNGZW5jZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuZmVuY2VDaGFyID0gbnVsbDtcbiAgICAgICAgX3RoaXMuZmVuY2VMZW5ndGggPSAwO1xuICAgICAgICBfdGhpcy5mZW5jZU9mZnNldCA9IC0xO1xuICAgICAgICBfdGhpcy5pbmZvID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaW5mb1BhZGRpbmcgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb2RlQmxvY2tOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBUYWJsZU5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgZXNtX2V4dGVuZHMoVGFibGVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbHVtbnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFibGVOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBUYWJsZUNlbGxOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKFRhYmxlQ2VsbE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVDZWxsTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXJ0SWR4ID0gMDtcbiAgICAgICAgX3RoaXMuZW5kSWR4ID0gMDtcbiAgICAgICAgX3RoaXMucGFkZGluZ0xlZnQgPSAwO1xuICAgICAgICBfdGhpcy5wYWRkaW5nUmlnaHQgPSAwO1xuICAgICAgICBfdGhpcy5pZ25vcmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlQ2VsbE5vZGU7XG59KEJsb2NrTm9kZSkpO1xudmFyIFJlZkRlZk5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgZXNtX2V4dGVuZHMoUmVmRGVmTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWZEZWZOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGl0bGUgPSAnJztcbiAgICAgICAgX3RoaXMuZGVzdCA9ICcnO1xuICAgICAgICBfdGhpcy5sYWJlbCA9ICcnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZWZEZWZOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBDdXN0b21CbG9ja05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgZXNtX2V4dGVuZHMoQ3VzdG9tQmxvY2tOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1c3RvbUJsb2NrTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN5bnRheExlbmd0aCA9IDA7XG4gICAgICAgIF90aGlzLm9mZnNldCA9IC0xO1xuICAgICAgICBfdGhpcy5pbmZvID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEN1c3RvbUJsb2NrTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgSHRtbEJsb2NrTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBlc21fZXh0ZW5kcyhIdG1sQmxvY2tOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEh0bWxCbG9ja05vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5odG1sQmxvY2tUeXBlID0gLTE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEh0bWxCbG9ja05vZGU7XG59KEJsb2NrTm9kZSkpO1xudmFyIExpbmtOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKExpbmtOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmtOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICBfdGhpcy50aXRsZSA9IG51bGw7XG4gICAgICAgIF90aGlzLmV4dGVuZGVkQXV0b2xpbmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGlua05vZGU7XG59KGVzbV9Ob2RlKSk7XG52YXIgQ29kZU5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgZXNtX2V4dGVuZHMoQ29kZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29kZU5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50aWNrQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb2RlTm9kZTtcbn0oZXNtX05vZGUpKTtcbnZhciBDdXN0b21JbmxpbmVOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKEN1c3RvbUlubGluZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3VzdG9tSW5saW5lTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmluZm8gPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ3VzdG9tSW5saW5lTm9kZTtcbn0oZXNtX05vZGUpKTtcbmZ1bmN0aW9uIGNyZWF0ZU5vZGUodHlwZSwgc291cmNlcG9zKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2hlYWRpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWFkaW5nTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgY2FzZSAnaXRlbSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3ROb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpbmtOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2NvZGVCbG9jayc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvZGVCbG9ja05vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAnaHRtbEJsb2NrJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSHRtbEJsb2NrTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRhYmxlTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICd0YWJsZUNlbGwnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYWJsZUNlbGxOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgY2FzZSAncGFyYWdyYXBoJzpcbiAgICAgICAgY2FzZSAnYmxvY2tRdW90ZSc6XG4gICAgICAgIGNhc2UgJ3RoZW1hdGljQnJlYWsnOlxuICAgICAgICBjYXNlICd0YWJsZVJvdyc6XG4gICAgICAgIGNhc2UgJ3RhYmxlQm9keSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlSGVhZCc6XG4gICAgICAgIGNhc2UgJ2Zyb250TWF0dGVyJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2NvZGUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2RlTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdyZWZEZWYnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWZEZWZOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2N1c3RvbUJsb2NrJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tQmxvY2tOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2N1c3RvbUlubGluZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUlubGluZU5vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXNtX05vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0NvZGVCbG9jayhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2NvZGVCbG9jayc7XG59XG5mdW5jdGlvbiBpc0h0bWxCbG9jayhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2h0bWxCbG9jayc7XG59XG5mdW5jdGlvbiBpc0hlYWRpbmcobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdoZWFkaW5nJztcbn1cbmZ1bmN0aW9uIGlzTGlzdChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2xpc3QnO1xufVxuZnVuY3Rpb24gaXNUYWJsZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ3RhYmxlJztcbn1cbmZ1bmN0aW9uIGlzUmVmRGVmKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAncmVmRGVmJztcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tQmxvY2sobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdjdXN0b21CbG9jayc7XG59XG5mdW5jdGlvbiBpc0N1c3RvbUlubGluZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2N1c3RvbUlubGluZSc7XG59XG5mdW5jdGlvbiBlc21fdGV4dChzLCBzb3VyY2Vwb3MpIHtcbiAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUoJ3RleHQnLCBzb3VyY2Vwb3MpO1xuICAgIG5vZGUubGl0ZXJhbCA9IHM7XG4gICAgcmV0dXJuIG5vZGU7XG59XG52YXIgVEFHTkFNRSA9ICdbQS1aYS16XVtBLVphLXowLTktXSonO1xudmFyIEFUVFJJQlVURU5BTUUgPSAnW2EtekEtWl86XVthLXpBLVowLTk6Ll8tXSonO1xudmFyIFVOUVVPVEVEVkFMVUUgPSAnW15cIlxcJz08PmBcXFxceDAwLVxcXFx4MjBdKyc7XG52YXIgU0lOR0xFUVVPVEVEVkFMVUUgPSBcIidbXiddKidcIjtcbnZhciBET1VCTEVRVU9URURWQUxVRSA9ICdcIlteXCJdKlwiJztcbnZhciBBVFRSSUJVVEVWQUxVRSA9IFwiKD86XCIgKyBVTlFVT1RFRFZBTFVFICsgXCJ8XCIgKyBTSU5HTEVRVU9URURWQUxVRSArIFwifFwiICsgRE9VQkxFUVVPVEVEVkFMVUUgKyBcIilcIjtcbnZhciBBVFRSSUJVVEVWQUxVRVNQRUMgPSBcIlwiICsgJyg/OlxcXFxzKj1cXFxccyonICsgQVRUUklCVVRFVkFMVUUgKyBcIilcIjtcbnZhciBBVFRSSUJVVEUgPSBcIlwiICsgJyg/OlxcXFxzKycgKyBBVFRSSUJVVEVOQU1FICsgQVRUUklCVVRFVkFMVUVTUEVDICsgXCI/KVwiO1xudmFyIE9QRU5UQUcgPSBcIjxcIiArIFRBR05BTUUgKyBBVFRSSUJVVEUgKyBcIipcXFxccyovPz5cIjtcbnZhciBDTE9TRVRBRyA9IFwiPC9cIiArIFRBR05BTUUgKyBcIlxcXFxzKls+XVwiO1xudmFyIEhUTUxDT01NRU5UID0gJzwhLS0tLT58PCEtLSg/Oi0/W14+LV0pKD86LT9bXi1dKSotLT4nO1xudmFyIFBST0NFU1NJTkdJTlNUUlVDVElPTiA9ICdbPF1bP10uKj9bP11bPl0nO1xudmFyIERFQ0xBUkFUSU9OID0gJzwhW0EtWl0rXFxcXHMrW14+XSo+JztcbnZhciBDREFUQSA9ICc8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nO1xudmFyIEhUTUxUQUcgPSBcIig/OlwiICsgT1BFTlRBRyArIFwifFwiICsgQ0xPU0VUQUcgKyBcInxcIiArIEhUTUxDT01NRU5UICsgXCJ8XCIgKyBQUk9DRVNTSU5HSU5TVFJVQ1RJT04gKyBcInxcIiArIERFQ0xBUkFUSU9OICsgXCJ8XCIgKyBDREFUQSArIFwiKVwiO1xudmFyIHJlSHRtbFRhZyA9IG5ldyBSZWdFeHAoXCJeXCIgKyBIVE1MVEFHLCAnaScpO1xuLy8gZGVyaXZlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5mcm9tQ29kZVBvaW50XG4vKiEgaHR0cDovL210aHMuYmUvZnJvbWNvZGVwb2ludCB2MC4yLjEgYnkgQG1hdGhpYXMgKi9cbnZhciBmcm9tQ29kZVBvaW50O1xuaWYgKFN0cmluZy5mcm9tQ29kZVBvaW50KSB7XG4gICAgZnJvbUNvZGVQb2ludCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZmZmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIHZhciBzdHJpbmdGcm9tQ2hhckNvZGVfMSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgdmFyIGZsb29yXzEgPSBNYXRoLmZsb29yO1xuICAgIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIE1BWF9TSVpFID0gMHg0MDAwO1xuICAgICAgICB2YXIgY29kZVVuaXRzID0gW107XG4gICAgICAgIHZhciBoaWdoU3Vycm9nYXRlO1xuICAgICAgICB2YXIgbG93U3Vycm9nYXRlO1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBOdW1iZXIoYXJnc1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShjb2RlUG9pbnQpIHx8IC8vIGBOYU5gLCBgK0luZmluaXR5YCwgb3IgYC1JbmZpbml0eWBcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPCAwIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgICAgIGNvZGVQb2ludCA+IDB4MTBmZmZmIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgICAgIGZsb29yXzEoY29kZVBvaW50KSAhPT0gY29kZVBvaW50IC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweGZmZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgICAgICAvLyBCTVAgY29kZSBwb2ludFxuICAgICAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGNvZGVQb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBc3RyYWwgY29kZSBwb2ludDsgc3BsaXQgaW4gc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICAgICAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgaGlnaFN1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgPj4gMTApICsgMHhkODAwO1xuICAgICAgICAgICAgICAgIGxvd1N1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgJSAweDQwMCkgKyAweGRjMDA7XG4gICAgICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goaGlnaFN1cnJvZ2F0ZSwgbG93U3Vycm9nYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCArIDEgPT09IGxlbmd0aCB8fCBjb2RlVW5pdHMubGVuZ3RoID4gTUFYX1NJWkUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlXzEuYXBwbHkodm9pZCAwLCBjb2RlVW5pdHMpO1xuICAgICAgICAgICAgICAgIGNvZGVVbml0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbnZhciBmcm9tQ29kZVBvaW50JDEgPSBmcm9tQ29kZVBvaW50O1xudmFyIERPTUFJTiA9ICcoPzpbdy1dKy4pKltBLVphLXowLTktXSsuW0EtWmEtejAtOS1dKyc7XG52YXIgUEFUSCA9ICdbXjxcXFxcc10qW148PyEuLDoqXz9+XFxcXHNdJztcbnZhciBFTUFJTCA9ICdbXFxcXHcuKy1dK0AoPzpbXFxcXHctXStcXFxcLikrW1xcXFx3LV0rJztcbmZ1bmN0aW9uIHRyaW1Vbm1hdGNoZWRUcmFpbGluZ1BhcmVucyhzb3VyY2UpIHtcbiAgICB2YXIgdHJhaWxpbmdQYXJlbiA9IC9cXCkrJC8uZXhlYyhzb3VyY2UpO1xuICAgIGlmICh0cmFpbGluZ1BhcmVuKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgc291cmNlXzEgPSBzb3VyY2U7IF9pIDwgc291cmNlXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSBzb3VyY2VfMVtfaV07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcoJykge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICAgICB2YXIgdHJpbUNvdW50ID0gTWF0aC5taW4oLWNvdW50LCB0cmFpbGluZ1BhcmVuWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLnN1YnN0cmluZygwLCBzb3VyY2UubGVuZ3RoIC0gdHJpbUNvdW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xufVxuZnVuY3Rpb24gdHJpbVRyYWlsaW5nRW50aXR5KHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2UucmVwbGFjZSgvJltBLVphLXowLTldKzskLywgJycpO1xufVxuZnVuY3Rpb24gcGFyc2VFbWFpbExpbmsoc291cmNlKSB7XG4gICAgdmFyIHJlRW1haWxMaW5rID0gbmV3IFJlZ0V4cChFTUFJTCwgJ2cnKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIG07XG4gICAgd2hpbGUgKChtID0gcmVFbWFpbExpbmsuZXhlYyhzb3VyY2UpKSkge1xuICAgICAgICB2YXIgdGV4dF8xID0gbVswXTtcbiAgICAgICAgaWYgKCEvW18tXSskLy50ZXN0KHRleHRfMSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0XzEsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFttLmluZGV4LCBtLmluZGV4ICsgdGV4dF8xLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIHVybDogXCJtYWlsdG86XCIgKyB0ZXh0XzEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VVcmxMaW5rKHNvdXJjZSkge1xuICAgIHZhciByZVd3d0F1dG9saW5rID0gbmV3IFJlZ0V4cChcIih3d3d8aHR0cHM/Oi8vKS5cIiArIERPTUFJTiArIFBBVEgsICdnJyk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBtO1xuICAgIHdoaWxlICgobSA9IHJlV3d3QXV0b2xpbmsuZXhlYyhzb3VyY2UpKSkge1xuICAgICAgICB2YXIgdGV4dF8yID0gdHJpbVRyYWlsaW5nRW50aXR5KHRyaW1Vbm1hdGNoZWRUcmFpbGluZ1BhcmVucyhtWzBdKSk7XG4gICAgICAgIHZhciBzY2hlbWUgPSBtWzFdID09PSAnd3d3JyA/ICdodHRwOi8vJyA6ICcnO1xuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XzIsXG4gICAgICAgICAgICByYW5nZTogW20uaW5kZXgsIG0uaW5kZXggKyB0ZXh0XzIubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICB1cmw6IFwiXCIgKyBzY2hlbWUgKyB0ZXh0XzIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYmFzZUF1dG9saW5rUGFyc2VyKHNvdXJjZSkge1xuICAgIHJldHVybiBlc21fc3ByZWFkQXJyYXkoZXNtX3NwcmVhZEFycmF5KFtdLCBwYXJzZVVybExpbmsoc291cmNlKSksIHBhcnNlRW1haWxMaW5rKHNvdXJjZSkpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEucmFuZ2VbMF0gLSBiLnJhbmdlWzBdOyB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRFeHRBdXRvTGlua3Mod2Fsa2VyLCBhdXRvbGlua1BhcnNlcikge1xuICAgIGlmICh0eXBlb2YgYXV0b2xpbmtQYXJzZXIgPT09ICdib29sZWFuJykge1xuICAgICAgICBhdXRvbGlua1BhcnNlciA9IGJhc2VBdXRvbGlua1BhcnNlcjtcbiAgICB9XG4gICAgdmFyIGV2ZW50O1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZywgbm9kZSA9IGV2ZW50Lm5vZGU7XG4gICAgICAgIGlmIChlbnRlcmluZyAmJiBub2RlLnR5cGUgPT09ICd0ZXh0JyAmJiBub2RlLnBhcmVudC50eXBlICE9PSAnbGluaycpIHtcbiAgICAgICAgICAgIHZhciBsaXRlcmFsID0gbm9kZS5saXRlcmFsO1xuICAgICAgICAgICAgdmFyIGxpbmtJbmZvcyA9IGF1dG9saW5rUGFyc2VyKGxpdGVyYWwpO1xuICAgICAgICAgICAgaWYgKCFsaW5rSW5mb3MgfHwgIWxpbmtJbmZvcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxhc3RJZHggPSAwO1xuICAgICAgICAgICAgdmFyIF9hID0gbm9kZS5zb3VyY2Vwb3NbMF0sIGxpbmVOdW1fMSA9IF9hWzBdLCBjaFBvc18xID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgc291cmNlcG9zID0gZnVuY3Rpb24gKHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBbbGluZU51bV8xLCBjaFBvc18xICsgc3RhcnRJZHhdLFxuICAgICAgICAgICAgICAgICAgICBbbGluZU51bV8xLCBjaFBvc18xICsgZW5kSWR4XSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBsaW5rSW5mb3NfMSA9IGxpbmtJbmZvczsgX2kgPCBsaW5rSW5mb3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBsaW5rSW5mb3NfMVtfaV0sIHJhbmdlID0gX2IucmFuZ2UsIHVybCA9IF9iLnVybCwgbGlua1RleHQgPSBfYi50ZXh0O1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZVswXSA+IGxhc3RJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZXMucHVzaChlc21fdGV4dChsaXRlcmFsLnN1YnN0cmluZyhsYXN0SWR4LCByYW5nZVswXSksIHNvdXJjZXBvcyhsYXN0SWR4LCByYW5nZVswXSAtIDEpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsaW5rTm9kZSA9IGNyZWF0ZU5vZGUoJ2xpbmsnLCBzb3VyY2Vwb3MuYXBwbHkodm9pZCAwLCByYW5nZSkpO1xuICAgICAgICAgICAgICAgIGxpbmtOb2RlLmFwcGVuZENoaWxkKGVzbV90ZXh0KGxpbmtUZXh0LCBzb3VyY2Vwb3MuYXBwbHkodm9pZCAwLCByYW5nZSkpKTtcbiAgICAgICAgICAgICAgICBsaW5rTm9kZS5kZXN0aW5hdGlvbiA9IHVybDtcbiAgICAgICAgICAgICAgICBsaW5rTm9kZS5leHRlbmRlZEF1dG9saW5rID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBuZXdOb2Rlcy5wdXNoKGxpbmtOb2RlKTtcbiAgICAgICAgICAgICAgICBsYXN0SWR4ID0gcmFuZ2VbMV0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RJZHggPCBsaXRlcmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5ld05vZGVzLnB1c2goZXNtX3RleHQobGl0ZXJhbC5zdWJzdHJpbmcobGFzdElkeCksIHNvdXJjZXBvcyhsYXN0SWR4LCBsaXRlcmFsLmxlbmd0aCAtIDEpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IDAsIG5ld05vZGVzXzEgPSBuZXdOb2RlczsgX2MgPCBuZXdOb2Rlc18xLmxlbmd0aDsgX2MrKykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gbmV3Tm9kZXNfMVtfY107XG4gICAgICAgICAgICAgICAgbm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLnVubGluaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgX2xvb3BfMSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxhc3QoYXJyKSB7XG4gICAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG4vLyBub3JtYWxpemUgYSByZWZlcmVuY2UgaW4gcmVmZXJlbmNlIGxpbmsgKHJlbW92ZSBbXXMsIHRyaW0sXG4vLyBjb2xsYXBzZSBpbnRlcm5hbCBzcGFjZSwgdW5pY29kZSBjYXNlIGZvbGQuXG4vLyBTZWUgY29tbW9ubWFyay9jb21tb25tYXJrLmpzIzE2OC5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIpIHtcbiAgICByZXR1cm4gc3RyXG4gICAgICAgIC5zbGljZSgxLCBzdHIubGVuZ3RoIC0gMSlcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAucmVwbGFjZSgvWyBcXHRcXHJcXG5dKy8sICcgJylcbiAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgLnRvVXBwZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBpdGVyYXRlT2JqZWN0KG9iaiwgaXRlcmF0ZWUpIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpdGVyYXRlZShrZXksIG9ialtrZXldKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG9taXQob2JqKSB7XG4gICAgdmFyIHByb3BOYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHByb3BOYW1lc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdE1hcCA9IGVzbV9hc3NpZ24oe30sIG9iaik7XG4gICAgcHJvcE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgcmVzdWx0TWFwW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdE1hcDtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlPYmoob2JqKSB7XG4gICAgcmV0dXJuICFPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNsZWFyT2JqKG9iaikge1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICB9KTtcbn1cbnZhciBDX05FV0xJTkUgPSAxMDtcbnZhciBDX0FTVEVSSVNLID0gNDI7XG52YXIgQ19VTkRFUlNDT1JFID0gOTU7XG52YXIgQ19CQUNLVElDSyA9IDk2O1xudmFyIENfT1BFTl9CUkFDS0VUJDEgPSA5MTtcbnZhciBDX0NMT1NFX0JSQUNLRVQgPSA5MztcbnZhciBDX1RJTERFID0gMTI2O1xudmFyIENfTEVTU1RIQU4kMSA9IDYwO1xudmFyIENfQkFORyA9IDMzO1xudmFyIENfQkFDS1NMQVNIID0gOTI7XG52YXIgQ19BTVBFUlNBTkQgPSAzODtcbnZhciBDX09QRU5fUEFSRU4gPSA0MDtcbnZhciBDX0NMT1NFX1BBUkVOID0gNDE7XG52YXIgQ19DT0xPTiA9IDU4O1xudmFyIENfU0lOR0xFUVVPVEUgPSAzOTtcbnZhciBDX0RPVUJMRVFVT1RFID0gMzQ7XG52YXIgQ19ET0xMQVIgPSAzNjtcbi8vIFNvbWUgcmVnZXhwcyB1c2VkIGluIGlubGluZSBwYXJzZXI6XG52YXIgRVNDQVBFRF9DSEFSID0gXCJcXFxcXFxcXFwiICsgRVNDQVBBQkxFO1xudmFyIHJlUHVuY3R1YXRpb24gPSBuZXcgUmVnRXhwKC9bIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XFx4QTFcXHhBN1xceEFCXFx4QjZcXHhCN1xceEJCXFx4QkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MEFGMFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMDgtXFx1MjMwQlxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkU0MlxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOEZDXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdfFxcdUQ4MDBbXFx1REQwMC1cXHVERDAyXFx1REY5RlxcdURGRDBdfFxcdUQ4MDFcXHVERDZGfFxcdUQ4MDJbXFx1REM1N1xcdUREMUZcXHVERDNGXFx1REU1MC1cXHVERTU4XFx1REU3RlxcdURFRjAtXFx1REVGNlxcdURGMzktXFx1REYzRlxcdURGOTktXFx1REY5Q118XFx1RDgwNFtcXHVEQzQ3LVxcdURDNERcXHVEQ0JCXFx1RENCQ1xcdURDQkUtXFx1RENDMVxcdURENDAtXFx1REQ0M1xcdURENzRcXHVERDc1XFx1RERDNS1cXHVEREM5XFx1RERDRFxcdUREREJcXHVERERELVxcdUREREZcXHVERTM4LVxcdURFM0RcXHVERUE5XXxcXHVEODA1W1xcdURDQzZcXHVEREMxLVxcdURERDdcXHVERTQxLVxcdURFNDNcXHVERjNDLVxcdURGM0VdfFxcdUQ4MDlbXFx1REM3MC1cXHVEQzc0XXxcXHVEODFBW1xcdURFNkVcXHVERTZGXFx1REVGNVxcdURGMzctXFx1REYzQlxcdURGNDRdfFxcdUQ4MkZcXHVEQzlGfFxcdUQ4MzZbXFx1REU4Ny1cXHVERThCXS8pO1xudmFyIHJlTGlua1RpdGxlID0gbmV3IFJlZ0V4cChcIl4oPzpcXFwiKFwiICsgRVNDQVBFRF9DSEFSICsgXCJ8W15cXFwiXFxcXHgwMF0pKlxcXCJcIiArXG4gICAgXCJ8XCIgK1xuICAgIChcIicoXCIgKyBFU0NBUEVEX0NIQVIgKyBcInxbXidcXFxceDAwXSkqJ1wiKSArXG4gICAgXCJ8XCIgK1xuICAgIChcIlxcXFwoKFwiICsgRVNDQVBFRF9DSEFSICsgXCJ8W14oKVxcXFx4MDBdKSpcXFxcKSlcIikpO1xudmFyIHJlTGlua0Rlc3RpbmF0aW9uQnJhY2VzID0gL14oPzo8KD86W148PlxcblxcXFxcXHgwMF18XFxcXC4pKj4pLztcbnZhciByZUVzY2FwYWJsZSA9IG5ldyBSZWdFeHAoXCJeXCIgKyBFU0NBUEFCTEUpO1xudmFyIHJlRW50aXR5SGVyZSA9IG5ldyBSZWdFeHAoXCJeXCIgKyBFTlRJVFksICdpJyk7XG52YXIgcmVUaWNrcyA9IC9gKy87XG52YXIgcmVUaWNrc0hlcmUgPSAvXmArLztcbnZhciByZUVsbGlwc2VzID0gL1xcLlxcLlxcLi9nO1xudmFyIHJlRGFzaCA9IC8tLSsvZztcbnZhciByZUVtYWlsQXV0b2xpbmsgPSAvXjwoW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKik+LztcbnZhciByZUF1dG9saW5rID0gL148W0EtWmEtel1bQS1aYS16MC05ListXXsxLDMxfTpbXjw+XFx4MDAtXFx4MjBdKj4vaTtcbnZhciByZVNwbmwgPSAvXiAqKD86XFxuICopPy87XG52YXIgcmVXaGl0ZXNwYWNlQ2hhciA9IC9eWyBcXHRcXG5cXHgwYlxceDBjXFx4MGRdLztcbnZhciByZVVuaWNvZGVXaGl0ZXNwYWNlQ2hhciA9IC9eXFxzLztcbnZhciByZUZpbmFsU3BhY2UgPSAvICokLztcbnZhciByZUluaXRpYWxTcGFjZSA9IC9eICovO1xudmFyIHJlU3BhY2VBdEVuZE9mTGluZSA9IC9eICooPzpcXG58JCkvO1xudmFyIHJlTGlua0xhYmVsID0gL15cXFsoPzpbXlxcXFxcXFtcXF1dfFxcXFwuKXswLDEwMDB9XFxdLztcbi8vIE1hdGNoZXMgYSBzdHJpbmcgb2Ygbm9uLXNwZWNpYWwgY2hhcmFjdGVycy5cbnZhciByZU1haW4gPSAvXlteXFxuYFxcW1xcXVxcXFwhPCYqXydcIn4kXSsvbTtcbnZhciBJbmxpbmVQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5saW5lUGFyc2VyKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQW4gSW5saW5lUGFyc2VyIGtlZXBzIHRyYWNrIG9mIGEgc3ViamVjdCAoYSBzdHJpbmcgdG8gYmUgcGFyc2VkKVxuICAgICAgICAvLyBhbmQgYSBwb3NpdGlvbiBpbiB0aGF0IHN1YmplY3QuXG4gICAgICAgIHRoaXMuc3ViamVjdCA9ICcnO1xuICAgICAgICB0aGlzLmRlbGltaXRlcnMgPSBudWxsOyAvLyB1c2VkIGJ5IGhhbmRsZURlbGltIG1ldGhvZFxuICAgICAgICB0aGlzLmJyYWNrZXRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmxpbmVTdGFydE51bSA9IDA7XG4gICAgICAgIHRoaXMubGluZUlkeCA9IDA7XG4gICAgICAgIHRoaXMubGluZU9mZnNldHMgPSBbMF07XG4gICAgICAgIHRoaXMubGluZVBvc09mZnNldCA9IDA7XG4gICAgICAgIHRoaXMucmVmTWFwID0ge307XG4gICAgICAgIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnNvdXJjZXBvcyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBsaW5lUG9zT2Zmc2V0ID0gdGhpcy5saW5lUG9zT2Zmc2V0ICsgdGhpcy5saW5lT2Zmc2V0c1t0aGlzLmxpbmVJZHhdO1xuICAgICAgICB2YXIgbGluZU51bSA9IHRoaXMubGluZVN0YXJ0TnVtICsgdGhpcy5saW5lSWR4O1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSBbbGluZU51bSwgc3RhcnQgKyBsaW5lUG9zT2Zmc2V0XTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gW3N0YXJ0cG9zLCBbbGluZU51bSwgZW5kICsgbGluZVBvc09mZnNldF1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydHBvcztcbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUubmV4dExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGluZUlkeCArPSAxO1xuICAgICAgICB0aGlzLmxpbmVQb3NPZmZzZXQgPSAtdGhpcy5wb3M7XG4gICAgfTtcbiAgICAvLyBJZiByZSBtYXRjaGVzIGF0IGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIHN1YmplY3QsIGFkdmFuY2VcbiAgICAvLyBwb3NpdGlvbiBpbiBzdWJqZWN0IGFuZCByZXR1cm4gdGhlIG1hdGNoOyBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChyZSkge1xuICAgICAgICB2YXIgbSA9IHJlLmV4ZWModGhpcy5zdWJqZWN0LnNsaWNlKHRoaXMucG9zKSk7XG4gICAgICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyArPSBtLmluZGV4ICsgbVswXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBtWzBdO1xuICAgIH07XG4gICAgLy8gUmV0dXJucyB0aGUgY29kZSBmb3IgdGhlIGNoYXJhY3RlciBhdCB0aGUgY3VycmVudCBzdWJqZWN0IHBvc2l0aW9uLCBvciAtMVxuICAgIC8vIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPCB0aGlzLnN1YmplY3QubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJqZWN0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIHplcm8gb3IgbW9yZSBzcGFjZSBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgYXQgbW9zdCBvbmUgbmV3bGluZVxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUuc3BubCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tYXRjaChyZVNwbmwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIEFsbCBvZiB0aGUgcGFyc2VycyBiZWxvdyB0cnkgdG8gbWF0Y2ggc29tZXRoaW5nIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uXG4gICAgLy8gaW4gdGhlIHN1YmplY3QuICBJZiB0aGV5IHN1Y2NlZWQgaW4gbWF0Y2hpbmcgYW55dGhpbmcsIHRoZXlcbiAgICAvLyByZXR1cm4gdGhlIGlubGluZSBtYXRjaGVkLCBhZHZhbmNpbmcgdGhlIHN1YmplY3QuXG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBiYWNrdGlja3MsIGFkZGluZyBlaXRoZXIgYSBiYWNrdGljayBjb2RlIHNwYW4gb3IgYVxuICAgIC8vIGxpdGVyYWwgc2VxdWVuY2Ugb2YgYmFja3RpY2tzLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VCYWNrdGlja3MgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICB2YXIgdGlja3MgPSB0aGlzLm1hdGNoKHJlVGlja3NIZXJlKTtcbiAgICAgICAgaWYgKHRpY2tzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFmdGVyT3BlblRpY2tzID0gdGhpcy5wb3M7XG4gICAgICAgIHZhciBtYXRjaGVkO1xuICAgICAgICB3aGlsZSAoKG1hdGNoZWQgPSB0aGlzLm1hdGNoKHJlVGlja3MpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoZWQgPT09IHRpY2tzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRzID0gdGhpcy5zdWJqZWN0LnNsaWNlKGFmdGVyT3BlblRpY2tzLCB0aGlzLnBvcyAtIHRpY2tzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZXBvcyA9IHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gY29udGVudHMuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0TGluZSA9IGxhc3QobGluZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVJZHggKz0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lUG9zT2Zmc2V0ID0gLSh0aGlzLnBvcyAtIGxhc3RMaW5lLmxlbmd0aCAtIHRpY2tzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZXBvc1sxXSA9IHRoaXMuc291cmNlcG9zKHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBsaW5lcy5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gY3JlYXRlTm9kZSgnY29kZScsIHNvdXJjZXBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMubWF0Y2goL1teIF0vKSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBjb250ZW50c1swXSA9PSAnICcgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHNbY29udGVudHMubGVuZ3RoIC0gMV0gPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGl0ZXJhbCA9IGNvbnRlbnRzLnNsaWNlKDEsIGNvbnRlbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5saXRlcmFsID0gY29udGVudHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUudGlja0NvdW50ID0gdGlja3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGdvdCBoZXJlLCB3ZSBkaWRuJ3QgbWF0Y2ggYSBjbG9zaW5nIGJhY2t0aWNrIHNlcXVlbmNlLlxuICAgICAgICB0aGlzLnBvcyA9IGFmdGVyT3BlblRpY2tzO1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZChlc21fdGV4dCh0aWNrcywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zIC0gMSkpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBQYXJzZSBhIGJhY2tzbGFzaC1lc2NhcGVkIHNwZWNpYWwgY2hhcmFjdGVyLCBhZGRpbmcgZWl0aGVyIHRoZSBlc2NhcGVkXG4gICAgLy8gY2hhcmFjdGVyLCBhIGhhcmQgbGluZSBicmVhayAoaWYgdGhlIGJhY2tzbGFzaCBpcyBmb2xsb3dlZCBieSBhIG5ld2xpbmUpLFxuICAgIC8vIG9yIGEgbGl0ZXJhbCBiYWNrc2xhc2ggdG8gdGhlIGJsb2NrJ3MgY2hpbGRyZW4uICBBc3N1bWVzIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgLy8gaXMgYSBiYWNrc2xhc2guXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJhY2tzbGFzaCA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgc3ViaiA9IHRoaXMuc3ViamVjdDtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09IENfTkVXTElORSkge1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKCdsaW5lYnJlYWsnLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcyAtIDEsIHRoaXMucG9zKSk7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZUVzY2FwYWJsZS50ZXN0KHN1YmouY2hhckF0KHRoaXMucG9zKSkpIHtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKGVzbV90ZXh0KHN1YmouY2hhckF0KHRoaXMucG9zKSwgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSkpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKGVzbV90ZXh0KCdcXFxcJywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHN0YXJ0cG9zKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBhbiBhdXRvbGluayAoVVJMIG9yIGVtYWlsIGluIHBvaW50eSBicmFja2V0cykuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUF1dG9saW5rID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBtO1xuICAgICAgICB2YXIgZGVzdDtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgaWYgKChtID0gdGhpcy5tYXRjaChyZUVtYWlsQXV0b2xpbmspKSkge1xuICAgICAgICAgICAgZGVzdCA9IG0uc2xpY2UoMSwgbS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKCdsaW5rJywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSk7XG4gICAgICAgICAgICBub2RlLmRlc3RpbmF0aW9uID0gbm9ybWFsaXplVVJJKFwibWFpbHRvOlwiICsgZGVzdCk7XG4gICAgICAgICAgICBub2RlLnRpdGxlID0gJyc7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGVzbV90ZXh0KGRlc3QsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zICsgMSwgdGhpcy5wb3MgLSAxKSkpO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG0gPSB0aGlzLm1hdGNoKHJlQXV0b2xpbmspKSkge1xuICAgICAgICAgICAgZGVzdCA9IG0uc2xpY2UoMSwgbS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKCdsaW5rJywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSk7XG4gICAgICAgICAgICBub2RlLmRlc3RpbmF0aW9uID0gbm9ybWFsaXplVVJJKGRlc3QpO1xuICAgICAgICAgICAgbm9kZS50aXRsZSA9ICcnO1xuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChlc21fdGV4dChkZXN0LCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcyArIDEsIHRoaXMucG9zIC0gMSkpKTtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBhIHJhdyBIVE1MIHRhZy5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlSHRtbFRhZyA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIHZhciBtID0gdGhpcy5tYXRjaChyZUh0bWxUYWcpO1xuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gY3JlYXRlTm9kZSgnaHRtbElubGluZScsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpO1xuICAgICAgICBub2RlLmxpdGVyYWwgPSBtO1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBTY2FuIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyB3aXRoIGNvZGUgY2MsIGFuZCByZXR1cm4gaW5mb3JtYXRpb24gYWJvdXRcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGRlbGltaXRlcnMgYW5kIHdoZXRoZXIgdGhleSBhcmUgcG9zaXRpb25lZCBzdWNoIHRoYXRcbiAgICAvLyB0aGV5IGNhbiBvcGVuIGFuZC9vciBjbG9zZSBlbXBoYXNpcyBvciBzdHJvbmcgZW1waGFzaXMuICBBIHV0aWxpdHlcbiAgICAvLyBmdW5jdGlvbiBmb3Igc3Ryb25nL2VtcGggcGFyc2luZy5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnNjYW5EZWxpbXMgPSBmdW5jdGlvbiAoY2MpIHtcbiAgICAgICAgdmFyIG51bWRlbGltcyA9IDA7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zO1xuICAgICAgICBpZiAoY2MgPT09IENfU0lOR0xFUVVPVEUgfHwgY2MgPT09IENfRE9VQkxFUVVPVEUpIHtcbiAgICAgICAgICAgIG51bWRlbGltcysrO1xuICAgICAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnBlZWsoKSA9PT0gY2MpIHtcbiAgICAgICAgICAgICAgICBudW1kZWxpbXMrKztcbiAgICAgICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChudW1kZWxpbXMgPT09IDAgfHwgKG51bWRlbGltcyA8IDIgJiYgKGNjID09PSBDX1RJTERFIHx8IGNjID09PSBDX0RPTExBUikpKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYXJCZWZvcmUgPSBzdGFydHBvcyA9PT0gMCA/ICdcXG4nIDogdGhpcy5zdWJqZWN0LmNoYXJBdChzdGFydHBvcyAtIDEpO1xuICAgICAgICB2YXIgY2NBZnRlciA9IHRoaXMucGVlaygpO1xuICAgICAgICB2YXIgY2hhckFmdGVyO1xuICAgICAgICBpZiAoY2NBZnRlciA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNoYXJBZnRlciA9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhckFmdGVyID0gZnJvbUNvZGVQb2ludCQxKGNjQWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZnRlcklzV2hpdGVzcGFjZSA9IHJlVW5pY29kZVdoaXRlc3BhY2VDaGFyLnRlc3QoY2hhckFmdGVyKTtcbiAgICAgICAgdmFyIGFmdGVySXNQdW5jdHVhdGlvbiA9IHJlUHVuY3R1YXRpb24udGVzdChjaGFyQWZ0ZXIpO1xuICAgICAgICB2YXIgYmVmb3JlSXNXaGl0ZXNwYWNlID0gcmVVbmljb2RlV2hpdGVzcGFjZUNoYXIudGVzdChjaGFyQmVmb3JlKTtcbiAgICAgICAgdmFyIGJlZm9yZUlzUHVuY3R1YXRpb24gPSByZVB1bmN0dWF0aW9uLnRlc3QoY2hhckJlZm9yZSk7XG4gICAgICAgIHZhciBsZWZ0RmxhbmtpbmcgPSAhYWZ0ZXJJc1doaXRlc3BhY2UgJiYgKCFhZnRlcklzUHVuY3R1YXRpb24gfHwgYmVmb3JlSXNXaGl0ZXNwYWNlIHx8IGJlZm9yZUlzUHVuY3R1YXRpb24pO1xuICAgICAgICB2YXIgcmlnaHRGbGFua2luZyA9ICFiZWZvcmVJc1doaXRlc3BhY2UgJiYgKCFiZWZvcmVJc1B1bmN0dWF0aW9uIHx8IGFmdGVySXNXaGl0ZXNwYWNlIHx8IGFmdGVySXNQdW5jdHVhdGlvbik7XG4gICAgICAgIHZhciBjYW5PcGVuO1xuICAgICAgICB2YXIgY2FuQ2xvc2U7XG4gICAgICAgIGlmIChjYyA9PT0gQ19VTkRFUlNDT1JFKSB7XG4gICAgICAgICAgICBjYW5PcGVuID0gbGVmdEZsYW5raW5nICYmICghcmlnaHRGbGFua2luZyB8fCBiZWZvcmVJc1B1bmN0dWF0aW9uKTtcbiAgICAgICAgICAgIGNhbkNsb3NlID0gcmlnaHRGbGFua2luZyAmJiAoIWxlZnRGbGFua2luZyB8fCBhZnRlcklzUHVuY3R1YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNjID09PSBDX1NJTkdMRVFVT1RFIHx8IGNjID09PSBDX0RPVUJMRVFVT1RFKSB7XG4gICAgICAgICAgICBjYW5PcGVuID0gbGVmdEZsYW5raW5nICYmICFyaWdodEZsYW5raW5nO1xuICAgICAgICAgICAgY2FuQ2xvc2UgPSByaWdodEZsYW5raW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNjID09PSBDX0RPTExBUikge1xuICAgICAgICAgICAgY2FuT3BlbiA9ICFhZnRlcklzV2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGNhbkNsb3NlID0gIWJlZm9yZUlzV2hpdGVzcGFjZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbk9wZW4gPSBsZWZ0Rmxhbmtpbmc7XG4gICAgICAgICAgICBjYW5DbG9zZSA9IHJpZ2h0Rmxhbmtpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgcmV0dXJuIHsgbnVtZGVsaW1zOiBudW1kZWxpbXMsIGNhbk9wZW46IGNhbk9wZW4sIGNhbkNsb3NlOiBjYW5DbG9zZSB9O1xuICAgIH07XG4gICAgLy8gSGFuZGxlIGEgZGVsaW1pdGVyIG1hcmtlciBmb3IgZW1waGFzaXMgb3IgYSBxdW90ZS5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLmhhbmRsZURlbGltID0gZnVuY3Rpb24gKGNjLCBibG9jaykge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5zY2FuRGVsaW1zKGNjKTtcbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnVtZGVsaW1zID0gcmVzLm51bWRlbGltcztcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICB2YXIgY29udGVudHM7XG4gICAgICAgIHRoaXMucG9zICs9IG51bWRlbGltcztcbiAgICAgICAgaWYgKGNjID09PSBDX1NJTkdMRVFVT1RFKSB7XG4gICAgICAgICAgICBjb250ZW50cyA9ICdcXHUyMDE5JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYyA9PT0gQ19ET1VCTEVRVU9URSkge1xuICAgICAgICAgICAgY29udGVudHMgPSAnXFx1MjAxQyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50cyA9IHRoaXMuc3ViamVjdC5zbGljZShzdGFydHBvcyAtIDEsIHRoaXMucG9zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IGVzbV90ZXh0KGNvbnRlbnRzLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIC8vIEFkZCBlbnRyeSB0byBzdGFjayBmb3IgdGhpcyBvcGVuZXJcbiAgICAgICAgaWYgKChyZXMuY2FuT3BlbiB8fCByZXMuY2FuQ2xvc2UpICYmXG4gICAgICAgICAgICAodGhpcy5vcHRpb25zLnNtYXJ0IHx8IChjYyAhPT0gQ19TSU5HTEVRVU9URSAmJiBjYyAhPT0gQ19ET1VCTEVRVU9URSkpKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGltaXRlcnMgPSB7XG4gICAgICAgICAgICAgICAgY2M6IGNjLFxuICAgICAgICAgICAgICAgIG51bWRlbGltczogbnVtZGVsaW1zLFxuICAgICAgICAgICAgICAgIG9yaWdkZWxpbXM6IG51bWRlbGltcyxcbiAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiB0aGlzLmRlbGltaXRlcnMsXG4gICAgICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICAgICAgICBjYW5PcGVuOiByZXMuY2FuT3BlbixcbiAgICAgICAgICAgICAgICBjYW5DbG9zZTogcmVzLmNhbkNsb3NlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGltaXRlcnMucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlcnMucHJldmlvdXMubmV4dCA9IHRoaXMuZGVsaW1pdGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucmVtb3ZlRGVsaW1pdGVyID0gZnVuY3Rpb24gKGRlbGltKSB7XG4gICAgICAgIGlmIChkZWxpbS5wcmV2aW91cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsaW0ucHJldmlvdXMubmV4dCA9IGRlbGltLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbGltLm5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHRvcCBvZiBzdGFja1xuICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gZGVsaW0ucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxpbS5uZXh0LnByZXZpb3VzID0gZGVsaW0ucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucmVtb3ZlRGVsaW1pdGVyc0JldHdlZW4gPSBmdW5jdGlvbiAoYm90dG9tLCB0b3ApIHtcbiAgICAgICAgaWYgKGJvdHRvbS5uZXh0ICE9PSB0b3ApIHtcbiAgICAgICAgICAgIGJvdHRvbS5uZXh0ID0gdG9wO1xuICAgICAgICAgICAgdG9wLnByZXZpb3VzID0gYm90dG9tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFsbCBkZWxpbWl0ZXJzIC0gZW1waGFzaXMsIHN0cm9uZyBlbXBoYXNpcywgc3RyaWtldGhyb3VnaChnZm0pXG4gICAgICogSWYgdGhlIHNtYXJ0IHB1bmN0dWF0aW9uIG9wdGlvbnMgaXMgdHJ1ZSxcbiAgICAgKiBjb252ZXJ0IHNpbmdsZS9kb3VibGUgcXVvdGVzIHRvIGNvcnJlc3BvbmRpbmcgdW5pY29kZSBjaGFyYWN0ZXJzLlxuICAgICAqKi9cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnByb2Nlc3NFbXBoYXNpcyA9IGZ1bmN0aW9uIChzdGFja0JvdHRvbSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBvcGVuZXI7XG4gICAgICAgIHZhciBjbG9zZXI7XG4gICAgICAgIHZhciBvbGRDbG9zZXI7XG4gICAgICAgIHZhciBvcGVuZXJJbmwsIGNsb3NlcklubDtcbiAgICAgICAgdmFyIG9wZW5lckZvdW5kO1xuICAgICAgICB2YXIgb2RkTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdmFyIG9wZW5lcnNCb3R0b20gPSAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW0NfVU5ERVJTQ09SRV0gPSBbc3RhY2tCb3R0b20sIHN0YWNrQm90dG9tLCBzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYVtDX0FTVEVSSVNLXSA9IFtzdGFja0JvdHRvbSwgc3RhY2tCb3R0b20sIHN0YWNrQm90dG9tXSxcbiAgICAgICAgICAgIF9hW0NfU0lOR0xFUVVPVEVdID0gW3N0YWNrQm90dG9tXSxcbiAgICAgICAgICAgIF9hW0NfRE9VQkxFUVVPVEVdID0gW3N0YWNrQm90dG9tXSxcbiAgICAgICAgICAgIF9hW0NfVElMREVdID0gW3N0YWNrQm90dG9tXSxcbiAgICAgICAgICAgIF9hW0NfRE9MTEFSXSA9IFtzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYSk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3QgY2xvc2VyIGFib3ZlIHN0YWNrQm90dG9tOlxuICAgICAgICBjbG9zZXIgPSB0aGlzLmRlbGltaXRlcnM7XG4gICAgICAgIHdoaWxlIChjbG9zZXIgIT09IG51bGwgJiYgY2xvc2VyLnByZXZpb3VzICE9PSBzdGFja0JvdHRvbSkge1xuICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1vdmUgZm9yd2FyZCwgbG9va2luZyBmb3IgY2xvc2VycywgYW5kIGhhbmRsaW5nIGVhY2hcbiAgICAgICAgd2hpbGUgKGNsb3NlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNsb3NlcmNjID0gY2xvc2VyLmNjO1xuICAgICAgICAgICAgdmFyIGNsb3NlckVtcGggPSBjbG9zZXJjYyA9PT0gQ19VTkRFUlNDT1JFIHx8IGNsb3NlcmNjID09PSBDX0FTVEVSSVNLO1xuICAgICAgICAgICAgaWYgKCFjbG9zZXIuY2FuQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXIgPSBjbG9zZXIubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZvdW5kIGVtcGhhc2lzIGNsb3Nlci4gbm93IGxvb2sgYmFjayBmb3IgZmlyc3QgbWF0Y2hpbmcgb3BlbmVyOlxuICAgICAgICAgICAgICAgIG9wZW5lciA9IGNsb3Nlci5wcmV2aW91cztcbiAgICAgICAgICAgICAgICBvcGVuZXJGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChvcGVuZXIgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyICE9PSBzdGFja0JvdHRvbSAmJlxuICAgICAgICAgICAgICAgICAgICBvcGVuZXIgIT09IG9wZW5lcnNCb3R0b21bY2xvc2VyY2NdW2Nsb3NlckVtcGggPyBjbG9zZXIub3JpZ2RlbGltcyAlIDMgOiAwXSkge1xuICAgICAgICAgICAgICAgICAgICBvZGRNYXRjaCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXJFbXBoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsb3Nlci5jYW5PcGVuIHx8IG9wZW5lci5jYW5DbG9zZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXIub3JpZ2RlbGltcyAlIDMgIT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3BlbmVyLm9yaWdkZWxpbXMgKyBjbG9zZXIub3JpZ2RlbGltcykgJSAzID09PSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbmVyLmNjID09PSBjbG9zZXIuY2MgJiYgb3BlbmVyLmNhbk9wZW4gJiYgIW9kZE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcGVuZXIgPSBvcGVuZXIucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9sZENsb3NlciA9IGNsb3NlcjtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VyRW1waCB8fCBjbG9zZXJjYyA9PT0gQ19USUxERSB8fCBjbG9zZXJjYyA9PT0gQ19ET0xMQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcGVuZXJGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3BlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAobnVsbCBvcGVuZXIgY2hlY2sgZm9yIHR5cGUgbmFycm93aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGFjdHVhbCBudW1iZXIgb2YgZGVsaW1pdGVycyB1c2VkIGZyb20gY2xvc2VyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlRGVsaW1zID0gY2xvc2VyLm51bWRlbGltcyA+PSAyICYmIG9wZW5lci5udW1kZWxpbXMgPj0gMiA/IDIgOiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVtcHR5RGVsaW1zID0gY2xvc2VyRW1waCA/IDAgOiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVySW5sID0gb3BlbmVyLm5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXJJbmwgPSBjbG9zZXIubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGNvbnRlbnRzIGZvciBuZXcgZW1waCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVR5cGUgPSBjbG9zZXJFbXBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB1c2VEZWxpbXMgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnZW1waCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnc3Ryb25nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3N0cmlrZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VyY2MgPT09IENfRE9MTEFSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVR5cGUgPSAnY3VzdG9tSW5saW5lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gY3JlYXRlTm9kZShub2RlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlbmVyRW5kUG9zID0gb3BlbmVySW5sLnNvdXJjZXBvc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZXJTdGFydFBvcyA9IGNsb3NlcklubC5zb3VyY2Vwb3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnNvdXJjZXBvcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3BlbmVyRW5kUG9zWzBdLCBvcGVuZXJFbmRQb3NbMV0gLSB1c2VEZWxpbXMgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2xvc2VyU3RhcnRQb3NbMF0sIGNsb3NlclN0YXJ0UG9zWzFdICsgdXNlRGVsaW1zIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVySW5sLnNvdXJjZXBvc1sxXVsxXSAtPSB1c2VEZWxpbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXJJbmwuc291cmNlcG9zWzBdWzFdICs9IHVzZURlbGltcztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lcklubC5saXRlcmFsID0gb3BlbmVySW5sLmxpdGVyYWwuc2xpY2UodXNlRGVsaW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlcklubC5saXRlcmFsID0gY2xvc2VySW5sLmxpdGVyYWwuc2xpY2UodXNlRGVsaW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lci5udW1kZWxpbXMgLT0gdXNlRGVsaW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VyLm51bWRlbGltcyAtPSB1c2VEZWxpbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdXNlZCBkZWxpbWl0ZXJzIGZyb20gc3RhY2sgZWx0cyBhbmQgaW5saW5lc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IG9wZW5lcklubC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodG1wICYmIHRtcCAhPT0gY2xvc2VySW5sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRtcC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLmFwcGVuZENoaWxkKHRtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGN1c3RvbSBpbmxpbmUgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlcmNjID09PSBDX0RPTExBUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0Tm9kZSA9IG5ld05vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHRleHROb2RlLmxpdGVyYWwgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSBsaXRlcmFsLnNwbGl0KC9cXHMvKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLmluZm8gPSBpbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXRlcmFsLmxlbmd0aCA8PSBpbmZvLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZS51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHROb2RlLnNvdXJjZXBvc1swXVsxXSArPSBpbmZvLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUubGl0ZXJhbCA9IGxpdGVyYWwucmVwbGFjZShpbmZvICsgXCIgXCIsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJJbmwuaW5zZXJ0QWZ0ZXIobmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZWx0cyBiZXR3ZWVuIG9wZW5lciBhbmQgY2xvc2VyIGluIGRlbGltaXRlcnMgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRGVsaW1pdGVyc0JldHdlZW4ob3BlbmVyLCBjbG9zZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgb3BlbmVyIGhhcyAwIGRlbGltcywgcmVtb3ZlIGl0IGFuZCB0aGUgaW5saW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBvcGVuZXIgaGFzIDEgZGVsaW1zIGFuZCBjaGFyYWN0ZXIgaXMgdGlsZGUsIHJlbW92ZSBkZWxpbWl0ZXIgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lci5udW1kZWxpbXMgPD0gZW1wdHlEZWxpbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlbmVyLm51bWRlbGltcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJJbmwudW5saW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRGVsaW1pdGVyKG9wZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBjbG9zZXIgaGFzIDAgZGVsaW1zLCByZW1vdmUgaXQgYW5kIHRoZSBpbmxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGNsb3NlciBoYXMgMSBkZWxpbXMgYW5kIGNoYXJhY3RlciBpcyB0aWxkZSwgcmVtb3ZlIGRlbGltaXRlciBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VyLm51bWRlbGltcyA8PSBlbXB0eURlbGltcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXIubnVtZGVsaW1zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlcklubC51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBzdGFjayA9IGNsb3Nlci5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRGVsaW1pdGVyKGNsb3Nlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VyID0gdGVtcHN0YWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsb3NlcmNjID09PSBDX1NJTkdMRVFVT1RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlci5ub2RlLmxpdGVyYWwgPSAnXFx1MjAxOSc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuZXJGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyLm5vZGUubGl0ZXJhbCA9ICdcXHUyMDE4JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbG9zZXIgPSBjbG9zZXIubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xvc2VyY2MgPT09IENfRE9VQkxFUVVPVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VyLm5vZGUubGl0ZXJhbCA9ICdcXHUyMDFEJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXIubm9kZS5saXRlcmFsID0gJ1xcdTIwMUMnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlciA9IGNsb3Nlci5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW9wZW5lckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBsb3dlciBib3VuZCBmb3IgZnV0dXJlIHNlYXJjaGVzIGZvciBvcGVuZXJzOlxuICAgICAgICAgICAgICAgICAgICBvcGVuZXJzQm90dG9tW2Nsb3NlcmNjXVtjbG9zZXJFbXBoID8gb2xkQ2xvc2VyLm9yaWdkZWxpbXMgJSAzIDogMF0gPSBvbGRDbG9zZXIucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb2xkQ2xvc2VyLmNhbk9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiByZW1vdmUgYSBjbG9zZXIgdGhhdCBjYW4ndCBiZSBhbiBvcGVuZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmNlIHdlJ3ZlIHNlZW4gdGhlcmUncyBubyBtYXRjaGluZyBvcGVuZXI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURlbGltaXRlcihvbGRDbG9zZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgZGVsaW1pdGVyc1xuICAgICAgICB3aGlsZSAodGhpcy5kZWxpbWl0ZXJzICE9PSBudWxsICYmIHRoaXMuZGVsaW1pdGVycyAhPT0gc3RhY2tCb3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRGVsaW1pdGVyKHRoaXMuZGVsaW1pdGVycyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgbGluayB0aXRsZSAoc2FucyBxdW90ZXMpLCByZXR1cm5pbmcgdGhlIHN0cmluZ1xuICAgIC8vIG9yIG51bGwgaWYgbm8gbWF0Y2guXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpbmtUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5tYXRjaChyZUxpbmtUaXRsZSk7XG4gICAgICAgIGlmICh0aXRsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hvcCBvZmYgcXVvdGVzIGZyb20gdGl0bGUgYW5kIHVuZXNjYXBlOlxuICAgICAgICByZXR1cm4gdW5lc2NhcGVTdHJpbmcodGl0bGUuc3Vic3RyKDEsIHRpdGxlLmxlbmd0aCAtIDIpKTtcbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgbGluayBkZXN0aW5hdGlvbiwgcmV0dXJuaW5nIHRoZSBzdHJpbmcgb3IgbnVsbCBpZiBubyBtYXRjaC5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlTGlua0Rlc3RpbmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5tYXRjaChyZUxpbmtEZXN0aW5hdGlvbkJyYWNlcyk7XG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gQ19MRVNTVEhBTiQxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAVE9ETyBoYW5kcm9sbGVkIHBhcnNlcjsgcmVzIHNob3VsZCBiZSBudWxsIG9yIHRoZSBzdHJpbmdcbiAgICAgICAgICAgIHZhciBzYXZlcG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB2YXIgb3BlbnBhcmVucyA9IDA7XG4gICAgICAgICAgICB2YXIgYyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHdoaWxlICgoYyA9IHRoaXMucGVlaygpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gQ19CQUNLU0xBU0ggJiYgcmVFc2NhcGFibGUudGVzdCh0aGlzLnN1YmplY3QuY2hhckF0KHRoaXMucG9zICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlZWsoKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gQ19PUEVOX1BBUkVOKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5wYXJlbnMgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gQ19DTE9TRV9QQVJFTikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbnBhcmVucyA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5wYXJlbnMgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZVdoaXRlc3BhY2VDaGFyLmV4ZWMoZnJvbUNvZGVQb2ludCQxKGMpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBzYXZlcG9zICYmIGMgIT09IENfQ0xPU0VfUEFSRU4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcGVucGFyZW5zICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSB0aGlzLnN1YmplY3Quc3Vic3RyKHNhdmVwb3MsIHRoaXMucG9zIC0gc2F2ZXBvcyk7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplVVJJKHVuZXNjYXBlU3RyaW5nKHJlcykpO1xuICAgICAgICB9IC8vIGNob3Agb2ZmIHN1cnJvdW5kaW5nIDwuLj46XG4gICAgICAgIHJldHVybiBub3JtYWxpemVVUkkodW5lc2NhcGVTdHJpbmcocmVzLnN1YnN0cigxLCByZXMubGVuZ3RoIC0gMikpKTtcbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYSBsaW5rIGxhYmVsLCByZXR1cm5pbmcgbnVtYmVyIG9mIGNoYXJhY3RlcnMgcGFyc2VkLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VMaW5rTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5tYXRjaChyZUxpbmtMYWJlbCk7XG4gICAgICAgIGlmIChtID09PSBudWxsIHx8IG0ubGVuZ3RoID4gMTAwMSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0ubGVuZ3RoO1xuICAgIH07XG4gICAgLy8gQWRkIG9wZW4gYnJhY2tldCB0byBkZWxpbWl0ZXIgc3RhY2sgYW5kIGFkZCBhIHRleHQgbm9kZSB0byBibG9jaydzIGNoaWxkcmVuLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VPcGVuQnJhY2tldCA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgdmFyIG5vZGUgPSBlc21fdGV4dCgnWycsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zLCB0aGlzLnBvcykpO1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgLy8gQWRkIGVudHJ5IHRvIHN0YWNrIGZvciB0aGlzIG9wZW5lclxuICAgICAgICB0aGlzLmFkZEJyYWNrZXQobm9kZSwgc3RhcnRwb3MsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBJRiBuZXh0IGNoYXJhY3RlciBpcyBbLCBhbmQgISBkZWxpbWl0ZXIgdG8gZGVsaW1pdGVyIHN0YWNrIGFuZFxuICAgIC8vIGFkZCBhIHRleHQgbm9kZSB0byBibG9jaydzIGNoaWxkcmVuLiAgT3RoZXJ3aXNlIGp1c3QgYWRkIGEgdGV4dCBub2RlLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VCYW5nID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09IENfT1BFTl9CUkFDS0VUJDEpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGVzbV90ZXh0KCchWycsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zIC0gMSwgdGhpcy5wb3MpKTtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgLy8gQWRkIGVudHJ5IHRvIHN0YWNrIGZvciB0aGlzIG9wZW5lclxuICAgICAgICAgICAgdGhpcy5hZGRCcmFja2V0KG5vZGUsIHN0YXJ0cG9zICsgMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGVzbV90ZXh0KCchJywgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MsIHRoaXMucG9zKSk7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIFRyeSB0byBtYXRjaCBjbG9zZSBicmFja2V0IGFnYWluc3QgYW4gb3BlbmluZyBpbiB0aGUgZGVsaW1pdGVyXG4gICAgLy8gc3RhY2suICBBZGQgZWl0aGVyIGEgbGluayBvciBpbWFnZSwgb3IgYSBwbGFpbiBbIGNoYXJhY3RlcixcbiAgICAvLyB0byBibG9jaydzIGNoaWxkcmVuLiAgSWYgdGhlcmUgaXMgYSBtYXRjaGluZyBkZWxpbWl0ZXIsXG4gICAgLy8gcmVtb3ZlIGl0IGZyb20gdGhlIGRlbGltaXRlciBzdGFjay5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xvc2VCcmFja2V0ID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBkZXN0ID0gbnVsbDtcbiAgICAgICAgdmFyIHRpdGxlID0gbnVsbDtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgICAgIC8vIGdldCBsYXN0IFsgb3IgIVtcbiAgICAgICAgdmFyIG9wZW5lciA9IHRoaXMuYnJhY2tldHM7XG4gICAgICAgIGlmIChvcGVuZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vIG1hdGNoZWQgb3BlbmVyLCBqdXN0IHJldHVybiBhIGxpdGVyYWxcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKGVzbV90ZXh0KCddJywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHN0YXJ0cG9zKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcGVuZXIuYWN0aXZlKSB7XG4gICAgICAgICAgICAvLyBubyBtYXRjaGVkIG9wZW5lciwganVzdCByZXR1cm4gYSBsaXRlcmFsXG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChlc21fdGV4dCgnXScsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCBzdGFydHBvcykpKTtcbiAgICAgICAgICAgIC8vIHRha2Ugb3BlbmVyIG9mZiBicmFja2V0cyBzdGFja1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVCcmFja2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgb3BlbiBpcyBhIHBvdGVudGlhbCBvcGVuZXJcbiAgICAgICAgdmFyIGlzSW1hZ2UgPSBvcGVuZXIuaW1hZ2U7XG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgbGluay9pbWFnZVxuICAgICAgICB2YXIgc2F2ZXBvcyA9IHRoaXMucG9zO1xuICAgICAgICAvLyBJbmxpbmUgbGluaz9cbiAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSBDX09QRU5fUEFSRU4pIHtcbiAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgICAgICBpZiAodGhpcy5zcG5sKCkgJiZcbiAgICAgICAgICAgICAgICAoZGVzdCA9IHRoaXMucGFyc2VMaW5rRGVzdGluYXRpb24oKSkgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNwbmwoKSAmJlxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSdzIGEgc3BhY2UgYmVmb3JlIHRoZSB0aXRsZTpcbiAgICAgICAgICAgICAgICAoKHJlV2hpdGVzcGFjZUNoYXIudGVzdCh0aGlzLnN1YmplY3QuY2hhckF0KHRoaXMucG9zIC0gMSkpICYmXG4gICAgICAgICAgICAgICAgICAgICh0aXRsZSA9IHRoaXMucGFyc2VMaW5rVGl0bGUoKSkpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRydWUpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zcG5sKCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnBlZWsoKSA9PT0gQ19DTE9TRV9QQVJFTikge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IHNhdmVwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZkxhYmVsID0gJyc7XG4gICAgICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgICAgICAgLy8gTmV4dCwgc2VlIGlmIHRoZXJlJ3MgYSBsaW5rIGxhYmVsXG4gICAgICAgICAgICB2YXIgYmVmb3JlbGFiZWwgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5wYXJzZUxpbmtMYWJlbCgpO1xuICAgICAgICAgICAgaWYgKG4gPiAyKSB7XG4gICAgICAgICAgICAgICAgcmVmTGFiZWwgPSB0aGlzLnN1YmplY3Quc2xpY2UoYmVmb3JlbGFiZWwsIGJlZm9yZWxhYmVsICsgbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghb3BlbmVyLmJyYWNrZXRBZnRlcikge1xuICAgICAgICAgICAgICAgIC8vIEVtcHR5IG9yIG1pc3Npbmcgc2Vjb25kIGxhYmVsIG1lYW5zIHRvIHVzZSB0aGUgZmlyc3QgbGFiZWwgYXMgdGhlIHJlZmVyZW5jZS5cbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVmZXJlbmNlIG11c3Qgbm90IGNvbnRhaW4gYSBicmFja2V0LiBJZiB3ZSBrbm93IHRoZXJlJ3MgYSBicmFja2V0LCB3ZSBkb24ndCBldmVuIGJvdGhlciBjaGVja2luZyBpdC5cbiAgICAgICAgICAgICAgICByZWZMYWJlbCA9IHRoaXMuc3ViamVjdC5zbGljZShvcGVuZXIuaW5kZXgsIHN0YXJ0cG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmssIHJld2luZCBiZWZvcmUgc3BhY2VzIHdlIHNraXBwZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBzYXZlcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlZkxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmVmTGFiZWwgPSBub3JtYWxpemVSZWZlcmVuY2UocmVmTGFiZWwpO1xuICAgICAgICAgICAgICAgIC8vIGxvb2t1cCByYXdsYWJlbCBpbiByZWZNYXBcbiAgICAgICAgICAgICAgICB2YXIgbGluayA9IHRoaXMucmVmTWFwW3JlZkxhYmVsXTtcbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICBkZXN0ID0gbGluay5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBsaW5rLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gY3JlYXRlTm9kZShpc0ltYWdlID8gJ2ltYWdlJyA6ICdsaW5rJyk7XG4gICAgICAgICAgICBub2RlLmRlc3RpbmF0aW9uID0gZGVzdDtcbiAgICAgICAgICAgIG5vZGUudGl0bGUgPSB0aXRsZSB8fCAnJztcbiAgICAgICAgICAgIG5vZGUuc291cmNlcG9zID0gW29wZW5lci5zdGFydHBvcywgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MpXTtcbiAgICAgICAgICAgIHZhciB0bXAgPSBvcGVuZXIubm9kZS5uZXh0O1xuICAgICAgICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG4gICAgICAgICAgICB3aGlsZSAodG1wKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHRtcC5uZXh0O1xuICAgICAgICAgICAgICAgIHRtcC51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRtcCk7XG4gICAgICAgICAgICAgICAgdG1wID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRW1waGFzaXMob3BlbmVyLnByZXZpb3VzRGVsaW1pdGVyKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQnJhY2tldCgpO1xuICAgICAgICAgICAgb3BlbmVyLm5vZGUudW5saW5rKCk7XG4gICAgICAgICAgICAvLyBXZSByZW1vdmUgdGhpcyBicmFja2V0IGFuZCBwcm9jZXNzRW1waGFzaXMgd2lsbCByZW1vdmUgbGF0ZXIgZGVsaW1pdGVycy5cbiAgICAgICAgICAgIC8vIE5vdywgZm9yIGEgbGluaywgd2UgYWxzbyBkZWFjdGl2YXRlIGVhcmxpZXIgbGluayBvcGVuZXJzLlxuICAgICAgICAgICAgLy8gKG5vIGxpbmtzIGluIGxpbmtzKVxuICAgICAgICAgICAgaWYgKCFpc0ltYWdlKSB7XG4gICAgICAgICAgICAgICAgb3BlbmVyID0gdGhpcy5icmFja2V0cztcbiAgICAgICAgICAgICAgICB3aGlsZSAob3BlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3BlbmVyLmltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXIuYWN0aXZlID0gZmFsc2U7IC8vIGRlYWN0aXZhdGUgdGhpcyBvcGVuZXJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcGVuZXIgPSBvcGVuZXIucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwW2Jsb2NrLmlkXSA9IHsgbm9kZTogYmxvY2ssIHJlZkxhYmVsOiByZWZMYWJlbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gbm8gbWF0Y2hcbiAgICAgICAgdGhpcy5yZW1vdmVCcmFja2V0KCk7IC8vIHJlbW92ZSB0aGlzIG9wZW5lciBmcm9tIHN0YWNrXG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKGVzbV90ZXh0KCddJywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHN0YXJ0cG9zKSkpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlZmVyZW5jZURlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcFtibG9jay5pZF0gPSB7IG5vZGU6IGJsb2NrLCByZWZMYWJlbDogcmVmTGFiZWwgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUuYWRkQnJhY2tldCA9IGZ1bmN0aW9uIChub2RlLCBpbmRleCwgaW1hZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuYnJhY2tldHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYnJhY2tldHMuYnJhY2tldEFmdGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJyYWNrZXRzID0ge1xuICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgIHN0YXJ0cG9zOiB0aGlzLnNvdXJjZXBvcyhpbmRleCArIChpbWFnZSA/IDAgOiAxKSksXG4gICAgICAgICAgICBwcmV2aW91czogdGhpcy5icmFja2V0cyxcbiAgICAgICAgICAgIHByZXZpb3VzRGVsaW1pdGVyOiB0aGlzLmRlbGltaXRlcnMsXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnJlbW92ZUJyYWNrZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJyYWNrZXRzKSB7XG4gICAgICAgICAgICB0aGlzLmJyYWNrZXRzID0gdGhpcy5icmFja2V0cy5wcmV2aW91cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBhbiBlbnRpdHkuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUVudGl0eSA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICBpZiAoKG0gPSB0aGlzLm1hdGNoKHJlRW50aXR5SGVyZSkpKSB7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChlc21fdGV4dChsaWIuZGVjb2RlSFRNTChtKSwgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLy8gUGFyc2UgYSBydW4gb2Ygb3JkaW5hcnkgY2hhcmFjdGVycywgb3IgYSBzaW5nbGUgY2hhcmFjdGVyIHdpdGhcbiAgICAvLyBhIHNwZWNpYWwgbWVhbmluZyBpbiBtYXJrZG93biwgYXMgYSBwbGFpbiBzdHJpbmcuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cmluZyA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICBpZiAoKG0gPSB0aGlzLm1hdGNoKHJlTWFpbikpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNtYXJ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpdCA9IG0ucmVwbGFjZShyZUVsbGlwc2VzLCAnXFx1MjAyNicpLnJlcGxhY2UocmVEYXNoLCBmdW5jdGlvbiAoY2hhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW1Db3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFycy5sZW5ndGggJSAzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc2libGUgYnkgMywgdXNlIGFsbCBlbSBkYXNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtQ291bnQgPSBjaGFycy5sZW5ndGggLyAzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJzLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzaWJsZSBieSAyLCB1c2UgYWxsIGVuIGRhc2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5Db3VudCA9IGNoYXJzLmxlbmd0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhcnMubGVuZ3RoICUgMyA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgMiBleHRyYSBkYXNoZXMsIHVzZSBlbiBkYXNoIGZvciBsYXN0IDI7IGVtIGRhc2hlcyBmb3IgcmVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5Db3VudCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbUNvdW50ID0gKGNoYXJzLmxlbmd0aCAtIDIpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBlbiBkYXNoZXMgZm9yIGxhc3QgNCBoeXBoZW5zOyBlbSBkYXNoZXMgZm9yIHJlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuQ291bnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1Db3VudCA9IChjaGFycy5sZW5ndGggLSA0KSAvIDM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcGVhdCgnXFx1MjAxNCcsIGVtQ291bnQpICsgcmVwZWF0KCdcXHUyMDEzJywgZW5Db3VudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoZXNtX3RleHQobGl0LCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGVzbV90ZXh0KG0sIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLy8gUGFyc2UgYSBuZXdsaW5lLiAgSWYgaXQgd2FzIHByZWNlZGVkIGJ5IHR3byBzcGFjZXMsIHJldHVybiBhIGhhcmRcbiAgICAvLyBsaW5lIGJyZWFrOyBvdGhlcndpc2UgYSBzb2Z0IGxpbmUgYnJlYWsuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZU5ld2xpbmUgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdGhpcy5wb3MgKz0gMTsgLy8gYXNzdW1lIHdlJ3JlIGF0IGEgXFxuXG4gICAgICAgIC8vIGNoZWNrIHByZXZpb3VzIG5vZGUgZm9yIHRyYWlsaW5nIHNwYWNlc1xuICAgICAgICB2YXIgbGFzdGMgPSBibG9jay5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmIChsYXN0YyAmJiBsYXN0Yy50eXBlID09PSAndGV4dCcgJiYgbGFzdGMubGl0ZXJhbFtsYXN0Yy5saXRlcmFsLmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgIHZhciBoYXJkYnJlYWsgPSBsYXN0Yy5saXRlcmFsW2xhc3RjLmxpdGVyYWwubGVuZ3RoIC0gMl0gPT09ICcgJztcbiAgICAgICAgICAgIHZhciBsaXRMZW4gPSBsYXN0Yy5saXRlcmFsLmxlbmd0aDtcbiAgICAgICAgICAgIGxhc3RjLmxpdGVyYWwgPSBsYXN0Yy5saXRlcmFsLnJlcGxhY2UocmVGaW5hbFNwYWNlLCAnJyk7XG4gICAgICAgICAgICB2YXIgZmluYWxTcGFjZUxlbiA9IGxpdExlbiAtIGxhc3RjLmxpdGVyYWwubGVuZ3RoO1xuICAgICAgICAgICAgbGFzdGMuc291cmNlcG9zWzFdWzFdIC09IGZpbmFsU3BhY2VMZW47XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChjcmVhdGVOb2RlKGhhcmRicmVhayA/ICdsaW5lYnJlYWsnIDogJ3NvZnRicmVhaycsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zIC0gZmluYWxTcGFjZUxlbiwgdGhpcy5wb3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChjcmVhdGVOb2RlKCdzb2Z0YnJlYWsnLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcywgdGhpcy5wb3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0TGluZSgpO1xuICAgICAgICB0aGlzLm1hdGNoKHJlSW5pdGlhbFNwYWNlKTsgLy8gZ29iYmxlIGxlYWRpbmcgc3BhY2VzIGluIG5leHQgbGluZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYSBsaW5rIHJlZmVyZW5jZSwgbW9kaWZ5aW5nIHJlZm1hcC5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlUmVmZXJlbmNlID0gZnVuY3Rpb24gKGJsb2NrLCByZWZNYXApIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucmVmZXJlbmNlRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gYmxvY2suc3RyaW5nQ29udGVudDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB2YXIgdGl0bGUgPSBudWxsO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgLy8gbGFiZWw6XG4gICAgICAgIHZhciBtYXRjaENoYXJzID0gdGhpcy5wYXJzZUxpbmtMYWJlbCgpO1xuICAgICAgICBpZiAobWF0Y2hDaGFycyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhd2xhYmVsID0gdGhpcy5zdWJqZWN0LnN1YnN0cigwLCBtYXRjaENoYXJzKTtcbiAgICAgICAgLy8gY29sb246XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gQ19DT0xPTikge1xuICAgICAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyAgbGluayB1cmxcbiAgICAgICAgdGhpcy5zcG5sKCk7XG4gICAgICAgIHZhciBkZXN0ID0gdGhpcy5wYXJzZUxpbmtEZXN0aW5hdGlvbigpO1xuICAgICAgICBpZiAoZGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZWZvcmV0aXRsZSA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnNwbmwoKTtcbiAgICAgICAgaWYgKHRoaXMucG9zICE9PSBiZWZvcmV0aXRsZSkge1xuICAgICAgICAgICAgdGl0bGUgPSB0aGlzLnBhcnNlTGlua1RpdGxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpdGxlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aXRsZSA9ICcnO1xuICAgICAgICAgICAgLy8gcmV3aW5kIGJlZm9yZSBzcGFjZXNcbiAgICAgICAgICAgIHRoaXMucG9zID0gYmVmb3JldGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlJ3JlIGF0IGxpbmUgZW5kOlxuICAgICAgICB2YXIgYXRMaW5lRW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2gocmVTcGFjZUF0RW5kT2ZMaW5lKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRpdGxlID09PSAnJykge1xuICAgICAgICAgICAgICAgIGF0TGluZUVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHBvdGVudGlhbCB0aXRsZSB3ZSBmb3VuZCBpcyBub3QgYXQgdGhlIGxpbmUgZW5kLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCBpdCBjb3VsZCBzdGlsbCBiZSBhIGxlZ2FsIGxpbmsgcmVmZXJlbmNlIGlmIHdlXG4gICAgICAgICAgICAgICAgLy8gZGlzY2FyZCB0aGUgdGl0bGVcbiAgICAgICAgICAgICAgICB0aXRsZSA9ICcnO1xuICAgICAgICAgICAgICAgIC8vIHJld2luZCBiZWZvcmUgc3BhY2VzXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBiZWZvcmV0aXRsZTtcbiAgICAgICAgICAgICAgICAvLyBhbmQgaW5zdGVhZCBjaGVjayBpZiB0aGUgbGluayBVUkwgaXMgYXQgdGhlIGxpbmUgZW5kXG4gICAgICAgICAgICAgICAgYXRMaW5lRW5kID0gdGhpcy5tYXRjaChyZVNwYWNlQXRFbmRPZkxpbmUpICE9PSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYXRMaW5lRW5kKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vcm1hbExhYmVsID0gbm9ybWFsaXplUmVmZXJlbmNlKHJhd2xhYmVsKTtcbiAgICAgICAgaWYgKG5vcm1hbExhYmVsID09PSAnJykge1xuICAgICAgICAgICAgLy8gbGFiZWwgbXVzdCBjb250YWluIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlcG9zID0gdGhpcy5nZXRSZWZlcmVuY2VEZWZTb3VyY2Vwb3MoYmxvY2spO1xuICAgICAgICBibG9jay5zb3VyY2Vwb3NbMF1bMF0gPSBzb3VyY2Vwb3NbMV1bMF0gKyAxO1xuICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUoJ3JlZkRlZicsIHNvdXJjZXBvcyk7XG4gICAgICAgIG5vZGUudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgbm9kZS5kZXN0ID0gZGVzdDtcbiAgICAgICAgbm9kZS5sYWJlbCA9IG5vcm1hbExhYmVsO1xuICAgICAgICBibG9jay5pbnNlcnRCZWZvcmUobm9kZSk7XG4gICAgICAgIGlmICghcmVmTWFwW25vcm1hbExhYmVsXSkge1xuICAgICAgICAgICAgcmVmTWFwW25vcm1hbExhYmVsXSA9IGNyZWF0ZVJlZkRlZlN0YXRlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXBbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyAtIHN0YXJ0cG9zO1xuICAgIH07XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5tZXJnZVRleHROb2RlcyA9IGZ1bmN0aW9uICh3YWxrZXIpIHtcbiAgICAgICAgdmFyIGV2ZW50O1xuICAgICAgICB2YXIgdGV4dE5vZGVzID0gW107XG4gICAgICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICAgICAgdmFyIGVudGVyaW5nID0gZXZlbnQuZW50ZXJpbmcsIG5vZGUgPSBldmVudC5ub2RlO1xuICAgICAgICAgICAgaWYgKGVudGVyaW5nICYmIG5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgdGV4dE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ZXh0Tm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGV4dE5vZGVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ZXh0Tm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdE5vZGUgPSB0ZXh0Tm9kZXNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGxhc3ROb2RlID0gdGV4dE5vZGVzW3RleHROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb2RlLnNvdXJjZXBvcyAmJiBsYXN0Tm9kZS5zb3VyY2Vwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb2RlLnNvdXJjZXBvc1sxXSA9IGxhc3ROb2RlLnNvdXJjZXBvc1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlyc3ROb2RlLm5leHQgPSBsYXN0Tm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdE5vZGUubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vZGUubmV4dC5wcmV2ID0gZmlyc3ROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRleHROb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vZGUubGl0ZXJhbCArPSB0ZXh0Tm9kZXNbaV0ubGl0ZXJhbDtcbiAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGVzW2ldLnVubGluaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXh0Tm9kZXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5nZXRSZWZlcmVuY2VEZWZTb3VyY2Vwb3MgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIGxpbmVzID0gYmxvY2suc3RyaW5nQ29udGVudC5zcGxpdCgvXFxufFxcclxcbi8pO1xuICAgICAgICB2YXIgcGFzc2VkVXJsTGluZSA9IGZhbHNlO1xuICAgICAgICB2YXIgcXVvdGF0aW9uQ291bnQgPSAwO1xuICAgICAgICB2YXIgbGFzdExpbmVPZmZzZXQgPSB7IGxpbmU6IDAsIGNoOiAwIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgICAgICAgICBpZiAocmVXaGl0ZXNwYWNlQ2hhci50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL1xcOi8udGVzdChsaW5lKSAmJiBxdW90YXRpb25Db3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXNzZWRVcmxMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGluZU9mZnNldCA9IGxpbmUuaW5kZXhPZignOicpID09PSBsaW5lLmxlbmd0aCAtIDEgPyBpICsgMSA6IGk7XG4gICAgICAgICAgICAgICAgbGFzdExpbmVPZmZzZXQgPSB7IGxpbmU6IGxpbmVPZmZzZXQsIGNoOiBsaW5lc1tsaW5lT2Zmc2V0XS5sZW5ndGggfTtcbiAgICAgICAgICAgICAgICBwYXNzZWRVcmxMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNob3VsZCBjb25zaWRlciBleHRlbmRhYmxlIHRpdGxlXG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IGxpbmUubWF0Y2goLyd8XCIvZyk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIHF1b3RhdGlvbkNvdW50ICs9IG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHF1b3RhdGlvbkNvdW50ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgbGFzdExpbmVPZmZzZXQgPSB7IGxpbmU6IGksIGNoOiBsaW5lLmxlbmd0aCB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbYmxvY2suc291cmNlcG9zWzBdWzBdLCBibG9jay5zb3VyY2Vwb3NbMF1bMV1dLFxuICAgICAgICAgICAgW2Jsb2NrLnNvdXJjZXBvc1swXVswXSArIGxhc3RMaW5lT2Zmc2V0LmxpbmUsIGxhc3RMaW5lT2Zmc2V0LmNoXSxcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIHRoZSBuZXh0IGlubGluZSBlbGVtZW50IGluIHN1YmplY3QsIGFkdmFuY2luZyBzdWJqZWN0IHBvc2l0aW9uLlxuICAgIC8vIE9uIHN1Y2Nlc3MsIGFkZCB0aGUgcmVzdWx0IHRvIGJsb2NrJ3MgY2hpbGRyZW4gYW5kIHJldHVybiB0cnVlLlxuICAgIC8vIE9uIGZhaWx1cmUsIHJldHVybiBmYWxzZS5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlSW5saW5lID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHJlcyA9IGZhbHNlO1xuICAgICAgICB2YXIgYyA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAoYyA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgIGNhc2UgQ19ORVdMSU5FOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VOZXdsaW5lKGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19CQUNLU0xBU0g6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZUJhY2tzbGFzaChibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfQkFDS1RJQ0s6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZUJhY2t0aWNrcyhibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfQVNURVJJU0s6XG4gICAgICAgICAgICBjYXNlIENfVU5ERVJTQ09SRTpcbiAgICAgICAgICAgIGNhc2UgQ19USUxERTpcbiAgICAgICAgICAgIGNhc2UgQ19ET0xMQVI6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5oYW5kbGVEZWxpbShjLCBibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfU0lOR0xFUVVPVEU6XG4gICAgICAgICAgICBjYXNlIENfRE9VQkxFUVVPVEU6XG4gICAgICAgICAgICAgICAgcmVzID0gISEoKF9hID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc21hcnQpICYmIHRoaXMuaGFuZGxlRGVsaW0oYywgYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX09QRU5fQlJBQ0tFVCQxOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VPcGVuQnJhY2tldChibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfQkFORzpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlQmFuZyhibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfQ0xPU0VfQlJBQ0tFVDpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlQ2xvc2VCcmFja2V0KGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19MRVNTVEhBTiQxOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VBdXRvbGluayhibG9jaykgfHwgdGhpcy5wYXJzZUh0bWxUYWcoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0FNUEVSU0FORDpcbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrLmRpc2FibGVkRW50aXR5UGFyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZUVudGl0eShibG9jayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlU3RyaW5nKGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKGVzbV90ZXh0KGZyb21Db2RlUG9pbnQkMShjKSwgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MsIHRoaXMucG9zICsgMSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIHN0cmluZyBjb250ZW50IGluIGJsb2NrIGludG8gaW5saW5lIGNoaWxkcmVuLFxuICAgIC8vIHVzaW5nIHJlZm1hcCB0byByZXNvbHZlIHJlZmVyZW5jZXMuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBibG9jay5zdHJpbmdDb250ZW50LnRyaW0oKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlbGltaXRlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmJyYWNrZXRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5saW5lT2Zmc2V0cyA9IGJsb2NrLmxpbmVPZmZzZXRzIHx8IFswXTtcbiAgICAgICAgdGhpcy5saW5lSWR4ID0gMDtcbiAgICAgICAgdGhpcy5saW5lUG9zT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5saW5lU3RhcnROdW0gPSBibG9jay5zb3VyY2Vwb3NbMF1bMF07XG4gICAgICAgIGlmIChpc0hlYWRpbmcoYmxvY2spKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVPZmZzZXRzWzBdICs9IGJsb2NrLmxldmVsICsgMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5wYXJzZUlubGluZShibG9jaykpIHsgfVxuICAgICAgICBibG9jay5zdHJpbmdDb250ZW50ID0gbnVsbDsgLy8gYWxsb3cgcmF3IHN0cmluZyB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICAgICAgICB0aGlzLnByb2Nlc3NFbXBoYXNpcyhudWxsKTtcbiAgICAgICAgdGhpcy5tZXJnZVRleHROb2RlcyhibG9jay53YWxrZXIoKSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgZXh0ZW5kZWRBdXRvbGlua3MgPSBfYS5leHRlbmRlZEF1dG9saW5rcywgY3VzdG9tUGFyc2VyID0gX2EuY3VzdG9tUGFyc2VyO1xuICAgICAgICBpZiAoZXh0ZW5kZWRBdXRvbGlua3MpIHtcbiAgICAgICAgICAgIGNvbnZlcnRFeHRBdXRvTGlua3MoYmxvY2sud2Fsa2VyKCksIGV4dGVuZGVkQXV0b2xpbmtzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VzdG9tUGFyc2VyICYmIGJsb2NrLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBldmVudF8xO1xuICAgICAgICAgICAgdmFyIHdhbGtlciA9IGJsb2NrLmZpcnN0Q2hpbGQud2Fsa2VyKCk7XG4gICAgICAgICAgICB3aGlsZSAoKGV2ZW50XzEgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gZXZlbnRfMS5ub2RlLCBlbnRlcmluZyA9IGV2ZW50XzEuZW50ZXJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbVBhcnNlcltub2RlLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVBhcnNlcltub2RlLnR5cGVdKG5vZGUsIHsgZW50ZXJpbmc6IGVudGVyaW5nLCBvcHRpb25zOiB0aGlzLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSW5saW5lUGFyc2VyO1xufSgpKTtcbnZhciByZVRhc2tMaXN0SXRlbU1hcmtlciA9IC9eXFxbKFsgXFx0eFhdKVxcXVsgXFx0XSsvO1xuLy8gZmluYWxpemUgZm9yIGJsb2NrIGhhbmRsZXJcbmZ1bmN0aW9uIHRhc2tMaXN0SXRlbUZpbmFsaXplKF8sIGJsb2NrKSB7XG4gICAgaWYgKGJsb2NrLmZpcnN0Q2hpbGQgJiYgYmxvY2suZmlyc3RDaGlsZC50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICB2YXIgcCA9IGJsb2NrLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBtID0gcC5zdHJpbmdDb250ZW50Lm1hdGNoKHJlVGFza0xpc3RJdGVtTWFya2VyKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHZhciBtTGVuID0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICBwLnN0cmluZ0NvbnRlbnQgPSBwLnN0cmluZ0NvbnRlbnQuc3Vic3RyaW5nKG1MZW4gLSAxKTtcbiAgICAgICAgICAgIHAuc291cmNlcG9zWzBdWzFdICs9IG1MZW47XG4gICAgICAgICAgICBwLmxpbmVPZmZzZXRzWzBdICs9IG1MZW47XG4gICAgICAgICAgICBibG9jay5saXN0RGF0YS50YXNrID0gdHJ1ZTtcbiAgICAgICAgICAgIGJsb2NrLmxpc3REYXRhLmNoZWNrZWQgPSAvW3hYXS8udGVzdChtWzFdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciB0YWJsZSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09ICd0YWJsZUhlYWQnIHx8IHQgPT09ICd0YWJsZUJvZHknO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVCb2R5JDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAndGFibGVSb3cnO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVIZWFkJDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09ICd0YWJsZVJvdycgfHwgdCA9PT0gJ3RhYmxlRGVsaW1Sb3cnO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVEZWxpbVJvdyA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gJ3RhYmxlRGVsaW1DZWxsJztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlRGVsaW1DZWxsID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVSb3cgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09ICd0YWJsZUNlbGwnO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVDZWxsID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgQ09ERV9JTkRFTlQgPSA0O1xudmFyIENfVEFCID0gOTtcbnZhciBDX0dSRUFURVJUSEFOID0gNjI7XG52YXIgQ19MRVNTVEhBTiA9IDYwO1xudmFyIENfU1BBQ0UgPSAzMjtcbnZhciBDX09QRU5fQlJBQ0tFVCA9IDkxO1xudmFyIHJlTm9uU3BhY2UgPSAvW14gXFx0XFxmXFx2XFxyXFxuXS87XG52YXIgcmVDbG9zaW5nQ29kZUZlbmNlID0gL14oPzpgezMsfXx+ezMsfSkoPz0gKiQpLztcbi8vIFJldHVybnMgdHJ1ZSBpZiBibG9jayBlbmRzIHdpdGggYSBibGFuayBsaW5lLCBkZXNjZW5kaW5nIGlmIG5lZWRlZFxuLy8gaW50byBsaXN0cyBhbmQgc3VibGlzdHMuXG5mdW5jdGlvbiBlbmRzV2l0aEJsYW5rTGluZShibG9jaykge1xuICAgIHZhciBjdXJCbG9jayA9IGJsb2NrO1xuICAgIHdoaWxlIChjdXJCbG9jaykge1xuICAgICAgICBpZiAoY3VyQmxvY2subGFzdExpbmVCbGFuaykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQgPSBjdXJCbG9jay50eXBlO1xuICAgICAgICBpZiAoIWN1ckJsb2NrLmxhc3RMaW5lQ2hlY2tlZCAmJiAodCA9PT0gJ2xpc3QnIHx8IHQgPT09ICdpdGVtJykpIHtcbiAgICAgICAgICAgIGN1ckJsb2NrLmxhc3RMaW5lQ2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICBjdXJCbG9jayA9IGN1ckJsb2NrLmxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1ckJsb2NrLmxhc3RMaW5lQ2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwZWVrKGxuLCBwb3MpIHtcbiAgICBpZiAocG9zIDwgbG4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBsbi5jaGFyQ29kZUF0KHBvcyk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8vIFJldHVybnMgdHJ1ZSBpZiBzdHJpbmcgY29udGFpbnMgb25seSBzcGFjZSBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gaXNCbGFuayhzKSB7XG4gICAgcmV0dXJuICFyZU5vblNwYWNlLnRlc3Qocyk7XG59XG5mdW5jdGlvbiBpc1NwYWNlT3JUYWIoYykge1xuICAgIHJldHVybiBjID09PSBDX1NQQUNFIHx8IGMgPT09IENfVEFCO1xufVxudmFyIHJlQ2xvc2luZ0N1c3RvbUJsb2NrID0gL15cXCRcXCQkLztcbnZhciBjdXN0b21CbG9jayQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBwYXJzZXIuY3VycmVudExpbmU7XG4gICAgICAgIHZhciBtYXRjaCA9IGxpbmUubWF0Y2gocmVDbG9zaW5nQ3VzdG9tQmxvY2spO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIGNsb3NpbmcgY3VzdG9tIGJsb2NrXG4gICAgICAgICAgICBwYXJzZXIubGFzdExpbmVMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICBwYXJzZXIuZmluYWxpemUoY29udGFpbmVyLCBwYXJzZXIubGluZU51bWJlcik7XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBGaW5pc2hlZCAqLztcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIG9wdGlvbmFsIHNwYWNlcyBvZiBjdXN0b20gYmxvY2sgb2Zmc2V0XG4gICAgICAgIHZhciBpID0gY29udGFpbmVyLm9mZnNldDtcbiAgICAgICAgd2hpbGUgKGkgPiAwICYmIGlzU3BhY2VPclRhYihwZWVrKGxpbmUsIHBhcnNlci5vZmZzZXQpKSkge1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKF8sIGJsb2NrKSB7XG4gICAgICAgIGlmIChibG9jay5zdHJpbmdDb250ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlyc3QgbGluZSBiZWNvbWVzIGluZm8gc3RyaW5nXG4gICAgICAgIHZhciBjb250ZW50ID0gYmxvY2suc3RyaW5nQ29udGVudDtcbiAgICAgICAgdmFyIG5ld2xpbmVQb3MgPSBjb250ZW50LmluZGV4T2YoJ1xcbicpO1xuICAgICAgICB2YXIgZmlyc3RMaW5lID0gY29udGVudC5zbGljZSgwLCBuZXdsaW5lUG9zKTtcbiAgICAgICAgdmFyIHJlc3QgPSBjb250ZW50LnNsaWNlKG5ld2xpbmVQb3MgKyAxKTtcbiAgICAgICAgdmFyIGluZm9TdHJpbmcgPSBmaXJzdExpbmUubWF0Y2goL14oXFxzKikoLiopLyk7XG4gICAgICAgIGJsb2NrLmluZm8gPSB1bmVzY2FwZVN0cmluZyhpbmZvU3RyaW5nWzJdLnRyaW0oKSk7XG4gICAgICAgIGJsb2NrLmxpdGVyYWwgPSByZXN0O1xuICAgICAgICBibG9jay5zdHJpbmdDb250ZW50ID0gbnVsbDtcbiAgICB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiB0cnVlLFxufTtcbnZhciBub29wID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiB0cnVlLFxufTtcbnZhciBkb2N1bWVudCQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCAhPT0gJ2l0ZW0nO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgbGlzdCA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoXywgYmxvY2spIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBibG9jay5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAoaXRlbSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG5vbi1maW5hbCBsaXN0IGl0ZW0gZW5kaW5nIHdpdGggYmxhbmsgbGluZTpcbiAgICAgICAgICAgIGlmIChlbmRzV2l0aEJsYW5rTGluZShpdGVtKSAmJiBpdGVtLm5leHQpIHtcbiAgICAgICAgICAgICAgICBibG9jay5saXN0RGF0YS50aWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVjdXJzZSBpbnRvIGNoaWxkcmVuIG9mIGxpc3QgaXRlbSwgdG8gc2VlIGlmIHRoZXJlIGFyZVxuICAgICAgICAgICAgLy8gc3BhY2VzIGJldHdlZW4gYW55IG9mIHRoZW06XG4gICAgICAgICAgICB2YXIgc3ViaXRlbSA9IGl0ZW0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChzdWJpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZHNXaXRoQmxhbmtMaW5lKHN1Yml0ZW0pICYmIChpdGVtLm5leHQgfHwgc3ViaXRlbS5uZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBibG9jay5saXN0RGF0YS50aWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ViaXRlbSA9IHN1Yml0ZW0ubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLm5leHQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAnaXRlbSc7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciBibG9ja1F1b3RlJDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICAgICAgdmFyIGxuID0gcGFyc2VyLmN1cnJlbnRMaW5lO1xuICAgICAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJiBwZWVrKGxuLCBwYXJzZXIubmV4dE5vbnNwYWNlKSA9PT0gQ19HUkVBVEVSVEhBTikge1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChpc1NwYWNlT3JUYWIocGVlayhsbiwgcGFyc2VyLm9mZnNldCkpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCAhPT0gJ2l0ZW0nO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgaXRlbSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChwYXJzZXIuYmxhbmspIHtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuZmlyc3RDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEJsYW5rIGxpbmUgYWZ0ZXIgZW1wdHkgbGlzdCBpdGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyc2VyLmluZGVudCA+PSBjb250YWluZXIubGlzdERhdGEubWFya2VyT2Zmc2V0ICsgY29udGFpbmVyLmxpc3REYXRhLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KGNvbnRhaW5lci5saXN0RGF0YS5tYXJrZXJPZmZzZXQgKyBjb250YWluZXIubGlzdERhdGEucGFkZGluZywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IHRhc2tMaXN0SXRlbUZpbmFsaXplLFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ICE9PSAnaXRlbSc7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciBoZWFkaW5nID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGEgaGVhZGluZyBjYW4gbmV2ZXIgY29udGFpbmVyID4gMSBsaW5lLCBzbyBmYWlsIHRvIG1hdGNoOlxuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRoZW1hdGljQnJlYWskMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhIHRoZW1hdGljIGJyZWFrIGNhbiBuZXZlciBjb250YWluZXIgPiAxIGxpbmUsIHNvIGZhaWwgdG8gbWF0Y2g6XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgY29kZUJsb2NrID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGxuID0gcGFyc2VyLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgaW5kZW50ID0gcGFyc2VyLmluZGVudDtcbiAgICAgICAgaWYgKGNvbnRhaW5lci5pc0ZlbmNlZCkge1xuICAgICAgICAgICAgLy8gZmVuY2VkXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBpbmRlbnQgPD0gMyAmJlxuICAgICAgICAgICAgICAgIGxuLmNoYXJBdChwYXJzZXIubmV4dE5vbnNwYWNlKSA9PT0gY29udGFpbmVyLmZlbmNlQ2hhciAmJlxuICAgICAgICAgICAgICAgIGxuLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpLm1hdGNoKHJlQ2xvc2luZ0NvZGVGZW5jZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMF0ubGVuZ3RoID49IGNvbnRhaW5lci5mZW5jZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGNsb3NpbmcgZmVuY2UgLSB3ZSdyZSBhdCBlbmQgb2YgbGluZSwgc28gd2UgY2FuIHJldHVyblxuICAgICAgICAgICAgICAgIHBhcnNlci5sYXN0TGluZUxlbmd0aCA9IHBhcnNlci5vZmZzZXQgKyBpbmRlbnQgKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmZpbmFsaXplKGNvbnRhaW5lciwgcGFyc2VyLmxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIEZpbmlzaGVkICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2tpcCBvcHRpb25hbCBzcGFjZXMgb2YgZmVuY2Ugb2Zmc2V0XG4gICAgICAgICAgICB2YXIgaSA9IGNvbnRhaW5lci5mZW5jZU9mZnNldDtcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCAmJiBpc1NwYWNlT3JUYWIocGVlayhsbiwgcGFyc2VyLm9mZnNldCkpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5kZW50ZWRcbiAgICAgICAgICAgIGlmIChpbmRlbnQgPj0gQ09ERV9JTkRFTlQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChDT0RFX0lOREVOVCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJzZXIuYmxhbmspIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoXywgYmxvY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoYmxvY2suc3RyaW5nQ29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9jay5pc0ZlbmNlZCkge1xuICAgICAgICAgICAgLy8gZmVuY2VkXG4gICAgICAgICAgICAvLyBmaXJzdCBsaW5lIGJlY29tZXMgaW5mbyBzdHJpbmdcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gYmxvY2suc3RyaW5nQ29udGVudDtcbiAgICAgICAgICAgIHZhciBuZXdsaW5lUG9zID0gY29udGVudC5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgICAgIHZhciBmaXJzdExpbmUgPSBjb250ZW50LnNsaWNlKDAsIG5ld2xpbmVQb3MpO1xuICAgICAgICAgICAgdmFyIHJlc3QgPSBjb250ZW50LnNsaWNlKG5ld2xpbmVQb3MgKyAxKTtcbiAgICAgICAgICAgIHZhciBpbmZvU3RyaW5nID0gZmlyc3RMaW5lLm1hdGNoKC9eKFxccyopKC4qKS8pO1xuICAgICAgICAgICAgYmxvY2suaW5mb1BhZGRpbmcgPSBpbmZvU3RyaW5nWzFdLmxlbmd0aDtcbiAgICAgICAgICAgIGJsb2NrLmluZm8gPSB1bmVzY2FwZVN0cmluZyhpbmZvU3RyaW5nWzJdLnRyaW0oKSk7XG4gICAgICAgICAgICBibG9jay5saXRlcmFsID0gcmVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluZGVudGVkXG4gICAgICAgICAgICBibG9jay5saXRlcmFsID0gKF9hID0gYmxvY2suc3RyaW5nQ29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2UoLyhcXG4gKikrJC8sICdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICBibG9jay5zdHJpbmdDb250ZW50ID0gbnVsbDsgLy8gYWxsb3cgR0NcbiAgICB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiB0cnVlLFxufTtcbnZhciBodG1sQmxvY2skMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBwYXJzZXIuYmxhbmsgJiYgKGNvbnRhaW5lci5odG1sQmxvY2tUeXBlID09PSA2IHx8IGNvbnRhaW5lci5odG1sQmxvY2tUeXBlID09PSA3KVxuICAgICAgICAgICAgPyAxIC8qIFN0b3AgKi9cbiAgICAgICAgICAgIDogMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoXywgYmxvY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBibG9jay5saXRlcmFsID0gKChfYSA9IGJsb2NrLnN0cmluZ0NvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKC8oXFxuICopKyQvLCAnJykpIHx8IG51bGw7XG4gICAgICAgIGJsb2NrLnN0cmluZ0NvbnRlbnQgPSBudWxsOyAvLyBhbGxvdyBHQ1xuICAgIH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IHRydWUsXG59O1xudmFyIHBhcmFncmFwaCA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlcikge1xuICAgICAgICByZXR1cm4gcGFyc2VyLmJsYW5rID8gMSAvKiBTdG9wICovIDogMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAocGFyc2VyLCBibG9jaykge1xuICAgICAgICBpZiAoYmxvY2suc3RyaW5nQ29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb3M7XG4gICAgICAgIHZhciBoYXNSZWZlcmVuY2VEZWZzID0gZmFsc2U7XG4gICAgICAgIC8vIHRyeSBwYXJzaW5nIHRoZSBiZWdpbm5pbmcgYXMgbGluayByZWZlcmVuY2UgZGVmaW5pdGlvbnM6XG4gICAgICAgIHdoaWxlIChwZWVrKGJsb2NrLnN0cmluZ0NvbnRlbnQsIDApID09PSBDX09QRU5fQlJBQ0tFVCAmJlxuICAgICAgICAgICAgKHBvcyA9IHBhcnNlci5pbmxpbmVQYXJzZXIucGFyc2VSZWZlcmVuY2UoYmxvY2ssIHBhcnNlci5yZWZNYXApKSkge1xuICAgICAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQuc2xpY2UocG9zKTtcbiAgICAgICAgICAgIGhhc1JlZmVyZW5jZURlZnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNSZWZlcmVuY2VEZWZzICYmIGlzQmxhbmsoYmxvY2suc3RyaW5nQ29udGVudCkpIHtcbiAgICAgICAgICAgIGJsb2NrLnVubGluaygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG52YXIgcmVmRGVmID0gbm9vcDtcbnZhciBmcm9udE1hdHRlciQyID0gbm9vcDtcbnZhciBibG9ja0hhbmRsZXJzID0ge1xuICAgIGRvY3VtZW50OiBkb2N1bWVudCQxLFxuICAgIGxpc3Q6IGxpc3QsXG4gICAgYmxvY2tRdW90ZTogYmxvY2tRdW90ZSQxLFxuICAgIGl0ZW06IGl0ZW0sXG4gICAgaGVhZGluZzogaGVhZGluZyxcbiAgICB0aGVtYXRpY0JyZWFrOiB0aGVtYXRpY0JyZWFrJDEsXG4gICAgY29kZUJsb2NrOiBjb2RlQmxvY2ssXG4gICAgaHRtbEJsb2NrOiBodG1sQmxvY2skMSxcbiAgICBwYXJhZ3JhcGg6IHBhcmFncmFwaCxcbiAgICB0YWJsZTogdGFibGUsXG4gICAgdGFibGVCb2R5OiB0YWJsZUJvZHkkMSxcbiAgICB0YWJsZUhlYWQ6IHRhYmxlSGVhZCQxLFxuICAgIHRhYmxlUm93OiB0YWJsZVJvdyxcbiAgICB0YWJsZUNlbGw6IHRhYmxlQ2VsbCxcbiAgICB0YWJsZURlbGltUm93OiB0YWJsZURlbGltUm93LFxuICAgIHRhYmxlRGVsaW1DZWxsOiB0YWJsZURlbGltQ2VsbCxcbiAgICByZWZEZWY6IHJlZkRlZixcbiAgICBjdXN0b21CbG9jazogY3VzdG9tQmxvY2skMSxcbiAgICBmcm9udE1hdHRlcjogZnJvbnRNYXR0ZXIkMixcbn07XG5mdW5jdGlvbiBwYXJzZVJvd0NvbnRlbnQoY29udGVudCkge1xuICAgIHZhciBzdGFydElkeCA9IDA7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIGNlbGxzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChjb250ZW50W2ldID09PSAnfCcgJiYgY29udGVudFtpIC0gMV0gIT09ICdcXFxcJykge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSBjb250ZW50LnN1YnN0cmluZyhzdGFydElkeCwgaSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRJZHggPT09IDAgJiYgaXNFbXB0eShjZWxsKSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbHMucHVzaChjZWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0SWR4ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0SWR4IDwgY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNlbGwgPSBjb250ZW50LnN1YnN0cmluZyhzdGFydElkeCwgY29udGVudC5sZW5ndGgpO1xuICAgICAgICBpZiAoIWlzRW1wdHkoY2VsbCkpIHtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goY2VsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtvZmZzZXQsIGNlbGxzXTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVGFibGVDZWxscyhjZWxsVHlwZSwgY29udGVudHMsIGxpbmVOdW0sIGNoUG9zKSB7XG4gICAgdmFyIGNlbGxzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBjb250ZW50c18xID0gY29udGVudHM7IF9pIDwgY29udGVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBjb250ZW50c18xW19pXTtcbiAgICAgICAgdmFyIHByZVNwYWNlcyA9IGNvbnRlbnQubWF0Y2goL15bIFxcdF0rLyk7XG4gICAgICAgIHZhciBwYWRkaW5nTGVmdCA9IHByZVNwYWNlcyA/IHByZVNwYWNlc1swXS5sZW5ndGggOiAwO1xuICAgICAgICB2YXIgcGFkZGluZ1JpZ2h0ID0gdm9pZCAwLCB0cmltbWVkID0gdm9pZCAwO1xuICAgICAgICBpZiAocGFkZGluZ0xlZnQgPT09IGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYWRkaW5nTGVmdCA9IDA7XG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQgPSAwO1xuICAgICAgICAgICAgdHJpbW1lZCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBvc3RTcGFjZXMgPSBjb250ZW50Lm1hdGNoKC9bIFxcdF0rJC8pO1xuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gcG9zdFNwYWNlcyA/IHBvc3RTcGFjZXNbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgIHRyaW1tZWQgPSBjb250ZW50LnNsaWNlKHBhZGRpbmdMZWZ0LCBjb250ZW50Lmxlbmd0aCAtIHBhZGRpbmdSaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoUG9zU3RhcnQgPSBjaFBvcyArIHBhZGRpbmdMZWZ0O1xuICAgICAgICB2YXIgdGFibGVDZWxsID0gY3JlYXRlTm9kZShjZWxsVHlwZSwgW1xuICAgICAgICAgICAgW2xpbmVOdW0sIGNoUG9zXSxcbiAgICAgICAgICAgIFtsaW5lTnVtLCBjaFBvcyArIGNvbnRlbnQubGVuZ3RoIC0gMV0sXG4gICAgICAgIF0pO1xuICAgICAgICB0YWJsZUNlbGwuc3RyaW5nQ29udGVudCA9IHRyaW1tZWQucmVwbGFjZSgvXFxcXFxcfC9nLCAnfCcpOyAvLyByZXBsYWNlIGVzYWNwZWQgcGlwZShcXHwpXG4gICAgICAgIHRhYmxlQ2VsbC5zdGFydElkeCA9IGNlbGxzLmxlbmd0aDtcbiAgICAgICAgdGFibGVDZWxsLmVuZElkeCA9IGNlbGxzLmxlbmd0aDtcbiAgICAgICAgdGFibGVDZWxsLmxpbmVPZmZzZXRzID0gW2NoUG9zU3RhcnQgLSAxXTtcbiAgICAgICAgdGFibGVDZWxsLnBhZGRpbmdMZWZ0ID0gcGFkZGluZ0xlZnQ7XG4gICAgICAgIHRhYmxlQ2VsbC5wYWRkaW5nUmlnaHQgPSBwYWRkaW5nUmlnaHQ7XG4gICAgICAgIGNlbGxzLnB1c2godGFibGVDZWxsKTtcbiAgICAgICAgY2hQb3MgKz0gY29udGVudC5sZW5ndGggKyAxO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbHM7XG59XG5mdW5jdGlvbiBnZXRDb2x1bW5Gcm9tRGVsaW1DZWxsKGNlbGxOb2RlKSB7XG4gICAgdmFyIGFsaWduID0gbnVsbDtcbiAgICB2YXIgY29udGVudCA9IGNlbGxOb2RlLnN0cmluZ0NvbnRlbnQ7XG4gICAgdmFyIGZpcnN0Q2ggPSBjb250ZW50WzBdO1xuICAgIHZhciBsYXN0Q2ggPSBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RDaCA9PT0gJzonKSB7XG4gICAgICAgIGFsaWduID0gZmlyc3RDaCA9PT0gJzonID8gJ2NlbnRlcicgOiAncmlnaHQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdENoID09PSAnOicpIHtcbiAgICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgfVxuICAgIHJldHVybiB7IGFsaWduOiBhbGlnbiB9O1xufVxudmFyIHRhYmxlSGVhZCA9IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIHZhciBzdHJpbmdDb250ZW50ID0gY29udGFpbmVyLnN0cmluZ0NvbnRlbnQ7XG4gICAgaWYgKGNvbnRhaW5lci50eXBlID09PSAncGFyYWdyYXBoJyAmJiAhcGFyc2VyLmluZGVudGVkICYmICFwYXJzZXIuYmxhbmspIHtcbiAgICAgICAgdmFyIGxhc3ROZXdMaW5lSWR4ID0gc3RyaW5nQ29udGVudC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgbGFzdExpbmVTdGFydElkeCA9IHN0cmluZ0NvbnRlbnQubGFzdEluZGV4T2YoJ1xcbicsIGxhc3ROZXdMaW5lSWR4IC0gMSkgKyAxO1xuICAgICAgICB2YXIgaGVhZGVyQ29udGVudCA9IHN0cmluZ0NvbnRlbnQuc2xpY2UobGFzdExpbmVTdGFydElkeCwgbGFzdE5ld0xpbmVJZHgpO1xuICAgICAgICB2YXIgZGVsaW1Db250ZW50ID0gcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICB2YXIgX2EgPSBwYXJzZVJvd0NvbnRlbnQoaGVhZGVyQ29udGVudCksIGhlYWRlck9mZnNldCA9IF9hWzBdLCBoZWFkZXJDZWxscyA9IF9hWzFdO1xuICAgICAgICB2YXIgX2IgPSBwYXJzZVJvd0NvbnRlbnQoZGVsaW1Db250ZW50KSwgZGVsaW1PZmZzZXQgPSBfYlswXSwgZGVsaW1DZWxscyA9IF9iWzFdO1xuICAgICAgICB2YXIgcmVWYWxpZERlbGltQ2VsbF8xID0gL15bIFxcdF0qOj8tKzo/WyBcXHRdKiQvO1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBjaGVja2luZyBpZiB0aGUgbnVtYmVyIG9mIGhlYWRlciBjZWxscyBhbmQgZGVsaW1pdGVyIGNlbGxzIGFyZSB0aGUgc2FtZVxuICAgICAgICAvLyB0byBjb25zaWRlciB0aGUgY2FzZSBvZiBtZXJnZWQtY29sdW1uICh2aWEgcGx1Z2luKVxuICAgICAgICAhaGVhZGVyQ2VsbHMubGVuZ3RoIHx8XG4gICAgICAgICAgICAhZGVsaW1DZWxscy5sZW5ndGggfHxcbiAgICAgICAgICAgIGRlbGltQ2VsbHMuc29tZShmdW5jdGlvbiAoY2VsbCkgeyByZXR1cm4gIXJlVmFsaWREZWxpbUNlbGxfMS50ZXN0KGNlbGwpOyB9KSB8fFxuICAgICAgICAgICAgLy8gdG8gcHJldmVudCB0byByZWdhcmQgc2V0VGV4dEhlYWRpbmcgYXMgdGFiZWwgZGVsaW0gY2VsbCB3aXRoICdkaXNhbGxvd0RlZXBIZWFkaW5nJyBvcHRpb25cbiAgICAgICAgICAgIChkZWxpbUNlbGxzLmxlbmd0aCA9PT0gMSAmJiBkZWxpbUNvbnRlbnQuaW5kZXhPZignfCcpICE9PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZU9mZnNldHMgPSBjb250YWluZXIubGluZU9mZnNldHM7XG4gICAgICAgIHZhciBmaXJzdExpbmVOdW0gPSBwYXJzZXIubGluZU51bWJlciAtIDE7XG4gICAgICAgIHZhciBmaXJzdExpbmVTdGFydCA9IGxhc3QobGluZU9mZnNldHMpICsgMTtcbiAgICAgICAgdmFyIHRhYmxlID0gY3JlYXRlTm9kZSgndGFibGUnLCBbXG4gICAgICAgICAgICBbZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydF0sXG4gICAgICAgICAgICBbcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5vZmZzZXRdLFxuICAgICAgICBdKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcbiAgICAgICAgdGFibGUuY29sdW1ucyA9IGRlbGltQ2VsbHMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7IGFsaWduOiBudWxsIH0pOyB9KTtcbiAgICAgICAgY29udGFpbmVyLmluc2VydEFmdGVyKHRhYmxlKTtcbiAgICAgICAgaWYgKGxpbmVPZmZzZXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29udGFpbmVyLnVubGluaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVyLnN0cmluZ0NvbnRlbnQgPSBzdHJpbmdDb250ZW50LnNsaWNlKDAsIGxhc3RMaW5lU3RhcnRJZHgpO1xuICAgICAgICAgICAgdmFyIHBhcmFMYXN0TGluZVN0YXJ0SWR4ID0gc3RyaW5nQ29udGVudC5sYXN0SW5kZXhPZignXFxuJywgbGFzdExpbmVTdGFydElkeCAtIDIpICsgMTtcbiAgICAgICAgICAgIHZhciBwYXJhTGFzdExpbmVMZW4gPSBsYXN0TGluZVN0YXJ0SWR4IC0gcGFyYUxhc3RMaW5lU3RhcnRJZHggLSAxO1xuICAgICAgICAgICAgcGFyc2VyLmxhc3RMaW5lTGVuZ3RoID0gbGluZU9mZnNldHNbbGluZU9mZnNldHMubGVuZ3RoIC0gMl0gKyBwYXJhTGFzdExpbmVMZW47XG4gICAgICAgICAgICBwYXJzZXIuZmluYWxpemUoY29udGFpbmVyLCBmaXJzdExpbmVOdW0gLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChwYXJzZXIuY3VycmVudExpbmUubGVuZ3RoIC0gcGFyc2VyLm9mZnNldCwgZmFsc2UpO1xuICAgICAgICB2YXIgdGFibGVIZWFkXzEgPSBjcmVhdGVOb2RlKCd0YWJsZUhlYWQnLCBbXG4gICAgICAgICAgICBbZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydF0sXG4gICAgICAgICAgICBbcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5vZmZzZXRdLFxuICAgICAgICBdKTtcbiAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQodGFibGVIZWFkXzEpO1xuICAgICAgICB2YXIgdGFibGVIZWFkUm93XzEgPSBjcmVhdGVOb2RlKCd0YWJsZVJvdycsIFtcbiAgICAgICAgICAgIFtmaXJzdExpbmVOdW0sIGZpcnN0TGluZVN0YXJ0XSxcbiAgICAgICAgICAgIFtmaXJzdExpbmVOdW0sIGZpcnN0TGluZVN0YXJ0ICsgaGVhZGVyQ29udGVudC5sZW5ndGggLSAxXSxcbiAgICAgICAgXSk7XG4gICAgICAgIHZhciB0YWJsZURlbGltUm93XzEgPSBjcmVhdGVOb2RlKCd0YWJsZURlbGltUm93JywgW1xuICAgICAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIubmV4dE5vbnNwYWNlICsgMV0sXG4gICAgICAgICAgICBbcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5vZmZzZXRdLFxuICAgICAgICBdKTtcbiAgICAgICAgdGFibGVIZWFkXzEuYXBwZW5kQ2hpbGQodGFibGVIZWFkUm93XzEpO1xuICAgICAgICB0YWJsZUhlYWRfMS5hcHBlbmRDaGlsZCh0YWJsZURlbGltUm93XzEpO1xuICAgICAgICBnZW5lcmF0ZVRhYmxlQ2VsbHMoJ3RhYmxlQ2VsbCcsIGhlYWRlckNlbGxzLCBmaXJzdExpbmVOdW0sIGZpcnN0TGluZVN0YXJ0ICsgaGVhZGVyT2Zmc2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsTm9kZSkge1xuICAgICAgICAgICAgdGFibGVIZWFkUm93XzEuYXBwZW5kQ2hpbGQoY2VsbE5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRlbGltQ2VsbE5vZGVzID0gZ2VuZXJhdGVUYWJsZUNlbGxzKCd0YWJsZURlbGltQ2VsbCcsIGRlbGltQ2VsbHMsIHBhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIubmV4dE5vbnNwYWNlICsgMSArIGRlbGltT2Zmc2V0KTtcbiAgICAgICAgZGVsaW1DZWxsTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoY2VsbE5vZGUpIHtcbiAgICAgICAgICAgIHRhYmxlRGVsaW1Sb3dfMS5hcHBlbmRDaGlsZChjZWxsTm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0YWJsZS5jb2x1bW5zID0gZGVsaW1DZWxsTm9kZXMubWFwKGdldENvbHVtbkZyb21EZWxpbUNlbGwpO1xuICAgICAgICBwYXJzZXIudGlwID0gdGFibGU7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIHRhYmxlQm9keSA9IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIGlmICgoY29udGFpbmVyLnR5cGUgIT09ICd0YWJsZScgJiYgY29udGFpbmVyLnR5cGUgIT09ICd0YWJsZUJvZHknKSB8fFxuICAgICAgICAoIXBhcnNlci5ibGFuayAmJiBwYXJzZXIuY3VycmVudExpbmUuaW5kZXhPZignfCcpID09PSAtMSkpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICB9XG4gICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQocGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aCAtIHBhcnNlci5vZmZzZXQsIGZhbHNlKTtcbiAgICBpZiAocGFyc2VyLmJsYW5rKSB7XG4gICAgICAgIHZhciB0YWJsZV8xID0gY29udGFpbmVyO1xuICAgICAgICBpZiAoY29udGFpbmVyLnR5cGUgPT09ICd0YWJsZUJvZHknKSB7XG4gICAgICAgICAgICB0YWJsZV8xID0gY29udGFpbmVyLnBhcmVudDtcbiAgICAgICAgICAgIHBhcnNlci5maW5hbGl6ZShjb250YWluZXIsIHBhcnNlci5saW5lTnVtYmVyIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLmZpbmFsaXplKHRhYmxlXzEsIHBhcnNlci5saW5lTnVtYmVyIC0gMSk7XG4gICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIHZhciB0YWJsZUJvZHkgPSBjb250YWluZXI7XG4gICAgaWYgKGNvbnRhaW5lci50eXBlID09PSAndGFibGUnKSB7XG4gICAgICAgIHRhYmxlQm9keSA9IHBhcnNlci5hZGRDaGlsZCgndGFibGVCb2R5JywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIHRhYmxlQm9keS5zdHJpbmdDb250ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHRhYmxlUm93ID0gY3JlYXRlTm9kZSgndGFibGVSb3cnLCBbXG4gICAgICAgIFtwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLm5leHROb25zcGFjZSArIDFdLFxuICAgICAgICBbcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5jdXJyZW50TGluZS5sZW5ndGhdLFxuICAgIF0pO1xuICAgIHRhYmxlQm9keS5hcHBlbmRDaGlsZCh0YWJsZVJvdyk7XG4gICAgdmFyIHRhYmxlID0gdGFibGVCb2R5LnBhcmVudDtcbiAgICB2YXIgY29udGVudCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICB2YXIgX2EgPSBwYXJzZVJvd0NvbnRlbnQoY29udGVudCksIG9mZnNldCA9IF9hWzBdLCBjZWxsQ29udGVudHMgPSBfYVsxXTtcbiAgICBnZW5lcmF0ZVRhYmxlQ2VsbHMoJ3RhYmxlQ2VsbCcsIGNlbGxDb250ZW50cywgcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5uZXh0Tm9uc3BhY2UgKyAxICsgb2Zmc2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsTm9kZSwgaWR4KSB7XG4gICAgICAgIGlmIChpZHggPj0gdGFibGUuY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNlbGxOb2RlLmlnbm9yZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlUm93LmFwcGVuZENoaWxkKGNlbGxOb2RlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gMiAvKiBMZWFmICovO1xufTtcbnZhciByZUN1c3RvbUJsb2NrID0gL14oXFwkXFwkKShcXHMqW2EtekEtWl0pKy87XG52YXIgcmVDYW5CZUN1c3RvbUlubGluZSA9IC9eKFxcJFxcJCkoXFxzKlthLXpBLVpdKSsuKihcXCRcXCQpLztcbnZhciBjdXN0b21CbG9jayA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICB2YXIgbWF0Y2g7XG4gICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiZcbiAgICAgICAgIXJlQ2FuQmVDdXN0b21JbmxpbmUudGVzdChwYXJzZXIuY3VycmVudExpbmUpICYmXG4gICAgICAgIChtYXRjaCA9IHBhcnNlci5jdXJyZW50TGluZS5tYXRjaChyZUN1c3RvbUJsb2NrKSkpIHtcbiAgICAgICAgdmFyIHN5bnRheExlbmd0aCA9IG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBwYXJzZXIuYWRkQ2hpbGQoJ2N1c3RvbUJsb2NrJywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIGNvbnRhaW5lci5zeW50YXhMZW5ndGggPSBzeW50YXhMZW5ndGg7XG4gICAgICAgIGNvbnRhaW5lci5vZmZzZXQgPSBwYXJzZXIuaW5kZW50O1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChzeW50YXhMZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgcmVDb2RlRmVuY2UgPSAvXmB7Myx9KD8hLipgKXxefnszLH0vO1xudmFyIHJlSHRtbEJsb2NrT3BlbiA9IFtcbiAgICAvLi8sXG4gICAgL148KD86c2NyaXB0fHByZXxzdHlsZSkoPzpcXHN8PnwkKS9pLFxuICAgIC9ePCEtLS8sXG4gICAgL148Wz9dLyxcbiAgICAvXjwhW0EtWl0vLFxuICAgIC9ePCFcXFtDREFUQVxcWy8sXG4gICAgL148Wy9dPyg/OmFkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9ufGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8Zm9ybXxmcmFtZXxmcmFtZXNldHxoWzEyMzQ1Nl18aGVhZHxoZWFkZXJ8aHJ8aHRtbHxpZnJhbWV8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG5hdnxub2ZyYW1lc3xvbHxvcHRncm91cHxvcHRpb258cHxwYXJhbXxzZWN0aW9ufHNvdXJjZXxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlfHRyfHRyYWNrfHVsKSg/Olxcc3xbL10/Wz5dfCQpL2ksXG4gICAgbmV3IFJlZ0V4cChcIl4oPzpcIiArIE9QRU5UQUcgKyBcInxcIiArIENMT1NFVEFHICsgXCIpXFxcXHMqJFwiLCAnaScpLFxuXTtcbnZhciByZVNldGV4dEhlYWRpbmdMaW5lID0gL14oPzo9K3wtKylbIFxcdF0qJC87XG52YXIgcmVBVFhIZWFkaW5nTWFya2VyID0gL14jezEsNn0oPzpbIFxcdF0rfCQpLztcbnZhciByZVRoZW1hdGljQnJlYWsgPSAvXig/Oig/OlxcKlsgXFx0XSopezMsfXwoPzpfWyBcXHRdKil7Myx9fCg/Oi1bIFxcdF0qKXszLH0pWyBcXHRdKiQvO1xudmFyIHJlQnVsbGV0TGlzdE1hcmtlciA9IC9eWyorLV0vO1xudmFyIHJlT3JkZXJlZExpc3RNYXJrZXIgPSAvXihcXGR7MSw5fSkoWy4pXSkvO1xuLy8gUGFyc2UgYSBsaXN0IG1hcmtlciBhbmQgcmV0dXJuIGRhdGEgb24gdGhlIG1hcmtlciAodHlwZSxcbi8vIHN0YXJ0LCBkZWxpbWl0ZXIsIGJ1bGxldCBjaGFyYWN0ZXIsIHBhZGRpbmcpIG9yIG51bGwuXG5mdW5jdGlvbiBwYXJzZUxpc3RNYXJrZXIocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgcmVzdCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICB2YXIgbWF0Y2g7XG4gICAgdmFyIG5leHRjO1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgICB0eXBlOiAnYnVsbGV0JyxcbiAgICAgICAgdGlnaHQ6IHRydWUsXG4gICAgICAgIGJ1bGxldENoYXI6ICcnLFxuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZGVsaW1pdGVyOiAnJyxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgbWFya2VyT2Zmc2V0OiBwYXJzZXIuaW5kZW50LFxuICAgICAgICAvLyBHRk06IFRhc2sgTGlzdCBJdGVtXG4gICAgICAgIHRhc2s6IGZhbHNlLFxuICAgICAgICBjaGVja2VkOiBmYWxzZSxcbiAgICB9O1xuICAgIGlmIChwYXJzZXIuaW5kZW50ID49IDQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSByZXN0Lm1hdGNoKHJlQnVsbGV0TGlzdE1hcmtlcikpKSB7XG4gICAgICAgIGRhdGEudHlwZSA9ICdidWxsZXQnO1xuICAgICAgICBkYXRhLmJ1bGxldENoYXIgPSBtYXRjaFswXVswXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG1hdGNoID0gcmVzdC5tYXRjaChyZU9yZGVyZWRMaXN0TWFya2VyKSkgJiZcbiAgICAgICAgKGNvbnRhaW5lci50eXBlICE9PSAncGFyYWdyYXBoJyB8fCBtYXRjaFsxXSA9PT0gJzEnKSkge1xuICAgICAgICBkYXRhLnR5cGUgPSAnb3JkZXJlZCc7XG4gICAgICAgIGRhdGEuc3RhcnQgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICBkYXRhLmRlbGltaXRlciA9IG1hdGNoWzJdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHNwYWNlcyBhZnRlclxuICAgIG5leHRjID0gcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5uZXh0Tm9uc3BhY2UgKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgIGlmICghKG5leHRjID09PSAtMSB8fCBuZXh0YyA9PT0gQ19UQUIgfHwgbmV4dGMgPT09IENfU1BBQ0UpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBpZiBpdCBpbnRlcnJ1cHRzIHBhcmFncmFwaCwgbWFrZSBzdXJlIGZpcnN0IGxpbmUgaXNuJ3QgYmxhbmtcbiAgICBpZiAoY29udGFpbmVyLnR5cGUgPT09ICdwYXJhZ3JhcGgnICYmXG4gICAgICAgICFwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSArIG1hdGNoWzBdLmxlbmd0aCkubWF0Y2gocmVOb25TcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIHdlJ3ZlIGdvdCBhIG1hdGNoISBhZHZhbmNlIG9mZnNldCBhbmQgY2FsY3VsYXRlIHBhZGRpbmdcbiAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpOyAvLyB0byBzdGFydCBvZiBtYXJrZXJcbiAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChtYXRjaFswXS5sZW5ndGgsIHRydWUpOyAvLyB0byBlbmQgb2YgbWFya2VyXG4gICAgdmFyIHNwYWNlc1N0YXJ0Q29sID0gcGFyc2VyLmNvbHVtbjtcbiAgICB2YXIgc3BhY2VzU3RhcnRPZmZzZXQgPSBwYXJzZXIub2Zmc2V0O1xuICAgIGRvIHtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgIG5leHRjID0gcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5vZmZzZXQpO1xuICAgIH0gd2hpbGUgKHBhcnNlci5jb2x1bW4gLSBzcGFjZXNTdGFydENvbCA8IDUgJiYgaXNTcGFjZU9yVGFiKG5leHRjKSk7XG4gICAgdmFyIGJsYW5rSXRlbSA9IHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIub2Zmc2V0KSA9PT0gLTE7XG4gICAgdmFyIHNwYWNlc0FmdGVyTWFya2VyID0gcGFyc2VyLmNvbHVtbiAtIHNwYWNlc1N0YXJ0Q29sO1xuICAgIGlmIChzcGFjZXNBZnRlck1hcmtlciA+PSA1IHx8IHNwYWNlc0FmdGVyTWFya2VyIDwgMSB8fCBibGFua0l0ZW0pIHtcbiAgICAgICAgZGF0YS5wYWRkaW5nID0gbWF0Y2hbMF0ubGVuZ3RoICsgMTtcbiAgICAgICAgcGFyc2VyLmNvbHVtbiA9IHNwYWNlc1N0YXJ0Q29sO1xuICAgICAgICBwYXJzZXIub2Zmc2V0ID0gc3BhY2VzU3RhcnRPZmZzZXQ7XG4gICAgICAgIGlmIChpc1NwYWNlT3JUYWIocGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5vZmZzZXQpKSkge1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGEucGFkZGluZyA9IG1hdGNoWzBdLmxlbmd0aCArIHNwYWNlc0FmdGVyTWFya2VyO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbi8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIGxpc3QgaXRlbXMgYXJlIG9mIHRoZSBzYW1lIHR5cGUsXG4vLyB3aXRoIHRoZSBzYW1lIGRlbGltaXRlciBhbmQgYnVsbGV0IGNoYXJhY3Rlci4gIFRoaXMgaXMgdXNlZFxuLy8gaW4gYWdnbG9tZXJhdGluZyBsaXN0IGl0ZW1zIGludG8gbGlzdHMuXG5mdW5jdGlvbiBsaXN0c01hdGNoKGxpc3REYXRhLCBpdGVtRGF0YSkge1xuICAgIHJldHVybiAobGlzdERhdGEudHlwZSA9PT0gaXRlbURhdGEudHlwZSAmJlxuICAgICAgICBsaXN0RGF0YS5kZWxpbWl0ZXIgPT09IGl0ZW1EYXRhLmRlbGltaXRlciAmJlxuICAgICAgICBsaXN0RGF0YS5idWxsZXRDaGFyID09PSBpdGVtRGF0YS5idWxsZXRDaGFyKTtcbn1cbmZ1bmN0aW9uIGlzRGlzYWxsb3dlZERlZXBIZWFkaW5nKHBhcnNlciwgbm9kZSkge1xuICAgIHJldHVybiBwYXJzZXIub3B0aW9ucy5kaXNhbGxvd0RlZXBIZWFkaW5nICYmIChub2RlLnR5cGUgPT09ICdibG9ja1F1b3RlJyB8fCBub2RlLnR5cGUgPT09ICdpdGVtJyk7XG59XG52YXIgYmxvY2tRdW90ZSA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJiBwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm5leHROb25zcGFjZSkgPT09IENfR1JFQVRFUlRIQU4pIHtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgZmFsc2UpO1xuICAgICAgICAvLyBvcHRpb25hbCBmb2xsb3dpbmcgc3BhY2VcbiAgICAgICAgaWYgKGlzU3BhY2VPclRhYihwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm9mZnNldCkpKSB7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldCgxLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgcGFyc2VyLmFkZENoaWxkKCdibG9ja1F1b3RlJywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIHJldHVybiAxIC8qIENvbnRhaW5lciAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgYXR4SGVhZGluZyA9IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIHZhciBtYXRjaDtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJlxuICAgICAgICAvLyBUaGUgbmVzdGVkIEhlYWRpbmcgaXMgZGlzYWxsb3dlZCBpbiBsaXN0IGFuZCBibG9ja3F1b3RlIHdpdGggJ2Rpc2FsbG93RGVlcEhlYWRpbmcnIG9wdGlvblxuICAgICAgICAhaXNEaXNhbGxvd2VkRGVlcEhlYWRpbmcocGFyc2VyLCBjb250YWluZXIpICYmXG4gICAgICAgIChtYXRjaCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKS5tYXRjaChyZUFUWEhlYWRpbmdNYXJrZXIpKSkge1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChtYXRjaFswXS5sZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHZhciBoZWFkaW5nID0gcGFyc2VyLmFkZENoaWxkKCdoZWFkaW5nJywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIGhlYWRpbmcubGV2ZWwgPSBtYXRjaFswXS50cmltKCkubGVuZ3RoOyAvLyBudW1iZXIgb2YgI3NcbiAgICAgICAgaGVhZGluZy5oZWFkaW5nVHlwZSA9ICdhdHgnO1xuICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgIyMjczpcbiAgICAgICAgaGVhZGluZy5zdHJpbmdDb250ZW50ID0gcGFyc2VyLmN1cnJlbnRMaW5lXG4gICAgICAgICAgICAuc2xpY2UocGFyc2VyLm9mZnNldClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eWyBcXHRdKiMrWyBcXHRdKiQvLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bIFxcdF0rIytbIFxcdF0qJC8sICcnKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQocGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aCAtIHBhcnNlci5vZmZzZXQpO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBmZW5jZWRDb2RlQmxvY2sgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIGlmICghcGFyc2VyLmluZGVudGVkICYmXG4gICAgICAgIChtYXRjaCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKS5tYXRjaChyZUNvZGVGZW5jZSkpKSB7XG4gICAgICAgIHZhciBmZW5jZUxlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBwYXJzZXIuYWRkQ2hpbGQoJ2NvZGVCbG9jaycsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBjb250YWluZXIuaXNGZW5jZWQgPSB0cnVlO1xuICAgICAgICBjb250YWluZXIuZmVuY2VMZW5ndGggPSBmZW5jZUxlbmd0aDtcbiAgICAgICAgY29udGFpbmVyLmZlbmNlQ2hhciA9IG1hdGNoWzBdWzBdO1xuICAgICAgICBjb250YWluZXIuZmVuY2VPZmZzZXQgPSBwYXJzZXIuaW5kZW50O1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChmZW5jZUxlbmd0aCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBodG1sQmxvY2sgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJiBwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm5leHROb25zcGFjZSkgPT09IENfTEVTU1RIQU4pIHtcbiAgICAgICAgdmFyIHMgPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIHZhciBkaXNhbGxvd2VkVGFncyA9IHBhcnNlci5vcHRpb25zLmRpc2FsbG93ZWRIdG1sQmxvY2tUYWdzO1xuICAgICAgICB2YXIgYmxvY2tUeXBlID0gdm9pZCAwO1xuICAgICAgICBmb3IgKGJsb2NrVHlwZSA9IDE7IGJsb2NrVHlwZSA8PSA3OyBibG9ja1R5cGUrKykge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBzLm1hdGNoKHJlSHRtbEJsb2NrT3BlbltibG9ja1R5cGVdKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrVHlwZSA9PT0gNykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNhbGxvd2VkVGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVEaXNhbGxvd2VkVGFncyA9IG5ldyBSZWdFeHAoXCI8Lz8oPzpcIiArIGRpc2FsbG93ZWRUYWdzLmpvaW4oJ3wnKSArIFwiKVwiLCAnaScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlRGlzYWxsb3dlZFRhZ3MudGVzdChtYXRjaGVkWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgYWRqdXN0IHBhcnNlci5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgLy8gc3BhY2VzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MIGJsb2NrOlxuICAgICAgICAgICAgICAgIHZhciBiID0gcGFyc2VyLmFkZENoaWxkKCdodG1sQmxvY2snLCBwYXJzZXIub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBiLmh0bWxCbG9ja1R5cGUgPSBibG9ja1R5cGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBzZVRleHRIZWFkaW5nID0gZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIGlmIChjb250YWluZXIuc3RyaW5nQ29udGVudCAhPT0gbnVsbCAmJlxuICAgICAgICAhcGFyc2VyLmluZGVudGVkICYmXG4gICAgICAgIGNvbnRhaW5lci50eXBlID09PSAncGFyYWdyYXBoJyAmJlxuICAgICAgICAvLyBUaGUgbmVzdGVkIEhlYWRpbmcgaXMgZGlzYWxsb3dlZCBpbiBsaXN0IGFuZCBibG9ja3F1b3RlIHdpdGggJ2Rpc2FsbG93RGVlcEhlYWRpbmcnIG9wdGlvblxuICAgICAgICAhaXNEaXNhbGxvd2VkRGVlcEhlYWRpbmcocGFyc2VyLCBjb250YWluZXIucGFyZW50KSAmJlxuICAgICAgICAobWF0Y2ggPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSkubWF0Y2gocmVTZXRleHRIZWFkaW5nTGluZSkpKSB7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICAvLyByZXNvbHZlIHJlZmVyZW5jZSBsaW5rIGRlZmluaXRpb25zXG4gICAgICAgIHZhciBwb3MgPSB2b2lkIDA7XG4gICAgICAgIHdoaWxlIChwZWVrKGNvbnRhaW5lci5zdHJpbmdDb250ZW50LCAwKSA9PT0gQ19PUEVOX0JSQUNLRVQgJiZcbiAgICAgICAgICAgIChwb3MgPSBwYXJzZXIuaW5saW5lUGFyc2VyLnBhcnNlUmVmZXJlbmNlKGNvbnRhaW5lciwgcGFyc2VyLnJlZk1hcCkpKSB7XG4gICAgICAgICAgICBjb250YWluZXIuc3RyaW5nQ29udGVudCA9IGNvbnRhaW5lci5zdHJpbmdDb250ZW50LnNsaWNlKHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRhaW5lci5zdHJpbmdDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBoZWFkaW5nID0gY3JlYXRlTm9kZSgnaGVhZGluZycsIGNvbnRhaW5lci5zb3VyY2Vwb3MpO1xuICAgICAgICAgICAgaGVhZGluZy5sZXZlbCA9IG1hdGNoWzBdWzBdID09PSAnPScgPyAxIDogMjtcbiAgICAgICAgICAgIGhlYWRpbmcuaGVhZGluZ1R5cGUgPSAnc2V0ZXh0JztcbiAgICAgICAgICAgIGhlYWRpbmcuc3RyaW5nQ29udGVudCA9IGNvbnRhaW5lci5zdHJpbmdDb250ZW50O1xuICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEFmdGVyKGhlYWRpbmcpO1xuICAgICAgICAgICAgY29udGFpbmVyLnVubGluaygpO1xuICAgICAgICAgICAgcGFyc2VyLnRpcCA9IGhlYWRpbmc7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChwYXJzZXIuY3VycmVudExpbmUubGVuZ3RoIC0gcGFyc2VyLm9mZnNldCwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciB0aGVtYXRpY0JyZWFrID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICAgIGlmICghcGFyc2VyLmluZGVudGVkICYmIHJlVGhlbWF0aWNCcmVhay50ZXN0KHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKSkpIHtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHBhcnNlci5hZGRDaGlsZCgndGhlbWF0aWNCcmVhaycsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChwYXJzZXIuY3VycmVudExpbmUubGVuZ3RoIC0gcGFyc2VyLm9mZnNldCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBsaXN0SXRlbSA9IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIHZhciBkYXRhO1xuICAgIHZhciBjdXJyTm9kZSA9IGNvbnRhaW5lcjtcbiAgICBpZiAoKCFwYXJzZXIuaW5kZW50ZWQgfHwgY29udGFpbmVyLnR5cGUgPT09ICdsaXN0JykgJiZcbiAgICAgICAgKGRhdGEgPSBwYXJzZUxpc3RNYXJrZXIocGFyc2VyLCBjdXJyTm9kZSkpKSB7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICAvLyBhZGQgdGhlIGxpc3QgaWYgbmVlZGVkXG4gICAgICAgIGlmIChwYXJzZXIudGlwLnR5cGUgIT09ICdsaXN0JyB8fCAhbGlzdHNNYXRjaChjdXJyTm9kZS5saXN0RGF0YSwgZGF0YSkpIHtcbiAgICAgICAgICAgIGN1cnJOb2RlID0gcGFyc2VyLmFkZENoaWxkKCdsaXN0JywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgICAgICBjdXJyTm9kZS5saXN0RGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHRoZSBsaXN0IGl0ZW1cbiAgICAgICAgY3Vyck5vZGUgPSBwYXJzZXIuYWRkQ2hpbGQoJ2l0ZW0nLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgY3Vyck5vZGUubGlzdERhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gMSAvKiBDb250YWluZXIgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xuLy8gaW5kZW50ZWQgY29kZSBibG9ja1xudmFyIGluZGVudGVkQ29kZUJsb2NrID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICAgIGlmIChwYXJzZXIuaW5kZW50ZWQgJiYgcGFyc2VyLnRpcC50eXBlICE9PSAncGFyYWdyYXBoJyAmJiAhcGFyc2VyLmJsYW5rKSB7XG4gICAgICAgIC8vIGluZGVudGVkIGNvZGVcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoQ09ERV9JTkRFTlQsIHRydWUpO1xuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgcGFyc2VyLmFkZENoaWxkKCdjb2RlQmxvY2snLCBwYXJzZXIub2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgYmxvY2tTdGFydHMgPSBbXG4gICAgYmxvY2tRdW90ZSxcbiAgICBhdHhIZWFkaW5nLFxuICAgIGZlbmNlZENvZGVCbG9jayxcbiAgICBodG1sQmxvY2ssXG4gICAgc2VUZXh0SGVhZGluZyxcbiAgICB0aGVtYXRpY0JyZWFrLFxuICAgIGxpc3RJdGVtLFxuICAgIGluZGVudGVkQ29kZUJsb2NrLFxuICAgIHRhYmxlSGVhZCxcbiAgICB0YWJsZUJvZHksXG4gICAgY3VzdG9tQmxvY2ssXG5dO1xuLy8gYC0tLWAgZm9yIFlBTUwsIGArKytgIGZvciBUT01MLCBgOzs7YCBmb3IgSlNPTlxudmFyIHJlRnJvbnRNYXR0ZXIgPSAvXigtezN9fFxcK3szfXw7ezN9KSQvO1xudmFyIGZyb250TWF0dGVyJDEgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgY3VycmVudExpbmUgPSBwYXJzZXIuY3VycmVudExpbmUsIGxpbmVOdW1iZXIgPSBwYXJzZXIubGluZU51bWJlciwgaW5kZW50ZWQgPSBwYXJzZXIuaW5kZW50ZWQ7XG4gICAgaWYgKGxpbmVOdW1iZXIgPT09IDEgJiZcbiAgICAgICAgIWluZGVudGVkICYmXG4gICAgICAgIGNvbnRhaW5lci50eXBlID09PSAnZG9jdW1lbnQnICYmXG4gICAgICAgIHJlRnJvbnRNYXR0ZXIudGVzdChjdXJyZW50TGluZSkpIHtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHZhciBmcm9udE1hdHRlcl8xID0gcGFyc2VyLmFkZENoaWxkKCdmcm9udE1hdHRlcicsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBmcm9udE1hdHRlcl8xLnN0cmluZ0NvbnRlbnQgPSBjdXJyZW50TGluZTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoY3VycmVudExpbmUubGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIGZyb250TWF0dGVyID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBwYXJzZXIuY3VycmVudExpbmU7XG4gICAgICAgIHZhciBtYXRjaCA9IGxpbmUubWF0Y2gocmVGcm9udE1hdHRlcik7XG4gICAgICAgIGlmIChjb250YWluZXIudHlwZSA9PT0gJ2Zyb250TWF0dGVyJyAmJiBtYXRjaCkge1xuICAgICAgICAgICAgY29udGFpbmVyLnN0cmluZ0NvbnRlbnQgKz0gbGluZTtcbiAgICAgICAgICAgIHBhcnNlci5sYXN0TGluZUxlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHBhcnNlci5maW5hbGl6ZShjb250YWluZXIsIHBhcnNlci5saW5lTnVtYmVyKTtcbiAgICAgICAgICAgIHJldHVybiAyIC8qIEZpbmlzaGVkICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uIChfLCBibG9jaykge1xuICAgICAgICBpZiAoYmxvY2suc3RyaW5nQ29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrLmxpdGVyYWwgPSBibG9jay5zdHJpbmdDb250ZW50O1xuICAgICAgICBibG9jay5zdHJpbmdDb250ZW50ID0gbnVsbDtcbiAgICB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiB0cnVlLFxufTtcbnZhciByZUh0bWxCbG9ja0Nsb3NlID0gW1xuICAgIC8uLyxcbiAgICAvPFxcLyg/OnNjcmlwdHxwcmV8c3R5bGUpPi9pLFxuICAgIC8tLT4vLFxuICAgIC9cXD8+LyxcbiAgICAvPi8sXG4gICAgL1xcXVxcXT4vLFxuXTtcbnZhciByZU1heWJlU3BlY2lhbCA9IC9eWyNgfiorXz08PjAtOS07JF0vO1xudmFyIHJlTGluZUVuZGluZyQxID0gL1xcclxcbnxcXG58XFxyLztcbmZ1bmN0aW9uIGVzbV9kb2N1bWVudCgpIHtcbiAgICByZXR1cm4gY3JlYXRlTm9kZSgnZG9jdW1lbnQnLCBbXG4gICAgICAgIFsxLCAxXSxcbiAgICAgICAgWzAsIDBdLFxuICAgIF0pO1xufVxudmFyIGRlZmF1bHRPcHRpb25zJDEgPSB7XG4gICAgc21hcnQ6IGZhbHNlLFxuICAgIHRhZ0ZpbHRlcjogZmFsc2UsXG4gICAgZXh0ZW5kZWRBdXRvbGlua3M6IGZhbHNlLFxuICAgIGRpc2FsbG93ZWRIdG1sQmxvY2tUYWdzOiBbXSxcbiAgICByZWZlcmVuY2VEZWZpbml0aW9uOiBmYWxzZSxcbiAgICBkaXNhbGxvd0RlZXBIZWFkaW5nOiBmYWxzZSxcbiAgICBjdXN0b21QYXJzZXI6IG51bGwsXG4gICAgZnJvbnRNYXR0ZXI6IGZhbHNlLFxufTtcbnZhciBQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZXNtX2Fzc2lnbihlc21fYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyQxKSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZG9jID0gZXNtX2RvY3VtZW50KCk7XG4gICAgICAgIHRoaXMudGlwID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMub2xkdGlwID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMubGluZU51bWJlciA9IDA7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgICAgICB0aGlzLm5leHROb25zcGFjZSA9IDA7XG4gICAgICAgIHRoaXMubmV4dE5vbnNwYWNlQ29sdW1uID0gMDtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRMaW5lID0gJyc7XG4gICAgICAgIHRoaXMuaW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ibGFuayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYXN0TWF0Y2hlZENvbnRhaW5lciA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLnJlZk1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5sYXN0TGluZUxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mcm9udE1hdHRlcikge1xuICAgICAgICAgICAgYmxvY2tIYW5kbGVycy5mcm9udE1hdHRlciA9IGZyb250TWF0dGVyO1xuICAgICAgICAgICAgYmxvY2tTdGFydHMudW5zaGlmdChmcm9udE1hdHRlciQxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlubGluZVBhcnNlciA9IG5ldyBJbmxpbmVQYXJzZXIodGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgUGFyc2VyLnByb3RvdHlwZS5hZHZhbmNlT2Zmc2V0ID0gZnVuY3Rpb24gKGNvdW50LCBjb2x1bW5zKSB7XG4gICAgICAgIGlmIChjb2x1bW5zID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbHVtbnMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudExpbmUgPSB0aGlzLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgY2hhcnNUb1RhYiwgY2hhcnNUb0FkdmFuY2U7XG4gICAgICAgIHZhciBjO1xuICAgICAgICB3aGlsZSAoY291bnQgPiAwICYmIChjID0gY3VycmVudExpbmVbdGhpcy5vZmZzZXRdKSkge1xuICAgICAgICAgICAgaWYgKGMgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNUb1RhYiA9IDQgLSAodGhpcy5jb2x1bW4gJSA0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID0gY2hhcnNUb1RhYiA+IGNvdW50O1xuICAgICAgICAgICAgICAgICAgICBjaGFyc1RvQWR2YW5jZSA9IGNoYXJzVG9UYWIgPiBjb3VudCA/IGNvdW50IDogY2hhcnNUb1RhYjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4gKz0gY2hhcnNUb0FkdmFuY2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgLT0gY2hhcnNUb0FkdmFuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uICs9IGNoYXJzVG9UYWI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4gKz0gMTsgLy8gYXNzdW1lIGFzY2lpOyBibG9jayBzdGFydHMgYXJlIGFzY2lpXG4gICAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5hZHZhbmNlTmV4dE5vbnNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMubmV4dE5vbnNwYWNlO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IHRoaXMubmV4dE5vbnNwYWNlQ29sdW1uO1xuICAgICAgICB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID0gZmFsc2U7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLmZpbmROZXh0Tm9uc3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50TGluZSA9IHRoaXMuY3VycmVudExpbmU7XG4gICAgICAgIHZhciBpID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHZhciBjb2xzID0gdGhpcy5jb2x1bW47XG4gICAgICAgIHZhciBjO1xuICAgICAgICB3aGlsZSAoKGMgPSBjdXJyZW50TGluZS5jaGFyQXQoaSkpICE9PSAnJykge1xuICAgICAgICAgICAgaWYgKGMgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb2xzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb2xzICs9IDQgLSAoY29scyAlIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ibGFuayA9IGMgPT09ICdcXG4nIHx8IGMgPT09ICdcXHInIHx8IGMgPT09ICcnO1xuICAgICAgICB0aGlzLm5leHROb25zcGFjZSA9IGk7XG4gICAgICAgIHRoaXMubmV4dE5vbnNwYWNlQ29sdW1uID0gY29scztcbiAgICAgICAgdGhpcy5pbmRlbnQgPSB0aGlzLm5leHROb25zcGFjZUNvbHVtbiAtIHRoaXMuY29sdW1uO1xuICAgICAgICB0aGlzLmluZGVudGVkID0gdGhpcy5pbmRlbnQgPj0gQ09ERV9JTkRFTlQ7XG4gICAgfTtcbiAgICAvLyBBZGQgYSBsaW5lIHRvIHRoZSBibG9jayBhdCB0aGUgdGlwLiAgV2UgYXNzdW1lIHRoZSB0aXBcbiAgICAvLyBjYW4gYWNjZXB0IGxpbmVzIC0tIHRoYXQgY2hlY2sgc2hvdWxkIGJlIGRvbmUgYmVmb3JlIGNhbGxpbmcgdGhpcy5cbiAgICBQYXJzZXIucHJvdG90eXBlLmFkZExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCArPSAxOyAvLyBza2lwIG92ZXIgdGFiXG4gICAgICAgICAgICAvLyBhZGQgc3BhY2UgY2hhcmFjdGVyczpcbiAgICAgICAgICAgIHZhciBjaGFyc1RvVGFiID0gNCAtICh0aGlzLmNvbHVtbiAlIDQpO1xuICAgICAgICAgICAgdGhpcy50aXAuc3RyaW5nQ29udGVudCArPSByZXBlYXQoJyAnLCBjaGFyc1RvVGFiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aXAubGluZU9mZnNldHMpIHtcbiAgICAgICAgICAgIHRoaXMudGlwLmxpbmVPZmZzZXRzLnB1c2godGhpcy5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50aXAubGluZU9mZnNldHMgPSBbdGhpcy5vZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlwLnN0cmluZ0NvbnRlbnQgKz0gdGhpcy5jdXJyZW50TGluZS5zbGljZSh0aGlzLm9mZnNldCkgKyBcIlxcblwiO1xuICAgIH07XG4gICAgLy8gQWRkIGJsb2NrIG9mIHR5cGUgdGFnIGFzIGEgY2hpbGQgb2YgdGhlIHRpcC4gIElmIHRoZSB0aXAgY2FuJ3RcbiAgICAvLyBhY2NlcHQgY2hpbGRyZW4sIGNsb3NlIGFuZCBmaW5hbGl6ZSBpdCBhbmQgdHJ5IGl0cyBwYXJlbnQsXG4gICAgLy8gYW5kIHNvIG9uIHRpbCB3ZSBmaW5kIGEgYmxvY2sgdGhhdCBjYW4gYWNjZXB0IGNoaWxkcmVuLlxuICAgIFBhcnNlci5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAodGFnLCBvZmZzZXQpIHtcbiAgICAgICAgd2hpbGUgKCFibG9ja0hhbmRsZXJzW3RoaXMudGlwLnR5cGVdLmNhbkNvbnRhaW4odGFnKSkge1xuICAgICAgICAgICAgdGhpcy5maW5hbGl6ZSh0aGlzLnRpcCwgdGhpcy5saW5lTnVtYmVyIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IG9mZnNldCArIDE7IC8vIG9mZnNldCAwID0gY29sdW1uIDFcbiAgICAgICAgdmFyIG5ld0Jsb2NrID0gY3JlYXRlTm9kZSh0YWcsIFtcbiAgICAgICAgICAgIFt0aGlzLmxpbmVOdW1iZXIsIGNvbHVtbk51bWJlcl0sXG4gICAgICAgICAgICBbMCwgMF0sXG4gICAgICAgIF0pO1xuICAgICAgICBuZXdCbG9jay5zdHJpbmdDb250ZW50ID0gJyc7XG4gICAgICAgIHRoaXMudGlwLmFwcGVuZENoaWxkKG5ld0Jsb2NrKTtcbiAgICAgICAgdGhpcy50aXAgPSBuZXdCbG9jaztcbiAgICAgICAgcmV0dXJuIG5ld0Jsb2NrO1xuICAgIH07XG4gICAgLy8gRmluYWxpemUgYW5kIGNsb3NlIGFueSB1bm1hdGNoZWQgYmxvY2tzLlxuICAgIFBhcnNlci5wcm90b3R5cGUuY2xvc2VVbm1hdGNoZWRCbG9ja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxDbG9zZWQpIHtcbiAgICAgICAgICAgIC8vIGZpbmFsaXplIGFueSBibG9ja3Mgbm90IG1hdGNoZWRcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLm9sZHRpcCAhPT0gdGhpcy5sYXN0TWF0Y2hlZENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IHRoaXMub2xkdGlwLnBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplKHRoaXMub2xkdGlwLCB0aGlzLmxpbmVOdW1iZXIgLSAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9sZHRpcCA9IHBhcmVudF8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbGxDbG9zZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBGaW5hbGl6ZSBhIGJsb2NrLiAgQ2xvc2UgaXQgYW5kIGRvIGFueSBuZWNlc3NhcnkgcG9zdHByb2Nlc3NpbmcsXG4gICAgLy8gZS5nLiBjcmVhdGluZyBzdHJpbmdDb250ZW50IGZyb20gc3RyaW5ncywgc2V0dGluZyB0aGUgJ3RpZ2h0J1xuICAgIC8vIG9yICdsb29zZScgc3RhdHVzIG9mIGEgbGlzdCwgYW5kIHBhcnNpbmcgdGhlIGJlZ2lubmluZ3NcbiAgICAvLyBvZiBwYXJhZ3JhcGhzIGZvciByZWZlcmVuY2UgZGVmaW5pdGlvbnMuICBSZXNldCB0aGUgdGlwIHRvIHRoZVxuICAgIC8vIHBhcmVudCBvZiB0aGUgY2xvc2VkIGJsb2NrLlxuICAgIFBhcnNlci5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoYmxvY2ssIGxpbmVOdW1iZXIpIHtcbiAgICAgICAgdmFyIGFib3ZlID0gYmxvY2sucGFyZW50O1xuICAgICAgICBibG9jay5vcGVuID0gZmFsc2U7XG4gICAgICAgIGJsb2NrLnNvdXJjZXBvc1sxXSA9IFtsaW5lTnVtYmVyLCB0aGlzLmxhc3RMaW5lTGVuZ3RoXTtcbiAgICAgICAgYmxvY2tIYW5kbGVyc1tibG9jay50eXBlXS5maW5hbGl6ZSh0aGlzLCBibG9jayk7XG4gICAgICAgIHRoaXMudGlwID0gYWJvdmU7XG4gICAgfTtcbiAgICAvLyBXYWxrIHRocm91Z2ggYSBibG9jayAmIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5LCBwYXJzaW5nIHN0cmluZyBjb250ZW50XG4gICAgLy8gaW50byBpbmxpbmUgY29udGVudCB3aGVyZSBhcHByb3ByaWF0ZS5cbiAgICBQYXJzZXIucHJvdG90eXBlLnByb2Nlc3NJbmxpbmVzID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBldmVudDtcbiAgICAgICAgdmFyIGN1c3RvbVBhcnNlciA9IHRoaXMub3B0aW9ucy5jdXN0b21QYXJzZXI7XG4gICAgICAgIHZhciB3YWxrZXIgPSBibG9jay53YWxrZXIoKTtcbiAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXIucmVmTWFwID0gdGhpcy5yZWZNYXA7XG4gICAgICAgIHRoaXMuaW5saW5lUGFyc2VyLnJlZkxpbmtDYW5kaWRhdGVNYXAgPSB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXA7XG4gICAgICAgIHRoaXMuaW5saW5lUGFyc2VyLnJlZkRlZkNhbmRpZGF0ZU1hcCA9IHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwO1xuICAgICAgICB0aGlzLmlubGluZVBhcnNlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZXZlbnQubm9kZSwgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZztcbiAgICAgICAgICAgIHZhciB0ID0gbm9kZS50eXBlO1xuICAgICAgICAgICAgaWYgKGN1c3RvbVBhcnNlciAmJiBjdXN0b21QYXJzZXJbdF0pIHtcbiAgICAgICAgICAgICAgICBjdXN0b21QYXJzZXJbdF0obm9kZSwgeyBlbnRlcmluZzogZW50ZXJpbmcsIG9wdGlvbnM6IHRoaXMub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZW50ZXJpbmcgJiZcbiAgICAgICAgICAgICAgICAodCA9PT0gJ3BhcmFncmFwaCcgfHxcbiAgICAgICAgICAgICAgICAgICAgdCA9PT0gJ2hlYWRpbmcnIHx8XG4gICAgICAgICAgICAgICAgICAgICh0ID09PSAndGFibGVDZWxsJyAmJiAhbm9kZS5pZ25vcmVkKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlubGluZVBhcnNlci5wYXJzZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQW5hbHl6ZSBhIGxpbmUgb2YgdGV4dCBhbmQgdXBkYXRlIHRoZSBkb2N1bWVudCBhcHByb3ByaWF0ZWx5LlxuICAgIC8vIFdlIHBhcnNlIG1hcmtkb3duIHRleHQgYnkgY2FsbGluZyB0aGlzIG9uIGVhY2ggbGluZSBvZiBpbnB1dCxcbiAgICAvLyB0aGVuIGZpbmFsaXppbmcgdGhlIGRvY3VtZW50LlxuICAgIFBhcnNlci5wcm90b3R5cGUuaW5jb3Jwb3JhdGVMaW5lID0gZnVuY3Rpb24gKGxuKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5vbGR0aXAgPSB0aGlzLnRpcDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMuYmxhbmsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpbmVOdW1iZXIgKz0gMTtcbiAgICAgICAgLy8gcmVwbGFjZSBOVUwgY2hhcmFjdGVycyBmb3Igc2VjdXJpdHlcbiAgICAgICAgaWYgKGxuLmluZGV4T2YoJ1xcdTAwMDAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxuID0gbG4ucmVwbGFjZSgvXFwwL2csICdcXHVGRkZEJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9IGxuO1xuICAgICAgICAvLyBGb3IgZWFjaCBjb250YWluaW5nIGJsb2NrLCB0cnkgdG8gcGFyc2UgdGhlIGFzc29jaWF0ZWQgbGluZSBzdGFydC5cbiAgICAgICAgLy8gQmFpbCBvdXQgb24gZmFpbHVyZTogY29udGFpbmVyIHdpbGwgcG9pbnQgdG8gdGhlIGxhc3QgbWF0Y2hpbmcgYmxvY2suXG4gICAgICAgIC8vIFNldCBhbGxNYXRjaGVkIHRvIGZhbHNlIGlmIG5vdCBhbGwgY29udGFpbmVycyBtYXRjaC5cbiAgICAgICAgdmFyIGFsbE1hdGNoZWQgPSB0cnVlO1xuICAgICAgICB2YXIgbGFzdENoaWxkO1xuICAgICAgICB3aGlsZSAoKGxhc3RDaGlsZCA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpICYmIGxhc3RDaGlsZC5vcGVuKSB7XG4gICAgICAgICAgICBjb250YWluZXIgPSBsYXN0Q2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmZpbmROZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoYmxvY2tIYW5kbGVyc1tjb250YWluZXIudHlwZV1bJ2NvbnRpbnVlJ10odGhpcywgY29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBHbyAqLzogLy8gd2UndmUgbWF0Y2hlZCwga2VlcCBnb2luZ1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogU3RvcCAqLzogLy8gd2UndmUgZmFpbGVkIHRvIG1hdGNoIGEgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgYWxsTWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogRmluaXNoZWQgKi86IC8vIHdlJ3ZlIGhpdCBlbmQgb2YgbGluZSBmb3IgZmVuY2VkIGNvZGUgY2xvc2UgYW5kIGNhbiByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0TGluZUxlbmd0aCA9IGxuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udGludWUgcmV0dXJuZWQgaWxsZWdhbCB2YWx1ZSwgbXVzdCBiZSAwLCAxLCBvciAyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbE1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIucGFyZW50OyAvLyBiYWNrIHVwIHRvIGxhc3QgbWF0Y2hpbmcgYmxvY2tcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbENsb3NlZCA9IGNvbnRhaW5lciA9PT0gdGhpcy5vbGR0aXA7XG4gICAgICAgIHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHZhciBtYXRjaGVkTGVhZiA9IGNvbnRhaW5lci50eXBlICE9PSAncGFyYWdyYXBoJyAmJiBibG9ja0hhbmRsZXJzW2NvbnRhaW5lci50eXBlXS5hY2NlcHRzTGluZXM7XG4gICAgICAgIHZhciBibG9ja1N0YXJ0c0xlbiA9IGJsb2NrU3RhcnRzLmxlbmd0aDtcbiAgICAgICAgLy8gVW5sZXNzIGxhc3QgbWF0Y2hlZCBjb250YWluZXIgaXMgYSBjb2RlIGJsb2NrLCB0cnkgbmV3IGNvbnRhaW5lciBzdGFydHMsXG4gICAgICAgIC8vIGFkZGluZyBjaGlsZHJlbiB0byB0aGUgbGFzdCBtYXRjaGVkIGNvbnRhaW5lcjpcbiAgICAgICAgd2hpbGUgKCFtYXRjaGVkTGVhZikge1xuICAgICAgICAgICAgdGhpcy5maW5kTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgbGl0dGxlIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjpcbiAgICAgICAgICAgIGlmIChjb250YWluZXIudHlwZSAhPT0gJ3RhYmxlJyAmJlxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci50eXBlICE9PSAndGFibGVCb2R5JyAmJlxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci50eXBlICE9PSAncGFyYWdyYXBoJyAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmluZGVudGVkICYmXG4gICAgICAgICAgICAgICAgIXJlTWF5YmVTcGVjaWFsLnRlc3QobG4uc2xpY2UodGhpcy5uZXh0Tm9uc3BhY2UpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBibG9ja1N0YXJ0c0xlbikge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBibG9ja1N0YXJ0c1tpXSh0aGlzLCBjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMgPT09IDEgLyogQ29udGFpbmVyICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMudGlwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzID09PSAyIC8qIExlYWYgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy50aXA7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRMZWFmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IGJsb2NrU3RhcnRzTGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90aGluZyBtYXRjaGVkXG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hhdCByZW1haW5zIGF0IHRoZSBvZmZzZXQgaXMgYSB0ZXh0IGxpbmUuICBBZGQgdGhlIHRleHQgdG8gdGhlXG4gICAgICAgIC8vIGFwcHJvcHJpYXRlIGNvbnRhaW5lci5cbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgZm9yIGEgbGF6eSBwYXJhZ3JhcGggY29udGludWF0aW9uOlxuICAgICAgICBpZiAoIXRoaXMuYWxsQ2xvc2VkICYmICF0aGlzLmJsYW5rICYmIHRoaXMudGlwLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAvLyBsYXp5IHBhcmFncmFwaCBjb250aW51YXRpb25cbiAgICAgICAgICAgIHRoaXMuYWRkTGluZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm90IGEgbGF6eSBjb250aW51YXRpb25cbiAgICAgICAgICAgIC8vIGZpbmFsaXplIGFueSBibG9ja3Mgbm90IG1hdGNoZWRcbiAgICAgICAgICAgIHRoaXMuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJsYW5rICYmIGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIubGFzdENoaWxkLmxhc3RMaW5lQmxhbmsgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQgPSBjb250YWluZXIudHlwZTtcbiAgICAgICAgICAgIC8vIEJsb2NrIHF1b3RlIGxpbmVzIGFyZSBuZXZlciBibGFuayBhcyB0aGV5IHN0YXJ0IHdpdGggPlxuICAgICAgICAgICAgLy8gYW5kIHdlIGRvbid0IGNvdW50IGJsYW5rcyBpbiBmZW5jZWQgY29kZSBmb3IgcHVycG9zZXMgb2YgdGlnaHQvbG9vc2VcbiAgICAgICAgICAgIC8vIGxpc3RzIG9yIGJyZWFraW5nIG91dCBvZiBsaXN0cy4gV2UgYWxzbyBkb24ndCBzZXQgX2xhc3RMaW5lQmxhbmtcbiAgICAgICAgICAgIC8vIG9uIGFuIGVtcHR5IGxpc3QgaXRlbSwgb3IgaWYgd2UganVzdCBjbG9zZWQgYSBmZW5jZWQgYmxvY2suXG4gICAgICAgICAgICB2YXIgbGFzdExpbmVCbGFuayA9IHRoaXMuYmxhbmsgJiZcbiAgICAgICAgICAgICAgICAhKHQgPT09ICdibG9ja1F1b3RlJyB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNDb2RlQmxvY2soY29udGFpbmVyKSAmJiBjb250YWluZXIuaXNGZW5jZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0ID09PSAnaXRlbScgJiYgIWNvbnRhaW5lci5maXJzdENoaWxkICYmIGNvbnRhaW5lci5zb3VyY2Vwb3NbMF1bMF0gPT09IHRoaXMubGluZU51bWJlcikpO1xuICAgICAgICAgICAgLy8gcHJvcGFnYXRlIGxhc3RMaW5lQmxhbmsgdXAgdGhyb3VnaCBwYXJlbnRzOlxuICAgICAgICAgICAgdmFyIGNvbnQgPSBjb250YWluZXI7XG4gICAgICAgICAgICB3aGlsZSAoY29udCkge1xuICAgICAgICAgICAgICAgIGNvbnQubGFzdExpbmVCbGFuayA9IGxhc3RMaW5lQmxhbms7XG4gICAgICAgICAgICAgICAgY29udCA9IGNvbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSGFuZGxlcnNbdF0uYWNjZXB0c0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMaW5lKCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgSHRtbEJsb2NrLCBjaGVjayBmb3IgZW5kIGNvbmRpdGlvblxuICAgICAgICAgICAgICAgIGlmIChpc0h0bWxCbG9jayhjb250YWluZXIpICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5odG1sQmxvY2tUeXBlID49IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmh0bWxCbG9ja1R5cGUgPD0gNSAmJlxuICAgICAgICAgICAgICAgICAgICByZUh0bWxCbG9ja0Nsb3NlW2NvbnRhaW5lci5odG1sQmxvY2tUeXBlXS50ZXN0KHRoaXMuY3VycmVudExpbmUuc2xpY2UodGhpcy5vZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gbG4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplKGNvbnRhaW5lciwgdGhpcy5saW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9mZnNldCA8IGxuLmxlbmd0aCAmJiAhdGhpcy5ibGFuaykge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBwYXJhZ3JhcGggY29udGFpbmVyIGZvciBsaW5lXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5hZGRDaGlsZCgncGFyYWdyYXBoJywgdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdExpbmVMZW5ndGggPSBsbi5sZW5ndGg7XG4gICAgfTtcbiAgICAvLyBUaGUgbWFpbiBwYXJzaW5nIGZ1bmN0aW9uLiAgUmV0dXJucyBhIHBhcnNlZCBkb2N1bWVudCBBU1QuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChpbnB1dCwgbGluZVRleHRzKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZXNtX2RvY3VtZW50KCk7XG4gICAgICAgIHRoaXMudGlwID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMubGluZU51bWJlciA9IDA7XG4gICAgICAgIHRoaXMubGFzdExpbmVMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgICAgdGhpcy5sYXN0TWF0Y2hlZENvbnRhaW5lciA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLmN1cnJlbnRMaW5lID0gJyc7XG4gICAgICAgIHZhciBsaW5lcyA9IGlucHV0LnNwbGl0KHJlTGluZUVuZGluZyQxKTtcbiAgICAgICAgdmFyIGxlbiA9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVUZXh0cyA/IGxpbmVUZXh0cyA6IGxpbmVzO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlZmVyZW5jZURlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJSZWZNYXBzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgPT09IENfTkVXTElORSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIGxhc3QgYmxhbmsgbGluZSBjcmVhdGVkIGJ5IGZpbmFsIG5ld2xpbmVcbiAgICAgICAgICAgIGxlbiAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5jb3Jwb3JhdGVMaW5lKGxpbmVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy50aXApIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemUodGhpcy50aXAsIGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9jZXNzSW5saW5lcyh0aGlzLmRvYyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYztcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFydGlhbFBhcnNlU3RhcnQgPSBmdW5jdGlvbiAobGluZU51bWJlciwgbGluZXMpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBlc21fZG9jdW1lbnQoKTtcbiAgICAgICAgdGhpcy50aXAgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gbGluZU51bWJlciAtIDE7XG4gICAgICAgIHRoaXMubGFzdExpbmVMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgICAgdGhpcy5sYXN0TWF0Y2hlZENvbnRhaW5lciA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLmN1cnJlbnRMaW5lID0gJyc7XG4gICAgICAgIHZhciBsZW4gPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5jb3Jwb3JhdGVMaW5lKGxpbmVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kb2M7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnRpYWxQYXJzZUV4dGVuZHMgPSBmdW5jdGlvbiAobGluZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pbmNvcnBvcmF0ZUxpbmUobGluZXNbaV0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnRpYWxQYXJzZUZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMudGlwKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmFsaXplKHRoaXMudGlwLCB0aGlzLmxpbmVOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc0lubGluZXModGhpcy5kb2MpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5zZXRSZWZNYXBzID0gZnVuY3Rpb24gKHJlZk1hcCwgcmVmTGlua0NhbmRpZGF0ZU1hcCwgcmVmRGVmQ2FuZGlkYXRlTWFwKSB7XG4gICAgICAgIHRoaXMucmVmTWFwID0gcmVmTWFwO1xuICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAgPSByZWZMaW5rQ2FuZGlkYXRlTWFwO1xuICAgICAgICB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCA9IHJlZkRlZkNhbmRpZGF0ZU1hcDtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuY2xlYXJSZWZNYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBbdGhpcy5yZWZNYXAsIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCwgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXBdLmZvckVhY2goZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgY2xlYXJPYmoobWFwKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VyO1xufSgpKTtcbmZ1bmN0aW9uIGNvbXBhcmVQb3MocDEsIHAyKSB7XG4gICAgaWYgKHAxWzBdIDwgcDJbMF0pIHtcbiAgICAgICAgcmV0dXJuIDEgLyogTFQgKi87XG4gICAgfVxuICAgIGlmIChwMVswXSA+IHAyWzBdKSB7XG4gICAgICAgIHJldHVybiAtMSAvKiBHVCAqLztcbiAgICB9XG4gICAgaWYgKHAxWzFdIDwgcDJbMV0pIHtcbiAgICAgICAgcmV0dXJuIDEgLyogTFQgKi87XG4gICAgfVxuICAgIGlmIChwMVsxXSA+IHAyWzFdKSB7XG4gICAgICAgIHJldHVybiAtMSAvKiBHVCAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogRVEgKi87XG59XG5mdW5jdGlvbiBjb21wYXJlUmFuZ2VBbmRQb3MoX2EsIHBvcykge1xuICAgIHZhciBzdGFydFBvcyA9IF9hWzBdLCBlbmRQb3MgPSBfYVsxXTtcbiAgICBpZiAoY29tcGFyZVBvcyhlbmRQb3MsIHBvcykgPT09IDEgLyogTFQgKi8pIHtcbiAgICAgICAgcmV0dXJuIDEgLyogTFQgKi87XG4gICAgfVxuICAgIGlmIChjb21wYXJlUG9zKHN0YXJ0UG9zLCBwb3MpID09PSAtMSAvKiBHVCAqLykge1xuICAgICAgICByZXR1cm4gLTEgLyogR1QgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIEVRICovO1xufVxuZnVuY3Rpb24gcmVtb3ZlTmV4dFVudGlsKG5vZGUsIGxhc3QpIHtcbiAgICBpZiAobm9kZS5wYXJlbnQgIT09IGxhc3QucGFyZW50IHx8IG5vZGUgPT09IGxhc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IG5vZGUubmV4dDtcbiAgICB3aGlsZSAobmV4dCAmJiBuZXh0ICE9PSBsYXN0KSB7XG4gICAgICAgIHZhciB0ZW1wID0gbmV4dC5uZXh0O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gWydwYXJlbnQnLCAncHJldicsICduZXh0J107IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChuZXh0W3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZUJ5SWQobmV4dFt0eXBlXS5pZCk7XG4gICAgICAgICAgICAgICAgbmV4dFt0eXBlXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCA9IHRlbXA7XG4gICAgfVxuICAgIG5vZGUubmV4dCA9IGxhc3QubmV4dDtcbiAgICBpZiAobGFzdC5uZXh0KSB7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gbm9kZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUucGFyZW50Lmxhc3RDaGlsZCA9IG5vZGU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGROb2RlcyhwYXJlbnQpIHtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgY3VyciA9IHBhcmVudC5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjdXJyKSB7XG4gICAgICAgIG5vZGVzLnB1c2goY3Vycik7XG4gICAgICAgIGN1cnIgPSBjdXJyLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIGluc2VydE5vZGVzQmVmb3JlKHRhcmdldCwgbm9kZXMpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIG5vZGVzXzEgPSBub2RlczsgX2kgPCBub2Rlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzXzFbX2ldO1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByZXBlbmRDaGlsZE5vZGVzKHBhcmVudCwgbm9kZXMpIHtcbiAgICBmb3IgKHZhciBpID0gbm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgcGFyZW50LnByZXBlbmRDaGlsZChub2Rlc1tpXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlTmV4dExpbmVOdW1iZXJzKGJhc2UsIGRpZmYpIHtcbiAgICBpZiAoIWJhc2UgfHwgIWJhc2UucGFyZW50IHx8IGRpZmYgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2Fsa2VyID0gYmFzZS5wYXJlbnQud2Fsa2VyKCk7XG4gICAgd2Fsa2VyLnJlc3VtZUF0KGJhc2UsIHRydWUpO1xuICAgIHZhciBldmVudDtcbiAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBldmVudC5ub2RlLCBlbnRlcmluZyA9IGV2ZW50LmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIG5vZGUuc291cmNlcG9zWzBdWzBdICs9IGRpZmY7XG4gICAgICAgICAgICBub2RlLnNvdXJjZXBvc1sxXVswXSArPSBkaWZmO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZVJhbmdlQW5kTGluZShfYSwgbGluZSkge1xuICAgIHZhciBzdGFydFBvcyA9IF9hWzBdLCBlbmRQb3MgPSBfYVsxXTtcbiAgICBpZiAoZW5kUG9zWzBdIDwgbGluZSkge1xuICAgICAgICByZXR1cm4gMSAvKiBMVCAqLztcbiAgICB9XG4gICAgaWYgKHN0YXJ0UG9zWzBdID4gbGluZSkge1xuICAgICAgICByZXR1cm4gLTEgLyogR1QgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIEVRICovO1xufVxuZnVuY3Rpb24gZmluZENoaWxkTm9kZUF0TGluZShwYXJlbnQsIGxpbmUpIHtcbiAgICB2YXIgbm9kZSA9IHBhcmVudC5maXJzdENoaWxkO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIHZhciBjb21wID0gY29tcGFyZVJhbmdlQW5kTGluZShub2RlLnNvdXJjZXBvcywgbGluZSk7XG4gICAgICAgIGlmIChjb21wID09PSAwIC8qIEVRICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcCA9PT0gLTEgLyogR1QgKi8pIHtcbiAgICAgICAgICAgIC8vIFRvIGNvbnNpZGVyIHRoYXQgdG9wIGxpbmUgaXMgYmxhbmsgbGluZVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUucHJldiB8fCBub2RlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnQubGFzdENoaWxkO1xufVxuZnVuY3Rpb24gbGFzdExlYWZOb2RlKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHNhbWVMaW5lVG9wQW5jZXN0b3Iobm9kZSkge1xuICAgIHdoaWxlIChub2RlLnBhcmVudCAmJlxuICAgICAgICBub2RlLnBhcmVudC50eXBlICE9PSAnZG9jdW1lbnQnICYmXG4gICAgICAgIG5vZGUucGFyZW50LnNvdXJjZXBvc1swXVswXSA9PT0gbm9kZS5zb3VyY2Vwb3NbMF1bMF0pIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGZpbmRGaXJzdE5vZGVBdExpbmUocGFyZW50LCBsaW5lKSB7XG4gICAgdmFyIG5vZGUgPSBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICB2YXIgcHJldiA9IG51bGw7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgdmFyIGNvbXAgPSBjb21wYXJlUmFuZ2VBbmRMaW5lKG5vZGUuc291cmNlcG9zLCBsaW5lKTtcbiAgICAgICAgaWYgKGNvbXAgPT09IDAgLyogRVEgKi8pIHtcbiAgICAgICAgICAgIGlmIChub2RlLnNvdXJjZXBvc1swXVswXSA9PT0gbGluZSB8fCAhbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcCA9PT0gLTEgLyogR1QgKi8pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2KSB7XG4gICAgICAgIHJldHVybiBzYW1lTGluZVRvcEFuY2VzdG9yKGxhc3RMZWFmTm9kZShwcmV2KSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZE5vZGVBdFBvc2l0aW9uKHBhcmVudCwgcG9zKSB7XG4gICAgdmFyIG5vZGUgPSBwYXJlbnQ7XG4gICAgdmFyIHByZXYgPSBudWxsO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIHZhciBjb21wID0gY29tcGFyZVJhbmdlQW5kUG9zKG5vZGUuc291cmNlcG9zLCBwb3MpO1xuICAgICAgICBpZiAoY29tcCA9PT0gMCAvKiBFUSAqLykge1xuICAgICAgICAgICAgaWYgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wID09PSAtMSAvKiBHVCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5uZXh0KSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBmaW5kTm9kZUJ5SWQoaWQpIHtcbiAgICByZXR1cm4gZ2V0Tm9kZUJ5SWQoaWQpIHx8IG51bGw7XG59XG5mdW5jdGlvbiBpbnZva2VOZXh0VW50aWwoY2FsbGJhY2ssIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoZW5kID09PSB2b2lkIDApIHtcbiAgICAgICAgZW5kID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHZhciB3YWxrZXIgPSBzdGFydC53YWxrZXIoKTtcbiAgICAgICAgd2hpbGUgKHN0YXJ0ICYmIHN0YXJ0ICE9PSBlbmQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBuZXh0Lm5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVW5saW5rZWQoaWQpIHtcbiAgICB2YXIgbm9kZSA9IGZpbmROb2RlQnlJZChpZCk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBub2RlLnR5cGUgIT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgICBpZiAoIW5vZGUucGFyZW50ICYmICFub2RlLnByZXYgJiYgIW5vZGUubmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG52YXIgcmVMaW5lRW5kaW5nID0gL1xcclxcbnxcXG58XFxyLztcbmZ1bmN0aW9uIGNhbkJlQ29udGludWVkTGlzdEl0ZW0obGluZVRleHQpIHtcbiAgICB2YXIgc3BhY2VNYXRjaCA9IGxpbmVUZXh0Lm1hdGNoKC9eWyBcXHRdKy8pO1xuICAgIGlmIChzcGFjZU1hdGNoICYmIChzcGFjZU1hdGNoWzBdLmxlbmd0aCA+PSAyIHx8IC9cXHQvLnRlc3Qoc3BhY2VNYXRjaFswXSkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgbGVmdFRyaW1tZWQgPSBzcGFjZU1hdGNoID8gbGluZVRleHQuc2xpY2Uoc3BhY2VNYXRjaC5sZW5ndGgpIDogbGluZVRleHQ7XG4gICAgcmV0dXJuIHJlQnVsbGV0TGlzdE1hcmtlci50ZXN0KGxlZnRUcmltbWVkKSB8fCByZU9yZGVyZWRMaXN0TWFya2VyLnRlc3QobGVmdFRyaW1tZWQpO1xufVxuZnVuY3Rpb24gY2FuQmVDb250aW51ZWRUYWJsZUJvZHkobGluZVRleHQpIHtcbiAgICByZXR1cm4gIWlzQmxhbmsobGluZVRleHQpICYmIGxpbmVUZXh0LmluZGV4T2YoJ3wnKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWZEZWZTdGF0ZShub2RlKSB7XG4gICAgdmFyIGlkID0gbm9kZS5pZCwgdGl0bGUgPSBub2RlLnRpdGxlLCBzb3VyY2Vwb3MgPSBub2RlLnNvdXJjZXBvcywgZGVzdCA9IG5vZGUuZGVzdDtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgc291cmNlcG9zOiBzb3VyY2Vwb3MsXG4gICAgICAgIHVubGlua2VkOiBmYWxzZSxcbiAgICAgICAgZGVzdGluYXRpb246IGRlc3QsXG4gICAgfTtcbn1cbnZhciBUb2FzdE1hcmsgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9hc3RNYXJrKGNvbnRlbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVmTWFwID0ge307XG4gICAgICAgIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZmVyZW5jZURlZmluaXRpb24gPSAhIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVmZXJlbmNlRGVmaW5pdGlvbik7XG4gICAgICAgIHRoaXMucGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wYXJzZXIuc2V0UmVmTWFwcyh0aGlzLnJlZk1hcCwgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwLCB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCk7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyTWFwID0geyBjaGFuZ2U6IFtdIH07XG4gICAgICAgIGNvbnRlbnRzID0gY29udGVudHMgfHwgJyc7XG4gICAgICAgIHRoaXMubGluZVRleHRzID0gY29udGVudHMuc3BsaXQocmVMaW5lRW5kaW5nKTtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5wYXJzZXIucGFyc2UoY29udGVudHMsIHRoaXMubGluZVRleHRzKTtcbiAgICB9XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS51cGRhdGVMaW5lVGV4dHMgPSBmdW5jdGlvbiAoc3RhcnRQb3MsIGVuZFBvcywgbmV3VGV4dCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBzdGFydExpbmUgPSBzdGFydFBvc1swXSwgc3RhcnRDb2wgPSBzdGFydFBvc1sxXTtcbiAgICAgICAgdmFyIGVuZExpbmUgPSBlbmRQb3NbMF0sIGVuZENvbCA9IGVuZFBvc1sxXTtcbiAgICAgICAgdmFyIG5ld0xpbmVzID0gbmV3VGV4dC5zcGxpdChyZUxpbmVFbmRpbmcpO1xuICAgICAgICB2YXIgbmV3TGluZUxlbiA9IG5ld0xpbmVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHN0YXJ0TGluZVRleHQgPSB0aGlzLmxpbmVUZXh0c1tzdGFydExpbmUgLSAxXTtcbiAgICAgICAgdmFyIGVuZExpbmVUZXh0ID0gdGhpcy5saW5lVGV4dHNbZW5kTGluZSAtIDFdO1xuICAgICAgICBuZXdMaW5lc1swXSA9IHN0YXJ0TGluZVRleHQuc2xpY2UoMCwgc3RhcnRDb2wgLSAxKSArIG5ld0xpbmVzWzBdO1xuICAgICAgICBuZXdMaW5lc1tuZXdMaW5lTGVuIC0gMV0gPSBuZXdMaW5lc1tuZXdMaW5lTGVuIC0gMV0gKyBlbmRMaW5lVGV4dC5zbGljZShlbmRDb2wgLSAxKTtcbiAgICAgICAgdmFyIHJlbW92ZWRMaW5lTGVuID0gZW5kTGluZSAtIHN0YXJ0TGluZSArIDE7XG4gICAgICAgIChfYSA9IHRoaXMubGluZVRleHRzKS5zcGxpY2UuYXBwbHkoX2EsIGVzbV9zcHJlYWRBcnJheShbc3RhcnRMaW5lIC0gMSwgcmVtb3ZlZExpbmVMZW5dLCBuZXdMaW5lcykpO1xuICAgICAgICByZXR1cm4gbmV3TGluZUxlbiAtIHJlbW92ZWRMaW5lTGVuO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS51cGRhdGVSb290Tm9kZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5saW5lVGV4dHMubGVuZ3RoID09PSAxICYmIHRoaXMubGluZVRleHRzWzBdID09PSAnJykge1xuICAgICAgICAgICAgdGhpcy5yb290Lmxhc3RMaW5lQmxhbmsgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yb290LnNvdXJjZXBvcyA9IFtcbiAgICAgICAgICAgICAgICBbMSwgMV0sXG4gICAgICAgICAgICAgICAgWzEsIDBdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yb290Lmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5yb290Lmxhc3RMaW5lQmxhbmsgPSB0aGlzLnJvb3QubGFzdENoaWxkLmxhc3RMaW5lQmxhbms7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmVUZXh0cyA9IHRoaXMubGluZVRleHRzO1xuICAgICAgICB2YXIgaWR4ID0gbGluZVRleHRzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChsaW5lVGV4dHNbaWR4XSA9PT0gJycpIHtcbiAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lVGV4dHMubGVuZ3RoIC0gMiA+IGlkeCkge1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290LnNvdXJjZXBvc1sxXSA9IFtpZHggKyAxLCBsaW5lVGV4dHNbaWR4XS5sZW5ndGhdO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5yZXBsYWNlUmFuZ2VOb2RlcyA9IGZ1bmN0aW9uIChzdGFydE5vZGUsIGVuZE5vZGUsIG5ld05vZGVzKSB7XG4gICAgICAgIGlmICghc3RhcnROb2RlKSB7XG4gICAgICAgICAgICBpZiAoZW5kTm9kZSkge1xuICAgICAgICAgICAgICAgIGluc2VydE5vZGVzQmVmb3JlKGVuZE5vZGUsIG5ld05vZGVzKTtcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlQnlJZChlbmROb2RlLmlkKTtcbiAgICAgICAgICAgICAgICBlbmROb2RlLnVubGluaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlcGVuZENoaWxkTm9kZXModGhpcy5yb290LCBuZXdOb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnROb2Rlc0JlZm9yZShzdGFydE5vZGUsIG5ld05vZGVzKTtcbiAgICAgICAgICAgIHJlbW92ZU5leHRVbnRpbChzdGFydE5vZGUsIGVuZE5vZGUpO1xuICAgICAgICAgICAgW3N0YXJ0Tm9kZS5pZCwgZW5kTm9kZS5pZF0uZm9yRWFjaChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHJlbW92ZU5vZGVCeUlkKGlkKTsgfSk7XG4gICAgICAgICAgICBzdGFydE5vZGUudW5saW5rKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZ2V0Tm9kZVJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IGZpbmRDaGlsZE5vZGVBdExpbmUodGhpcy5yb290LCBzdGFydFBvc1swXSk7XG4gICAgICAgIHZhciBlbmROb2RlID0gZmluZENoaWxkTm9kZUF0TGluZSh0aGlzLnJvb3QsIGVuZFBvc1swXSk7XG4gICAgICAgIC8vIGV4dGVuZCBub2RlIHJhbmdlIHRvIGluY2x1ZGUgYSBmb2xsb3dpbmcgYmxvY2sgd2hpY2ggZG9lc24ndCBoYXZlIHByZWNlZGluZyBibGFuayBsaW5lXG4gICAgICAgIGlmIChlbmROb2RlICYmIGVuZE5vZGUubmV4dCAmJiBlbmRQb3NbMF0gKyAxID09PSBlbmROb2RlLm5leHQuc291cmNlcG9zWzBdWzBdKSB7XG4gICAgICAgICAgICBlbmROb2RlID0gZW5kTm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3RhcnROb2RlLCBlbmROb2RlXTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHBhcmFtKSB7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyTWFwW2V2ZW50TmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihwYXJhbSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5leHRlbmRFbmRMaW5lID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubGluZVRleHRzW2xpbmVdID09PSAnJykge1xuICAgICAgICAgICAgbGluZSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5wYXJzZVJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgc3RhcnRMaW5lLCBlbmRMaW5lKSB7XG4gICAgICAgIC8vIGV4dGVuZHMgc3RhcnRpbmcgcmFuZ2UgaWYgdGhlIGZpcnN0IG5vZGUgY2FuIGJlIGEgY29udGludWVkIGxpc3QgaXRlbVxuICAgICAgICBpZiAoc3RhcnROb2RlICYmXG4gICAgICAgICAgICBzdGFydE5vZGUucHJldiAmJlxuICAgICAgICAgICAgKChpc0xpc3Qoc3RhcnROb2RlLnByZXYpICYmIGNhbkJlQ29udGludWVkTGlzdEl0ZW0odGhpcy5saW5lVGV4dHNbc3RhcnRMaW5lIC0gMV0pKSB8fFxuICAgICAgICAgICAgICAgIChpc1RhYmxlKHN0YXJ0Tm9kZS5wcmV2KSAmJiBjYW5CZUNvbnRpbnVlZFRhYmxlQm9keSh0aGlzLmxpbmVUZXh0c1tzdGFydExpbmUgLSAxXSkpKSkge1xuICAgICAgICAgICAgc3RhcnROb2RlID0gc3RhcnROb2RlLnByZXY7XG4gICAgICAgICAgICBzdGFydExpbmUgPSBzdGFydE5vZGUuc291cmNlcG9zWzBdWzBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlZGl0ZWRMaW5lcyA9IHRoaXMubGluZVRleHRzLnNsaWNlKHN0YXJ0TGluZSAtIDEsIGVuZExpbmUpO1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMucGFyc2VyLnBhcnRpYWxQYXJzZVN0YXJ0KHN0YXJ0TGluZSwgZWRpdGVkTGluZXMpO1xuICAgICAgICAvLyBleHRlbmRzIGVuZGluZyByYW5nZSBpZiB0aGUgZm9sbG93aW5nIG5vZGUgY2FuIGJlIGEgZmVuY2VkIGNvZGUgYmxvY2sgb3IgYSBjb250aW51ZWQgbGlzdCBpdGVtXG4gICAgICAgIHZhciBuZXh0Tm9kZSA9IGVuZE5vZGUgPyBlbmROb2RlLm5leHQgOiB0aGlzLnJvb3QuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIGxhc3RDaGlsZCA9IHJvb3QubGFzdENoaWxkO1xuICAgICAgICB2YXIgaXNPcGVuZWRMYXN0Q2hpbGRDb2RlQmxvY2sgPSBsYXN0Q2hpbGQgJiYgaXNDb2RlQmxvY2sobGFzdENoaWxkKSAmJiBsYXN0Q2hpbGQub3BlbjtcbiAgICAgICAgdmFyIGlzT3BlbmVkTGFzdENoaWxkQ3VzdG9tQmxvY2sgPSBsYXN0Q2hpbGQgJiYgaXNDdXN0b21CbG9jayhsYXN0Q2hpbGQpICYmIGxhc3RDaGlsZC5vcGVuO1xuICAgICAgICB2YXIgaXNMYXN0Q2hpbGRMaXN0ID0gbGFzdENoaWxkICYmIGlzTGlzdChsYXN0Q2hpbGQpO1xuICAgICAgICB3aGlsZSAoKChpc09wZW5lZExhc3RDaGlsZENvZGVCbG9jayB8fCBpc09wZW5lZExhc3RDaGlsZEN1c3RvbUJsb2NrKSAmJiBuZXh0Tm9kZSkgfHxcbiAgICAgICAgICAgIChpc0xhc3RDaGlsZExpc3QgJiYgbmV4dE5vZGUgJiYgKG5leHROb2RlLnR5cGUgPT09ICdsaXN0JyB8fCBuZXh0Tm9kZS5zb3VyY2Vwb3NbMF1bMV0gPj0gMikpKSB7XG4gICAgICAgICAgICB2YXIgbmV3RW5kTGluZSA9IHRoaXMuZXh0ZW5kRW5kTGluZShuZXh0Tm9kZS5zb3VyY2Vwb3NbMV1bMF0pO1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIucGFydGlhbFBhcnNlRXh0ZW5kcyh0aGlzLmxpbmVUZXh0cy5zbGljZShlbmRMaW5lLCBuZXdFbmRMaW5lKSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0Tm9kZSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IGVuZE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmROb2RlID0gbmV4dE5vZGU7XG4gICAgICAgICAgICBlbmRMaW5lID0gbmV3RW5kTGluZTtcbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dE5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnNlci5wYXJ0aWFsUGFyc2VGaW5pc2goKTtcbiAgICAgICAgdmFyIG5ld05vZGVzID0gZ2V0Q2hpbGROb2Rlcyhyb290KTtcbiAgICAgICAgcmV0dXJuIHsgbmV3Tm9kZXM6IG5ld05vZGVzLCBleHRTdGFydE5vZGU6IHN0YXJ0Tm9kZSwgZXh0RW5kTm9kZTogZW5kTm9kZSB9O1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5nZXRSZW1vdmVkTm9kZVJhbmdlID0gZnVuY3Rpb24gKGV4dFN0YXJ0Tm9kZSwgZXh0RW5kTm9kZSkge1xuICAgICAgICBpZiAoIWV4dFN0YXJ0Tm9kZSB8fFxuICAgICAgICAgICAgKGV4dFN0YXJ0Tm9kZSAmJiBpc1JlZkRlZihleHRTdGFydE5vZGUpKSB8fFxuICAgICAgICAgICAgKGV4dEVuZE5vZGUgJiYgaXNSZWZEZWYoZXh0RW5kTm9kZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IFtleHRTdGFydE5vZGUuaWQsIGV4dEVuZE5vZGUuaWRdLFxuICAgICAgICAgICAgbGluZTogW2V4dFN0YXJ0Tm9kZS5zb3VyY2Vwb3NbMF1bMF0gLSAxLCBleHRFbmROb2RlLnNvdXJjZXBvc1sxXVswXSAtIDFdLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5tYXJrRGVsZXRlZFJlZk1hcCA9IGZ1bmN0aW9uIChleHRTdGFydE5vZGUsIGV4dEVuZE5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFpc0VtcHR5T2JqKHRoaXMucmVmTWFwKSkge1xuICAgICAgICAgICAgdmFyIG1hcmtEZWxldGVkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWZEZWYobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZkRlZlN0YXRlID0gX3RoaXMucmVmTWFwW25vZGUubGFiZWxdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmRGVmU3RhdGUgJiYgbm9kZS5pZCA9PT0gcmVmRGVmU3RhdGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZkRlZlN0YXRlLnVubGlua2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXh0U3RhcnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlTmV4dFVudGlsKG1hcmtEZWxldGVkLCBleHRTdGFydE5vZGUucGFyZW50LCBleHRFbmROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRFbmROb2RlKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlTmV4dFVudGlsKG1hcmtEZWxldGVkLCBleHRFbmROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5yZXBsYWNlV2l0aE5ld1JlZkRlZlN0YXRlID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghaXNFbXB0eU9iaih0aGlzLnJlZk1hcCkpIHtcbiAgICAgICAgICAgIHZhciByZXBsYWNlV2l0aF8xID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWZEZWYobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gbm9kZS5sYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZkRlZlN0YXRlID0gX3RoaXMucmVmTWFwW2xhYmVsXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWZEZWZTdGF0ZSB8fCByZWZEZWZTdGF0ZS51bmxpbmtlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVmTWFwW2xhYmVsXSA9IGNyZWF0ZVJlZkRlZlN0YXRlKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VOZXh0VW50aWwocmVwbGFjZVdpdGhfMSwgbm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5yZXBsYWNlV2l0aFJlZkRlZkNhbmRpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFpc0VtcHR5T2JqKHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwKSkge1xuICAgICAgICAgICAgaXRlcmF0ZU9iamVjdCh0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCwgZnVuY3Rpb24gKF8sIGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IGNhbmRpZGF0ZS5sYWJlbCwgc291cmNlcG9zID0gY2FuZGlkYXRlLnNvdXJjZXBvcztcbiAgICAgICAgICAgICAgICB2YXIgcmVmRGVmU3RhdGUgPSBfdGhpcy5yZWZNYXBbbGFiZWxdO1xuICAgICAgICAgICAgICAgIGlmICghcmVmRGVmU3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgcmVmRGVmU3RhdGUudW5saW5rZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgcmVmRGVmU3RhdGUuc291cmNlcG9zWzBdWzBdID4gc291cmNlcG9zWzBdWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZk1hcFtsYWJlbF0gPSBjcmVhdGVSZWZEZWZTdGF0ZShjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmdldFJhbmdlV2l0aFJlZkRlZiA9IGZ1bmN0aW9uIChzdGFydExpbmUsIGVuZExpbmUsIHN0YXJ0Tm9kZSwgZW5kTm9kZSwgbGluZURpZmYpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmZXJlbmNlRGVmaW5pdGlvbiAmJiAhaXNFbXB0eU9iaih0aGlzLnJlZk1hcCkpIHtcbiAgICAgICAgICAgIHZhciBwcmV2Tm9kZSA9IGZpbmRDaGlsZE5vZGVBdExpbmUodGhpcy5yb290LCBzdGFydExpbmUgLSAxKTtcbiAgICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IGZpbmRDaGlsZE5vZGVBdExpbmUodGhpcy5yb290LCBlbmRMaW5lICsgMSk7XG4gICAgICAgICAgICBpZiAocHJldk5vZGUgJiYgaXNSZWZEZWYocHJldk5vZGUpICYmIHByZXZOb2RlICE9PSBzdGFydE5vZGUgJiYgcHJldk5vZGUgIT09IGVuZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBzdGFydE5vZGUgPSBwcmV2Tm9kZTtcbiAgICAgICAgICAgICAgICBzdGFydExpbmUgPSBzdGFydE5vZGUuc291cmNlcG9zWzBdWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHROb2RlICYmIGlzUmVmRGVmKG5leHROb2RlKSAmJiBuZXh0Tm9kZSAhPT0gc3RhcnROb2RlICYmIG5leHROb2RlICE9PSBlbmROb2RlKSB7XG4gICAgICAgICAgICAgICAgZW5kTm9kZSA9IG5leHROb2RlO1xuICAgICAgICAgICAgICAgIGVuZExpbmUgPSB0aGlzLmV4dGVuZEVuZExpbmUoZW5kTm9kZS5zb3VyY2Vwb3NbMV1bMF0gKyBsaW5lRGlmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzdGFydE5vZGUsIGVuZE5vZGUsIHN0YXJ0TGluZSwgZW5kTGluZV07XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBlbmRQb3MsIGxpbmVEaWZmKSB7XG4gICAgICAgIGlmIChsaW5lRGlmZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBsaW5lRGlmZiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXROb2RlUmFuZ2Uoc3RhcnRQb3MsIGVuZFBvcyk7XG4gICAgICAgIHZhciBzdGFydE5vZGUgPSByYW5nZVswXSwgZW5kTm9kZSA9IHJhbmdlWzFdO1xuICAgICAgICB2YXIgc3RhcnRMaW5lID0gc3RhcnROb2RlID8gTWF0aC5taW4oc3RhcnROb2RlLnNvdXJjZXBvc1swXVswXSwgc3RhcnRQb3NbMF0pIDogc3RhcnRQb3NbMF07XG4gICAgICAgIHZhciBlbmRMaW5lID0gdGhpcy5leHRlbmRFbmRMaW5lKChlbmROb2RlID8gTWF0aC5tYXgoZW5kTm9kZS5zb3VyY2Vwb3NbMV1bMF0sIGVuZFBvc1swXSkgOiBlbmRQb3NbMF0pICsgbGluZURpZmYpO1xuICAgICAgICB2YXIgcGFyc2VSZXN1bHQgPSB0aGlzLnBhcnNlUmFuZ2UuYXBwbHkodGhpcywgdGhpcy5nZXRSYW5nZVdpdGhSZWZEZWYoc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydE5vZGUsIGVuZE5vZGUsIGxpbmVEaWZmKSk7XG4gICAgICAgIHZhciBuZXdOb2RlcyA9IHBhcnNlUmVzdWx0Lm5ld05vZGVzLCBleHRTdGFydE5vZGUgPSBwYXJzZVJlc3VsdC5leHRTdGFydE5vZGUsIGV4dEVuZE5vZGUgPSBwYXJzZVJlc3VsdC5leHRFbmROb2RlO1xuICAgICAgICB2YXIgcmVtb3ZlZE5vZGVSYW5nZSA9IHRoaXMuZ2V0UmVtb3ZlZE5vZGVSYW5nZShleHRTdGFydE5vZGUsIGV4dEVuZE5vZGUpO1xuICAgICAgICB2YXIgbmV4dE5vZGUgPSBleHRFbmROb2RlID8gZXh0RW5kTm9kZS5uZXh0IDogdGhpcy5yb290LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZURlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWFya0RlbGV0ZWRSZWZNYXAoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlKTtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVJhbmdlTm9kZXMoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlLCBuZXdOb2Rlcyk7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VXaXRoTmV3UmVmRGVmU3RhdGUobmV3Tm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUmFuZ2VOb2RlcyhleHRTdGFydE5vZGUsIGV4dEVuZE5vZGUsIG5ld05vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBub2RlczogbmV3Tm9kZXMsIHJlbW92ZWROb2RlUmFuZ2U6IHJlbW92ZWROb2RlUmFuZ2UsIG5leHROb2RlOiBuZXh0Tm9kZSB9O1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5wYXJzZVJlZkxpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKCFpc0VtcHR5T2JqKHRoaXMucmVmTWFwKSkge1xuICAgICAgICAgICAgaXRlcmF0ZU9iamVjdCh0aGlzLnJlZk1hcCwgZnVuY3Rpb24gKGxhYmVsLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS51bmxpbmtlZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMucmVmTWFwW2xhYmVsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlcmF0ZU9iamVjdChfdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwLCBmdW5jdGlvbiAoXywgY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gY2FuZGlkYXRlLm5vZGUsIHJlZkxhYmVsID0gY2FuZGlkYXRlLnJlZkxhYmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmTGFiZWwgPT09IGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChfdGhpcy5wYXJzZShub2RlLnNvdXJjZXBvc1swXSwgbm9kZS5zb3VyY2Vwb3NbMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucmVtb3ZlVW5saW5rZWRDYW5kaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNFbXB0eU9iaih0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCkpIHtcbiAgICAgICAgICAgIFt0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAsIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwXS5mb3JFYWNoKGZ1bmN0aW9uIChjYW5kaWRhdGVNYXApIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRlT2JqZWN0KGNhbmRpZGF0ZU1hcCwgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1VubGlua2VkKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhbmRpZGF0ZU1hcFtpZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmVkaXRNYXJrZG93biA9IGZ1bmN0aW9uIChzdGFydFBvcywgZW5kUG9zLCBuZXdUZXh0KSB7XG4gICAgICAgIHZhciBsaW5lRGlmZiA9IHRoaXMudXBkYXRlTGluZVRleHRzKHN0YXJ0UG9zLCBlbmRQb3MsIG5ld1RleHQpO1xuICAgICAgICB2YXIgcGFyc2VSZXN1bHQgPSB0aGlzLnBhcnNlKHN0YXJ0UG9zLCBlbmRQb3MsIGxpbmVEaWZmKTtcbiAgICAgICAgdmFyIGVkaXRSZXN1bHQgPSBvbWl0KHBhcnNlUmVzdWx0LCAnbmV4dE5vZGUnKTtcbiAgICAgICAgdXBkYXRlTmV4dExpbmVOdW1iZXJzKHBhcnNlUmVzdWx0Lm5leHROb2RlLCBsaW5lRGlmZik7XG4gICAgICAgIHRoaXMudXBkYXRlUm9vdE5vZGVTdGF0ZSgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW2VkaXRSZXN1bHRdO1xuICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVVubGlua2VkQ2FuZGlkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VXaXRoUmVmRGVmQ2FuZGlkYXRlKCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMucGFyc2VSZWZMaW5rKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJywgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZ2V0TGluZVRleHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lVGV4dHM7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmdldFJvb3ROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290O1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5maW5kTm9kZUF0UG9zaXRpb24gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHZhciBub2RlID0gZmluZE5vZGVBdFBvc2l0aW9uKHRoaXMucm9vdCwgcG9zKTtcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUgPT09IHRoaXMucm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmZpbmRGaXJzdE5vZGVBdExpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICByZXR1cm4gZmluZEZpcnN0Tm9kZUF0TGluZSh0aGlzLnJvb3QsIGxpbmUpO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyTWFwW2V2ZW50TmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuZXZlbnRIYW5kbGVyTWFwW2V2ZW50TmFtZV07XG4gICAgICAgIHZhciBpZHggPSBoYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmZpbmROb2RlQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gZmluZE5vZGVCeUlkKGlkKTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucmVtb3ZlQWxsTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlQWxsTm9kZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRvYXN0TWFyaztcbn0oKSk7XG52YXIgZGlzYWxsb3dlZFRhZ3MgPSBbXG4gICAgJ3RpdGxlJyxcbiAgICAndGV4dGFyZWEnLFxuICAgICdzdHlsZScsXG4gICAgJ3htcCcsXG4gICAgJ2lmcmFtZScsXG4gICAgJ25vZW1iZWQnLFxuICAgICdub2ZyYW1lcycsXG4gICAgJ3NjcmlwdCcsXG4gICAgJ3BsYWludGV4dCcsXG5dO1xudmFyIHJlRGlzYWxsb3dlZFRhZyA9IG5ldyBSZWdFeHAoXCI8KC8/KD86XCIgKyBkaXNhbGxvd2VkVGFncy5qb2luKCd8JykgKyBcIilbXj5dKj4pXCIsICdpZycpO1xuZnVuY3Rpb24gZmlsdGVyRGlzYWxsb3dlZFRhZ3Moc3RyKSB7XG4gICAgaWYgKHJlRGlzYWxsb3dlZFRhZy50ZXN0KHN0cikpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlRGlzYWxsb3dlZFRhZywgZnVuY3Rpb24gKF8sIGdyb3VwKSB7IHJldHVybiBcIiZsdDtcIiArIGdyb3VwOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbnZhciBiYXNlQ29udmVydG9ycyA9IHtcbiAgICBoZWFkaW5nOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiBcImhcIiArIG5vZGUubGV2ZWwsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0ZXh0OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgY29udGVudDogbm9kZS5saXRlcmFsLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgc29mdGJyZWFrOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgY29udGVudDogb3B0aW9ucy5zb2Z0YnJlYWssXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBsaW5lYnJlYWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICc8YnIgLz5cXG4nLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZW1waDogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2VtJyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHN0cm9uZzogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3N0cm9uZycsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwYXJhZ3JhcGg6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICB2YXIgZ3JhbmRwYXJlbnQgPSAoX2IgPSBub2RlLnBhcmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcmVudDtcbiAgICAgICAgaWYgKGdyYW5kcGFyZW50ICYmIGdyYW5kcGFyZW50LnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgaWYgKGdyYW5kcGFyZW50Lmxpc3REYXRhLnRpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdwJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRoZW1hdGljQnJlYWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdocicsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICBzZWxmQ2xvc2U6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBibG9ja1F1b3RlOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnYmxvY2txdW90ZScsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICBpbm5lck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBsaXN0OiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHZhciBfYiA9IG5vZGUubGlzdERhdGEsIHR5cGUgPSBfYi50eXBlLCBzdGFydCA9IF9iLnN0YXJ0O1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHR5cGUgPT09ICdidWxsZXQnID8gJ3VsJyA6ICdvbCc7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnb2wnICYmIHN0YXJ0ICE9PSBudWxsICYmIHN0YXJ0ICE9PSAxKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnN0YXJ0ID0gc3RhcnQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBpdGVtOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnbGknLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgaHRtbElubGluZTogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBvcHRpb25zLnRhZ0ZpbHRlciA/IGZpbHRlckRpc2FsbG93ZWRUYWdzKG5vZGUubGl0ZXJhbCkgOiBub2RlLmxpdGVyYWw7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdodG1sJywgY29udGVudDogY29udGVudCB9O1xuICAgIH0sXG4gICAgaHRtbEJsb2NrOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICB2YXIgY29udGVudCA9IG9wdGlvbnMudGFnRmlsdGVyID8gZmlsdGVyRGlzYWxsb3dlZFRhZ3Mobm9kZS5saXRlcmFsKSA6IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgaWYgKG9wdGlvbnMubm9kZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnZGl2Jywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnaHRtbCcsIGNvbnRlbnQ6IGNvbnRlbnQgfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdkaXYnLCBvdXRlck5ld0xpbmU6IHRydWUgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2h0bWwnLCBjb250ZW50OiBjb250ZW50LCBvdXRlck5ld0xpbmU6IHRydWUgfTtcbiAgICB9LFxuICAgIGNvZGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2NvZGUnIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogbm9kZS5saXRlcmFsIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdjb2RlJyB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgY29kZUJsb2NrOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgaW5mb1N0ciA9IG5vZGUuaW5mbztcbiAgICAgICAgdmFyIGluZm9Xb3JkcyA9IGluZm9TdHIgPyBpbmZvU3RyLnNwbGl0KC9cXHMrLykgOiBbXTtcbiAgICAgICAgdmFyIGNvZGVDbGFzc05hbWVzID0gW107XG4gICAgICAgIGlmIChpbmZvV29yZHMubGVuZ3RoID4gMCAmJiBpbmZvV29yZHNbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29kZUNsYXNzTmFtZXMucHVzaChcImxhbmd1YWdlLVwiICsgZXNjYXBlWG1sKGluZm9Xb3Jkc1swXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ3ByZScsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdjb2RlJywgY2xhc3NOYW1lczogY29kZUNsYXNzTmFtZXMgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmxpdGVyYWwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2NvZGUnIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdwcmUnLCBvdXRlck5ld0xpbmU6IHRydWUgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBub2RlLCB0aXRsZSA9IF9iLnRpdGxlLCBkZXN0aW5hdGlvbiA9IF9iLmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2EnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGVzbV9hc3NpZ24oeyBocmVmOiBlc2NhcGVYbWwoZGVzdGluYXRpb24pIH0sICh0aXRsZSAmJiB7IHRpdGxlOiBlc2NhcGVYbWwodGl0bGUpIH0pKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2EnIH07XG4gICAgfSxcbiAgICBpbWFnZTogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBnZXRDaGlsZHJlblRleHQgPSBfYS5nZXRDaGlsZHJlblRleHQsIHNraXBDaGlsZHJlbiA9IF9hLnNraXBDaGlsZHJlbjtcbiAgICAgICAgdmFyIF9iID0gbm9kZSwgdGl0bGUgPSBfYi50aXRsZSwgZGVzdGluYXRpb24gPSBfYi5kZXN0aW5hdGlvbjtcbiAgICAgICAgc2tpcENoaWxkcmVuKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnaW1nJyxcbiAgICAgICAgICAgIHNlbGZDbG9zZTogdHJ1ZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGVzbV9hc3NpZ24oeyBzcmM6IGVzY2FwZVhtbChkZXN0aW5hdGlvbiksIGFsdDogZ2V0Q2hpbGRyZW5UZXh0KG5vZGUpIH0sICh0aXRsZSAmJiB7IHRpdGxlOiBlc2NhcGVYbWwodGl0bGUpIH0pKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGN1c3RvbUJsb2NrOiBmdW5jdGlvbiAobm9kZSwgY29udGV4dCwgY29udmVydG9ycykge1xuICAgICAgICB2YXIgaW5mbyA9IG5vZGUuaW5mby50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGN1c3RvbUNvbnZlcnRvciA9IGNvbnZlcnRvcnNbaW5mb107XG4gICAgICAgIGlmIChjdXN0b21Db252ZXJ0b3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUNvbnZlcnRvcihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0B0b2FzdC11aS9lZGl0b3JdIC0gVGhlIGVycm9yIG9jY3VycmVkIHdoZW4gXCIgKyBpbmZvICsgXCIgYmxvY2sgbm9kZSB3YXMgcGFyc2VkIGluIG1hcmtkb3duIHJlbmRlcmVyOiBcIiArIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2RpdicsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnZGl2Jywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBmcm9udE1hdHRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2RpdicsXG4gICAgICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgZnJvbnQgbWF0dGVyIGlzIG1ldGFkYXRhLCBpdCBzaG91bGQgbm90IGJlIHJlbmRlci5cbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IHN0eWxlOiAnd2hpdGUtc3BhY2U6IHByZTsgZGlzcGxheTogbm9uZTsnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnZGl2Jywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBjdXN0b21JbmxpbmU6IGZ1bmN0aW9uIChub2RlLCBjb250ZXh0LCBjb252ZXJ0b3JzKSB7XG4gICAgICAgIHZhciBfYSA9IG5vZGUsIGluZm8gPSBfYS5pbmZvLCBmaXJzdENoaWxkID0gX2EuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIG5vbWFsaXplZEluZm8gPSBpbmZvLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgY3VzdG9tQ29udmVydG9yID0gY29udmVydG9yc1tub21hbGl6ZWRJbmZvXTtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gY29udGV4dC5lbnRlcmluZztcbiAgICAgICAgaWYgKGN1c3RvbUNvbnZlcnRvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tQ29udmVydG9yKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbQHRvYXN0LXVpL2VkaXRvcl0gLSBUaGUgZXJyb3Igb2NjdXJyZWQgd2hlbiBcIiArIG5vbWFsaXplZEluZm8gKyBcIiBpbmxpbmUgbm9kZSB3YXMgcGFyc2VkIGluIG1hcmtkb3duIHJlbmRlcmVyOiBcIiArIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRlcmluZ1xuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdzcGFuJyB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBcIiQkXCIgKyBpbmZvICsgKGZpcnN0Q2hpbGQgPyAnICcgOiAnJykgfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiAnJCQnIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnc3BhbicgfSxcbiAgICAgICAgICAgIF07XG4gICAgfSxcbn07XG52YXIgZ2ZtQ29udmVydG9ycyA9IHtcbiAgICBzdHJpa2U6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdkZWwnLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgaXRlbTogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICB2YXIgX2IgPSBub2RlLmxpc3REYXRhLCBjaGVja2VkID0gX2IuY2hlY2tlZCwgdGFzayA9IF9iLnRhc2s7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgdmFyIGl0ZW1UYWcgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdsaScsXG4gICAgICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVRhZyxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGZDbG9zZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGVzbV9hc3NpZ24oZXNtX2Fzc2lnbih7fSwgKGNoZWNrZWQgJiYgeyBjaGVja2VkOiAnJyB9KSksIHsgZGlzYWJsZWQ6ICcnLCB0eXBlOiAnY2hlY2tib3gnIH0pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnICcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtVGFnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2xpJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAndGFibGUnLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGFibGVIZWFkOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAndGhlYWQnLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGFibGVCb2R5OiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAndGJvZHknLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGFibGVSb3c6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAndHInLFxuICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW5MZW4gPSBub2RlLnBhcmVudC5wYXJlbnQuY29sdW1ucy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbGFzdENvbElkeCA9IG5vZGUubGFzdENoaWxkLmVuZElkeDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsYXN0Q29sSWR4ICsgMTsgaSA8IGNvbHVtbkxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6ICd0ZCcsXG4gICAgICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6ICd0ZCcsXG4gICAgICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3RyJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICB0YWJsZUNlbGw6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKG5vZGUuaWdub3JlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YWJsZVBhcnQgPSBub2RlLnBhcmVudC5wYXJlbnQ7XG4gICAgICAgIHZhciB0YWdOYW1lID0gdGFibGVQYXJ0LnR5cGUgPT09ICd0YWJsZUhlYWQnID8gJ3RoJyA6ICd0ZCc7XG4gICAgICAgIHZhciB0YWJsZSA9IHRhYmxlUGFydC5wYXJlbnQ7XG4gICAgICAgIHZhciBjb2x1bW5JbmZvID0gdGFibGUuY29sdW1uc1tub2RlLnN0YXJ0SWR4XTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSAoY29sdW1uSW5mbyA9PT0gbnVsbCB8fCBjb2x1bW5JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2x1bW5JbmZvLmFsaWduKSA/IHsgYWxpZ246IGNvbHVtbkluZm8uYWxpZ24gfSA6IG51bGw7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGVzbV9hc3NpZ24oeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6IHRhZ05hbWUsIG91dGVyTmV3TGluZTogdHJ1ZSB9LCAoYXR0cmlidXRlcyAmJiB7IGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBzb2Z0YnJlYWs6ICdcXG4nLFxuICAgIGdmbTogZmFsc2UsXG4gICAgdGFnRmlsdGVyOiBmYWxzZSxcbiAgICBub2RlSWQ6IGZhbHNlLFxufTtcbmZ1bmN0aW9uIGdldENoaWxkcmVuVGV4dChub2RlKSB7XG4gICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgIHZhciB3YWxrZXIgPSBub2RlLndhbGtlcigpO1xuICAgIHZhciBldmVudCA9IG51bGw7XG4gICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgIHZhciBub2RlXzEgPSBldmVudC5ub2RlO1xuICAgICAgICBpZiAobm9kZV8xLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgYnVmZmVyLnB1c2gobm9kZV8xLmxpdGVyYWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbignJyk7XG59XG52YXIgUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVuZGVyZXIoY3VzdG9tT3B0aW9ucykge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBlc21fYXNzaWduKGVzbV9hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zKSwgY3VzdG9tT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29udmVydG9ycyA9IHRoaXMuY3JlYXRlQ29udmVydG9ycygpO1xuICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLmNvbnZlcnRvcnM7XG4gICAgfVxuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDb252ZXJ0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udmVydG9ycyA9IGVzbV9hc3NpZ24oe30sIGJhc2VDb252ZXJ0b3JzKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICAgICAgICAgIGNvbnZlcnRvcnMgPSBlc21fYXNzaWduKGVzbV9hc3NpZ24oe30sIGNvbnZlcnRvcnMpLCBnZm1Db252ZXJ0b3JzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnZlcnRvcnMpIHtcbiAgICAgICAgICAgIHZhciBjdXN0b21Db252ZXJ0b3JzXzEgPSB0aGlzLm9wdGlvbnMuY29udmVydG9ycztcbiAgICAgICAgICAgIHZhciBub2RlVHlwZXMgPSBPYmplY3Qua2V5cyhjdXN0b21Db252ZXJ0b3JzXzEpO1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRDb252ZXJ0b3JzXzEgPSBlc21fYXNzaWduKGVzbV9hc3NpZ24oe30sIGJhc2VDb252ZXJ0b3JzKSwgZ2ZtQ29udmVydG9ycyk7XG4gICAgICAgICAgICBub2RlVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JnQ29udmVydG9yID0gY29udmVydG9yc1tub2RlVHlwZV07XG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRvciA9IGN1c3RvbUNvbnZlcnRvcnNfMVtub2RlVHlwZV07XG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRvclR5cGUgPSBPYmplY3Qua2V5cyhkZWZhdWx0Q29udmVydG9yc18xKS5pbmRleE9mKG5vZGVUeXBlKSA9PT0gLTFcbiAgICAgICAgICAgICAgICAgICAgPyBub2RlVHlwZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIDogbm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKG9yZ0NvbnZlcnRvcikge1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0b3JzW2NvbnZlcnRvclR5cGVdID0gZnVuY3Rpb24gKG5vZGUsIGNvbnRleHQsIGNvbnZlcnRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub3JpZ2luID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb3JnQ29udmVydG9yKG5vZGUsIGNvbnRleHQsIGNvbnZlcnRvcnMpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRvcihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRvcnNbY29udmVydG9yVHlwZV0gPSBjb252ZXJ0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRvcnM7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuZ2V0Q29udmVydG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydG9ycztcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5nZXRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChyb290Tm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB2YXIgd2Fsa2VyID0gcm9vdE5vZGUud2Fsa2VyKCk7XG4gICAgICAgIHZhciBldmVudCA9IG51bGw7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBldmVudC5ub2RlLCBlbnRlcmluZyA9IGV2ZW50LmVudGVyaW5nO1xuICAgICAgICAgICAgdmFyIGNvbnZlcnRvciA9IHRoaXNfMS5jb252ZXJ0b3JzW25vZGUudHlwZV07XG4gICAgICAgICAgICBpZiAoIWNvbnZlcnRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2tpcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgZW50ZXJpbmc6IGVudGVyaW5nLFxuICAgICAgICAgICAgICAgIGxlYWY6ICFpc0NvbnRhaW5lcihub2RlKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB0aGlzXzEub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBnZXRDaGlsZHJlblRleHQ6IGdldENoaWxkcmVuVGV4dCxcbiAgICAgICAgICAgICAgICBza2lwQ2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY29udmVydGVkID0gaXNDdXN0b21CbG9jayhub2RlKSB8fCBpc0N1c3RvbUlubGluZShub2RlKVxuICAgICAgICAgICAgICAgID8gY29udmVydG9yKG5vZGUsIGNvbnRleHQsIHRoaXNfMS5jb252ZXJ0b3JzKVxuICAgICAgICAgICAgICAgIDogY29udmVydG9yKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGNvbnZlcnRlZCkge1xuICAgICAgICAgICAgICAgIHZhciBodG1sTm9kZXMgPSBBcnJheS5pc0FycmF5KGNvbnZlcnRlZCkgPyBjb252ZXJ0ZWQgOiBbY29udmVydGVkXTtcbiAgICAgICAgICAgICAgICBodG1sTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoaHRtbE5vZGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChodG1sTm9kZS50eXBlID09PSAnb3BlblRhZycgJiYgX3RoaXMub3B0aW9ucy5ub2RlSWQgJiYgaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaHRtbE5vZGUuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxOb2RlLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxOb2RlLmF0dHJpYnV0ZXNbJ2RhdGEtbm9kZWlkJ10gPSBTdHJpbmcobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVuZGVySFRNTE5vZGUoaHRtbE5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbGtlci5yZXN1bWVBdChub2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHdhbGtlci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgICAgICBfbG9vcF8xKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGROZXdMaW5lKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5qb2luKCcnKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJIVE1MTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdvcGVuVGFnJzpcbiAgICAgICAgICAgIGNhc2UgJ2Nsb3NlVGFnJzpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckVsZW1lbnROb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUZXh0Tm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUmF3SHRtbE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBuby1kZWZhdWx0LWNhc2VcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmdlbmVyYXRlT3BlblRhZ1N0cmluZyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0YWdOYW1lID0gbm9kZS50YWdOYW1lLCBjbGFzc05hbWVzID0gbm9kZS5jbGFzc05hbWVzLCBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiPFwiICsgdGFnTmFtZSk7XG4gICAgICAgIGlmIChjbGFzc05hbWVzICYmIGNsYXNzTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChcIiBjbGFzcz1cXFwiXCIgKyBjbGFzc05hbWVzLmpvaW4oJyAnKSArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gYXR0cmlidXRlc1thdHRyTmFtZV07XG4gICAgICAgICAgICAgICAgX3RoaXMuYnVmZmVyLnB1c2goXCIgXCIgKyBhdHRyTmFtZSArIFwiPVxcXCJcIiArIGF0dHJWYWx1ZSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnNlbGZDbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCgnIC8nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKCc+Jyk7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuZ2VuZXJhdGVDbG9zZVRhZ1N0cmluZyA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdGFnTmFtZSA9IF9hLnRhZ05hbWU7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCI8L1wiICsgdGFnTmFtZSArIFwiPlwiKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5hZGROZXdMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoICYmIGxhc3QobGFzdCh0aGlzLmJ1ZmZlcikpICE9PSAnXFxuJykge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCgnXFxuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5hZGRPdXRlck5ld0xpbmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5vdXRlck5ld0xpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTmV3TGluZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuYWRkSW5uZXJOZXdMaW5lID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuaW5uZXJOZXdMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE5ld0xpbmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRleHROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChlc2NhcGVYbWwobm9kZS5jb250ZW50KSk7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyUmF3SHRtbE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmFkZE91dGVyTmV3TGluZShub2RlKTtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChub2RlLmNvbnRlbnQpO1xuICAgICAgICB0aGlzLmFkZE91dGVyTmV3TGluZShub2RlKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJFbGVtZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdvcGVuVGFnJykge1xuICAgICAgICAgICAgdGhpcy5hZGRPdXRlck5ld0xpbmUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlT3BlblRhZ1N0cmluZyhub2RlKTtcbiAgICAgICAgICAgIGlmIChub2RlLnNlbGZDbG9zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkT3V0ZXJOZXdMaW5lKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRJbm5lck5ld0xpbmUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZElubmVyTmV3TGluZShub2RlKTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVDbG9zZVRhZ1N0cmluZyhub2RlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0ZXJOZXdMaW5lKG5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmVuZGVyZXI7XG59KCkpO1xuXG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoT3duUHJvcGVydGllcy5qc1xudmFyIGNvbGxlY3Rpb25fZm9yRWFjaE93blByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1Nik7XG52YXIgZm9yRWFjaE93blByb3BlcnRpZXNfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29sbGVjdGlvbl9mb3JFYWNoT3duUHJvcGVydGllcyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy90dWktY29kZS1zbmlwcGV0L29iamVjdC9leHRlbmQuanNcbnZhciBleHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2OSk7XG52YXIgZXh0ZW5kX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGV4dGVuZCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy90dWktY29kZS1zbmlwcGV0L2RvbUV2ZW50L29uLmpzXG52YXIgb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0OCk7XG52YXIgb25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ob24pO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9kb21FdmVudC9vZmYuanNcbnZhciBvZmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0OSk7XG52YXIgb2ZmX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKG9mZik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy90dWktY29kZS1zbmlwcGV0L2RvbVV0aWwvYWRkQ2xhc3MuanNcbnZhciBhZGRDbGFzcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjA0KTtcbnZhciBhZGRDbGFzc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihhZGRDbGFzcyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy90dWktY29kZS1zbmlwcGV0L2RvbVV0aWwvcmVtb3ZlQ2xhc3MuanNcbnZhciByZW1vdmVDbGFzcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDYyKTtcbnZhciByZW1vdmVDbGFzc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihyZW1vdmVDbGFzcyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy90dWktY29kZS1zbmlwcGV0L2RvbVV0aWwvY3NzLmpzXG52YXIgY3NzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjIpO1xudmFyIGNzc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjc3MpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL3RvQXJyYXkuanNcbnZhciBjb2xsZWN0aW9uX3RvQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MCk7XG52YXIgdG9BcnJheV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb2xsZWN0aW9uX3RvQXJyYXkpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC90eXBlL2lzQXJyYXkuanNcbnZhciB0eXBlX2lzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyMik7XG52YXIgaXNBcnJheV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih0eXBlX2lzQXJyYXkpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC90eXBlL2lzU3RyaW5nLmpzXG52YXIgdHlwZV9pc1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oNzU4KTtcbnZhciBpc1N0cmluZ19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih0eXBlX2lzU3RyaW5nKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvdHlwZS9pc1VuZGVmaW5lZC5qc1xudmFyIHR5cGVfaXNVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOSk7XG52YXIgaXNVbmRlZmluZWRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odHlwZV9pc1VuZGVmaW5lZCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy90dWktY29kZS1zbmlwcGV0L2RvbVV0aWwvaGFzQ2xhc3MuanNcbnZhciBoYXNDbGFzcyA9IF9fd2VicGFja19yZXF1aXJlX18oNzE0KTtcbnZhciBoYXNDbGFzc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihoYXNDbGFzcyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy90dWktY29kZS1zbmlwcGV0L2RvbVV0aWwvbWF0Y2hlcy5qc1xudmFyIGRvbVV0aWxfbWF0Y2hlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDcxKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy9jb25zdGFudHMudHNcbnZhciBUQUdfTkFNRSA9ICdbQS1aYS16XVtBLVphLXowLTktXSonO1xudmFyIEFUVFJJQlVURV9OQU1FID0gJ1thLXpBLVpfOl1bYS16QS1aMC05Oi5fLV0qJztcbnZhciBVTlFVT1RFRF9WQUxVRSA9ICdbXlwiXFwnPTw+YFxcXFx4MDAtXFxcXHgyMF0rJztcbnZhciBTSU5HTEVfUVVPVEVEX1ZBTFVFID0gXCInW14nXSonXCI7XG52YXIgRE9VQkxFX1FVT1RFRF9WQUxVRSA9ICdcIlteXCJdKlwiJztcbnZhciBBVFRSSUJVVEVfVkFMVUUgPSBcIig/OlwiICsgVU5RVU9URURfVkFMVUUgKyBcInxcIiArIFNJTkdMRV9RVU9URURfVkFMVUUgKyBcInxcIiArIERPVUJMRV9RVU9URURfVkFMVUUgKyBcIilcIjtcbnZhciBBVFRSSUJVVEVfVkFMVUVfU1BFQyA9IFwiXCIgKyAnKD86XFxcXHMqPVxcXFxzKicgKyBBVFRSSUJVVEVfVkFMVUUgKyBcIilcIjtcbnZhciBjb25zdGFudHNfQVRUUklCVVRFID0gXCJcIiArICcoPzpcXFxccysnICsgQVRUUklCVVRFX05BTUUgKyBBVFRSSUJVVEVfVkFMVUVfU1BFQyArIFwiPylcIjtcbnZhciBjb25zdGFudHNfT1BFTl9UQUcgPSBcIjwoXCIgKyBUQUdfTkFNRSArIFwiKShcIiArIGNvbnN0YW50c19BVFRSSUJVVEUgKyBcIikqXFxcXHMqLz8+XCI7XG52YXIgQ0xPU0VfVEFHID0gXCI8LyhcIiArIFRBR19OQU1FICsgXCIpXFxcXHMqWz5dXCI7XG52YXIgY29uc3RhbnRzX0hUTUxfVEFHID0gXCIoPzpcIiArIGNvbnN0YW50c19PUEVOX1RBRyArIFwifFwiICsgQ0xPU0VfVEFHICsgXCIpXCI7XG52YXIgcmVIVE1MVGFnID0gbmV3IFJlZ0V4cChcIl5cIiArIGNvbnN0YW50c19IVE1MX1RBRywgJ2knKTtcbnZhciBjb25zdGFudHNfcmVCUiA9IC88YnJcXHMqXFwvKj4vaTtcbnZhciByZUhUTUxDb21tZW50ID0gLzwhIC0tLS0+fDwhLS0oPzotP1tePi1dKSg/Oi0/W14tXSkqLS0+LztcbnZhciBjb25zdGFudHNfQUxURVJOQVRJVkVfVEFHX0ZPUl9CUiA9ICc8L3A+PHA+JztcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC90eXBlL2lzTnVsbC5qc1xudmFyIHR5cGVfaXNOdWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzQpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9yZXF1ZXN0L3NlbmRIb3N0bmFtZS5qc1xudmFyIHJlcXVlc3Rfc2VuZEhvc3RuYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOTEpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzL2NvbW1vbi50c1xuXG5cblxuXG5cbnZhciBpc01hYyA9IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbnZhciByZVNwYWNlTW9yZVRoYW5PbmUgPSAvW1xcdTAwMjBdKy9nO1xudmFyIGNvbW1vbl9yZUVzY2FwZUNoYXJzID0gL1s+KCl7fVtcXF0rLS4hI3xdL2c7XG52YXIgcmVFc2NhcGVIVE1MID0gLzwoW2EtekEtWl9dW2EtekEtWjAtOVxcLS5fXSopKFxcc3xbXlxcXFw+XSkqXFwvPz58PChcXC8pKFthLXpBLVpfXVthLXpBLVowLTlcXC0uX10qKVxccypcXC8/Pnw8IS0tW14tXSstLT58PChbYS16QS1aX11bYS16QS1aMC05XFwtLjovXSopPi9nO1xudmFyIHJlRXNjYXBlQmFja1NsYXNoID0gL1xcXFxbIVwiIyQlJicoKSorLC0uLzo7PD0+P0BbXFxdXl9ge3x9flxcXFxdL2c7XG52YXIgcmVFc2NhcGVQYWlyZWRDaGFycyA9IC9bKl9+YF0vZztcbnZhciByZU1kSW1hZ2VTeW50YXggPSAvIVxcWy4qXFxdXFwoLipcXCkvZztcbnZhciByZUVzY2FwZWRDaGFySW5MaW5rU3ludGF4ID0gL1tbXFxdXS9nO1xudmFyIHJlRXNjYXBlQmFja1NsYXNoSW5TZW50ZW5jZSA9IC8oPzpefFteXFxcXF0pXFxcXCg/IVxcXFwpL2c7XG52YXIgY29tbW9uX1hNTFNQRUNJQUwgPSAnWyY8PlwiXSc7XG52YXIgY29tbW9uX3JlWG1sU3BlY2lhbCA9IG5ldyBSZWdFeHAoY29tbW9uX1hNTFNQRUNJQUwsICdnJyk7XG5mdW5jdGlvbiBjb21tb25fcmVwbGFjZVVuc2FmZUNoYXIoY2hhcikge1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgIHJldHVybiAnJmFtcDsnO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgIHJldHVybiAnJmx0Oyc7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICcmZ3Q7JztcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgcmV0dXJuICcmcXVvdDsnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNoYXI7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tbW9uX2VzY2FwZVhtbCh0ZXh0KSB7XG4gICAgaWYgKGNvbW1vbl9yZVhtbFNwZWNpYWwudGVzdCh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKGNvbW1vbl9yZVhtbFNwZWNpYWwsIGNvbW1vbl9yZXBsYWNlVW5zYWZlQ2hhcik7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gc2VuZEhvc3ROYW1lKCkge1xuICAgIHNlbmRIb3N0bmFtZSgnZWRpdG9yJywgJ1VBLTEyOTk2NjkyOS0xJyk7XG59XG5mdW5jdGlvbiBjb21tb25faW5jbHVkZXMoYXJyLCB0YXJnZXRJdGVtKSB7XG4gICAgcmV0dXJuIGFyci5pbmRleE9mKHRhcmdldEl0ZW0pICE9PSAtMTtcbn1cbnZhciBhdmFpbGFibGVMaW5rQXR0cmlidXRlcyA9IFsncmVsJywgJ3RhcmdldCcsICdocmVmbGFuZycsICd0eXBlJ107XG52YXIgcmVNYXJrZG93blRleHRUb0VzY2FwZU1hcCA9IHtcbiAgICBjb2RlYmxvY2s6IC8oXiB7NH1bXlxcbl0rXFxuKikrLyxcbiAgICB0aGVtYXRpY0JyZWFrOiAvXiAqKChcXCogKil7Myx9fCgtICopezMsfSAqfChfICopezMsfSkgKi8sXG4gICAgYXR4SGVhZGluZzogL14oI3sxLDZ9KSArW1xcc1xcU10rLyxcbiAgICBzZVRleHRoZWFkaW5nOiAvXihbXlxcbl0rKVxcbiAqKD18LSl7Mix9ICovLFxuICAgIGJsb2NrcXVvdGU6IC9eKCAqPlteXFxuXSsuKikrLyxcbiAgICBsaXN0OiAvXiAqKFxcKit8LSt8XFxkK1xcLikgW1xcc1xcU10rLyxcbiAgICBkZWY6IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArW1wiKF0oW15cXG5dKylbXCIpXSk/ICovLFxuICAgIGxpbms6IC8hP1xcWy4qXFxdXFwoLipcXCkvLFxuICAgIHJlZmxpbms6IC8hP1xcWy4qXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8sXG4gICAgdmVydGljYWxCYXI6IC9cXHUwMDdDLyxcbiAgICBmZW5jZWRDb2RlYmxvY2s6IC9eKChgfH4pezMsfSkvLFxufTtcbmZ1bmN0aW9uIHNhbml0aXplTGlua0F0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgICBpZiAoIWF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGxpbmtBdHRyaWJ1dGVzID0ge307XG4gICAgYXZhaWxhYmxlTGlua0F0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWRfZGVmYXVsdCgpKGF0dHJpYnV0ZVtrZXldKSkge1xuICAgICAgICAgICAgbGlua0F0dHJpYnV0ZXNba2V5XSA9IGF0dHJpYnV0ZVtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGxpbmtBdHRyaWJ1dGVzO1xufVxuZnVuY3Rpb24gY29tbW9uX3JlcGVhdCh0ZXh0LCBjb3VudCkge1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgcmVzdWx0ICs9IHRleHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc05lZWRFc2NhcGVUZXh0KHRleHQpIHtcbiAgICB2YXIgbmVlZEVzY2FwZSA9IGZhbHNlO1xuICAgIGZvckVhY2hPd25Qcm9wZXJ0aWVzKHJlTWFya2Rvd25UZXh0VG9Fc2NhcGVNYXAsIGZ1bmN0aW9uIChyZU1hcmtkb3duVGV4dFRvRXNjYXBlKSB7XG4gICAgICAgIGlmIChyZU1hcmtkb3duVGV4dFRvRXNjYXBlLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgIG5lZWRFc2NhcGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhbmVlZEVzY2FwZTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmVlZEVzY2FwZTtcbn1cbmZ1bmN0aW9uIGVzY2FwZVRleHRGb3JMaW5rKHRleHQpIHtcbiAgICB2YXIgaW1hZ2VTeW50YXhSYW5nZXMgPSBbXTtcbiAgICB2YXIgcmVzdWx0ID0gcmVNZEltYWdlU3ludGF4LmV4ZWModGV4dCk7XG4gICAgd2hpbGUgKHJlc3VsdCkge1xuICAgICAgICBpbWFnZVN5bnRheFJhbmdlcy5wdXNoKFtyZXN1bHQuaW5kZXgsIHJlc3VsdC5pbmRleCArIHJlc3VsdFswXS5sZW5ndGhdKTtcbiAgICAgICAgcmVzdWx0ID0gcmVNZEltYWdlU3ludGF4LmV4ZWModGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UocmVFc2NhcGVkQ2hhckluTGlua1N5bnRheCwgZnVuY3Rpb24gKG1hdGNoZWQsIG9mZnNldCkge1xuICAgICAgICB2YXIgaXNEZWxpbWl0ZXIgPSBpbWFnZVN5bnRheFJhbmdlcy5zb21lKGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gb2Zmc2V0ID4gcmFuZ2VbMF0gJiYgb2Zmc2V0IDwgcmFuZ2VbMV07IH0pO1xuICAgICAgICByZXR1cm4gaXNEZWxpbWl0ZXIgPyBtYXRjaGVkIDogXCJcXFxcXCIgKyBtYXRjaGVkO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY29tbW9uX2VzY2FwZSh0ZXh0KSB7XG4gICAgdmFyIGFoZWFkUmVwbGFjZXIgPSBmdW5jdGlvbiAobWF0Y2hlZCkgeyByZXR1cm4gXCJcXFxcXCIgKyBtYXRjaGVkOyB9O1xuICAgIHZhciBiZWhpbmRSZXBsYWNlciA9IGZ1bmN0aW9uIChtYXRjaGVkKSB7IHJldHVybiBtYXRjaGVkICsgXCJcXFxcXCI7IH07XG4gICAgdmFyIGVzY2FwZWRUZXh0ID0gdGV4dC5yZXBsYWNlKHJlU3BhY2VNb3JlVGhhbk9uZSwgJyAnKTtcbiAgICBpZiAocmVFc2NhcGVCYWNrU2xhc2gudGVzdChlc2NhcGVkVGV4dCkpIHtcbiAgICAgICAgZXNjYXBlZFRleHQgPSBlc2NhcGVkVGV4dC5yZXBsYWNlKHJlRXNjYXBlQmFja1NsYXNoLCBhaGVhZFJlcGxhY2VyKTtcbiAgICB9XG4gICAgaWYgKHJlRXNjYXBlQmFja1NsYXNoSW5TZW50ZW5jZS50ZXN0KGVzY2FwZWRUZXh0KSkge1xuICAgICAgICBlc2NhcGVkVGV4dCA9IGVzY2FwZWRUZXh0LnJlcGxhY2UocmVFc2NhcGVCYWNrU2xhc2hJblNlbnRlbmNlLCBiZWhpbmRSZXBsYWNlcik7XG4gICAgfVxuICAgIGVzY2FwZWRUZXh0ID0gZXNjYXBlZFRleHQucmVwbGFjZShyZUVzY2FwZVBhaXJlZENoYXJzLCBhaGVhZFJlcGxhY2VyKTtcbiAgICBpZiAocmVFc2NhcGVIVE1MLnRlc3QoZXNjYXBlZFRleHQpKSB7XG4gICAgICAgIGVzY2FwZWRUZXh0ID0gZXNjYXBlZFRleHQucmVwbGFjZShyZUVzY2FwZUhUTUwsIGFoZWFkUmVwbGFjZXIpO1xuICAgIH1cbiAgICBpZiAoaXNOZWVkRXNjYXBlVGV4dChlc2NhcGVkVGV4dCkpIHtcbiAgICAgICAgZXNjYXBlZFRleHQgPSBlc2NhcGVkVGV4dC5yZXBsYWNlKGNvbW1vbl9yZUVzY2FwZUNoYXJzLCBhaGVhZFJlcGxhY2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIGVzY2FwZWRUZXh0O1xufVxuZnVuY3Rpb24gcXVvdGUodGV4dCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKHRleHQuaW5kZXhPZignXCInKSA9PT0gLTEpIHtcbiAgICAgICAgcmVzdWx0ID0gJ1wiXCInO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGV4dC5pbmRleE9mKFwiJ1wiKSA9PT0gLTEgPyBcIicnXCIgOiAnKCknO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0WzBdICsgdGV4dCArIHJlc3VsdFsxXTtcbn1cbmZ1bmN0aW9uIGNvbW1vbl9pc05pbCh2YWx1ZSkge1xuICAgIHJldHVybiBpc051bGwodmFsdWUpIHx8IGlzVW5kZWZpbmVkKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvMSwgbzIpIHtcbiAgICBpZiAobzEgPT09IG51bGwgJiYgbzEgPT09IG8yKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG8xICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgbzIgIT09ICdvYmplY3QnIHx8IGNvbW1vbl9pc05pbChvMSkgfHwgY29tbW9uX2lzTmlsKG8yKSkge1xuICAgICAgICByZXR1cm4gbzEgPT09IG8yO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gbzEpIHtcbiAgICAgICAgaWYgKG8xW2tleV0gIT09IG8yW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gbzIpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIG8xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY29tbW9uX2xhc3QoYXJyKSB7XG4gICAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBjb21tb25fYmV0d2Vlbih2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gdmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heDtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGw7XG59XG5mdW5jdGlvbiBkZWVwTWVyZ2VkQ29weSh0YXJnZXRPYmosIG9iaikge1xuICAgIHZhciByZXN1bHRPYmogPSB0c2xpYl9lczZfYXNzaWduKHt9LCB0YXJnZXRPYmopO1xuICAgIGlmICh0YXJnZXRPYmogJiYgb2JqKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHJlc3VsdE9ialtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE9ialtwcm9wXSA9IGRlZXBDb3B5QXJyYXkob2JqW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0T2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE9ialtwcm9wXSA9IGRlZXBNZXJnZWRDb3B5KHJlc3VsdE9ialtwcm9wXSwgb2JqW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE9ialtwcm9wXSA9IGRlZXBDb3B5KG9ialtwcm9wXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0T2JqW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdE9iajtcbn1cbmZ1bmN0aW9uIGRlZXBDb3B5QXJyYXkoaXRlbXMpIHtcbiAgICByZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaXRlbSkgPyBkZWVwQ29weUFycmF5KGl0ZW0pIDogZGVlcENvcHkoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkZWVwQ29weShvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcHJvcCkge1xuICAgICAgICBpZiAoaXNPYmplY3Qob2JqW3Byb3BdKSkge1xuICAgICAgICAgICAgYWNjW3Byb3BdID0gQXJyYXkuaXNBcnJheShvYmpbcHJvcF0pID8gZGVlcENvcHlBcnJheShvYmpbcHJvcF0pIDogZGVlcENvcHkob2JqW3Byb3BdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjY1twcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGNvbW1vbl9hc3NpZ24odGFyZ2V0T2JqLCBvYmopIHtcbiAgICBpZiAob2JqID09PSB2b2lkIDApIHsgb2JqID0ge307IH1cbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgaWYgKHRhcmdldE9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiB0eXBlb2YgdGFyZ2V0T2JqW3Byb3BdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldE9ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbW1vbl9hc3NpZ24odGFyZ2V0T2JqW3Byb3BdLCBvYmpbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0T2JqW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldE9iajtcbn1cbmZ1bmN0aW9uIGdldFNvcnRlZE51bVBhaXIodmFsdWVBLCB2YWx1ZUIpIHtcbiAgICByZXR1cm4gdmFsdWVBID4gdmFsdWVCID8gW3ZhbHVlQiwgdmFsdWVBXSA6IFt2YWx1ZUEsIHZhbHVlQl07XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy9kb20udHNcblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gaXNQb3NpdGlvbkluQm94KHN0eWxlLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgdmFyIGxlZnQgPSBwYXJzZUludChzdHlsZS5sZWZ0LCAxMCk7XG4gICAgdmFyIHRvcCA9IHBhcnNlSW50KHN0eWxlLnRvcCwgMTApO1xuICAgIHZhciB3aWR0aCA9IHBhcnNlSW50KHN0eWxlLndpZHRoLCAxMCkgKyBwYXJzZUludChzdHlsZS5wYWRkaW5nTGVmdCwgMTApICsgcGFyc2VJbnQoc3R5bGUucGFkZGluZ1JpZ2h0LCAxMCk7XG4gICAgdmFyIGhlaWdodCA9IHBhcnNlSW50KHN0eWxlLmhlaWdodCwgMTApICsgcGFyc2VJbnQoc3R5bGUucGFkZGluZ1RvcCwgMTApICsgcGFyc2VJbnQoc3R5bGUucGFkZGluZ0JvdHRvbSwgMTApO1xuICAgIHJldHVybiBvZmZzZXRYID49IGxlZnQgJiYgb2Zmc2V0WCA8PSBsZWZ0ICsgd2lkdGggJiYgb2Zmc2V0WSA+PSB0b3AgJiYgb2Zmc2V0WSA8PSB0b3AgKyBoZWlnaHQ7XG59XG52YXIgQ0xTX1BSRUZJWCA9ICd0b2FzdHVpLWVkaXRvci0nO1xuZnVuY3Rpb24gY2xzKCkge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG5hbWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBfYSA9IDAsIG5hbWVzXzEgPSBuYW1lczsgX2EgPCBuYW1lc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzXzFbX2FdO1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdm9pZCAwO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gbmFtZVswXSA/IG5hbWVbMV0gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcIlwiICsgQ0xTX1BSRUZJWCArIGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBjbHNXaXRoTWRQcmVmaXgoKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgbmFtZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLm1hcChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiBDTFNfUFJFRklYICsgXCJtZC1cIiArIGNsYXNzTmFtZTsgfSkuam9pbignICcpO1xufVxuZnVuY3Rpb24gaXNUZXh0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUubm9kZVR5cGUpID09PSBOb2RlLlRFWFRfTk9ERTtcbn1cbmZ1bmN0aW9uIGlzRWxlbU5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xufVxuZnVuY3Rpb24gZmluZE5vZGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgdmFyIG5vZGVMaXN0ID0gdG9BcnJheShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICBpZiAobm9kZUxpc3QubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBub2RlTGlzdDtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gYXBwZW5kTm9kZXMobm9kZSwgbm9kZXNUb0FwcGVuZCkge1xuICAgIG5vZGVzVG9BcHBlbmQgPSBpc0FycmF5KG5vZGVzVG9BcHBlbmQpID8gdG9BcnJheShub2Rlc1RvQXBwZW5kKSA6IFtub2Rlc1RvQXBwZW5kXTtcbiAgICBub2Rlc1RvQXBwZW5kLmZvckVhY2goZnVuY3Rpb24gKG5vZGVUb0FwcGVuZCkge1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKG5vZGVUb0FwcGVuZCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbnNlcnRCZWZvcmVOb2RlKGluc2VydGVkTm9kZSwgbm9kZSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShpbnNlcnRlZE5vZGUsIG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVud3JhcE5vZGUobm9kZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZS5maXJzdENoaWxkLCBub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVOb2RlKG5vZGUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUsIHN0YXRlKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkX2RlZmF1bHQoKShzdGF0ZSkpIHtcbiAgICAgICAgc3RhdGUgPSAhaGFzQ2xhc3NfZGVmYXVsdCgpKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHZhciB0b2dnbGVGbiA9IHN0YXRlID8gKGFkZENsYXNzX2RlZmF1bHQoKSkgOiAocmVtb3ZlQ2xhc3NfZGVmYXVsdCgpKTtcbiAgICB0b2dnbGVGbihlbGVtZW50LCBjbGFzc05hbWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGgoY29udGVudHMsIHRhcmdldCkge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpZiAoaXNTdHJpbmdfZGVmYXVsdCgpKGNvbnRlbnRzKSkge1xuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gY29udGVudHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGVudHMpO1xuICAgIH1cbiAgICB2YXIgZmlyc3RDaGlsZCA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3RDaGlsZDtcbn1cbmZ1bmN0aW9uIGdldE91dGVyV2lkdGgoZWwpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgcmV0dXJuIChbJ21hcmdpbi1sZWZ0JywgJ21hcmdpbi1yaWdodCddLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB0eXBlKSB7IHJldHVybiBhY2MgKyBwYXJzZUludChjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKHR5cGUpLCAxMCk7IH0sIDApICsgZWwub2Zmc2V0V2lkdGgpO1xufVxuZnVuY3Rpb24gY2xvc2VzdChub2RlLCBmb3VuZCkge1xuICAgIHZhciBjb25kaXRpb247XG4gICAgaWYgKGlzU3RyaW5nKGZvdW5kKSkge1xuICAgICAgICBjb25kaXRpb24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiBtYXRjaGVzKHRhcmdldCwgZm91bmQpOyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uZGl0aW9uID0gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0ID09PSBmb3VuZDsgfTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKGlzRWxlbU5vZGUobm9kZSkgJiYgY29uZGl0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFRvdGFsT2Zmc2V0KGVsLCByb290KSB7XG4gICAgdmFyIG9mZnNldFRvcCA9IDA7XG4gICAgdmFyIG9mZnNldExlZnQgPSAwO1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gcm9vdCkge1xuICAgICAgICB2YXIgdG9wID0gZWwub2Zmc2V0VG9wLCBsZWZ0ID0gZWwub2Zmc2V0TGVmdCwgb2Zmc2V0UGFyZW50ID0gZWwub2Zmc2V0UGFyZW50O1xuICAgICAgICBvZmZzZXRUb3AgKz0gdG9wO1xuICAgICAgICBvZmZzZXRMZWZ0ICs9IGxlZnQ7XG4gICAgICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IHJvb3Qub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsLm9mZnNldFBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHsgb2Zmc2V0VG9wOiBvZmZzZXRUb3AsIG9mZnNldExlZnQ6IG9mZnNldExlZnQgfTtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplSHRtbChodG1sLCBuZWVkSHRtbFRleHQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChuZWVkSHRtbFRleHQpIHtcbiAgICAgICAgcmVzdWx0ID0gaHRtbC5pbm5lckhUTUw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0b0FycmF5KGh0bWwuY2hpbGROb2Rlcyk7XG4gICAgICAgIHZhciBsZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChjaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBmcmFnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZG9tX2VtcHR5KG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmROb2RlKG5vZGUsIGFwcGVuZGVkKSB7XG4gICAgaWYgKGlzU3RyaW5nKGFwcGVuZGVkKSkge1xuICAgICAgICBub2RlLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgYXBwZW5kZWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG5vZGVzID0gYXBwZW5kZWQubGVuZ3RoXG4gICAgICAgICAgICA/IHRvQXJyYXkoYXBwZW5kZWQpXG4gICAgICAgICAgICA6IFthcHBlbmRlZF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChub2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwcmVwZW5kTm9kZShub2RlLCBhcHBlbmRlZCkge1xuICAgIGlmIChpc1N0cmluZyhhcHBlbmRlZCkpIHtcbiAgICAgICAgbm9kZS5pbnNlcnRBZGphY2VudEhUTUwoJ2FmdGVyYmVnaW4nLCBhcHBlbmRlZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgbm9kZXMgPSBhcHBlbmRlZC5sZW5ndGhcbiAgICAgICAgICAgID8gdG9BcnJheShhcHBlbmRlZClcbiAgICAgICAgICAgIDogW2FwcGVuZGVkXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IG5vZGVzLmxlbmd0aCAtIDEsIGxlbiA9IDA7IGkgPj0gbGVuOyBpIC09IDEpIHtcbiAgICAgICAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKG5vZGVzW2ldLCBub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBlbGVtZW50KSB7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgaWYgKGlzTmlsKGF0dHJpYnV0ZXNbYXR0ck5hbWVdKSkge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJpYnV0ZXNbYXR0ck5hbWVdKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVwbGFjZUJSV2l0aEVtcHR5QmxvY2soaHRtbCkge1xuICAgIC8vIHJlbW92ZSBiciBpbiBwYXJhZ3JhcGggdG8gY29tcGF0aWJsZSB3aXRoIG1hcmtkb3duXG4gICAgdmFyIHJlcGxhY2VkSFRNTCA9IGh0bWwucmVwbGFjZSgvPHA+PGJyXFxzKlxcLyo+PFxcL3A+L2dpLCAnPHA+PC9wPicpO1xuICAgIHZhciByZUhUTUxUYWcgPSBuZXcgUmVnRXhwKEhUTUxfVEFHLCAnaWcnKTtcbiAgICB2YXIgaHRtbFRhZ01hdGNoZWQgPSByZXBsYWNlZEhUTUwubWF0Y2gocmVIVE1MVGFnKTtcbiAgICBodG1sVGFnTWF0Y2hlZCA9PT0gbnVsbCB8fCBodG1sVGFnTWF0Y2hlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHRtbFRhZ01hdGNoZWQuZm9yRWFjaChmdW5jdGlvbiAoaHRtbFRhZywgaW5kZXgpIHtcbiAgICAgICAgaWYgKHJlQlIudGVzdChodG1sVGFnKSkge1xuICAgICAgICAgICAgdmFyIGFsdGVybmF0aXZlVGFnID0gQUxURVJOQVRJVkVfVEFHX0ZPUl9CUjtcbiAgICAgICAgICAgIGlmIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2VGFnID0gaHRtbFRhZ01hdGNoZWRbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgb3BlblRhZ01hdGNoZWQgPSBwcmV2VGFnLm1hdGNoKE9QRU5fVEFHKTtcbiAgICAgICAgICAgICAgICBpZiAob3BlblRhZ01hdGNoZWQgJiYgIS9ici9pLnRlc3Qob3BlblRhZ01hdGNoZWRbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWdOYW1lID0gb3BlblRhZ01hdGNoZWRbMV07XG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlVGFnID0gXCI8L1wiICsgdGFnTmFtZSArIFwiPjxcIiArIHRhZ05hbWUgKyBcIj5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBsYWNlZEhUTUwgPSByZXBsYWNlZEhUTUwucmVwbGFjZShyZUJSLCBhbHRlcm5hdGl2ZVRhZyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVwbGFjZWRIVE1MO1xufVxuZnVuY3Rpb24gcmVtb3ZlUHJvc2VNaXJyb3JIYWNrTm9kZXMoaHRtbCkge1xuICAgIHZhciByZVByb3NlTWlycm9ySW1hZ2UgPSAvPGltZyBjbGFzcz1cIlByb3NlTWlycm9yLXNlcGFyYXRvclwiIGFsdD1cIlwiPi9nO1xuICAgIHZhciByZVByb3NlTWlycm9yVHJhaWxpbmdCcmVhayA9IC8gY2xhc3M9XCJQcm9zZU1pcnJvci10cmFpbGluZ0JyZWFrXCIvZztcbiAgICB2YXIgcmVzdWx0SFRNTCA9IGh0bWw7XG4gICAgcmVzdWx0SFRNTCA9IHJlc3VsdEhUTUwucmVwbGFjZShyZVByb3NlTWlycm9ySW1hZ2UsICcnKTtcbiAgICByZXN1bHRIVE1MID0gcmVzdWx0SFRNTC5yZXBsYWNlKHJlUHJvc2VNaXJyb3JUcmFpbGluZ0JyZWFrLCAnJyk7XG4gICAgcmV0dXJuIHJlc3VsdEhUTUw7XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvdHlwZS9pc0Z1bmN0aW9uLmpzXG52YXIgaXNGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjk0KTtcbnZhciBpc0Z1bmN0aW9uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlzRnVuY3Rpb24pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzL21hcmtkb3duLnRzXG5cbmZ1bmN0aW9uIGhhc1NwZWNpZmljVHlwZUFuY2VzdG9yKG1kTm9kZSkge1xuICAgIHZhciB0eXBlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHR5cGVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB3aGlsZSAobWROb2RlICYmIG1kTm9kZS5wYXJlbnQgJiYgbWROb2RlLnBhcmVudC50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgIGlmIChpbmNsdWRlcyh0eXBlcywgbWROb2RlLnBhcmVudC50eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbWROb2RlID0gbWROb2RlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWFya2Rvd25fZ2V0TWRTdGFydExpbmUobWROb2RlKSB7XG4gICAgcmV0dXJuIG1kTm9kZS5zb3VyY2Vwb3NbMF1bMF07XG59XG5mdW5jdGlvbiBtYXJrZG93bl9nZXRNZEVuZExpbmUobWROb2RlKSB7XG4gICAgcmV0dXJuIG1kTm9kZS5zb3VyY2Vwb3NbMV1bMF07XG59XG5mdW5jdGlvbiBnZXRNZFN0YXJ0Q2gobWROb2RlKSB7XG4gICAgcmV0dXJuIG1kTm9kZS5zb3VyY2Vwb3NbMF1bMV07XG59XG5mdW5jdGlvbiBnZXRNZEVuZENoKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUuc291cmNlcG9zWzFdWzFdO1xufVxuZnVuY3Rpb24gaXNNdWx0aUxpbmVOb2RlKG1kTm9kZSkge1xuICAgIHZhciB0eXBlID0gbWROb2RlLnR5cGU7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdjb2RlQmxvY2snIHx8IHR5cGUgPT09ICdwYXJhZ3JhcGgnO1xufVxuZnVuY3Rpb24gaXNIVE1MTm9kZShtZE5vZGUpIHtcbiAgICB2YXIgdHlwZSA9IG1kTm9kZS50eXBlO1xuICAgIHJldHVybiB0eXBlID09PSAnaHRtbEJsb2NrJyB8fCB0eXBlID09PSAnaHRtbElubGluZSc7XG59XG5mdW5jdGlvbiBtYXJrZG93bl9pc1N0eWxlZElubGluZU5vZGUobWROb2RlKSB7XG4gICAgdmFyIHR5cGUgPSBtZE5vZGUudHlwZTtcbiAgICByZXR1cm4gKHR5cGUgPT09ICdzdHJpa2UnIHx8XG4gICAgICAgIHR5cGUgPT09ICdzdHJvbmcnIHx8XG4gICAgICAgIHR5cGUgPT09ICdlbXBoJyB8fFxuICAgICAgICB0eXBlID09PSAnY29kZScgfHxcbiAgICAgICAgdHlwZSA9PT0gJ2xpbmsnIHx8XG4gICAgICAgIHR5cGUgPT09ICdpbWFnZScpO1xufVxuZnVuY3Rpb24gaXNDb2RlQmxvY2tOb2RlKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUgJiYgbWROb2RlLnR5cGUgPT09ICdjb2RlQmxvY2snO1xufVxuZnVuY3Rpb24gaXNDdXN0b21CbG9ja05vZGUobWROb2RlKSB7XG4gICAgcmV0dXJuIG1kTm9kZSAmJiBtZE5vZGUudHlwZSA9PT0gJ2N1c3RvbUJsb2NrJztcbn1cbmZ1bmN0aW9uIGlzTGlzdE5vZGUobWROb2RlKSB7XG4gICAgcmV0dXJuIG1kTm9kZSAmJiAobWROb2RlLnR5cGUgPT09ICdpdGVtJyB8fCBtZE5vZGUudHlwZSA9PT0gJ2xpc3QnKTtcbn1cbmZ1bmN0aW9uIGlzT3JkZXJlZExpc3ROb2RlKG1kTm9kZSkge1xuICAgIHJldHVybiBpc0xpc3ROb2RlKG1kTm9kZSkgJiYgbWROb2RlLmxpc3REYXRhLnR5cGUgPT09ICdvcmRlcmVkJztcbn1cbmZ1bmN0aW9uIGlzQnVsbGV0TGlzdE5vZGUobWROb2RlKSB7XG4gICAgcmV0dXJuIGlzTGlzdE5vZGUobWROb2RlKSAmJiBtZE5vZGUubGlzdERhdGEudHlwZSAhPT0gJ29yZGVyZWQnO1xufVxuZnVuY3Rpb24gaXNUYWJsZUNlbGxOb2RlKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUgJiYgKG1kTm9kZS50eXBlID09PSAndGFibGVDZWxsJyB8fCBtZE5vZGUudHlwZSA9PT0gJ3RhYmxlRGVsaW1DZWxsJyk7XG59XG5mdW5jdGlvbiBpc0lubGluZU5vZGUobWROb2RlKSB7XG4gICAgc3dpdGNoIChtZE5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgIGNhc2UgJ2VtcGgnOlxuICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICBjYXNlICdzdHJpa2UnOlxuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICBjYXNlICdodG1sSW5saW5lJzpcbiAgICAgICAgY2FzZSAnbGluZWJyZWFrJzpcbiAgICAgICAgY2FzZSAnc29mdGJyZWFrJzpcbiAgICAgICAgY2FzZSAnY3VzdG9tSW5saW5lJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRDbG9zZXN0Tm9kZShtZE5vZGUsIGNvbmRpdGlvbiwgaW5jbHVkZVNlbGYpIHtcbiAgICBpZiAoaW5jbHVkZVNlbGYgPT09IHZvaWQgMCkgeyBpbmNsdWRlU2VsZiA9IHRydWU7IH1cbiAgICBtZE5vZGUgPSBpbmNsdWRlU2VsZiA/IG1kTm9kZSA6IG1kTm9kZS5wYXJlbnQ7XG4gICAgd2hpbGUgKG1kTm9kZSAmJiBtZE5vZGUudHlwZSAhPT0gJ2RvY3VtZW50Jykge1xuICAgICAgICBpZiAoY29uZGl0aW9uKG1kTm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbWROb2RlID0gbWROb2RlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVBhcmVudE5vZGVzKG1kTm9kZSwgaXRlcmF0ZWUsIGluY2x1ZGVTZWxmKSB7XG4gICAgaWYgKGluY2x1ZGVTZWxmID09PSB2b2lkIDApIHsgaW5jbHVkZVNlbGYgPSB0cnVlOyB9XG4gICAgbWROb2RlID0gaW5jbHVkZVNlbGYgPyBtZE5vZGUgOiBtZE5vZGUucGFyZW50O1xuICAgIHdoaWxlIChtZE5vZGUgJiYgbWROb2RlLnR5cGUgIT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgaXRlcmF0ZWUobWROb2RlKTtcbiAgICAgICAgbWROb2RlID0gbWROb2RlLnBhcmVudDtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRPZmZzZXRQb3Mob3JpZ2luUG9zLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gW29yaWdpblBvc1swXSwgb3JpZ2luUG9zWzFdICsgb2Zmc2V0XTtcbn1cbmZ1bmN0aW9uIHNldE9mZnNldFBvcyhvcmlnaW5Qb3MsIG5ld09mZnNldCkge1xuICAgIHJldHVybiBbb3JpZ2luUG9zWzBdLCBuZXdPZmZzZXRdO1xufVxuZnVuY3Rpb24gZ2V0SW5saW5lTWFya2Rvd25UZXh0KG1kTm9kZSkge1xuICAgIHZhciB0ZXh0ID0gbWROb2RlLmZpcnN0Q2hpbGQubGl0ZXJhbDtcbiAgICBzd2l0Y2ggKG1kTm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2VtcGgnOlxuICAgICAgICAgICAgcmV0dXJuIFwiKlwiICsgdGV4dCArIFwiKlwiO1xuICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICAgICAgcmV0dXJuIFwiKipcIiArIHRleHQgKyBcIioqXCI7XG4gICAgICAgIGNhc2UgJ3N0cmlrZSc6XG4gICAgICAgICAgICByZXR1cm4gXCJ+flwiICsgdGV4dCArIFwifn5cIjtcbiAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgICAgICByZXR1cm4gXCJgXCIgKyB0ZXh0ICsgXCJgXCI7XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jYXNlLWRlY2xhcmF0aW9ucyAqL1xuICAgICAgICAgICAgdmFyIF9hID0gbWROb2RlLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uLCB0aXRsZSA9IF9hLnRpdGxlO1xuICAgICAgICAgICAgdmFyIGRlbGltID0gbWROb2RlLnR5cGUgPT09ICdsaW5rJyA/ICcnIDogJyEnO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGltICsgXCJbXCIgKyB0ZXh0ICsgXCJdKFwiICsgZGVzdGluYXRpb24gKyAodGl0bGUgPyBcIiBcXFwiXCIgKyB0aXRsZSArIFwiXFxcIlwiIDogJycpICsgXCIpXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXJrZG93bl9pc0NvbnRhaW5lcihub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICBjYXNlICdibG9ja1F1b3RlJzpcbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIGNhc2UgJ2l0ZW0nOlxuICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOlxuICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgY2FzZSAnZW1waCc6XG4gICAgICAgIGNhc2UgJ3N0cm9uZyc6XG4gICAgICAgIGNhc2UgJ3N0cmlrZSc6XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgY2FzZSAndGFibGVIZWFkJzpcbiAgICAgICAgY2FzZSAndGFibGVCb2R5JzpcbiAgICAgICAgY2FzZSAndGFibGVSb3cnOlxuICAgICAgICBjYXNlICd0YWJsZUNlbGwnOlxuICAgICAgICBjYXNlICd0YWJsZURlbGltUm93JzpcbiAgICAgICAgY2FzZSAnY3VzdG9tSW5saW5lJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcmtkb3duX2dldENoaWxkcmVuVGV4dChub2RlKSB7XG4gICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgIHZhciB3YWxrZXIgPSBub2RlLndhbGtlcigpO1xuICAgIHZhciBldmVudCA9IG51bGw7XG4gICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSBldmVudC5ub2RlO1xuICAgICAgICBpZiAoY2hpbGROb2RlLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgYnVmZmVyLnB1c2goY2hpbGROb2RlLmxpdGVyYWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbignJyk7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy93aWRnZXQvcnVsZXMudHNcblxudmFyIHdpZGdldFJ1bGVzID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoW10pKTtcbnZhciB3aWRnZXRSdWxlTWFwID0ge307XG52YXIgcmVXaWRnZXRQcmVmaXggPSAvXFwkXFwkd2lkZ2V0XFxkK1xccy87XG5mdW5jdGlvbiB1bndyYXBXaWRnZXRTeW50YXgodGV4dCkge1xuICAgIHZhciBpbmRleCA9IHRleHQuc2VhcmNoKHJlV2lkZ2V0UHJlZml4KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGV4dC5zdWJzdHJpbmcoaW5kZXgpO1xuICAgICAgICB2YXIgcmVwbGFjZWQgPSByZXN0LnJlcGxhY2UocmVXaWRnZXRQcmVmaXgsICcnKS5yZXBsYWNlKCckJCcsICcnKTtcbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgdGV4dCArPSB1bndyYXBXaWRnZXRTeW50YXgocmVwbGFjZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdpZGdldENvbnRlbnQoaW5mbywgdGV4dCkge1xuICAgIHJldHVybiBcIiQkXCIgKyBpbmZvICsgXCIgXCIgKyB0ZXh0ICsgXCIkJFwiO1xufVxuZnVuY3Rpb24gd2lkZ2V0VG9ET00oaW5mbywgdGV4dCkge1xuICAgIHZhciBfYSA9IHdpZGdldFJ1bGVNYXBbaW5mb10sIHJ1bGUgPSBfYS5ydWxlLCB0b0RPTSA9IF9hLnRvRE9NO1xuICAgIHZhciBtYXRjaGVzID0gdW53cmFwV2lkZ2V0U3ludGF4KHRleHQpLm1hdGNoKHJ1bGUpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHRleHQgPSBtYXRjaGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdG9ET00odGV4dCk7XG59XG5mdW5jdGlvbiBnZXRXaWRnZXRSdWxlcygpIHtcbiAgICByZXR1cm4gd2lkZ2V0UnVsZXM7XG59XG5mdW5jdGlvbiBzZXRXaWRnZXRSdWxlcyhydWxlcykge1xuICAgIHdpZGdldFJ1bGVzID0gcnVsZXM7XG4gICAgd2lkZ2V0UnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSwgaW5kZXgpIHtcbiAgICAgICAgd2lkZ2V0UnVsZU1hcFtcIndpZGdldFwiICsgaW5kZXhdID0gcnVsZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG1lcmdlTm9kZXMobm9kZXMsIHRleHQsIHNjaGVtYSwgcnVsZUluZGV4KSB7XG4gICAgcmV0dXJuIG5vZGVzLmNvbmNhdChjcmVhdGVOb2Rlc1dpdGhXaWRnZXQodGV4dCwgc2NoZW1hLCBydWxlSW5kZXgpKTtcbn1cbi8qKlxuICogY3JlYXRlIG5vZGVzIHdpdGggcGxhaW4gdGV4dCBhbmQgcmVwbGFjZSB0ZXh0IG1hdGNoZWQgdG8gdGhlIHdpZGdldCBydWxlcyB3aXRoIHRoZSB3aWRnZXQgbm9kZVxuICogRm9yIGV4YW1wbGUsIGluIGNhc2UgdGhlIHRleHQgYW5kIHdpZGdldCBydWxlcyBhcyBiZWxvd1xuICpcbiAqIHRleHQ6ICR0ZXN0IHBsYWluIHRleHQgI3Rlc3RcbiAqIHdpZGdldCBydWxlczogW3sgcnVsZTogLyQuKy8gfSwgeyBydWxlOiAvIy4rLyB9XVxuICpcbiAqIFRoZSBjcmVhdGluZyBub2RlIHByb2Nlc3MgaXMgcmVjdXJzaXZlIGFuZCBpcyBhcyBmb2xsb3dzLlxuICpcbiAqIGluIGZpcnN0IHdpZGdldCBydWxlKC8kLisvKVxuICogICR0ZXN0IC0+IHdpZGdldCBub2RlXG4gKiAgcGxhaW4gdGV4dCAtPiBtYXRjaCB3aXRoIG5leHQgd2lkZ2V0IHJ1bGVcbiAqICAjdGVzdCAtPiBtYXRjaCB3aXRoIG5leHQgd2lkZ2V0IHJ1bGVcbiAqXG4gKiBpbiBzZWNvbmQgd2lkZ2V0IHJ1bGUoLyMuKy8pXG4gKiAgcGxhaW4gdGV4dCAtPiB0ZXh0IG5vZGUobm8gcnVsZSBmb3IgbWF0Y2hpbmcpXG4gKiAgI3Rlc3QgLT4gd2lkZ2V0IG5vZGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZXNXaXRoV2lkZ2V0KHRleHQsIHNjaGVtYSwgcnVsZUluZGV4KSB7XG4gICAgaWYgKHJ1bGVJbmRleCA9PT0gdm9pZCAwKSB7IHJ1bGVJbmRleCA9IDA7IH1cbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgcnVsZSA9ICh3aWRnZXRSdWxlc1tydWxlSW5kZXhdIHx8IHt9KS5ydWxlO1xuICAgIHZhciBuZXh0UnVsZUluZGV4ID0gcnVsZUluZGV4ICsgMTtcbiAgICB0ZXh0ID0gdW53cmFwV2lkZ2V0U3ludGF4KHRleHQpO1xuICAgIGlmIChydWxlICYmIHJ1bGUudGVzdCh0ZXh0KSkge1xuICAgICAgICB2YXIgaW5kZXggPSB2b2lkIDA7XG4gICAgICAgIHdoaWxlICgoaW5kZXggPSB0ZXh0LnNlYXJjaChydWxlKSkgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHRleHQuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgIC8vIGdldCB3aWRnZXQgbm9kZSBvbiBmaXJzdCBzcGxpdHRlZCB0ZXh0IHVzaW5nIG5leHQgd2lkZ2V0IHJ1bGVcbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgbm9kZXMgPSBtZXJnZU5vZGVzKG5vZGVzLCBwcmV2LCBzY2hlbWEsIG5leHRSdWxlSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYnVpbGQgd2lkZ2V0IG5vZGUgdXNpbmcgY3VycmVudCB3aWRnZXQgcnVsZVxuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKGluZGV4KTtcbiAgICAgICAgICAgIHZhciBsaXRlcmFsID0gdGV4dC5tYXRjaChydWxlKVswXTtcbiAgICAgICAgICAgIHZhciBpbmZvID0gXCJ3aWRnZXRcIiArIHJ1bGVJbmRleDtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goc2NoZW1hLm5vZGVzLndpZGdldC5jcmVhdGUoeyBpbmZvOiBpbmZvIH0sIHNjaGVtYS50ZXh0KGNyZWF0ZVdpZGdldENvbnRlbnQoaW5mbywgbGl0ZXJhbCkpKSk7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcobGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCB3aWRnZXQgbm9kZSBvbiBsYXN0IHNwbGl0dGVkIHRleHQgdXNpbmcgbmV4dCB3aWRnZXQgcnVsZVxuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgbm9kZXMgPSBtZXJnZU5vZGVzKG5vZGVzLCB0ZXh0LCBzY2hlbWEsIG5leHRSdWxlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRleHQpIHtcbiAgICAgICAgbm9kZXMgPVxuICAgICAgICAgICAgcnVsZUluZGV4IDwgd2lkZ2V0UnVsZXMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgID8gbWVyZ2VOb2Rlcyhub2RlcywgdGV4dCwgc2NoZW1hLCBuZXh0UnVsZUluZGV4KVxuICAgICAgICAgICAgICAgIDogW3NjaGVtYS50ZXh0KHRleHQpXTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuZnVuY3Rpb24gZ2V0V2lkZ2V0Q29udGVudCh3aWRnZXROb2RlKSB7XG4gICAgdmFyIGV2ZW50O1xuICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgdmFyIHdhbGtlciA9IHdpZGdldE5vZGUud2Fsa2VyKCk7XG4gICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgIHZhciBub2RlID0gZXZlbnQubm9kZSwgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gd2lkZ2V0Tm9kZSAmJiBub2RlLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gZ2V0SW5saW5lTWFya2Rvd25UZXh0KG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIHNraXAgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgd2Fsa2VyLnJlc3VtZUF0KHdpZGdldE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvZG9tcHVyaWZ5L2Rpc3QvcHVyaWZ5LmpzXG52YXIgcHVyaWZ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNjgpO1xudmFyIHB1cmlmeV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihwdXJpZnkpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Nhbml0aXplci9odG1sU2FuaXRpemVyLnRzXG5cblxuXG52YXIgQ0FOX0JFX1dISVRFX1RBR19MSVNUID0gWydpZnJhbWUnLCAnZW1iZWQnXTtcbnZhciB3aGl0ZVRhZ0xpc3QgPSBbXTtcbmZ1bmN0aW9uIGh0bWxTYW5pdGl6ZXJfcmVnaXN0ZXJUYWdXaGl0ZWxpc3RJZlBvc3NpYmxlKHRhZ05hbWUpIHtcbiAgICBpZiAoY29tbW9uX2luY2x1ZGVzKENBTl9CRV9XSElURV9UQUdfTElTVCwgdGFnTmFtZSkpIHtcbiAgICAgICAgd2hpdGVUYWdMaXN0LnB1c2godGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUhUTUwoaHRtbCwgb3B0aW9ucykge1xuICAgIHJldHVybiBwdXJpZnlfZGVmYXVsdCgpLnNhbml0aXplKGh0bWwsIHRzbGliX2VzNl9hc3NpZ24oeyBBRERfVEFHUzogd2hpdGVUYWdMaXN0LCBBRERfQVRUUjogWydyZWwnLCAndGFyZ2V0JywgJ2hyZWZsYW5nJywgJ3R5cGUnXSwgRk9SQklEX1RBR1M6IFtcbiAgICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgICAnc2NyaXB0JyxcbiAgICAgICAgICAgICd0ZXh0YXJlYScsXG4gICAgICAgICAgICAnZm9ybScsXG4gICAgICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgICAgICdzZWxlY3QnLFxuICAgICAgICAgICAgJ21ldGEnLFxuICAgICAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgICAgICdsaW5rJyxcbiAgICAgICAgICAgICd0aXRsZScsXG4gICAgICAgICAgICAnb2JqZWN0JyxcbiAgICAgICAgICAgICdiYXNlJyxcbiAgICAgICAgXSB9LCBvcHRpb25zKSk7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy93eXNpd3lnL25vZGVzL2h0bWwudHNcblxuXG5cblxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW5IVE1MKG5vZGUsIHR5cGVOYW1lKSB7XG4gICAgcmV0dXJuIG5vZGVcbiAgICAgICAgLmxpdGVyYWwucmVwbGFjZShuZXcgUmVnRXhwKFwiKDxcXFxccypcIiArIHR5cGVOYW1lICsgXCJbXj5dKj4pfCg8L1wiICsgdHlwZU5hbWUgKyBcIlxcXFxzKls+XSlcIiwgJ2lnJyksICcnKVxuICAgICAgICAudHJpbSgpO1xufVxuZnVuY3Rpb24gZ2V0SFRNTEF0dHJzQnlIVE1MU3RyaW5nKGh0bWwpIHtcbiAgICBodG1sID0gaHRtbC5tYXRjaChyZUhUTUxUYWcpWzBdO1xuICAgIHZhciBhdHRycyA9IGh0bWwubWF0Y2gobmV3IFJlZ0V4cChjb25zdGFudHNfQVRUUklCVVRFLCAnZycpKTtcbiAgICByZXR1cm4gYXR0cnNcbiAgICAgICAgPyBhdHRycy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgYXR0cikge1xuICAgICAgICAgICAgdmFyIF9hID0gYXR0ci50cmltKCkuc3BsaXQoJz0nKSwgbmFtZSA9IF9hWzBdLCB2YWx1ZXMgPSBfYS5zbGljZSgxKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYWNjW25hbWVdID0gdmFsdWVzLmpvaW4oJz0nKS5yZXBsYWNlKC8nfFwiL2csICcnKS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSlcbiAgICAgICAgOiB7fTtcbn1cbmZ1bmN0aW9uIGdldEhUTUxBdHRycyhkb20pIHtcbiAgICByZXR1cm4gdG9BcnJheV9kZWZhdWx0KCkoZG9tLmF0dHJpYnV0ZXMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyKSB7XG4gICAgICAgIGFjY1thdHRyLm5vZGVOYW1lXSA9IGF0dHIubm9kZVZhbHVlO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplRE9NKG5vZGUsIHR5cGVOYW1lLCBzYW5pdGl6ZXIsIHd3VG9ET01BZGFwdG9yKSB7XG4gICAgdmFyIGRvbSA9IHd3VG9ET01BZGFwdG9yLmdldFRvRE9NTm9kZSh0eXBlTmFtZSkobm9kZSk7XG4gICAgdmFyIGh0bWwgPSBzYW5pdGl6ZXIoZG9tLm91dGVySFRNTCk7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICAgIGRvbSA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgIHZhciBodG1sQXR0cnMgPSBnZXRIVE1MQXR0cnMoZG9tKTtcbiAgICByZXR1cm4geyBkb206IGRvbSwgaHRtbEF0dHJzOiBodG1sQXR0cnMgfTtcbn1cbnZhciBzY2hlbWFGYWN0b3J5ID0ge1xuICAgIGh0bWxCbG9jazogZnVuY3Rpb24gKHR5cGVOYW1lLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdG9tOiB0cnVlLFxuICAgICAgICAgICAgY29udGVudDogJ2Jsb2NrKycsXG4gICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgaHRtbEF0dHJzOiB7IGRlZmF1bHQ6IHt9IH0sXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5IVE1MOiB7IGRlZmF1bHQ6ICcnIH0sXG4gICAgICAgICAgICAgICAgaHRtbEJsb2NrOiB7IGRlZmF1bHQ6IHRydWUgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiB0eXBlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEF0dHJzOiBnZXRIVE1MQXR0cnMoZG9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkhUTUw6IGRvbS5pbm5lckhUTUwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gc2FuaXRpemVET00obm9kZSwgdHlwZU5hbWUsIHNhbml0aXplSFRNTCwgd3dUb0RPTUFkYXB0b3IpLCBkb20gPSBfYS5kb20sIGh0bWxBdHRycyA9IF9hLmh0bWxBdHRycztcbiAgICAgICAgICAgICAgICBodG1sQXR0cnMuY2xhc3MgPSBodG1sQXR0cnMuY2xhc3MgPyBodG1sQXR0cnMuY2xhc3MgKyBcIiBodG1sLWJsb2NrXCIgOiAnaHRtbC1ibG9jayc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoW3R5cGVOYW1lLCBodG1sQXR0cnNdLCB0b0FycmF5X2RlZmF1bHQoKShkb20uY2hpbGROb2RlcykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGh0bWxJbmxpbmU6IGZ1bmN0aW9uICh0eXBlTmFtZSwgc2FuaXRpemVIVE1MLCB3d1RvRE9NQWRhcHRvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBodG1sQXR0cnM6IHsgZGVmYXVsdDoge30gfSxcbiAgICAgICAgICAgICAgICBodG1sSW5saW5lOiB7IGRlZmF1bHQ6IHRydWUgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiB0eXBlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEF0dHJzOiBnZXRIVE1MQXR0cnMoZG9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaHRtbEF0dHJzID0gc2FuaXRpemVET00obm9kZSwgdHlwZU5hbWUsIHNhbml0aXplSFRNTCwgd3dUb0RPTUFkYXB0b3IpLmh0bWxBdHRycztcbiAgICAgICAgICAgICAgICByZXR1cm4gW3R5cGVOYW1lLCBodG1sQXR0cnMsIDBdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUhUTUxTY2hlbWFNYXAoY29udmVydG9yTWFwLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKSB7XG4gICAgdmFyIGh0bWxTY2hlbWFNYXAgPSB7IG5vZGVzOiB7fSwgbWFya3M6IHt9IH07XG4gICAgWydodG1sQmxvY2snLCAnaHRtbElubGluZSddLmZvckVhY2goZnVuY3Rpb24gKGh0bWxUeXBlKSB7XG4gICAgICAgIGlmIChjb252ZXJ0b3JNYXBbaHRtbFR5cGVdKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb252ZXJ0b3JNYXBbaHRtbFR5cGVdKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFR5cGUgPSBodG1sVHlwZSA9PT0gJ2h0bWxCbG9jaycgPyAnbm9kZXMnIDogJ21hcmtzJztcbiAgICAgICAgICAgICAgICAvLyByZWdpc3RlciB0YWcgd2hpdGUgbGlzdCBmb3IgcHJldmVudGluZyB0byByZW1vdmUgdGhlIGh0bWwgaW4gc2FuaXRpemVyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJUYWdXaGl0ZWxpc3RJZlBvc3NpYmxlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGh0bWxTY2hlbWFNYXBbdGFyZ2V0VHlwZV1bdHlwZV0gPSBzY2hlbWFGYWN0b3J5W2h0bWxUeXBlXSh0eXBlLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGh0bWxTY2hlbWFNYXA7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9tYXJrZG93bi9odG1sUmVuZGVyQ29udmVydG9ycy50c1xuXG5cblxuXG5cblxudmFyIHJlQ2xvc2VUYWcgPSAvXlxccyo8XFxzKlxcLy87XG52YXIgaHRtbFJlbmRlckNvbnZlcnRvcnNfYmFzZUNvbnZlcnRvcnMgPSB7XG4gICAgcGFyYWdyYXBoOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmcsIG9yaWdpbiA9IF9hLm9yaWdpbiwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zLm5vZGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdwJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbigpO1xuICAgIH0sXG4gICAgc29mdGJyZWFrOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgaXNQcmV2Tm9kZUhUTUwgPSBub2RlLnByZXYgJiYgbm9kZS5wcmV2LnR5cGUgPT09ICdodG1sSW5saW5lJztcbiAgICAgICAgdmFyIGlzUHJldkJSID0gaXNQcmV2Tm9kZUhUTUwgJiYgLzxiciA/XFwvPz4vLnRlc3Qobm9kZS5wcmV2LmxpdGVyYWwpO1xuICAgICAgICB2YXIgY29udGVudCA9IGlzUHJldkJSID8gJ1xcbicgOiAnPGJyPlxcbic7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdodG1sJywgY29udGVudDogY29udGVudCB9O1xuICAgIH0sXG4gICAgaXRlbTogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xuICAgICAgICAgICAgaWYgKG5vZGUubGlzdERhdGEudGFzaykge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbJ2RhdGEtdGFzayddID0gJyc7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCd0YXNrLWxpc3QtaXRlbScpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmxpc3REYXRhLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdjaGVja2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbJ2RhdGEtdGFzay1jaGVja2VkJ10gPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAnbGknLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IGNsYXNzTmFtZXMsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2xpJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvZGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0geyAnZGF0YS1iYWNrdGlja3MnOiBTdHJpbmcobm9kZS50aWNrQ291bnQpIH07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2NvZGUnLCBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogbm9kZS5saXRlcmFsIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdjb2RlJyB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgY29kZUJsb2NrOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgX2EgPSBub2RlLCBmZW5jZUxlbmd0aCA9IF9hLmZlbmNlTGVuZ3RoLCBpbmZvID0gX2EuaW5mbztcbiAgICAgICAgdmFyIGluZm9Xb3JkcyA9IGluZm8gPyBpbmZvLnNwbGl0KC9cXHMrLykgOiBbXTtcbiAgICAgICAgdmFyIHByZUNsYXNzZXMgPSBbXTtcbiAgICAgICAgdmFyIGNvZGVBdHRycyA9IHt9O1xuICAgICAgICBpZiAoZmVuY2VMZW5ndGggPiAzKSB7XG4gICAgICAgICAgICBjb2RlQXR0cnNbJ2RhdGEtYmFja3RpY2tzJ10gPSBmZW5jZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mb1dvcmRzLmxlbmd0aCA+IDAgJiYgaW5mb1dvcmRzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBsYW5nID0gaW5mb1dvcmRzWzBdO1xuICAgICAgICAgICAgcHJlQ2xhc3Nlcy5wdXNoKFwibGFuZy1cIiArIGxhbmcpO1xuICAgICAgICAgICAgY29kZUF0dHJzWydkYXRhLWxhbmd1YWdlJ10gPSBsYW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ3ByZScsIGNsYXNzTmFtZXM6IHByZUNsYXNzZXMgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnY29kZScsIGF0dHJpYnV0ZXM6IGNvZGVBdHRycyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnY29kZScgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ3ByZScgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGN1c3RvbUlubGluZTogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBvcmlnaW4gPSBfYS5vcmlnaW4sIGVudGVyaW5nID0gX2EuZW50ZXJpbmcsIHNraXBDaGlsZHJlbiA9IF9hLnNraXBDaGlsZHJlbjtcbiAgICAgICAgdmFyIGluZm8gPSBub2RlLmluZm87XG4gICAgICAgIGlmIChpbmZvLmluZGV4T2YoJ3dpZGdldCcpICE9PSAtMSAmJiBlbnRlcmluZykge1xuICAgICAgICAgICAgc2tpcENoaWxkcmVuKCk7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGdldFdpZGdldENvbnRlbnQobm9kZSk7XG4gICAgICAgICAgICB2YXIgaHRtbElubGluZSA9IHdpZGdldFRvRE9NKGluZm8sIGNvbnRlbnQpLm91dGVySFRNTDtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdzcGFuJywgY2xhc3NOYW1lczogWyd0dWktd2lkZ2V0J10gfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdodG1sJywgY29udGVudDogaHRtbElubGluZSB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ3NwYW4nIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW4oKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGdldEhUTUxSZW5kZXJDb252ZXJ0b3JzKGxpbmtBdHRyaWJ1dGVzLCBjdXN0b21Db252ZXJ0b3JzKSB7XG4gICAgdmFyIGNvbnZlcnRvcnMgPSB0c2xpYl9lczZfYXNzaWduKHt9LCBodG1sUmVuZGVyQ29udmVydG9yc19iYXNlQ29udmVydG9ycyk7XG4gICAgaWYgKGxpbmtBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnZlcnRvcnMubGluayA9IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmcsIG9yaWdpbiA9IF9hLm9yaWdpbjtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcmlnaW4oKTtcbiAgICAgICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hdHRyaWJ1dGVzID0gdHNsaWJfZXM2X2Fzc2lnbih0c2xpYl9lczZfYXNzaWduKHt9LCByZXN1bHQuYXR0cmlidXRlcyksIGxpbmtBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChjdXN0b21Db252ZXJ0b3JzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGN1c3RvbUNvbnZlcnRvcnMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVUeXBlKSB7XG4gICAgICAgICAgICB2YXIgb3JnQ29udmVydG9yID0gY29udmVydG9yc1tub2RlVHlwZV07XG4gICAgICAgICAgICB2YXIgY3VzdG9tQ29udmVydG9yID0gY3VzdG9tQ29udmVydG9yc1tub2RlVHlwZV07XG4gICAgICAgICAgICBpZiAob3JnQ29udmVydG9yICYmIGlzRnVuY3Rpb25fZGVmYXVsdCgpKGN1c3RvbUNvbnZlcnRvcikpIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0b3JzW25vZGVUeXBlXSA9IGZ1bmN0aW9uIChub2RlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdDb250ZXh0ID0gdHNsaWJfZXM2X2Fzc2lnbih7fSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQub3JpZ2luID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb3JnQ29udmVydG9yKG5vZGUsIGNvbnRleHQpOyB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tQ29udmVydG9yKG5vZGUsIG5ld0NvbnRleHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21tb25faW5jbHVkZXMoWydodG1sQmxvY2snLCAnaHRtbElubGluZSddLCBub2RlVHlwZSkgJiYgIWlzRnVuY3Rpb25fZGVmYXVsdCgpKGN1c3RvbUNvbnZlcnRvcikpIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0b3JzW25vZGVUeXBlXSA9IGZ1bmN0aW9uIChub2RlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVkID0gbm9kZS5saXRlcmFsLm1hdGNoKHJlSFRNTFRhZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdEhUTUwgPSBtYXRjaGVkWzBdLCBvcGVuVGFnTmFtZSA9IG1hdGNoZWRbMV0sIGNsb3NlVGFnTmFtZSA9IG1hdGNoZWRbM107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZU5hbWUgPSAob3BlblRhZ05hbWUgfHwgY2xvc2VUYWdOYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWxDb252ZXJ0b3IgPSBjdXN0b21Db252ZXJ0b3JbdHlwZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuSFRNTCA9IGdldENoaWxkcmVuSFRNTChub2RlLCB0eXBlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHRtbENvbnZlcnRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgZm9yIHByZXZlbnRpbmcgdG8gb3ZlcndyaXRlIHRoZSBvcmlnaW5pYWwgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IHRzbGliX2VzNl9hc3NpZ24oe30sIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuYXR0cnMgPSBnZXRIVE1MQXR0cnNCeUhUTUxTdHJpbmcocm9vdEhUTUwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuY2hpbGRyZW5IVE1MID0gY2hpbGRyZW5IVE1MO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUudHlwZSA9IHR5cGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZW50ZXJpbmcgPSAhcmVDbG9zZVRhZy50ZXN0KG5vZGUubGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGh0bWxDb252ZXJ0b3IobmV3Tm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQub3JpZ2luKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnZlcnRvcnNbbm9kZVR5cGVdID0gY3VzdG9tQ29udmVydG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRvcnM7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9tYXJrZG93bi9zY3JvbGwvZG9tLnRzXG5cblxudmFyIG5lc3RhYmxlVHlwZXMgPSAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChbJ2xpc3QnLCAnaXRlbScsICdibG9ja1F1b3RlJ10pKTtcbnZhciBuZXN0YWJsZVRhZ05hbWVzID0gWydVTCcsICdPTCcsICdCTE9DS1FVT1RFJ107XG5mdW5jdGlvbiBpc0JsYW5rTGluZShkb2MsIGluZGV4KSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBwbU5vZGUgPSBkb2MuY2hpbGQoaW5kZXgpO1xuICAgIHJldHVybiAhcG1Ob2RlLmNoaWxkQ291bnQgfHwgKHBtTm9kZS5jaGlsZENvdW50ID09PSAxICYmICEoKF9hID0gcG1Ob2RlLmZpcnN0Q2hpbGQudGV4dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyaW0oKSkpO1xufVxuZnVuY3Rpb24gZ2V0RWRpdG9yUmFuZ2VIZWlnaHRJbmZvKGRvYywgbWROb2RlLCBjaGlsZHJlbikge1xuICAgIHZhciBzdGFydCA9IGdldE1kU3RhcnRMaW5lKG1kTm9kZSkgLSAxO1xuICAgIHZhciBlbmQgPSBnZXRNZEVuZExpbmUobWROb2RlKSAtIDE7XG4gICAgdmFyIHJlY3QgPSBjaGlsZHJlbltzdGFydF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGhlaWdodCA9IGNoaWxkcmVuW2VuZF0ub2Zmc2V0VG9wIC1cbiAgICAgICAgY2hpbGRyZW5bc3RhcnRdLm9mZnNldFRvcCArXG4gICAgICAgIGNoaWxkcmVuW2VuZF0uY2xpZW50SGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogaGVpZ2h0IDw9IDBcbiAgICAgICAgICAgID8gY2hpbGRyZW5bc3RhcnRdLmNsaWVudEhlaWdodFxuICAgICAgICAgICAgOiBoZWlnaHQgKyBnZXRCbGFua0xpbmVzSGVpZ2h0KGRvYywgY2hpbGRyZW4sIE1hdGgubWluKGVuZCArIDEsIGRvYy5jaGlsZENvdW50IC0gMSkpLFxuICAgICAgICByZWN0OiByZWN0LFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRCbGFua0xpbmVzSGVpZ2h0KGRvYywgY2hpbGRyZW4sIHN0YXJ0KSB7XG4gICAgdmFyIGVuZCA9IGRvYy5jaGlsZENvdW50IC0gMTtcbiAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kICYmIGlzQmxhbmtMaW5lKGRvYywgc3RhcnQpKSB7XG4gICAgICAgIGhlaWdodCArPSBjaGlsZHJlbltzdGFydF0uY2xpZW50SGVpZ2h0O1xuICAgICAgICBzdGFydCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0O1xufVxuZnVuY3Rpb24gZmluZEFuY2VzdG9ySGF2aW5nSWQoZWwsIHJvb3QpIHtcbiAgICB3aGlsZSAoIWVsLmdldEF0dHJpYnV0ZSgnZGF0YS1ub2RlaWQnKSAmJiBlbC5wYXJlbnRFbGVtZW50ICE9PSByb290KSB7XG4gICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gZG9tX2dldFRvdGFsT2Zmc2V0VG9wKGVsLCByb290KSB7XG4gICAgdmFyIG9mZnNldFRvcCA9IDA7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSByb290KSB7XG4gICAgICAgIGlmICghY29tbW9uX2luY2x1ZGVzKG5lc3RhYmxlVGFnTmFtZXMsIGVsLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICBvZmZzZXRUb3AgKz0gZWwub2Zmc2V0VG9wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbC5vZmZzZXRQYXJlbnQgPT09IHJvb3Qub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXRUb3A7XG59XG5mdW5jdGlvbiBmaW5kQWRqYWNlbnRFbGVtZW50VG9TY3JvbGxUb3Aoc2Nyb2xsVG9wLCByb290KSB7XG4gICAgdmFyIGVsID0gcm9vdDtcbiAgICB2YXIgcHJldiA9IG51bGw7XG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICAgIHZhciBmaXJzdEVsZW1lbnRDaGlsZCA9IGVsLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICBpZiAoIWZpcnN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdFNpYmxpbmcgPSBmaW5kTGFzdFNpYmxpbmdFbGVtZW50VG9TY3JvbGxUb3AoZmlyc3RFbGVtZW50Q2hpbGQsIHNjcm9sbFRvcCwgZG9tX2dldFRvdGFsT2Zmc2V0VG9wKGVsLCByb290KSk7XG4gICAgICAgIHByZXYgPSBlbDtcbiAgICAgICAgZWwgPSBsYXN0U2libGluZztcbiAgICB9XG4gICAgdmFyIGFkamFjZW50RWwgPSBlbCB8fCBwcmV2O1xuICAgIHJldHVybiBhZGphY2VudEVsID09PSByb290ID8gbnVsbCA6IGFkamFjZW50RWw7XG59XG5mdW5jdGlvbiBmaW5kTGFzdFNpYmxpbmdFbGVtZW50VG9TY3JvbGxUb3AoZWwsIHNjcm9sbFRvcCwgb2Zmc2V0VG9wKSB7XG4gICAgaWYgKGVsICYmIHNjcm9sbFRvcCA+IG9mZnNldFRvcCArIGVsLm9mZnNldFRvcCkge1xuICAgICAgICByZXR1cm4gKGZpbmRMYXN0U2libGluZ0VsZW1lbnRUb1Njcm9sbFRvcChlbC5uZXh0RWxlbWVudFNpYmxpbmcsIHNjcm9sbFRvcCwgb2Zmc2V0VG9wKSB8fCBlbCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0QWRkaXRpb25hbFBvcyhzY3JvbGxUb3AsIG9mZnNldFRvcCwgaGVpZ2h0LCB0YXJnZXROb2RlSGVpZ2h0KSB7XG4gICAgdmFyIHJhdGlvID0gTWF0aC5taW4oKHNjcm9sbFRvcCAtIG9mZnNldFRvcCkgLyBoZWlnaHQsIDEpO1xuICAgIHJldHVybiByYXRpbyAqIHRhcmdldE5vZGVIZWlnaHQ7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlT2JqKHByZXZpZXdDb250ZW50LCBtZE5vZGUpIHtcbiAgICB2YXIgZWwgPSBwcmV2aWV3Q29udGVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtbm9kZWlkPVxcXCJcIiArIG1kTm9kZS5pZCArIFwiXFxcIl1cIik7XG4gICAgd2hpbGUgKCFlbCB8fCBpc1N0eWxlZElubGluZU5vZGUobWROb2RlKSkge1xuICAgICAgICBtZE5vZGUgPSBtZE5vZGUucGFyZW50O1xuICAgICAgICBlbCA9IHByZXZpZXdDb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1ub2RlaWQ9XFxcIlwiICsgbWROb2RlLmlkICsgXCJcXFwiXVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldE5vbk5lc3RhYmxlTm9kZU9iaih7IG1kTm9kZTogbWROb2RlLCBlbDogZWwgfSk7XG59XG5mdW5jdGlvbiBnZXROb25OZXN0YWJsZU5vZGVPYmooX2EpIHtcbiAgICB2YXIgbWROb2RlID0gX2EubWROb2RlLCBlbCA9IF9hLmVsO1xuICAgIHdoaWxlICgoaW5jbHVkZXMobmVzdGFibGVUeXBlcywgbWROb2RlLnR5cGUpIHx8IG1kTm9kZS50eXBlID09PSAndGFibGUnKSAmJiBtZE5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBtZE5vZGUgPSBtZE5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgZWwgPSBlbC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWROb2RlOiBtZE5vZGUsIGVsOiBlbCB9O1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWFya2Rvd24vc2Nyb2xsL29mZnNldC50c1xuXG5cbnZhciBvZmZzZXRJbmZvTWFwID0ge307XG5mdW5jdGlvbiBzZXRIZWlnaHQoaWQsIGhlaWdodCkge1xuICAgIG9mZnNldEluZm9NYXBbaWRdID0gb2Zmc2V0SW5mb01hcFtpZF0gfHwge307XG4gICAgb2Zmc2V0SW5mb01hcFtpZF0uaGVpZ2h0ID0gaGVpZ2h0O1xufVxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9wKGlkLCBvZmZzZXRUb3ApIHtcbiAgICBvZmZzZXRJbmZvTWFwW2lkXSA9IG9mZnNldEluZm9NYXBbaWRdIHx8IHt9O1xuICAgIG9mZnNldEluZm9NYXBbaWRdLm9mZnNldFRvcCA9IG9mZnNldFRvcDtcbn1cbmZ1bmN0aW9uIGdldEhlaWdodChpZCkge1xuICAgIHJldHVybiBvZmZzZXRJbmZvTWFwW2lkXSAmJiBvZmZzZXRJbmZvTWFwW2lkXS5oZWlnaHQ7XG59XG5mdW5jdGlvbiBnZXRPZmZzZXRUb3AoaWQpIHtcbiAgICByZXR1cm4gb2Zmc2V0SW5mb01hcFtpZF0gJiYgb2Zmc2V0SW5mb01hcFtpZF0ub2Zmc2V0VG9wO1xufVxuZnVuY3Rpb24gcmVtb3ZlT2Zmc2V0SW5mb0J5Tm9kZShub2RlKSB7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgZGVsZXRlIG9mZnNldEluZm9NYXBbTnVtYmVyKG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW5vZGVpZCcpKV07XG4gICAgICAgIHRvQXJyYXlfZGVmYXVsdCgpKG5vZGUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZW1vdmVPZmZzZXRJbmZvQnlOb2RlKGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QW5kU2F2ZU9mZnNldEluZm8obm9kZSwgcm9vdCwgbWROb2RlSWQpIHtcbiAgICB2YXIgY2FjaGVkSGVpZ2h0ID0gZ2V0SGVpZ2h0KG1kTm9kZUlkKTtcbiAgICB2YXIgY2FjaGVkVG9wID0gZ2V0T2Zmc2V0VG9wKG1kTm9kZUlkKTtcbiAgICB2YXIgbm9kZUhlaWdodCA9IGNhY2hlZEhlaWdodCB8fCBub2RlLmNsaWVudEhlaWdodDtcbiAgICB2YXIgb2Zmc2V0VG9wID0gY2FjaGVkVG9wIHx8IGdldFRvdGFsT2Zmc2V0VG9wKG5vZGUsIHJvb3QpIHx8IG5vZGUub2Zmc2V0VG9wO1xuICAgIGlmICghY2FjaGVkSGVpZ2h0KSB7XG4gICAgICAgIHNldEhlaWdodChtZE5vZGVJZCwgbm9kZUhlaWdodCk7XG4gICAgfVxuICAgIGlmICghY2FjaGVkVG9wKSB7XG4gICAgICAgIHNldE9mZnNldFRvcChtZE5vZGVJZCwgb2Zmc2V0VG9wKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZUhlaWdodDogbm9kZUhlaWdodCwgb2Zmc2V0VG9wOiBvZmZzZXRUb3AgfTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21hcmtkb3duL21kUHJldmlldy50c1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBDTEFTU19ISUdITElHSFQgPSBjbHMoJ21kLXByZXZpZXctaGlnaGxpZ2h0Jyk7XG5mdW5jdGlvbiBmaW5kVGFibGVDZWxsKHRhYmxlUm93LCBjaE9mZnNldCkge1xuICAgIHZhciBjZWxsID0gdGFibGVSb3cuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2VsbCAmJiBjZWxsLm5leHQpIHtcbiAgICAgICAgaWYgKGdldE1kU3RhcnRDaChjZWxsLm5leHQpID4gY2hPZmZzZXQgKyAxKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjZWxsID0gY2VsbC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gY2VsbDtcbn1cbi8qKlxuICogQ2xhc3MgTWFya2Rvd24gUHJldmlld1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBiYXNlIGVsZW1lbnRcbiAqIEBwYXJhbSB7ZXZlbnRFbWl0dGVyfSBldmVudEVtaXR0ZXIgLSBldmVudCBtYW5hZ2VyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmlzVmlld2VyIC0gdHJ1ZSBmb3Igdmlldy1vbmx5IG1vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5oaWdobGlnaHQgLSB0cnVlIGZvciB1c2luZyBsaXZlLWhpZ2hsaWdodCBmZWF0dXJlXG4gKiBAcGFyYW0ge29iamVjdH0gb3BpdG9ucy5saW5rQXR0cmlidXRlcyAtIGF0dHJpYnV0ZXMgZm9yIGxpbmsgZWxlbWVudFxuICogQHBhcmFtIHtvYmplY3R9IG9waXRvbnMuY3VzdG9tSFRNTFJlbmRlcmVyIC0gbWFwIG9mIGN1c3RvbSBIVE1MIHJlbmRlciBmdW5jdGlvbnNcbiAqXG4gKiBAaWdub3JlXG4gKi9cbnZhciBNYXJrZG93blByZXZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFya2Rvd25QcmV2aWV3KGV2ZW50RW1pdHRlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IGV2ZW50RW1pdHRlcjtcbiAgICAgICAgdGhpcy5pc1ZpZXdlciA9ICEhb3B0aW9ucy5pc1ZpZXdlcjtcbiAgICAgICAgdGhpcy5lbC5jbGFzc05hbWUgPSBjbHMoJ21kLXByZXZpZXcnKTtcbiAgICAgICAgdmFyIGxpbmtBdHRyaWJ1dGVzID0gb3B0aW9ucy5saW5rQXR0cmlidXRlcywgY3VzdG9tSFRNTFJlbmRlcmVyID0gb3B0aW9ucy5jdXN0b21IVE1MUmVuZGVyZXIsIHNhbml0aXplciA9IG9wdGlvbnMuc2FuaXRpemVyLCBfYSA9IG9wdGlvbnMuaGlnaGxpZ2h0LCBoaWdobGlnaHQgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcih7XG4gICAgICAgICAgICBnZm06IHRydWUsXG4gICAgICAgICAgICBub2RlSWQ6IHRydWUsXG4gICAgICAgICAgICBjb252ZXJ0b3JzOiBnZXRIVE1MUmVuZGVyQ29udmVydG9ycyhsaW5rQXR0cmlidXRlcywgY3VzdG9tSFRNTFJlbmRlcmVyKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3Vyc29yTm9kZUlkID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYW5pdGl6ZXIgPSBzYW5pdGl6ZXI7XG4gICAgICAgIHRoaXMuaW5pdEV2ZW50KGhpZ2hsaWdodCk7XG4gICAgICAgIHRoaXMuaW5pdENvbnRlbnRTZWN0aW9uKCk7XG4gICAgICAgIC8vIFRvIHByZXZlbnQgb3ZlcmZsb3dpbmcgY29udGVudHMgaW4gdGhlIHZpZXdlclxuICAgICAgICBpZiAodGhpcy5pc1ZpZXdlcikge1xuICAgICAgICAgICAgdGhpcy5wcmV2aWV3Q29udGVudC5zdHlsZS5vdmVyZmxvd1dyYXAgPSAnYnJlYWstd29yZCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5pbml0Q29udGVudFNlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJldmlld0NvbnRlbnQgPSBjcmVhdGVFbGVtZW50V2l0aChcIjxkaXYgY2xhc3M9XFxcIlwiICsgY2xzKCdjb250ZW50cycpICsgXCJcXFwiPjwvZGl2PlwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmlld2VyKSB7XG4gICAgICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMucHJldmlld0NvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLnRvZ2dsZUFjdGl2ZSA9IGZ1bmN0aW9uIChhY3RpdmUpIHtcbiAgICAgICAgdG9nZ2xlQ2xhc3ModGhpcy5lbCwgJ2FjdGl2ZScsIGFjdGl2ZSk7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uIChoaWdobGlnaHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCd1cGRhdGVQcmV2aWV3JywgdGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIGlmICh0aGlzLmlzVmlld2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpZ2hsaWdodCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdjaGFuZ2VUb29sYmFyU3RhdGUnLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWROb2RlID0gX2EubWROb2RlLCBjdXJzb3JQb3MgPSBfYS5jdXJzb3JQb3M7XG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlQ3Vyc29yTm9kZShtZE5vZGUsIGN1cnNvclBvcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignYmx1cicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVIaWdobGlnaHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG9uX2RlZmF1bHQoKSh0aGlzLmVsLCAnc2Nyb2xsJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnc2Nyb2xsJywgJ3ByZXZpZXcnLCBmaW5kQWRqYWNlbnRFbGVtZW50VG9TY3JvbGxUb3AoZXZlbnQudGFyZ2V0LnNjcm9sbFRvcCwgX3RoaXMucHJldmlld0NvbnRlbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignY2hhbmdlUHJldmlld1RhYlByZXZpZXcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50b2dnbGVBY3RpdmUodHJ1ZSk7IH0pO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2NoYW5nZVByZXZpZXdUYWJXcml0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRvZ2dsZUFjdGl2ZShmYWxzZSk7IH0pO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5yZW1vdmVIaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvck5vZGVJZCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRFbCA9IHRoaXMuZ2V0RWxlbWVudEJ5Tm9kZUlkKHRoaXMuY3Vyc29yTm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RWwpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzc19kZWZhdWx0KCkoY3VycmVudEVsLCBDTEFTU19ISUdITElHSFQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLnVwZGF0ZUN1cnNvck5vZGUgPSBmdW5jdGlvbiAoY3Vyc29yTm9kZSwgY3Vyc29yUG9zKSB7XG4gICAgICAgIGlmIChjdXJzb3JOb2RlKSB7XG4gICAgICAgICAgICBjdXJzb3JOb2RlID0gZmluZENsb3Nlc3ROb2RlKGN1cnNvck5vZGUsIGZ1bmN0aW9uIChtZE5vZGUpIHsgcmV0dXJuICFpc0lubGluZU5vZGUobWROb2RlKTsgfSk7XG4gICAgICAgICAgICBpZiAoY3Vyc29yTm9kZS50eXBlID09PSAndGFibGVSb3cnKSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yTm9kZSA9IGZpbmRUYWJsZUNlbGwoY3Vyc29yTm9kZSwgY3Vyc29yUG9zWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnNvck5vZGUudHlwZSA9PT0gJ3RhYmxlQm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBsaW5lIG5leHQgdG8gdGFibGVcbiAgICAgICAgICAgICAgICBjdXJzb3JOb2RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY3Vyc29yTm9kZUlkID0gY3Vyc29yTm9kZSA/IGN1cnNvck5vZGUuaWQgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5jdXJzb3JOb2RlSWQgPT09IGN1cnNvck5vZGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGRFTCA9IHRoaXMuZ2V0RWxlbWVudEJ5Tm9kZUlkKHRoaXMuY3Vyc29yTm9kZUlkKTtcbiAgICAgICAgdmFyIG5ld0VMID0gdGhpcy5nZXRFbGVtZW50QnlOb2RlSWQoY3Vyc29yTm9kZUlkKTtcbiAgICAgICAgaWYgKG9sZEVMKSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzc19kZWZhdWx0KCkob2xkRUwsIENMQVNTX0hJR0hMSUdIVCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0VMKSB7XG4gICAgICAgICAgICBhZGRDbGFzc19kZWZhdWx0KCkobmV3RUwsIENMQVNTX0hJR0hMSUdIVCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJzb3JOb2RlSWQgPSBjdXJzb3JOb2RlSWQ7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLmdldEVsZW1lbnRCeU5vZGVJZCA9IGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVJZFxuICAgICAgICAgICAgPyB0aGlzLnByZXZpZXdDb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1ub2RlaWQ9XFxcIlwiICsgbm9kZUlkICsgXCJcXFwiXVwiKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoY2hhbmdlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjaGFuZ2VkLmZvckVhY2goZnVuY3Rpb24gKGVkaXRSZXN1bHQpIHsgcmV0dXJuIF90aGlzLnJlcGxhY2VSYW5nZU5vZGVzKGVkaXRSZXN1bHQpOyB9KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnYWZ0ZXJQcmV2aWV3UmVuZGVyJywgdGhpcyk7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLnJlcGxhY2VSYW5nZU5vZGVzID0gZnVuY3Rpb24gKGVkaXRSZXN1bHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vZGVzID0gZWRpdFJlc3VsdC5ub2RlcywgcmVtb3ZlZE5vZGVSYW5nZSA9IGVkaXRSZXN1bHQucmVtb3ZlZE5vZGVSYW5nZTtcbiAgICAgICAgdmFyIGNvbnRlbnRFbCA9IHRoaXMucHJldmlld0NvbnRlbnQ7XG4gICAgICAgIHZhciBuZXdIdG1sID0gdGhpcy5ldmVudEVtaXR0ZXIuZW1pdFJlZHVjZSgnYmVmb3JlUHJldmlld1JlbmRlcicsIHRoaXMuc2FuaXRpemVyKG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gX3RoaXMucmVuZGVyZXIucmVuZGVyKG5vZGUpOyB9KS5qb2luKCcnKSkpO1xuICAgICAgICBpZiAoIXJlbW92ZWROb2RlUmFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnRlbnRFbC5pbnNlcnRBZGphY2VudEhUTUwoJ2FmdGVyYmVnaW4nLCBuZXdIdG1sKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHJlbW92ZWROb2RlUmFuZ2UuaWQsIHN0YXJ0Tm9kZUlkID0gX2FbMF0sIGVuZE5vZGVJZCA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIHN0YXJ0RWwgPSB0aGlzLmdldEVsZW1lbnRCeU5vZGVJZChzdGFydE5vZGVJZCk7XG4gICAgICAgICAgICB2YXIgZW5kRWwgPSB0aGlzLmdldEVsZW1lbnRCeU5vZGVJZChlbmROb2RlSWQpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0RWwpIHtcbiAgICAgICAgICAgICAgICBzdGFydEVsLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlYmVnaW4nLCBuZXdIdG1sKTtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBzdGFydEVsO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gZW5kRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRFbCA9IGVsLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShlbCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU9mZnNldEluZm9CeU5vZGUoZWwpO1xuICAgICAgICAgICAgICAgICAgICBlbCA9IG5leHRFbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsID09PSBudWxsIHx8IGVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoZWwpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVPZmZzZXRJbmZvQnlOb2RlKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuZ2V0UmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmZfZGVmYXVsdCgpKHRoaXMuZWwsICdzY3JvbGwnKTtcbiAgICAgICAgdGhpcy5lbCA9IG51bGw7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5nZXRIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlUHJvc2VNaXJyb3JIYWNrTm9kZXModGhpcy5wcmV2aWV3Q29udGVudC5pbm5lckhUTUwpO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5zZXRIVE1MID0gZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgdGhpcy5wcmV2aWV3Q29udGVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gICAgICAgIGNzc19kZWZhdWx0KCkodGhpcy5lbCwgeyBoZWlnaHQ6IGhlaWdodCArIFwicHhcIiB9KTtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuc2V0TWluSGVpZ2h0ID0gZnVuY3Rpb24gKG1pbkhlaWdodCkge1xuICAgICAgICBjc3NfZGVmYXVsdCgpKHRoaXMuZWwsIHsgbWluSGVpZ2h0OiBtaW5IZWlnaHQgKyBcInB4XCIgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFya2Rvd25QcmV2aWV3O1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG1kUHJldmlldyA9IChNYXJrZG93blByZXZpZXcpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJwcm9zZW1pcnJvci1zdGF0ZVwiLFwiY29tbW9uanMyXCI6XCJwcm9zZW1pcnJvci1zdGF0ZVwiLFwiYW1kXCI6XCJwcm9zZW1pcnJvci1zdGF0ZVwifVxudmFyIGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX3N0YXRlX2NvbW1vbmpzMl9wcm9zZW1pcnJvcl9zdGF0ZV9hbWRfcHJvc2VtaXJyb3Jfc3RhdGVfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTQpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwicHJvc2VtaXJyb3ItaW5wdXRydWxlc1wiLFwiY29tbW9uanMyXCI6XCJwcm9zZW1pcnJvci1pbnB1dHJ1bGVzXCIsXCJhbWRcIjpcInByb3NlbWlycm9yLWlucHV0cnVsZXNcIn1cbnZhciBleHRlcm5hbF9jb21tb25qc19wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzX2NvbW1vbmpzMl9wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzX2FtZF9wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDc5KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcInByb3NlbWlycm9yLXZpZXdcIixcImNvbW1vbmpzMlwiOlwicHJvc2VtaXJyb3Itdmlld1wiLFwiYW1kXCI6XCJwcm9zZW1pcnJvci12aWV3XCJ9XG52YXIgZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3Jfdmlld19jb21tb25qczJfcHJvc2VtaXJyb3Jfdmlld19hbWRfcHJvc2VtaXJyb3Jfdmlld18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxMSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJwcm9zZW1pcnJvci1rZXltYXBcIixcImNvbW1vbmpzMlwiOlwicHJvc2VtaXJyb3Ita2V5bWFwXCIsXCJhbWRcIjpcInByb3NlbWlycm9yLWtleW1hcFwifVxudmFyIGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX2tleW1hcF9jb21tb25qczJfcHJvc2VtaXJyb3Jfa2V5bWFwX2FtZF9wcm9zZW1pcnJvcl9rZXltYXBfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0ODEpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwicHJvc2VtaXJyb3ItbW9kZWxcIixcImNvbW1vbmpzMlwiOlwicHJvc2VtaXJyb3ItbW9kZWxcIixcImFtZFwiOlwicHJvc2VtaXJyb3ItbW9kZWxcIn1cbnZhciBleHRlcm5hbF9jb21tb25qc19wcm9zZW1pcnJvcl9tb2RlbF9jb21tb25qczJfcHJvc2VtaXJyb3JfbW9kZWxfYW1kX3Byb3NlbWlycm9yX21vZGVsXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9hcnJheS9pbkFycmF5LmpzXG52YXIgaW5BcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oOTI4KTtcbnZhciBpbkFycmF5X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGluQXJyYXkpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzL21hcC50c1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGlnbm9yZVxuICogQGNsYXNzZGVzYyBFUzYgTWFwXG4gKi9cbnZhciBtYXBfTWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcCgpIHtcbiAgICAgICAgdGhpcy5rZXlzID0gW107XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgfVxuICAgIE1hcC5wcm90b3R5cGUuZ2V0S2V5SW5kZXggPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBpbkFycmF5X2RlZmF1bHQoKShrZXksIHRoaXMua2V5cyk7XG4gICAgfTtcbiAgICBNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW3RoaXMuZ2V0S2V5SW5kZXgoa2V5KV07XG4gICAgfTtcbiAgICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBrZXlJbmRleCA9IHRoaXMuZ2V0S2V5SW5kZXgoa2V5KTtcbiAgICAgICAgaWYgKGtleUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzW2tleUluZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEtleUluZGV4KGtleSkgPiAtMTtcbiAgICB9O1xuICAgIE1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIga2V5SW5kZXggPSB0aGlzLmdldEtleUluZGV4KGtleSk7XG4gICAgICAgIGlmIChrZXlJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmtleXMuc3BsaWNlKGtleUluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnNwbGljZShrZXlJbmRleCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBNYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXNBcmcgPT09IHZvaWQgMCkgeyB0aGlzQXJnID0gdGhpczsgfVxuICAgICAgICB0aGlzLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBfdGhpcy5rZXlzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIF90aGlzLmtleXNbaW5kZXhdLCBfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5rZXlzID0gW107XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgfTtcbiAgICByZXR1cm4gTWFwO1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHV0aWxzX21hcCA9IChtYXBfTWFwKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2kxOG4vaTE4bi50c1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEltcGxlbWVudHMgaTE4blxuICogQGF1dGhvciBOSE4gQ2xvdWQgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG52YXIgREVGQVVMVF9DT0RFID0gJ2VuLVVTJztcbi8qKlxuICogQ2xhc3MgSTE4blxuICogQGlnbm9yZVxuICovXG52YXIgSTE4biA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJMThuKCkge1xuICAgICAgICB0aGlzLmNvZGUgPSBERUZBVUxUX0NPREU7XG4gICAgICAgIHRoaXMubGFuZ3MgPSBuZXcgdXRpbHNfbWFwKCk7XG4gICAgfVxuICAgIEkxOG4ucHJvdG90eXBlLnNldENvZGUgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlIHx8IERFRkFVTFRfQ09ERTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBsYW5ndWFnZSBzZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gY29kZXMgbG9jYWxlIGNvZGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBsYW5ndWFnZSBzZXRcbiAgICAgKi9cbiAgICBJMThuLnByb3RvdHlwZS5zZXRMYW5ndWFnZSA9IGZ1bmN0aW9uIChjb2RlcywgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjb2RlcyA9IFtdLmNvbmNhdChjb2Rlcyk7XG4gICAgICAgIGNvZGVzLmZvckVhY2goZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMubGFuZ3MuaGFzKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubGFuZ3Muc2V0KGNvZGUsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhbmdEYXRhID0gX3RoaXMubGFuZ3MuZ2V0KGNvZGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxhbmdzLnNldChjb2RlLCBleHRlbmRfZGVmYXVsdCgpKGxhbmdEYXRhLCBkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSTE4bi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSwgY29kZSkge1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhbmdTZXQgPSB0aGlzLmxhbmdzLmdldChjb2RlKTtcbiAgICAgICAgaWYgKCFsYW5nU2V0KSB7XG4gICAgICAgICAgICBsYW5nU2V0ID0gdGhpcy5sYW5ncy5nZXQoREVGQVVMVF9DT0RFKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dCA9IGxhbmdTZXRba2V5XTtcbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyB0ZXh0IGtleSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaW4gXCIgKyBjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIHJldHVybiBJMThuO1xufSgpKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaTE4biA9IChuZXcgSTE4bigpKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3d5c2l3eWcvaGVscGVyL25vZGUudHNcblxuXG5mdW5jdGlvbiBmaW5kTm9kZUJ5KHBvcywgY29uZGl0aW9uKSB7XG4gICAgdmFyIGRlcHRoID0gcG9zLmRlcHRoO1xuICAgIHdoaWxlIChkZXB0aCkge1xuICAgICAgICB2YXIgbm9kZSA9IHBvcy5ub2RlKGRlcHRoKTtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihub2RlLCBkZXB0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICBkZXB0aDogZGVwdGgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBkZXB0aCA+IDAgPyBwb3MuYmVmb3JlKGRlcHRoKSA6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGRlcHRoIC09IDE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbm9kZV9pc0xpc3ROb2RlKF9hKSB7XG4gICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICdidWxsZXRMaXN0JyB8fCB0eXBlLm5hbWUgPT09ICdvcmRlcmVkTGlzdCc7XG59XG5mdW5jdGlvbiBpc0luTGlzdE5vZGUocG9zKSB7XG4gICAgcmV0dXJuICEhZmluZE5vZGVCeShwb3MsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICdsaXN0SXRlbScgfHwgdHlwZS5uYW1lID09PSAnYnVsbGV0TGlzdCcgfHwgdHlwZS5uYW1lID09PSAnb3JkZXJlZExpc3QnO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNJblRhYmxlTm9kZShwb3MpIHtcbiAgICByZXR1cm4gISFmaW5kTm9kZUJ5KHBvcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ3RhYmxlSGVhZENlbGwnIHx8IHR5cGUubmFtZSA9PT0gJ3RhYmxlQm9keUNlbGwnO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZmluZExpc3RJdGVtKHBvcykge1xuICAgIHJldHVybiBmaW5kTm9kZUJ5KHBvcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ2xpc3RJdGVtJztcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURPTUluZm9QYXJzZWRSYXdIVE1MKHRhZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhZzogdGFnLFxuICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNlbGxBdHRycyhhdHRycykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRycykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGF0dHJOYW1lKSB7XG4gICAgICAgIGlmIChhdHRyTmFtZSAhPT0gJ3Jhd0hUTUwnICYmIGF0dHJzW2F0dHJOYW1lXSkge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyTmFtZSA9PT0gJ2NsYXNzTmFtZScgPyAnY2xhc3MnIDogYXR0ck5hbWU7XG4gICAgICAgICAgICBhY2NbYXR0ck5hbWVdID0gYXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFyc2VkQ2VsbERPTSh0YWcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgIHJldHVybiBbJ3Jhd0hUTUwnLCAnY29sc3BhbicsICdyb3dzcGFuJywgJ2V4dGVuZGVkJ10ucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGF0dHJOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lSW5ET00gPSBhdHRyTmFtZSA9PT0gJ3Jhd0hUTUwnID8gJ2RhdGEtcmF3LWh0bWwnIDogYXR0ck5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IGRvbS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWVJbkRPTSk7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NbYXR0ck5hbWVdID0gaW5jbHVkZXMoWydyYXdIVE1MJywgJ2V4dGVuZGVkJ10sIGF0dHJOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhdHRyVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTnVtYmVyKGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRDdXN0b21BdHRycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBodG1sQXR0cnM6IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICBjbGFzc05hbWVzOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpIHtcbiAgICB2YXIgaHRtbEF0dHJzID0gYXR0cnMuaHRtbEF0dHJzLCBjbGFzc05hbWVzID0gYXR0cnMuY2xhc3NOYW1lcztcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGh0bWxBdHRycyksIHsgY2xhc3M6IGNsYXNzTmFtZXMgPyBjbGFzc05hbWVzLmpvaW4oJyAnKSA6IG51bGwgfSk7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy93eXNpd3lnL2hlbHBlci90YWJsZU9mZnNldE1hcC50c1xuXG5cbnZhciBjYWNoZSA9IG5ldyBNYXAoKTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xudmFyIFRhYmxlT2Zmc2V0TWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhYmxlT2Zmc2V0TWFwKHRhYmxlLCB0YWJsZVJvd3MsIHRhYmxlU3RhcnRQb3MsIHJvd0luZm8pIHtcbiAgICAgICAgdGhpcy50YWJsZSA9IHRhYmxlO1xuICAgICAgICB0aGlzLnRhYmxlUm93cyA9IHRhYmxlUm93cztcbiAgICAgICAgdGhpcy50YWJsZVN0YXJ0UG9zID0gdGFibGVTdGFydFBvcztcbiAgICAgICAgdGhpcy5yb3dJbmZvID0gcm93SW5mbztcbiAgICB9XG4gICAgVGFibGVPZmZzZXRNYXAuY3JlYXRlID0gZnVuY3Rpb24gKGNlbGxQb3MpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gZmluZE5vZGVCeShjZWxsUG9zLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICd0YWJsZSc7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGFibGUpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGFibGUubm9kZSwgZGVwdGggPSB0YWJsZS5kZXB0aCwgb2Zmc2V0ID0gdGFibGUub2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGNhY2hlZCA9IGNhY2hlLmdldChub2RlKTtcbiAgICAgICAgICAgIGlmICgoY2FjaGVkID09PSBudWxsIHx8IGNhY2hlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FjaGVkLnRhYmxlU3RhcnRQb3MpID09PSBvZmZzZXQgKyAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByb3dzXzEgPSBbXTtcbiAgICAgICAgICAgIHZhciB0YWJsZVBvcyA9IGNlbGxQb3Muc3RhcnQoZGVwdGgpO1xuICAgICAgICAgICAgdmFyIHRoZWFkID0gbm9kZS5jaGlsZCgwKTtcbiAgICAgICAgICAgIHZhciB0Ym9keSA9IG5vZGUuY2hpbGQoMSk7XG4gICAgICAgICAgICB2YXIgdGhlYWRDZWxsSW5mbyA9IGNyZWF0ZU9mZnNldE1hcCh0aGVhZCwgdGFibGVQb3MpO1xuICAgICAgICAgICAgdmFyIHRib2R5Q2VsbEluZm8gPSBjcmVhdGVPZmZzZXRNYXAodGJvZHksIHRhYmxlUG9zICsgdGhlYWQubm9kZVNpemUpO1xuICAgICAgICAgICAgdGhlYWQuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7IHJldHVybiByb3dzXzEucHVzaChyb3cpOyB9KTtcbiAgICAgICAgICAgIHRib2R5LmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93c18xLnB1c2gocm93KTsgfSk7XG4gICAgICAgICAgICB2YXIgbWFwID0gbmV3IFRhYmxlT2Zmc2V0TWFwKG5vZGUsIHJvd3NfMSwgdGFibGVQb3MsIHRoZWFkQ2VsbEluZm8uY29uY2F0KHRib2R5Q2VsbEluZm8pKTtcbiAgICAgICAgICAgIGNhY2hlLnNldChub2RlLCBtYXApO1xuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUsIFwidG90YWxSb3dDb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SW5mby5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLCBcInRvdGFsQ29sdW1uQ291bnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0luZm9bMF0ubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZSwgXCJ0YWJsZVN0YXJ0T2Zmc2V0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWJsZVN0YXJ0UG9zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZSwgXCJ0YWJsZUVuZE9mZnNldFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFibGVTdGFydFBvcyArIHRoaXMudGFibGUubm9kZVNpemUgLSAxO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldENlbGxJbmZvID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd0luZm9bcm93SWR4XVtjb2xJZHhdO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLnBvc0F0ID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCByb3dTdGFydCA9IHRoaXMudGFibGVTdGFydFBvczs7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHJvd0VuZCA9IHJvd1N0YXJ0ICsgdGhpcy50YWJsZVJvd3NbaV0ubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoaSA9PT0gcm93SWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gY29sSWR4O1xuICAgICAgICAgICAgICAgIC8vIFNraXAgdGhlIGNlbGxzIGZyb20gcHJldmlvdXMgcm93KHZpYSByb3dzcGFuKVxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IHRoaXMudG90YWxDb2x1bW5Db3VudCAmJiB0aGlzLnJvd0luZm9baV1baW5kZXhdLm9mZnNldCA8IHJvd1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gdGhpcy50b3RhbENvbHVtbkNvdW50ID8gcm93RW5kIDogdGhpcy5yb3dJbmZvW2ldW2luZGV4XS5vZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dTdGFydCA9IHJvd0VuZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldE5vZGVBbmRQb3MgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgdmFyIGNlbGxJbmZvID0gdGhpcy5yb3dJbmZvW3Jvd0lkeF1bY29sSWR4XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGU6IHRoaXMudGFibGUubm9kZUF0KGNlbGxJbmZvLm9mZnNldCAtIHRoaXMudGFibGVTdGFydE9mZnNldCksXG4gICAgICAgICAgICBwb3M6IGNlbGxJbmZvLm9mZnNldCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5leHRlbmRlZFJvd3NwYW4gPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmV4dGVuZGVkQ29sc3BhbiA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Um93c3BhbkNvdW50ID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldENvbHNwYW5Db3VudCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5kZWNyZWFzZUNvbHNwYW5Db3VudCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5kZWNyZWFzZVJvd3NwYW5Db3VudCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDb2xzcGFuU3RhcnRJbmZvID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldFJvd3NwYW5TdGFydEluZm8gPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Q2VsbFN0YXJ0T2Zmc2V0ID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnJvd0luZm9bcm93SWR4XVtjb2xJZHhdLm9mZnNldDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kZWRSb3dzcGFuKHJvd0lkeCwgY29sSWR4KSA/IHRoaXMucG9zQXQocm93SWR4LCBjb2xJZHgpIDogb2Zmc2V0O1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldENlbGxFbmRPZmZzZXQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5yb3dJbmZvW3Jvd0lkeF1bY29sSWR4XSwgb2Zmc2V0ID0gX2Eub2Zmc2V0LCBub2RlU2l6ZSA9IF9hLm5vZGVTaXplO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlbmRlZFJvd3NwYW4ocm93SWR4LCBjb2xJZHgpID8gdGhpcy5wb3NBdChyb3dJZHgsIGNvbElkeCkgOiBvZmZzZXQgKyBub2RlU2l6ZTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDZWxsSW5kZXggPSBmdW5jdGlvbiAoY2VsbFBvcykge1xuICAgICAgICBmb3IgKHZhciByb3dJZHggPSAwOyByb3dJZHggPCB0aGlzLnRvdGFsUm93Q291bnQ7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgcm93SW5mbyA9IHRoaXMucm93SW5mb1tyb3dJZHhdO1xuICAgICAgICAgICAgZm9yICh2YXIgY29sSWR4ID0gMDsgY29sSWR4IDwgdGhpcy50b3RhbENvbHVtbkNvdW50OyBjb2xJZHggKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChyb3dJbmZvW2NvbElkeF0ub2Zmc2V0ICsgMSA+IGNlbGxQb3MucG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbcm93SWR4LCBjb2xJZHhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldFJlY3RPZmZzZXRzID0gZnVuY3Rpb24gKHN0YXJ0Q2VsbFBvcywgZW5kQ2VsbFBvcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKGVuZENlbGxQb3MgPT09IHZvaWQgMCkgeyBlbmRDZWxsUG9zID0gc3RhcnRDZWxsUG9zOyB9XG4gICAgICAgIGlmIChzdGFydENlbGxQb3MucG9zID4gZW5kQ2VsbFBvcy5wb3MpIHtcbiAgICAgICAgICAgIF9hID0gW2VuZENlbGxQb3MsIHN0YXJ0Q2VsbFBvc10sIHN0YXJ0Q2VsbFBvcyA9IF9hWzBdLCBlbmRDZWxsUG9zID0gX2FbMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9kID0gdGhpcy5nZXRDZWxsSW5kZXgoc3RhcnRDZWxsUG9zKSwgc3RhcnRSb3dJZHggPSBfZFswXSwgc3RhcnRDb2xJZHggPSBfZFsxXTtcbiAgICAgICAgdmFyIF9lID0gdGhpcy5nZXRDZWxsSW5kZXgoZW5kQ2VsbFBvcyksIGVuZFJvd0lkeCA9IF9lWzBdLCBlbmRDb2xJZHggPSBfZVsxXTtcbiAgICAgICAgX2IgPSBnZXRTb3J0ZWROdW1QYWlyKHN0YXJ0Um93SWR4LCBlbmRSb3dJZHgpLCBzdGFydFJvd0lkeCA9IF9iWzBdLCBlbmRSb3dJZHggPSBfYlsxXTtcbiAgICAgICAgX2MgPSBnZXRTb3J0ZWROdW1QYWlyKHN0YXJ0Q29sSWR4LCBlbmRDb2xJZHgpLCBzdGFydENvbElkeCA9IF9jWzBdLCBlbmRDb2xJZHggPSBfY1sxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3Bhbm5lZE9mZnNldHMoeyBzdGFydFJvd0lkeDogc3RhcnRSb3dJZHgsIHN0YXJ0Q29sSWR4OiBzdGFydENvbElkeCwgZW5kUm93SWR4OiBlbmRSb3dJZHgsIGVuZENvbElkeDogZW5kQ29sSWR4IH0pO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldFNwYW5uZWRPZmZzZXRzID0gZnVuY3Rpb24gKHNlbGVjdGlvbkluZm8pIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkluZm87XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVPZmZzZXRNYXA7XG59KCkpO1xuXG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xudmFyIGNyZWF0ZU9mZnNldE1hcCA9IGZ1bmN0aW9uIChoZWFkT3JCb2R5LCBzdGFydE9mZnNldCkge1xuICAgIHZhciBjZWxsSW5mb01hdHJpeCA9IFtdO1xuICAgIGhlYWRPckJvZHkuZm9yRWFjaChmdW5jdGlvbiAocm93LCByb3dPZmZzZXQpIHtcbiAgICAgICAgLy8gZ2V0IHJvdyBpbmRleCBiYXNlZCBvbiB0YWJsZShub3QgdGFibGUgaGVhZCBvciB0YWJsZSBib2R5KVxuICAgICAgICB2YXIgcm93SW5mbyA9IHsgcm93c3Bhbk1hcDoge30sIGNvbHNwYW5NYXA6IHt9LCBsZW5ndGg6IDAgfTtcbiAgICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24gKF9hLCBjZWxsT2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgbm9kZVNpemUgPSBfYS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIHZhciBjb2xJZHggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHJvd0luZm9bY29sSWR4XSkge1xuICAgICAgICAgICAgICAgIGNvbElkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93SW5mb1tjb2xJZHhdID0ge1xuICAgICAgICAgICAgICAgIC8vIDIgaXMgdGhlIHN1bSBvZiB0aGUgZnJvbnQgYW5kIGJhY2sgcG9zaXRpb25zIG9mIHRoZSB0YWdcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0T2Zmc2V0ICsgcm93T2Zmc2V0ICsgY2VsbE9mZnNldCArIDIsXG4gICAgICAgICAgICAgICAgbm9kZVNpemU6IG5vZGVTaXplLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJvd0luZm8ubGVuZ3RoICs9IDE7XG4gICAgICAgIH0pO1xuICAgICAgICBjZWxsSW5mb01hdHJpeC5wdXNoKHJvd0luZm8pO1xuICAgIH0pO1xuICAgIHJldHVybiBjZWxsSW5mb01hdHJpeDtcbn07XG5mdW5jdGlvbiBtaXhpblRhYmxlT2Zmc2V0TWFwUHJvdG90eXBlKG9mZnNldE1hcE1peGluLCBjcmVhdGVPZmZzZXRNYXBNaXhpbikge1xuICAgIGNvbW1vbl9hc3NpZ24oVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLCBvZmZzZXRNYXBNaXhpbik7XG4gICAgY3JlYXRlT2Zmc2V0TWFwID0gY3JlYXRlT2Zmc2V0TWFwTWl4aW47XG4gICAgcmV0dXJuIFRhYmxlT2Zmc2V0TWFwO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaGVscGVyL3BsdWdpbi50c1xuXG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBleGVjUGx1Z2luKHBsdWdpbkluZm8pIHtcbiAgICB2YXIgcGx1Z2luID0gcGx1Z2luSW5mby5wbHVnaW4sIGV2ZW50RW1pdHRlciA9IHBsdWdpbkluZm8uZXZlbnRFbWl0dGVyLCB1c2FnZVN0YXRpc3RpY3MgPSBwbHVnaW5JbmZvLnVzYWdlU3RhdGlzdGljcywgaW5zdGFuY2UgPSBwbHVnaW5JbmZvLmluc3RhbmNlO1xuICAgIHZhciBwbVN0YXRlID0geyBQbHVnaW46IGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX3N0YXRlX2NvbW1vbmpzMl9wcm9zZW1pcnJvcl9zdGF0ZV9hbWRfcHJvc2VtaXJyb3Jfc3RhdGVfLlBsdWdpbiwgUGx1Z2luS2V5OiBleHRlcm5hbF9jb21tb25qc19wcm9zZW1pcnJvcl9zdGF0ZV9jb21tb25qczJfcHJvc2VtaXJyb3Jfc3RhdGVfYW1kX3Byb3NlbWlycm9yX3N0YXRlXy5QbHVnaW5LZXksIFNlbGVjdGlvbjogZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3Jfc3RhdGVfY29tbW9uanMyX3Byb3NlbWlycm9yX3N0YXRlX2FtZF9wcm9zZW1pcnJvcl9zdGF0ZV8uU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uOiBleHRlcm5hbF9jb21tb25qc19wcm9zZW1pcnJvcl9zdGF0ZV9jb21tb25qczJfcHJvc2VtaXJyb3Jfc3RhdGVfYW1kX3Byb3NlbWlycm9yX3N0YXRlXy5UZXh0U2VsZWN0aW9uIH07XG4gICAgdmFyIHBtVmlldyA9IHsgRGVjb3JhdGlvbjogZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3Jfdmlld19jb21tb25qczJfcHJvc2VtaXJyb3Jfdmlld19hbWRfcHJvc2VtaXJyb3Jfdmlld18uRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldDogZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3Jfdmlld19jb21tb25qczJfcHJvc2VtaXJyb3Jfdmlld19hbWRfcHJvc2VtaXJyb3Jfdmlld18uRGVjb3JhdGlvblNldCB9O1xuICAgIHZhciBwbU1vZGVsID0geyBGcmFnbWVudDogZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3JfbW9kZWxfY29tbW9uanMyX3Byb3NlbWlycm9yX21vZGVsX2FtZF9wcm9zZW1pcnJvcl9tb2RlbF8uRnJhZ21lbnQgfTtcbiAgICB2YXIgcG1SdWxlcyA9IHsgSW5wdXRSdWxlOiBleHRlcm5hbF9jb21tb25qc19wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzX2NvbW1vbmpzMl9wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzX2FtZF9wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzXy5JbnB1dFJ1bGUsIGlucHV0UnVsZXM6IGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX2lucHV0cnVsZXNfY29tbW9uanMyX3Byb3NlbWlycm9yX2lucHV0cnVsZXNfYW1kX3Byb3NlbWlycm9yX2lucHV0cnVsZXNfLmlucHV0UnVsZXMsIHVuZG9JbnB1dFJ1bGU6IGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX2lucHV0cnVsZXNfY29tbW9uanMyX3Byb3NlbWlycm9yX2lucHV0cnVsZXNfYW1kX3Byb3NlbWlycm9yX2lucHV0cnVsZXNfLnVuZG9JbnB1dFJ1bGUgfTtcbiAgICB2YXIgcG1LZXltYXAgPSB7IGtleW1hcDogZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3Jfa2V5bWFwX2NvbW1vbmpzMl9wcm9zZW1pcnJvcl9rZXltYXBfYW1kX3Byb3NlbWlycm9yX2tleW1hcF8ua2V5bWFwIH07XG4gICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgIGV2ZW50RW1pdHRlcjogZXZlbnRFbWl0dGVyLFxuICAgICAgICB1c2FnZVN0YXRpc3RpY3M6IHVzYWdlU3RhdGlzdGljcyxcbiAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICBwbVN0YXRlOiBwbVN0YXRlLFxuICAgICAgICBwbVZpZXc6IHBtVmlldyxcbiAgICAgICAgcG1Nb2RlbDogcG1Nb2RlbCxcbiAgICAgICAgcG1SdWxlczogcG1SdWxlcyxcbiAgICAgICAgcG1LZXltYXA6IHBtS2V5bWFwLFxuICAgICAgICBpMThuOiBpMThuLFxuICAgIH07XG4gICAgaWYgKGlzQXJyYXlfZGVmYXVsdCgpKHBsdWdpbikpIHtcbiAgICAgICAgdmFyIHBsdWdpbkZuID0gcGx1Z2luWzBdLCBfYSA9IHBsdWdpblsxXSwgb3B0aW9ucyA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hO1xuICAgICAgICByZXR1cm4gcGx1Z2luRm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBwbHVnaW4oY29udGV4dCk7XG59XG5mdW5jdGlvbiBnZXRQbHVnaW5JbmZvKHBsdWdpbnNJbmZvKSB7XG4gICAgdmFyIHBsdWdpbnMgPSBwbHVnaW5zSW5mby5wbHVnaW5zLCBldmVudEVtaXR0ZXIgPSBwbHVnaW5zSW5mby5ldmVudEVtaXR0ZXIsIHVzYWdlU3RhdGlzdGljcyA9IHBsdWdpbnNJbmZvLnVzYWdlU3RhdGlzdGljcywgaW5zdGFuY2UgPSBwbHVnaW5zSW5mby5pbnN0YW5jZTtcbiAgICBldmVudEVtaXR0ZXIubGlzdGVuKCdtaXhpblRhYmxlT2Zmc2V0TWFwUHJvdG90eXBlJywgbWl4aW5UYWJsZU9mZnNldE1hcFByb3RvdHlwZSk7XG4gICAgcmV0dXJuIChwbHVnaW5zICE9PSBudWxsICYmIHBsdWdpbnMgIT09IHZvaWQgMCA/IHBsdWdpbnMgOiBbXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsdWdpbikge1xuICAgICAgICB2YXIgcGx1Z2luSW5mb1Jlc3VsdCA9IGV4ZWNQbHVnaW4oe1xuICAgICAgICAgICAgcGx1Z2luOiBwbHVnaW4sXG4gICAgICAgICAgICBldmVudEVtaXR0ZXI6IGV2ZW50RW1pdHRlcixcbiAgICAgICAgICAgIHVzYWdlU3RhdGlzdGljczogdXNhZ2VTdGF0aXN0aWNzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwbHVnaW5JbmZvUmVzdWx0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGV4ZWN1dGVkIHBsdWdpbiBpcyBlbXB0eS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFya2Rvd25QYXJzZXJzID0gcGx1Z2luSW5mb1Jlc3VsdC5tYXJrZG93blBhcnNlcnMsIHRvSFRNTFJlbmRlcmVycyA9IHBsdWdpbkluZm9SZXN1bHQudG9IVE1MUmVuZGVyZXJzLCB0b01hcmtkb3duUmVuZGVyZXJzID0gcGx1Z2luSW5mb1Jlc3VsdC50b01hcmtkb3duUmVuZGVyZXJzLCBtYXJrZG93blBsdWdpbnMgPSBwbHVnaW5JbmZvUmVzdWx0Lm1hcmtkb3duUGx1Z2lucywgd3lzaXd5Z1BsdWdpbnMgPSBwbHVnaW5JbmZvUmVzdWx0Lnd5c2l3eWdQbHVnaW5zLCB3eXNpd3lnTm9kZVZpZXdzID0gcGx1Z2luSW5mb1Jlc3VsdC53eXNpd3lnTm9kZVZpZXdzLCBtYXJrZG93bkNvbW1hbmRzID0gcGx1Z2luSW5mb1Jlc3VsdC5tYXJrZG93bkNvbW1hbmRzLCB3eXNpd3lnQ29tbWFuZHMgPSBwbHVnaW5JbmZvUmVzdWx0Lnd5c2l3eWdDb21tYW5kcywgdG9vbGJhckl0ZW1zID0gcGx1Z2luSW5mb1Jlc3VsdC50b29sYmFySXRlbXM7XG4gICAgICAgIGlmICh0b0hUTUxSZW5kZXJlcnMpIHtcbiAgICAgICAgICAgIGFjYy50b0hUTUxSZW5kZXJlcnMgPSBkZWVwTWVyZ2VkQ29weShhY2MudG9IVE1MUmVuZGVyZXJzLCB0b0hUTUxSZW5kZXJlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b01hcmtkb3duUmVuZGVyZXJzKSB7XG4gICAgICAgICAgICBhY2MudG9NYXJrZG93blJlbmRlcmVycyA9IGRlZXBNZXJnZWRDb3B5KGFjYy50b01hcmtkb3duUmVuZGVyZXJzLCB0b01hcmtkb3duUmVuZGVyZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2Rvd25QbHVnaW5zKSB7XG4gICAgICAgICAgICBhY2MubWRQbHVnaW5zID0gYWNjLm1kUGx1Z2lucy5jb25jYXQobWFya2Rvd25QbHVnaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3lzaXd5Z1BsdWdpbnMpIHtcbiAgICAgICAgICAgIGFjYy53d1BsdWdpbnMgPSBhY2Mud3dQbHVnaW5zLmNvbmNhdCh3eXNpd3lnUGx1Z2lucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHd5c2l3eWdOb2RlVmlld3MpIHtcbiAgICAgICAgICAgIGFjYy53d05vZGVWaWV3cyA9IHRzbGliX2VzNl9hc3NpZ24odHNsaWJfZXM2X2Fzc2lnbih7fSwgYWNjLnd3Tm9kZVZpZXdzKSwgd3lzaXd5Z05vZGVWaWV3cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtkb3duQ29tbWFuZHMpIHtcbiAgICAgICAgICAgIGFjYy5tZENvbW1hbmRzID0gdHNsaWJfZXM2X2Fzc2lnbih0c2xpYl9lczZfYXNzaWduKHt9LCBhY2MubWRDb21tYW5kcyksIG1hcmtkb3duQ29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3eXNpd3lnQ29tbWFuZHMpIHtcbiAgICAgICAgICAgIGFjYy53d0NvbW1hbmRzID0gdHNsaWJfZXM2X2Fzc2lnbih0c2xpYl9lczZfYXNzaWduKHt9LCBhY2Mud3dDb21tYW5kcyksIHd5c2l3eWdDb21tYW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvb2xiYXJJdGVtcykge1xuICAgICAgICAgICAgYWNjLnRvb2xiYXJJdGVtcyA9IGFjYy50b29sYmFySXRlbXMuY29uY2F0KHRvb2xiYXJJdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtkb3duUGFyc2Vycykge1xuICAgICAgICAgICAgYWNjLm1hcmtkb3duUGFyc2VycyA9IHRzbGliX2VzNl9hc3NpZ24odHNsaWJfZXM2X2Fzc2lnbih7fSwgYWNjLm1hcmtkb3duUGFyc2VycyksIG1hcmtkb3duUGFyc2Vycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7XG4gICAgICAgIHRvSFRNTFJlbmRlcmVyczoge30sXG4gICAgICAgIHRvTWFya2Rvd25SZW5kZXJlcnM6IHt9LFxuICAgICAgICBtZFBsdWdpbnM6IFtdLFxuICAgICAgICB3d1BsdWdpbnM6IFtdLFxuICAgICAgICB3d05vZGVWaWV3czoge30sXG4gICAgICAgIG1kQ29tbWFuZHM6IHt9LFxuICAgICAgICB3d0NvbW1hbmRzOiB7fSxcbiAgICAgICAgdG9vbGJhckl0ZW1zOiBbXSxcbiAgICAgICAgbWFya2Rvd25QYXJzZXJzOiB7fSxcbiAgICB9KTtcbn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC90eXBlL2lzRmFsc3kuanNcbnZhciBpc0ZhbHN5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MDQpO1xudmFyIGlzRmFsc3lfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNGYWxzeSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZXZlbnQvZXZlbnRFbWl0dGVyLnRzXG5cblxuXG5cbnZhciBldmVudFR5cGVMaXN0ID0gW1xuICAgICdhZnRlclByZXZpZXdSZW5kZXInLFxuICAgICd1cGRhdGVQcmV2aWV3JyxcbiAgICAnY2hhbmdlTW9kZScsXG4gICAgJ25lZWRDaGFuZ2VNb2RlJyxcbiAgICAnY29tbWFuZCcsXG4gICAgJ2NoYW5nZVByZXZpZXdTdHlsZScsXG4gICAgJ2NoYW5nZVByZXZpZXdUYWJQcmV2aWV3JyxcbiAgICAnY2hhbmdlUHJldmlld1RhYldyaXRlJyxcbiAgICAnc2Nyb2xsJyxcbiAgICAnY29udGV4dG1lbnUnLFxuICAgICdzaG93JyxcbiAgICAnaGlkZScsXG4gICAgJ2NoYW5nZUxhbmd1YWdlJyxcbiAgICAnY2hhbmdlVG9vbGJhclN0YXRlJyxcbiAgICAndG9nZ2xlU2Nyb2xsU3luYycsXG4gICAgJ21peGluVGFibGVPZmZzZXRNYXBQcm90b3R5cGUnLFxuICAgICdzZXRGb2N1c2VkTm9kZScsXG4gICAgJ3JlbW92ZVBvcHVwV2lkZ2V0JyxcbiAgICAncXVlcnknLFxuICAgIC8vIHByb3ZpZGUgZXZlbnQgZm9yIHVzZXJcbiAgICAnb3BlblBvcHVwJyxcbiAgICAnY2xvc2VQb3B1cCcsXG4gICAgJ2FkZEltYWdlQmxvYkhvb2snLFxuICAgICdiZWZvcmVQcmV2aWV3UmVuZGVyJyxcbiAgICAnYmVmb3JlQ29udmVydFd5c2l3eWdUb01hcmtkb3duJyxcbiAgICAnbG9hZCcsXG4gICAgJ2xvYWRVSScsXG4gICAgJ2NoYW5nZScsXG4gICAgJ2NhcmV0Q2hhbmdlJyxcbiAgICAnZGVzdHJveScsXG4gICAgJ2ZvY3VzJyxcbiAgICAnYmx1cicsXG4gICAgJ2tleWRvd24nLFxuICAgICdrZXl1cCcsXG5dO1xuLyoqXG4gKiBDbGFzcyBFdmVudEVtaXR0ZXJcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEV2ZW50RW1pdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IHV0aWxzX21hcCgpO1xuICAgICAgICB0aGlzLmV2ZW50VHlwZXMgPSBldmVudFR5cGVMaXN0LnJlZHVjZShmdW5jdGlvbiAodHlwZXMsIHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl9lczZfYXNzaWduKHRzbGliX2VzNl9hc3NpZ24oe30sIHR5cGVzKSwgeyB0eXBlOiB0eXBlIH0pO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHRoaXMuaG9sZCA9IGZhbHNlO1xuICAgICAgICBldmVudFR5cGVMaXN0LmZvckVhY2goZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgX3RoaXMuYWRkRXZlbnRUeXBlKGV2ZW50VHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gZXZlbnQgYW5kIGJpbmQgZXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUgc3RyaW5nXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBFdmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgdHlwZUluZm8gPSB0aGlzLmdldFR5cGVJbmZvKHR5cGUpO1xuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuZXZlbnRzLmdldCh0eXBlSW5mby50eXBlKSB8fCBbXTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0V2ZW50VHlwZSh0eXBlSW5mby50eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgbm8gZXZlbnQgdHlwZSBcIiArIHR5cGVJbmZvLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlSW5mby5uYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIGhhbmRsZXIubmFtZXNwYWNlID0gdHlwZUluZm8ubmFtZXNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50SGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldmVudHMuc2V0KHR5cGVJbmZvLnR5cGUsIGV2ZW50SGFuZGxlcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW1pdCBldmVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZSB0byBlbWl0XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlSW5mbyA9IHRoaXMuZ2V0VHlwZUluZm8odHlwZSk7XG4gICAgICAgIHZhciBldmVudEhhbmRsZXJzID0gdGhpcy5ldmVudHMuZ2V0KHR5cGVJbmZvLnR5cGUpO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoIXRoaXMuaG9sZCAmJiBldmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBldmVudEhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaGFuZGxlci5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWRfZGVmYXVsdCgpKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbWl0IGdpdmVuIGV2ZW50IGFuZCByZXR1cm4gcmVzdWx0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lIHRvIGVtaXRcbiAgICAgKiBAcGFyYW0ge2FueX0gc291cmNlIFNvdXJjZSB0byBjaGFuZ2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdFJlZHVjZSA9IGZ1bmN0aW9uICh0eXBlLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB0aGlzLmV2ZW50cy5nZXQodHlwZSk7XG4gICAgICAgIGlmICghdGhpcy5ob2xkICYmIGV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBoYW5kbGVyLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbc291cmNlXSwgYXJncykpO1xuICAgICAgICAgICAgICAgIGlmICghaXNGYWxzeV9kZWZhdWx0KCkocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBldmVudCB0eXBlIGFuZCBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7e3R5cGU6IHN0cmluZywgbmFtZXNwYWNlOiBzdHJpbmd9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRUeXBlSW5mbyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBzcGxpdGVkID0gdHlwZS5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogc3BsaXRlZFswXSxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogc3BsaXRlZFsxXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgZXZlbnQgdHlwZSBleGlzdHMgb3Igbm90XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZSBuYW1lXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmhhc0V2ZW50VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiAhaXNVbmRlZmluZWRfZGVmYXVsdCgpKHRoaXMuZXZlbnRUeXBlc1t0aGlzLmdldFR5cGVJbmZvKHR5cGUpLnR5cGVdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBldmVudCB0eXBlIHdoZW4gZ2l2ZW4gZXZlbnQgbm90IGV4aXN0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUgbmFtZVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzRXZlbnRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBhbHJlYWR5IGhhdmUgZXZlbnQgdHlwZSBcIiArIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRUeXBlc1t0eXBlXSA9IHR5cGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXZlbnQgaGFuZGxlciBmcm9tIGdpdmVuIGV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUgbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtoYW5kbGVyXSAtIHJlZ2lzdGVyZWQgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldFR5cGVJbmZvKGV2ZW50VHlwZSksIHR5cGUgPSBfYS50eXBlLCBuYW1lc3BhY2UgPSBfYS5uYW1lc3BhY2U7XG4gICAgICAgIGlmICh0eXBlICYmIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRIYW5kbGVyV2l0aEhhbmRsZXIodHlwZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSAmJiAhbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5kZWxldGUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXR5cGUgJiYgbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfLCBldnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlRXZlbnRIYW5kbGVyV2l0aFR5cGVJbmZvKGV2dFR5cGUsIG5hbWVzcGFjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlICYmIG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudEhhbmRsZXJXaXRoVHlwZUluZm8odHlwZSwgbmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50IGhhbmRsZXIgd2l0aCBldmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBldmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gZXZlbnQgaGFuZGxlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudEhhbmRsZXJXaXRoSGFuZGxlciA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBldmVudEhhbmRsZXJzID0gdGhpcy5ldmVudHMuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoZXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXJJbmRleCA9IGV2ZW50SGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcikgPj0gMCkge1xuICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlcnMuc3BsaWNlKGhhbmRsZXJJbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBldmVudCBoYW5kbGVyIHdpdGggZXZlbnQgdHlwZSBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lc3BhY2UgRXZlbnQgbmFtZXNwYWNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50SGFuZGxlcldpdGhUeXBlSW5mbyA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzVG9TdXJ2aXZlID0gW107XG4gICAgICAgIHZhciBldmVudEhhbmRsZXJzID0gdGhpcy5ldmVudHMuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIWV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudEhhbmRsZXJzLm1hcChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIubmFtZXNwYWNlICE9PSBuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyc1RvU3Vydml2ZS5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50cy5zZXQodHlwZSwgaGFuZGxlcnNUb1N1cnZpdmUpO1xuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50cztcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuaG9sZEV2ZW50SW52b2tlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuaG9sZCA9IHRydWU7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHRoaXMuaG9sZCA9IGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBldmVudEVtaXR0ZXIgPSAoRXZlbnRFbWl0dGVyKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3ZpZXdlci50c1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIFRBU0tfQVRUUl9OQU1FID0gJ2RhdGEtdGFzayc7XG52YXIgRElTQUJMRURfVEFTS19BVFRSX05BTUUgPSAnZGF0YS10YXNrLWRpc2FibGVkJztcbnZhciBUQVNLX0NIRUNLRURfQ0xBU1NfTkFNRSA9ICdjaGVja2VkJztcbmZ1bmN0aW9uIHJlZ2lzdGVySFRNTFRhZ1RvV2hpdGVsaXN0KGNvbnZlcnRvck1hcCkge1xuICAgIFsnaHRtbEJsb2NrJywgJ2h0bWxJbmxpbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChodG1sVHlwZSkge1xuICAgICAgICBpZiAoY29udmVydG9yTWFwW2h0bWxUeXBlXSkge1xuICAgICAgICAgICAgLy8gcmVnaXN0ZXIgdGFnIHdoaXRlIGxpc3QgZm9yIHByZXZlbnRpbmcgdG8gcmVtb3ZlIHRoZSBodG1sIGluIHNhbml0aXplclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udmVydG9yTWFwW2h0bWxUeXBlXSkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gaHRtbFNhbml0aXplcl9yZWdpc3RlclRhZ1doaXRlbGlzdElmUG9zc2libGUodHlwZSk7IH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIENsYXNzIFRvYXN0VUlFZGl0b3JWaWV3ZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9wdGlvbiBvYmplY3RcbiAqICAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBvcHRpb25zLmVsIC0gY29udGFpbmVyIGVsZW1lbnRcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaW5pdGlhbFZhbHVlXSBFZGl0b3IncyBpbml0aWFsIHZhbHVlXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV2ZW50c10gLSBFdmVudHNcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmxvYWRdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGVkaXRvciBmdWxseSBsb2FkXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5jaGFuZ2VdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGNvbnRlbnQgY2hhbmdlZFxuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuY2FyZXRDaGFuZ2VdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGZvcm1hdCBjaGFuZ2UgYnkgY3Vyc29yIHBvc2l0aW9uXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5mb2N1c10gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gZWRpdG9yIGdldCBmb2N1c1xuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuYmx1cl0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gZWRpdG9yIGxvb3NlIGZvY3VzXG4gKiAgICAgQHBhcmFtIHtBcnJheS48ZnVuY3Rpb258QXJyYXk+fSBbb3B0aW9ucy5wbHVnaW5zXSAtIEFycmF5IG9mIHBsdWdpbnMuIEEgcGx1Z2luIGNhbiBiZSBlaXRoZXIgYSBmdW5jdGlvbiBvciBhbiBhcnJheSBpbiB0aGUgZm9ybSBvZiBbZnVuY3Rpb24sIG9wdGlvbnNdLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5leHRlbmRlZEF1dG9saW5rc10gLSBVc2luZyBleHRlbmRlZCBBdXRvbGlua3Mgc3BlY2lmaWVkIGluIEdGTSBzcGVjXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxpbmtBdHRyaWJ1dGVzXSAtIEF0dHJpYnV0ZXMgb2YgYW5jaG9yIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgcmVsLCB0YXJnZXQsIGhyZWZsYW5nLCB0eXBlXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmN1c3RvbUhUTUxSZW5kZXJlcj1udWxsXSAtIE9iamVjdCBjb250YWluaW5nIGN1c3RvbSByZW5kZXJlciBmdW5jdGlvbnMgY29ycmVzcG9uZCB0byBjaGFuZ2UgbWFya2Rvd24gbm9kZSB0byBwcmV2aWV3IEhUTUwgb3Igd3lzaXd5ZyBub2RlXG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uPWZhbHNlXSAtIHdoZXRoZXIgdXNlIHRoZSBzcGVjaWZpY2F0aW9uIG9mIGxpbmsgcmVmZXJlbmNlIGRlZmluaXRpb25cbiAqICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5jdXN0b21IVE1MU2FuaXRpemVyPW51bGxdIC0gY3VzdG9tIEhUTUwgc2FuaXRpemVyXG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mcm9udE1hdHRlcj1mYWxzZV0gLSB3aGV0aGVyIHVzZSB0aGUgZnJvbnQgbWF0dGVyXG4gKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRoZW1lXSAtIFRoZSB0aGVtZSB0byBzdHlsZSB0aGUgdmlld2VyIHdpdGguIFRoZSBkZWZhdWx0IGlzIGluY2x1ZGVkIGluIHRvYXN0dWktZWRpdG9yLmNzcy5cbiAqL1xudmFyIFRvYXN0VUlFZGl0b3JWaWV3ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9hc3RVSUVkaXRvclZpZXdlcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZF9kZWZhdWx0KCkoe1xuICAgICAgICAgICAgbGlua0F0dHJpYnV0ZXM6IG51bGwsXG4gICAgICAgICAgICBleHRlbmRlZEF1dG9saW5rczogZmFsc2UsXG4gICAgICAgICAgICBjdXN0b21IVE1MUmVuZGVyZXI6IG51bGwsXG4gICAgICAgICAgICByZWZlcmVuY2VEZWZpbml0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGN1c3RvbUhUTUxTYW5pdGl6ZXI6IG51bGwsXG4gICAgICAgICAgICBmcm9udE1hdHRlcjogZmFsc2UsXG4gICAgICAgICAgICB1c2FnZVN0YXRpc3RpY3M6IHRydWUsXG4gICAgICAgICAgICB0aGVtZTogJ2xpZ2h0JyxcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gbmV3IGV2ZW50RW1pdHRlcigpO1xuICAgICAgICB2YXIgbGlua0F0dHJpYnV0ZXMgPSBzYW5pdGl6ZUxpbmtBdHRyaWJ1dGUodGhpcy5vcHRpb25zLmxpbmtBdHRyaWJ1dGVzKTtcbiAgICAgICAgdmFyIF9hID0gZ2V0UGx1Z2luSW5mbyh7XG4gICAgICAgICAgICBwbHVnaW5zOiB0aGlzLm9wdGlvbnMucGx1Z2lucyxcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlcjogdGhpcy5ldmVudEVtaXR0ZXIsXG4gICAgICAgICAgICB1c2FnZVN0YXRpc3RpY3M6IHRoaXMub3B0aW9ucy51c2FnZVN0YXRpc3RpY3MsXG4gICAgICAgICAgICBpbnN0YW5jZTogdGhpcyxcbiAgICAgICAgfSkgfHwge30sIHRvSFRNTFJlbmRlcmVycyA9IF9hLnRvSFRNTFJlbmRlcmVycywgbWFya2Rvd25QYXJzZXJzID0gX2EubWFya2Rvd25QYXJzZXJzO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLm9wdGlvbnMsIGN1c3RvbUhUTUxSZW5kZXJlciA9IF9iLmN1c3RvbUhUTUxSZW5kZXJlciwgZXh0ZW5kZWRBdXRvbGlua3MgPSBfYi5leHRlbmRlZEF1dG9saW5rcywgcmVmZXJlbmNlRGVmaW5pdGlvbiA9IF9iLnJlZmVyZW5jZURlZmluaXRpb24sIGZyb250TWF0dGVyID0gX2IuZnJvbnRNYXR0ZXIsIGN1c3RvbUhUTUxTYW5pdGl6ZXIgPSBfYi5jdXN0b21IVE1MU2FuaXRpemVyO1xuICAgICAgICB2YXIgcmVuZGVyZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgbGlua0F0dHJpYnV0ZXM6IGxpbmtBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgY3VzdG9tSFRNTFJlbmRlcmVyOiB0c2xpYl9lczZfYXNzaWduKHRzbGliX2VzNl9hc3NpZ24oe30sIHRvSFRNTFJlbmRlcmVycyksIGN1c3RvbUhUTUxSZW5kZXJlciksXG4gICAgICAgICAgICBleHRlbmRlZEF1dG9saW5rczogZXh0ZW5kZWRBdXRvbGlua3MsXG4gICAgICAgICAgICByZWZlcmVuY2VEZWZpbml0aW9uOiByZWZlcmVuY2VEZWZpbml0aW9uLFxuICAgICAgICAgICAgZnJvbnRNYXR0ZXI6IGZyb250TWF0dGVyLFxuICAgICAgICAgICAgc2FuaXRpemVyOiBjdXN0b21IVE1MU2FuaXRpemVyIHx8IHNhbml0aXplSFRNTCxcbiAgICAgICAgfTtcbiAgICAgICAgcmVnaXN0ZXJIVE1MVGFnVG9XaGl0ZWxpc3QocmVuZGVyZXJPcHRpb25zLmN1c3RvbUhUTUxSZW5kZXJlcik7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgICAgICBmb3JFYWNoT3duUHJvcGVydGllc19kZWZhdWx0KCkodGhpcy5vcHRpb25zLmV2ZW50cywgZnVuY3Rpb24gKGZuLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbihrZXksIGZuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYyA9IHRoaXMub3B0aW9ucywgZWwgPSBfYy5lbCwgaW5pdGlhbFZhbHVlID0gX2MuaW5pdGlhbFZhbHVlLCB0aGVtZSA9IF9jLnRoZW1lO1xuICAgICAgICB2YXIgZXhpc3RpbmdIVE1MID0gZWwuaW5uZXJIVE1MO1xuICAgICAgICBpZiAodGhlbWUgIT09ICdsaWdodCcpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKHRoZW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHRoaXMudG9hc3RNYXJrID0gbmV3IFRvYXN0TWFyaygnJywge1xuICAgICAgICAgICAgZGlzYWxsb3dlZEh0bWxCbG9ja1RhZ3M6IFsnYnInLCAnaW1nJ10sXG4gICAgICAgICAgICBleHRlbmRlZEF1dG9saW5rczogZXh0ZW5kZWRBdXRvbGlua3MsXG4gICAgICAgICAgICByZWZlcmVuY2VEZWZpbml0aW9uOiByZWZlcmVuY2VEZWZpbml0aW9uLFxuICAgICAgICAgICAgZGlzYWxsb3dEZWVwSGVhZGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGZyb250TWF0dGVyOiBmcm9udE1hdHRlcixcbiAgICAgICAgICAgIGN1c3RvbVBhcnNlcjogbWFya2Rvd25QYXJzZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcmV2aWV3ID0gbmV3IG1kUHJldmlldyh0aGlzLmV2ZW50RW1pdHRlciwgdHNsaWJfZXM2X2Fzc2lnbih0c2xpYl9lczZfYXNzaWduKHt9LCByZW5kZXJlck9wdGlvbnMpLCB7IGlzVmlld2VyOiB0cnVlIH0pKTtcbiAgICAgICAgb25fZGVmYXVsdCgpKHRoaXMucHJldmlldy5wcmV2aWV3Q29udGVudCwgJ21vdXNlZG93bicsIHRoaXMudG9nZ2xlVGFzay5iaW5kKHRoaXMpKTtcbiAgICAgICAgaWYgKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRNYXJrZG93bihpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4aXN0aW5nSFRNTCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2aWV3LnNldEhUTUwoZXhpc3RpbmdIVE1MKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLnByZXZpZXcucHJldmlld0NvbnRlbnQpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdsb2FkJywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0YXNrIGJ5IGRldGVjdGluZyBtb3VzZWRvd24gZXZlbnQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldiAtIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS50b2dnbGVUYXNrID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZXYudGFyZ2V0O1xuICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICc6YmVmb3JlJyk7XG4gICAgICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoRElTQUJMRURfVEFTS19BVFRSX05BTUUpICYmXG4gICAgICAgICAgICBlbGVtZW50Lmhhc0F0dHJpYnV0ZShUQVNLX0FUVFJfTkFNRSkgJiZcbiAgICAgICAgICAgIGlzUG9zaXRpb25JbkJveChzdHlsZSwgZXYub2Zmc2V0WCwgZXYub2Zmc2V0WSkpIHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIFRBU0tfQ0hFQ0tFRF9DTEFTU19OQU1FKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICd2aWV3ZXInLFxuICAgICAgICAgICAgICAgIGRhdGU6IGV2LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBjb250ZW50IGZvciBwcmV2aWV3XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmtkb3duIE1hcmtkb3duIHRleHRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS5zZXRNYXJrZG93biA9IGZ1bmN0aW9uIChtYXJrZG93bikge1xuICAgICAgICB2YXIgbGluZVRleHRzID0gdGhpcy50b2FzdE1hcmsuZ2V0TGluZVRleHRzKCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBsaW5lVGV4dHMubGVuZ3RoO1xuICAgICAgICB2YXIgbGFzdExpbmUgPSBjb21tb25fbGFzdChsaW5lVGV4dHMpO1xuICAgICAgICB2YXIgZW5kU291cmNlcG9zID0gW2xlbmd0aCwgbGFzdExpbmUubGVuZ3RoICsgMV07XG4gICAgICAgIHZhciBlZGl0UmVzdWx0ID0gdGhpcy50b2FzdE1hcmsuZWRpdE1hcmtkb3duKFsxLCAxXSwgZW5kU291cmNlcG9zLCBtYXJrZG93biB8fCAnJyk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3VwZGF0ZVByZXZpZXcnLCBlZGl0UmVzdWx0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJpbmQgZXZlbnRIYW5kbGVyIHRvIGV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBFdmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4odHlwZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbmJpbmQgZXZlbnRIYW5kbGVyIGZyb20gZXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVFdmVudEhhbmRsZXIodHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgaG9vayB0byBUVUlFZGl0b3IgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBFdmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuYWRkSG9vayA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50SGFuZGxlcih0eXBlKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKHR5cGUsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIFZpZXdlciBwcmV2aWV3IGZyb20gZG9jdW1lbnRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmZfZGVmYXVsdCgpKHRoaXMucHJldmlldy5lbCwgJ21vdXNlZG93bicsIHRoaXMudG9nZ2xlVGFzay5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5wcmV2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnZGVzdHJveScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS5pc1ZpZXdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS5pc01hcmtkb3duTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGZhbHNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuaXNXeXNpd3lnTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIFRvYXN0VUlFZGl0b3JWaWV3ZXI7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdmlld2VyID0gKFRvYXN0VUlFZGl0b3JWaWV3ZXIpO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaW5kZXhWaWV3ZXIudHNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBpbmRleFZpZXdlciA9ICh2aWV3ZXIpO1xuXG59KCk7XG5fX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl07XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toast-ui/editor/dist/toastui-editor-viewer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toast-ui/react-editor/dist/esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@toast-ui/react-editor/dist/esm/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ default_1),\n/* harmony export */   Viewer: () => (/* binding */ ViewerComponent)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _toast_ui_editor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @toast-ui/editor */ \"(ssr)/./node_modules/@toast-ui/editor/dist/esm/index.js\");\n/* harmony import */ var _toast_ui_editor_dist_toastui_editor_viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toast-ui/editor/dist/toastui-editor-viewer */ \"(ssr)/./node_modules/@toast-ui/editor/dist/toastui-editor-viewer.js\");\n/* harmony import */ var _toast_ui_editor_dist_toastui_editor_viewer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_toast_ui_editor_dist_toastui_editor_viewer__WEBPACK_IMPORTED_MODULE_2__);\n/**\n * TOAST UI Editor : React Wrapper\n * @version 3.2.3 | Fri Feb 17 2023\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n * @license MIT\n */\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar default_1 = /** @class */ (function (_super) {\n    __extends(default_1, _super);\n    function default_1() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootEl = react__WEBPACK_IMPORTED_MODULE_0___default().createRef();\n        return _this;\n    }\n    default_1.prototype.getRootElement = function () {\n        return this.rootEl.current;\n    };\n    default_1.prototype.getInstance = function () {\n        return this.editorInst;\n    };\n    default_1.prototype.getBindingEventNames = function () {\n        var _this = this;\n        return Object.keys(this.props)\n            .filter(function (key) { return /^on[A-Z][a-zA-Z]+/.test(key); })\n            .filter(function (key) { return _this.props[key]; });\n    };\n    default_1.prototype.bindEventHandlers = function (props) {\n        var _this = this;\n        this.getBindingEventNames().forEach(function (key) {\n            var eventName = key[2].toLowerCase() + key.slice(3);\n            _this.editorInst.off(eventName);\n            _this.editorInst.on(eventName, props[key]);\n        });\n    };\n    default_1.prototype.getInitEvents = function () {\n        var _this = this;\n        return this.getBindingEventNames().reduce(function (acc, key) {\n            var eventName = (key[2].toLowerCase() + key.slice(3));\n            acc[eventName] = _this.props[key];\n            return acc;\n        }, {});\n    };\n    default_1.prototype.componentDidMount = function () {\n        this.editorInst = new _toast_ui_editor__WEBPACK_IMPORTED_MODULE_1__[\"default\"](__assign(__assign({ el: this.rootEl.current }, this.props), { events: this.getInitEvents() }));\n    };\n    default_1.prototype.shouldComponentUpdate = function (nextProps) {\n        var instance = this.getInstance();\n        var height = nextProps.height, previewStyle = nextProps.previewStyle;\n        if (height && this.props.height !== height) {\n            instance.setHeight(height);\n        }\n        if (previewStyle && this.props.previewStyle !== previewStyle) {\n            instance.changePreviewStyle(previewStyle);\n        }\n        this.bindEventHandlers(nextProps);\n        return false;\n    };\n    default_1.prototype.render = function () {\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { ref: this.rootEl });\n    };\n    return default_1;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().Component)));\n\nvar ViewerComponent = /** @class */ (function (_super) {\n    __extends(ViewerComponent, _super);\n    function ViewerComponent() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootEl = react__WEBPACK_IMPORTED_MODULE_0___default().createRef();\n        return _this;\n    }\n    ViewerComponent.prototype.getRootElement = function () {\n        return this.rootEl.current;\n    };\n    ViewerComponent.prototype.getInstance = function () {\n        return this.viewerInst;\n    };\n    ViewerComponent.prototype.getBindingEventNames = function () {\n        var _this = this;\n        return Object.keys(this.props)\n            .filter(function (key) { return /^on[A-Z][a-zA-Z]+/.test(key); })\n            .filter(function (key) { return _this.props[key]; });\n    };\n    ViewerComponent.prototype.bindEventHandlers = function (props) {\n        var _this = this;\n        this.getBindingEventNames().forEach(function (key) {\n            var eventName = key[2].toLowerCase() + key.slice(3);\n            _this.viewerInst.off(eventName);\n            _this.viewerInst.on(eventName, props[key]);\n        });\n    };\n    ViewerComponent.prototype.getInitEvents = function () {\n        var _this = this;\n        return this.getBindingEventNames().reduce(function (acc, key) {\n            var eventName = (key[2].toLowerCase() + key.slice(3));\n            acc[eventName] = _this.props[key];\n            return acc;\n        }, {});\n    };\n    ViewerComponent.prototype.componentDidMount = function () {\n        this.viewerInst = new (_toast_ui_editor_dist_toastui_editor_viewer__WEBPACK_IMPORTED_MODULE_2___default())(__assign(__assign({ el: this.rootEl.current }, this.props), { events: this.getInitEvents() }));\n    };\n    ViewerComponent.prototype.shouldComponentUpdate = function (nextProps) {\n        this.bindEventHandlers(nextProps);\n        return false;\n    };\n    ViewerComponent.prototype.render = function () {\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { ref: this.rootEl });\n    };\n    return ViewerComponent;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().Component)));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL3JlYWN0LWVkaXRvci9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUNZO0FBQzJCOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1Q0FBdUM7QUFDNUUscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQSw4QkFBOEIsd0RBQU0scUJBQXFCLHlCQUF5QixpQkFBaUIsOEJBQThCO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFtQixVQUFVLGtCQUFrQjtBQUM5RDtBQUNBO0FBQ0EsQ0FBQyxDQUFDLHdEQUFlOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHVDQUF1QztBQUM1RSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBLDhCQUE4QixvRkFBTSxxQkFBcUIseUJBQXlCLGlCQUFpQiw4QkFBOEI7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBbUIsVUFBVSxrQkFBa0I7QUFDOUQ7QUFDQTtBQUNBLENBQUMsQ0FBQyx3REFBZTs7QUFFeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1jb250ZW50LWdlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvcmVhY3QtZWRpdG9yL2Rpc3QvZXNtL2luZGV4LmpzPzcyODciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUT0FTVCBVSSBFZGl0b3IgOiBSZWFjdCBXcmFwcGVyXG4gKiBAdmVyc2lvbiAzLjIuMyB8IEZyaSBGZWIgMTcgMjAyM1xuICogQGF1dGhvciBOSE4gQ2xvdWQgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IEVkaXRvciBmcm9tICdAdG9hc3QtdWkvZWRpdG9yJztcbmltcG9ydCBWaWV3ZXIgZnJvbSAnQHRvYXN0LXVpL2VkaXRvci9kaXN0L3RvYXN0dWktZWRpdG9yLXZpZXdlcic7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xuXG52YXIgZGVmYXVsdF8xID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhkZWZhdWx0XzEsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gZGVmYXVsdF8xKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucm9vdEVsID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgZGVmYXVsdF8xLnByb3RvdHlwZS5nZXRSb290RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdEVsLmN1cnJlbnQ7XG4gICAgfTtcbiAgICBkZWZhdWx0XzEucHJvdG90eXBlLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3JJbnN0O1xuICAgIH07XG4gICAgZGVmYXVsdF8xLnByb3RvdHlwZS5nZXRCaW5kaW5nRXZlbnROYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucHJvcHMpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIC9eb25bQS1aXVthLXpBLVpdKy8udGVzdChrZXkpOyB9KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBfdGhpcy5wcm9wc1trZXldOyB9KTtcbiAgICB9O1xuICAgIGRlZmF1bHRfMS5wcm90b3R5cGUuYmluZEV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5nZXRCaW5kaW5nRXZlbnROYW1lcygpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGtleVsyXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDMpO1xuICAgICAgICAgICAgX3RoaXMuZWRpdG9ySW5zdC5vZmYoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIF90aGlzLmVkaXRvckluc3Qub24oZXZlbnROYW1lLCBwcm9wc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBkZWZhdWx0XzEucHJvdG90eXBlLmdldEluaXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJpbmRpbmdFdmVudE5hbWVzKCkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IChrZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKSk7XG4gICAgICAgICAgICBhY2NbZXZlbnROYW1lXSA9IF90aGlzLnByb3BzW2tleV07XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICBkZWZhdWx0XzEucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVkaXRvckluc3QgPSBuZXcgRWRpdG9yKF9fYXNzaWduKF9fYXNzaWduKHsgZWw6IHRoaXMucm9vdEVsLmN1cnJlbnQgfSwgdGhpcy5wcm9wcyksIHsgZXZlbnRzOiB0aGlzLmdldEluaXRFdmVudHMoKSB9KSk7XG4gICAgfTtcbiAgICBkZWZhdWx0XzEucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5nZXRJbnN0YW5jZSgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gbmV4dFByb3BzLmhlaWdodCwgcHJldmlld1N0eWxlID0gbmV4dFByb3BzLnByZXZpZXdTdHlsZTtcbiAgICAgICAgaWYgKGhlaWdodCAmJiB0aGlzLnByb3BzLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRIZWlnaHQoaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmlld1N0eWxlICYmIHRoaXMucHJvcHMucHJldmlld1N0eWxlICE9PSBwcmV2aWV3U3R5bGUpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNoYW5nZVByZXZpZXdTdHlsZShwcmV2aWV3U3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmluZEV2ZW50SGFuZGxlcnMobmV4dFByb3BzKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgZGVmYXVsdF8xLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLnJvb3RFbCB9KTtcbiAgICB9O1xuICAgIHJldHVybiBkZWZhdWx0XzE7XG59KFJlYWN0LkNvbXBvbmVudCkpO1xuXG52YXIgVmlld2VyQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaWV3ZXJDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlld2VyQ29tcG9uZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucm9vdEVsID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVmlld2VyQ29tcG9uZW50LnByb3RvdHlwZS5nZXRSb290RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdEVsLmN1cnJlbnQ7XG4gICAgfTtcbiAgICBWaWV3ZXJDb21wb25lbnQucHJvdG90eXBlLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3ZXJJbnN0O1xuICAgIH07XG4gICAgVmlld2VyQ29tcG9uZW50LnByb3RvdHlwZS5nZXRCaW5kaW5nRXZlbnROYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucHJvcHMpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIC9eb25bQS1aXVthLXpBLVpdKy8udGVzdChrZXkpOyB9KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBfdGhpcy5wcm9wc1trZXldOyB9KTtcbiAgICB9O1xuICAgIFZpZXdlckNvbXBvbmVudC5wcm90b3R5cGUuYmluZEV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5nZXRCaW5kaW5nRXZlbnROYW1lcygpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGtleVsyXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDMpO1xuICAgICAgICAgICAgX3RoaXMudmlld2VySW5zdC5vZmYoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIF90aGlzLnZpZXdlckluc3Qub24oZXZlbnROYW1lLCBwcm9wc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBWaWV3ZXJDb21wb25lbnQucHJvdG90eXBlLmdldEluaXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJpbmRpbmdFdmVudE5hbWVzKCkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IChrZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKSk7XG4gICAgICAgICAgICBhY2NbZXZlbnROYW1lXSA9IF90aGlzLnByb3BzW2tleV07XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICBWaWV3ZXJDb21wb25lbnQucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXdlckluc3QgPSBuZXcgVmlld2VyKF9fYXNzaWduKF9fYXNzaWduKHsgZWw6IHRoaXMucm9vdEVsLmN1cnJlbnQgfSwgdGhpcy5wcm9wcyksIHsgZXZlbnRzOiB0aGlzLmdldEluaXRFdmVudHMoKSB9KSk7XG4gICAgfTtcbiAgICBWaWV3ZXJDb21wb25lbnQucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRIYW5kbGVycyhuZXh0UHJvcHMpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBWaWV3ZXJDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMucm9vdEVsIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFZpZXdlckNvbXBvbmVudDtcbn0oUmVhY3QuQ29tcG9uZW50KSk7XG5cbmV4cG9ydCB7IGRlZmF1bHRfMSBhcyBFZGl0b3IsIFZpZXdlckNvbXBvbmVudCBhcyBWaWV3ZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toast-ui/react-editor/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toast-ui/editor/dist/toastui-editor.css":
/*!***************************************************************!*\
  !*** ./node_modules/@toast-ui/editor/dist/toastui-editor.css ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"dc6b4e2d7563\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2VkaXRvci9kaXN0L3RvYXN0dWktZWRpdG9yLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWNvbnRlbnQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9lZGl0b3IvZGlzdC90b2FzdHVpLWVkaXRvci5jc3M/NmUzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImRjNmI0ZTJkNzU2M1wiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toast-ui/editor/dist/toastui-editor.css\n");

/***/ })

};
;